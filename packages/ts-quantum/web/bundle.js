"use strict";
(() => {
  var __create = Object.create;
  var __defProp = Object.defineProperty;
  var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
  var __getOwnPropNames = Object.getOwnPropertyNames;
  var __getProtoOf = Object.getPrototypeOf;
  var __hasOwnProp = Object.prototype.hasOwnProperty;
  var __commonJS = (cb, mod2) => function __require() {
    return mod2 || (0, cb[__getOwnPropNames(cb)[0]])((mod2 = { exports: {} }).exports, mod2), mod2.exports;
  };
  var __copyProps = (to, from, except, desc) => {
    if (from && typeof from === "object" || typeof from === "function") {
      for (let key of __getOwnPropNames(from))
        if (!__hasOwnProp.call(to, key) && key !== except)
          __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
    }
    return to;
  };
  var __toESM = (mod2, isNodeMode, target) => (target = mod2 != null ? __create(__getProtoOf(mod2)) : {}, __copyProps(
    // If the importer is in node compatibility mode or this is not an ESM
    // file that has been converted to a CommonJS file using a Babel-
    // compatible transform (i.e. "__esModule" has not been set), then set
    // "default" to the CommonJS "module.exports" for node compatibility.
    isNodeMode || !mod2 || !mod2.__esModule ? __defProp(target, "default", { value: mod2, enumerable: true }) : target,
    mod2
  ));

  // node_modules/.pnpm/@babel+runtime@7.28.4/node_modules/@babel/runtime/helpers/interopRequireDefault.js
  var require_interopRequireDefault = __commonJS({
    "node_modules/.pnpm/@babel+runtime@7.28.4/node_modules/@babel/runtime/helpers/interopRequireDefault.js"(exports, module) {
      function _interopRequireDefault(e) {
        return e && e.__esModule ? e : {
          "default": e
        };
      }
      module.exports = _interopRequireDefault, module.exports.__esModule = true, module.exports["default"] = module.exports;
    }
  });

  // node_modules/.pnpm/@babel+runtime@7.28.4/node_modules/@babel/runtime/helpers/extends.js
  var require_extends = __commonJS({
    "node_modules/.pnpm/@babel+runtime@7.28.4/node_modules/@babel/runtime/helpers/extends.js"(exports, module) {
      function _extends2() {
        return module.exports = _extends2 = Object.assign ? Object.assign.bind() : function(n) {
          for (var e = 1; e < arguments.length; e++) {
            var t = arguments[e];
            for (var r in t) ({}).hasOwnProperty.call(t, r) && (n[r] = t[r]);
          }
          return n;
        }, module.exports.__esModule = true, module.exports["default"] = module.exports, _extends2.apply(null, arguments);
      }
      module.exports = _extends2, module.exports.__esModule = true, module.exports["default"] = module.exports;
    }
  });

  // node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/core/config.js
  var require_config = __commonJS({
    "node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/core/config.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.DEFAULT_CONFIG = void 0;
      var DEFAULT_CONFIG2 = exports.DEFAULT_CONFIG = {
        // minimum relative difference between two compared values,
        // used by all comparison functions
        epsilon: 1e-12,
        // type of default matrix output. Choose 'matrix' (default) or 'array'
        matrix: "Matrix",
        // type of default number output. Choose 'number' (default) 'BigNumber', or 'Fraction
        number: "number",
        // number of significant digits in BigNumbers
        precision: 64,
        // predictable output type of functions. When true, output type depends only
        // on the input types. When false (default), output type can vary depending
        // on input values. For example `math.sqrt(-4)` returns `complex('2i')` when
        // predictable is false, and returns `NaN` when true.
        predictable: false,
        // random seed for seeded pseudo random number generation
        // null = randomly seed
        randomSeed: null
      };
    }
  });

  // node_modules/.pnpm/@babel+runtime@7.28.4/node_modules/@babel/runtime/helpers/typeof.js
  var require_typeof = __commonJS({
    "node_modules/.pnpm/@babel+runtime@7.28.4/node_modules/@babel/runtime/helpers/typeof.js"(exports, module) {
      function _typeof(o) {
        "@babel/helpers - typeof";
        return module.exports = _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(o2) {
          return typeof o2;
        } : function(o2) {
          return o2 && "function" == typeof Symbol && o2.constructor === Symbol && o2 !== Symbol.prototype ? "symbol" : typeof o2;
        }, module.exports.__esModule = true, module.exports["default"] = module.exports, _typeof(o);
      }
      module.exports = _typeof, module.exports.__esModule = true, module.exports["default"] = module.exports;
    }
  });

  // node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/utils/is.js
  var require_is = __commonJS({
    "node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/utils/is.js"(exports) {
      "use strict";
      var _interopRequireDefault = require_interopRequireDefault();
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.isAccessorNode = isAccessorNode2;
      exports.isArray = void 0;
      exports.isArrayNode = isArrayNode2;
      exports.isAssignmentNode = isAssignmentNode2;
      exports.isBigNumber = isBigNumber2;
      exports.isBlockNode = isBlockNode2;
      exports.isBoolean = isBoolean2;
      exports.isChain = isChain2;
      exports.isCollection = isCollection2;
      exports.isComplex = isComplex2;
      exports.isConditionalNode = isConditionalNode2;
      exports.isConstantNode = isConstantNode2;
      exports.isDate = isDate2;
      exports.isDenseMatrix = isDenseMatrix2;
      exports.isFraction = isFraction2;
      exports.isFunction = isFunction2;
      exports.isFunctionAssignmentNode = isFunctionAssignmentNode2;
      exports.isFunctionNode = isFunctionNode2;
      exports.isHelp = isHelp2;
      exports.isIndex = isIndex2;
      exports.isIndexNode = isIndexNode2;
      exports.isMatrix = isMatrix2;
      exports.isNode = isNode2;
      exports.isNull = isNull2;
      exports.isNumber = isNumber2;
      exports.isObject = isObject2;
      exports.isObjectNode = isObjectNode2;
      exports.isOperatorNode = isOperatorNode2;
      exports.isParenthesisNode = isParenthesisNode2;
      exports.isRange = isRange2;
      exports.isRangeNode = isRangeNode2;
      exports.isRegExp = isRegExp2;
      exports.isRelationalNode = isRelationalNode2;
      exports.isResultSet = isResultSet2;
      exports.isSparseMatrix = isSparseMatrix2;
      exports.isString = isString2;
      exports.isSymbolNode = isSymbolNode2;
      exports.isUndefined = isUndefined2;
      exports.isUnit = isUnit2;
      exports.rule2Node = rule2Node;
      exports.typeOf = typeOf2;
      var _typeof2 = _interopRequireDefault(require_typeof());
      function isNumber2(x) {
        return typeof x === "number";
      }
      function isBigNumber2(x) {
        if (!x || (0, _typeof2["default"])(x) !== "object" || typeof x.constructor !== "function") {
          return false;
        }
        if (x.isBigNumber === true && (0, _typeof2["default"])(x.constructor.prototype) === "object" && x.constructor.prototype.isBigNumber === true) {
          return true;
        }
        if (typeof x.constructor.isDecimal === "function" && x.constructor.isDecimal(x) === true) {
          return true;
        }
        return false;
      }
      function isComplex2(x) {
        return x && (0, _typeof2["default"])(x) === "object" && Object.getPrototypeOf(x).isComplex === true || false;
      }
      function isFraction2(x) {
        return x && (0, _typeof2["default"])(x) === "object" && Object.getPrototypeOf(x).isFraction === true || false;
      }
      function isUnit2(x) {
        return x && x.constructor.prototype.isUnit === true || false;
      }
      function isString2(x) {
        return typeof x === "string";
      }
      var isArray2 = exports.isArray = Array.isArray;
      function isMatrix2(x) {
        return x && x.constructor.prototype.isMatrix === true || false;
      }
      function isCollection2(x) {
        return Array.isArray(x) || isMatrix2(x);
      }
      function isDenseMatrix2(x) {
        return x && x.isDenseMatrix && x.constructor.prototype.isMatrix === true || false;
      }
      function isSparseMatrix2(x) {
        return x && x.isSparseMatrix && x.constructor.prototype.isMatrix === true || false;
      }
      function isRange2(x) {
        return x && x.constructor.prototype.isRange === true || false;
      }
      function isIndex2(x) {
        return x && x.constructor.prototype.isIndex === true || false;
      }
      function isBoolean2(x) {
        return typeof x === "boolean";
      }
      function isResultSet2(x) {
        return x && x.constructor.prototype.isResultSet === true || false;
      }
      function isHelp2(x) {
        return x && x.constructor.prototype.isHelp === true || false;
      }
      function isFunction2(x) {
        return typeof x === "function";
      }
      function isDate2(x) {
        return x instanceof Date;
      }
      function isRegExp2(x) {
        return x instanceof RegExp;
      }
      function isObject2(x) {
        return !!(x && (0, _typeof2["default"])(x) === "object" && x.constructor === Object && !isComplex2(x) && !isFraction2(x));
      }
      function isNull2(x) {
        return x === null;
      }
      function isUndefined2(x) {
        return x === void 0;
      }
      function isAccessorNode2(x) {
        return x && x.isAccessorNode === true && x.constructor.prototype.isNode === true || false;
      }
      function isArrayNode2(x) {
        return x && x.isArrayNode === true && x.constructor.prototype.isNode === true || false;
      }
      function isAssignmentNode2(x) {
        return x && x.isAssignmentNode === true && x.constructor.prototype.isNode === true || false;
      }
      function isBlockNode2(x) {
        return x && x.isBlockNode === true && x.constructor.prototype.isNode === true || false;
      }
      function isConditionalNode2(x) {
        return x && x.isConditionalNode === true && x.constructor.prototype.isNode === true || false;
      }
      function isConstantNode2(x) {
        return x && x.isConstantNode === true && x.constructor.prototype.isNode === true || false;
      }
      function rule2Node(node) {
        return isConstantNode2(node) || isOperatorNode2(node) && node.args.length === 1 && isConstantNode2(node.args[0]) && "-+~".includes(node.op);
      }
      function isFunctionAssignmentNode2(x) {
        return x && x.isFunctionAssignmentNode === true && x.constructor.prototype.isNode === true || false;
      }
      function isFunctionNode2(x) {
        return x && x.isFunctionNode === true && x.constructor.prototype.isNode === true || false;
      }
      function isIndexNode2(x) {
        return x && x.isIndexNode === true && x.constructor.prototype.isNode === true || false;
      }
      function isNode2(x) {
        return x && x.isNode === true && x.constructor.prototype.isNode === true || false;
      }
      function isObjectNode2(x) {
        return x && x.isObjectNode === true && x.constructor.prototype.isNode === true || false;
      }
      function isOperatorNode2(x) {
        return x && x.isOperatorNode === true && x.constructor.prototype.isNode === true || false;
      }
      function isParenthesisNode2(x) {
        return x && x.isParenthesisNode === true && x.constructor.prototype.isNode === true || false;
      }
      function isRangeNode2(x) {
        return x && x.isRangeNode === true && x.constructor.prototype.isNode === true || false;
      }
      function isRelationalNode2(x) {
        return x && x.isRelationalNode === true && x.constructor.prototype.isNode === true || false;
      }
      function isSymbolNode2(x) {
        return x && x.isSymbolNode === true && x.constructor.prototype.isNode === true || false;
      }
      function isChain2(x) {
        return x && x.constructor.prototype.isChain === true || false;
      }
      function typeOf2(x) {
        var t = (0, _typeof2["default"])(x);
        if (t === "object") {
          if (x === null) return "null";
          if (isBigNumber2(x)) return "BigNumber";
          if (x.constructor && x.constructor.name) return x.constructor.name;
          return "Object";
        }
        return t;
      }
    }
  });

  // node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/utils/object.js
  var require_object = __commonJS({
    "node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/utils/object.js"(exports) {
      "use strict";
      var _interopRequireDefault = require_interopRequireDefault();
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.canDefineProperty = canDefineProperty;
      exports.clone = clone4;
      exports.deepExtend = deepExtend;
      exports.deepFlatten = deepFlatten;
      exports.deepStrictEqual = deepStrictEqual2;
      exports.extend = extend;
      exports.get = get;
      exports.hasOwnProperty = hasOwnProperty2;
      exports.isLegacyFactory = isLegacyFactory;
      exports.lazy = lazy;
      exports.mapObject = mapObject2;
      exports.pick = pick;
      exports.pickShallow = pickShallow2;
      exports.set = set;
      exports.traverse = traverse;
      var _typeof2 = _interopRequireDefault(require_typeof());
      var _is = require_is();
      function clone4(x) {
        var type = (0, _typeof2["default"])(x);
        if (type === "number" || type === "string" || type === "boolean" || x === null || x === void 0) {
          return x;
        }
        if (typeof x.clone === "function") {
          return x.clone();
        }
        if (Array.isArray(x)) {
          return x.map(function(value) {
            return clone4(value);
          });
        }
        if (x instanceof Date) return new Date(x.valueOf());
        if ((0, _is.isBigNumber)(x)) return x;
        if ((0, _is.isObject)(x)) {
          return mapObject2(x, clone4);
        }
        throw new TypeError("Cannot clone: unknown type of value (value: ".concat(x, ")"));
      }
      function mapObject2(object, callback) {
        var clone5 = {};
        for (var key in object) {
          if (hasOwnProperty2(object, key)) {
            clone5[key] = callback(object[key]);
          }
        }
        return clone5;
      }
      function extend(a, b) {
        for (var prop in b) {
          if (hasOwnProperty2(b, prop)) {
            a[prop] = b[prop];
          }
        }
        return a;
      }
      function deepExtend(a, b) {
        if (Array.isArray(b)) {
          throw new TypeError("Arrays are not supported by deepExtend");
        }
        for (var prop in b) {
          if (hasOwnProperty2(b, prop) && !(prop in Object.prototype) && !(prop in Function.prototype)) {
            if (b[prop] && b[prop].constructor === Object) {
              if (a[prop] === void 0) {
                a[prop] = {};
              }
              if (a[prop] && a[prop].constructor === Object) {
                deepExtend(a[prop], b[prop]);
              } else {
                a[prop] = b[prop];
              }
            } else if (Array.isArray(b[prop])) {
              throw new TypeError("Arrays are not supported by deepExtend");
            } else {
              a[prop] = b[prop];
            }
          }
        }
        return a;
      }
      function deepStrictEqual2(a, b) {
        var prop, i, len;
        if (Array.isArray(a)) {
          if (!Array.isArray(b)) {
            return false;
          }
          if (a.length !== b.length) {
            return false;
          }
          for (i = 0, len = a.length; i < len; i++) {
            if (!deepStrictEqual2(a[i], b[i])) {
              return false;
            }
          }
          return true;
        } else if (typeof a === "function") {
          return a === b;
        } else if (a instanceof Object) {
          if (Array.isArray(b) || !(b instanceof Object)) {
            return false;
          }
          for (prop in a) {
            if (!(prop in b) || !deepStrictEqual2(a[prop], b[prop])) {
              return false;
            }
          }
          for (prop in b) {
            if (!(prop in a)) {
              return false;
            }
          }
          return true;
        } else {
          return a === b;
        }
      }
      function deepFlatten(nestedObject) {
        var flattenedObject = {};
        _deepFlatten(nestedObject, flattenedObject);
        return flattenedObject;
      }
      function _deepFlatten(nestedObject, flattenedObject) {
        for (var prop in nestedObject) {
          if (hasOwnProperty2(nestedObject, prop)) {
            var value = nestedObject[prop];
            if ((0, _typeof2["default"])(value) === "object" && value !== null) {
              _deepFlatten(value, flattenedObject);
            } else {
              flattenedObject[prop] = value;
            }
          }
        }
      }
      function canDefineProperty() {
        try {
          if (Object.defineProperty) {
            Object.defineProperty({}, "x", {
              get: function get2() {
                return null;
              }
            });
            return true;
          }
        } catch (e) {
        }
        return false;
      }
      function lazy(object, prop, valueResolver) {
        var _uninitialized = true;
        var _value;
        Object.defineProperty(object, prop, {
          get: function get2() {
            if (_uninitialized) {
              _value = valueResolver();
              _uninitialized = false;
            }
            return _value;
          },
          set: function set2(value) {
            _value = value;
            _uninitialized = false;
          },
          configurable: true,
          enumerable: true
        });
      }
      function traverse(object, path) {
        if (path && typeof path === "string") {
          return traverse(object, path.split("."));
        }
        var obj = object;
        if (path) {
          for (var i = 0; i < path.length; i++) {
            var key = path[i];
            if (!(key in obj)) {
              obj[key] = {};
            }
            obj = obj[key];
          }
        }
        return obj;
      }
      function hasOwnProperty2(object, property) {
        return object && Object.hasOwnProperty.call(object, property);
      }
      function isLegacyFactory(object) {
        return object && typeof object.factory === "function";
      }
      function get(object, path) {
        if (typeof path === "string") {
          if (isPath(path)) {
            return get(object, path.split("."));
          } else {
            return object[path];
          }
        }
        var child = object;
        for (var i = 0; i < path.length; i++) {
          var key = path[i];
          child = child ? child[key] : void 0;
        }
        return child;
      }
      function set(object, path, value) {
        if (typeof path === "string") {
          if (isPath(path)) {
            return set(object, path.split("."), value);
          } else {
            object[path] = value;
            return object;
          }
        }
        var child = object;
        for (var i = 0; i < path.length - 1; i++) {
          var key = path[i];
          if (child[key] === void 0) {
            child[key] = {};
          }
          child = child[key];
        }
        if (path.length > 0) {
          var lastKey = path[path.length - 1];
          child[lastKey] = value;
        }
        return object;
      }
      function pick(object, properties, transform) {
        var copy = {};
        for (var i = 0; i < properties.length; i++) {
          var key = properties[i];
          var value = get(object, key);
          if (value !== void 0) {
            set(copy, key, transform ? transform(value, key) : value);
          }
        }
        return copy;
      }
      function pickShallow2(object, properties) {
        var copy = {};
        for (var i = 0; i < properties.length; i++) {
          var key = properties[i];
          var value = object[key];
          if (value !== void 0) {
            copy[key] = value;
          }
        }
        return copy;
      }
      function isPath(str) {
        return str.includes(".");
      }
    }
  });

  // node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/core/function/config.js
  var require_config2 = __commonJS({
    "node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/core/function/config.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.NUMBER_OPTIONS = exports.MATRIX_OPTIONS = void 0;
      exports.configFactory = configFactory;
      var _object = require_object();
      var _config2 = require_config();
      var MATRIX_OPTIONS2 = exports.MATRIX_OPTIONS = ["Matrix", "Array"];
      var NUMBER_OPTIONS2 = exports.NUMBER_OPTIONS = ["number", "BigNumber", "Fraction"];
      function configFactory(config4, emit) {
        function _config(options) {
          if (options) {
            var prev = (0, _object.mapObject)(config4, _object.clone);
            validateOption(options, "matrix", MATRIX_OPTIONS2);
            validateOption(options, "number", NUMBER_OPTIONS2);
            (0, _object.deepExtend)(config4, options);
            var curr = (0, _object.mapObject)(config4, _object.clone);
            var changes = (0, _object.mapObject)(options, _object.clone);
            emit("config", curr, prev, changes);
            return curr;
          } else {
            return (0, _object.mapObject)(config4, _object.clone);
          }
        }
        _config.MATRIX_OPTIONS = MATRIX_OPTIONS2;
        _config.NUMBER_OPTIONS = NUMBER_OPTIONS2;
        Object.keys(_config2.DEFAULT_CONFIG).forEach(function(key) {
          Object.defineProperty(_config, key, {
            get: function get() {
              return config4[key];
            },
            enumerable: true,
            configurable: true
          });
        });
        return _config;
      }
      function validateOption(options, name18, values) {
        if (options[name18] !== void 0 && !values.includes(options[name18])) {
          console.warn('Warning: Unknown value "' + options[name18] + '" for configuration option "' + name18 + '". Available options: ' + values.map(function(value) {
            return JSON.stringify(value);
          }).join(", ") + ".");
        }
      }
    }
  });

  // node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/entry/configReadonly.js
  var require_configReadonly = __commonJS({
    "node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/entry/configReadonly.js"(exports) {
      "use strict";
      var _interopRequireDefault = require_interopRequireDefault();
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.config = void 0;
      var _extends2 = _interopRequireDefault(require_extends());
      var _config = require_config();
      var _config2 = require_config2();
      var config4 = exports.config = function config5(options) {
        if (options) {
          throw new Error("The global config is readonly. \nPlease create a mathjs instance if you want to change the default configuration. \nExample:\n\n  import { create, all } from 'mathjs';\n  const mathjs = create(all);\n  mathjs.config({ number: 'BigNumber' });\n");
        }
        return Object.freeze(_config.DEFAULT_CONFIG);
      };
      (0, _extends2["default"])(config4, _config.DEFAULT_CONFIG, {
        MATRIX_OPTIONS: _config2.MATRIX_OPTIONS,
        NUMBER_OPTIONS: _config2.NUMBER_OPTIONS
      });
    }
  });

  // node_modules/.pnpm/typed-function@4.2.2/node_modules/typed-function/lib/umd/typed-function.js
  var require_typed_function = __commonJS({
    "node_modules/.pnpm/typed-function@4.2.2/node_modules/typed-function/lib/umd/typed-function.js"(exports, module) {
      (function(global, factory2) {
        typeof exports === "object" && typeof module !== "undefined" ? module.exports = factory2() : typeof define === "function" && define.amd ? define(factory2) : (global = typeof globalThis !== "undefined" ? globalThis : global || self, global.typed = factory2());
      })(exports, (function() {
        "use strict";
        function ok() {
          return true;
        }
        function notOk() {
          return false;
        }
        function undef() {
          return void 0;
        }
        const NOT_TYPED_FUNCTION = "Argument is not a typed-function.";
        function create() {
          function isPlainObject2(x) {
            return typeof x === "object" && x !== null && x.constructor === Object;
          }
          const _types = [{
            name: "number",
            test: function(x) {
              return typeof x === "number";
            }
          }, {
            name: "string",
            test: function(x) {
              return typeof x === "string";
            }
          }, {
            name: "boolean",
            test: function(x) {
              return typeof x === "boolean";
            }
          }, {
            name: "Function",
            test: function(x) {
              return typeof x === "function";
            }
          }, {
            name: "Array",
            test: Array.isArray
          }, {
            name: "Date",
            test: function(x) {
              return x instanceof Date;
            }
          }, {
            name: "RegExp",
            test: function(x) {
              return x instanceof RegExp;
            }
          }, {
            name: "Object",
            test: isPlainObject2
          }, {
            name: "null",
            test: function(x) {
              return x === null;
            }
          }, {
            name: "undefined",
            test: function(x) {
              return x === void 0;
            }
          }];
          const anyType = {
            name: "any",
            test: ok,
            isAny: true
          };
          let typeMap;
          let typeList;
          let nConversions = 0;
          let typed2 = {
            createCount: 0
          };
          function findType(typeName) {
            const type = typeMap.get(typeName);
            if (type) {
              return type;
            }
            let message = 'Unknown type "' + typeName + '"';
            const name18 = typeName.toLowerCase();
            let otherName;
            for (otherName of typeList) {
              if (otherName.toLowerCase() === name18) {
                message += '. Did you mean "' + otherName + '" ?';
                break;
              }
            }
            throw new TypeError(message);
          }
          function addTypes(types) {
            let beforeSpec = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "any";
            const beforeIndex = beforeSpec ? findType(beforeSpec).index : typeList.length;
            const newTypes = [];
            for (let i = 0; i < types.length; ++i) {
              if (!types[i] || typeof types[i].name !== "string" || typeof types[i].test !== "function") {
                throw new TypeError("Object with properties {name: string, test: function} expected");
              }
              const typeName = types[i].name;
              if (typeMap.has(typeName)) {
                throw new TypeError('Duplicate type name "' + typeName + '"');
              }
              newTypes.push(typeName);
              typeMap.set(typeName, {
                name: typeName,
                test: types[i].test,
                isAny: types[i].isAny,
                index: beforeIndex + i,
                conversionsTo: []
                // Newly added type can't have any conversions to it
              });
            }
            const affectedTypes = typeList.slice(beforeIndex);
            typeList = typeList.slice(0, beforeIndex).concat(newTypes).concat(affectedTypes);
            for (let i = beforeIndex + newTypes.length; i < typeList.length; ++i) {
              typeMap.get(typeList[i]).index = i;
            }
          }
          function clear() {
            typeMap = /* @__PURE__ */ new Map();
            typeList = [];
            nConversions = 0;
            addTypes([anyType], false);
          }
          clear();
          addTypes(_types);
          function clearConversions() {
            let typeName;
            for (typeName of typeList) {
              typeMap.get(typeName).conversionsTo = [];
            }
            nConversions = 0;
          }
          function findTypeNames(value) {
            const matches = typeList.filter((name18) => {
              const type = typeMap.get(name18);
              return !type.isAny && type.test(value);
            });
            if (matches.length) {
              return matches;
            }
            return ["any"];
          }
          function isTypedFunction(entity) {
            return entity && typeof entity === "function" && "_typedFunctionData" in entity;
          }
          function findSignature(fn, signature, options) {
            if (!isTypedFunction(fn)) {
              throw new TypeError(NOT_TYPED_FUNCTION);
            }
            const exact = options && options.exact;
            const stringSignature = Array.isArray(signature) ? signature.join(",") : signature;
            const params = parseSignature(stringSignature);
            const canonicalSignature = stringifyParams(params);
            if (!exact || canonicalSignature in fn.signatures) {
              const match = fn._typedFunctionData.signatureMap.get(canonicalSignature);
              if (match) {
                return match;
              }
            }
            const nParams = params.length;
            let remainingSignatures;
            if (exact) {
              remainingSignatures = [];
              let name18;
              for (name18 in fn.signatures) {
                remainingSignatures.push(fn._typedFunctionData.signatureMap.get(name18));
              }
            } else {
              remainingSignatures = fn._typedFunctionData.signatures;
            }
            for (let i = 0; i < nParams; ++i) {
              const want = params[i];
              const filteredSignatures = [];
              let possibility;
              for (possibility of remainingSignatures) {
                const have = getParamAtIndex(possibility.params, i);
                if (!have || want.restParam && !have.restParam) {
                  continue;
                }
                if (!have.hasAny) {
                  const haveTypes = paramTypeSet(have);
                  if (want.types.some((wtype) => !haveTypes.has(wtype.name))) {
                    continue;
                  }
                }
                filteredSignatures.push(possibility);
              }
              remainingSignatures = filteredSignatures;
              if (remainingSignatures.length === 0) break;
            }
            let candidate;
            for (candidate of remainingSignatures) {
              if (candidate.params.length <= nParams) {
                return candidate;
              }
            }
            throw new TypeError("Signature not found (signature: " + (fn.name || "unnamed") + "(" + stringifyParams(params, ", ") + "))");
          }
          function find(fn, signature, options) {
            return findSignature(fn, signature, options).implementation;
          }
          function convert(value, typeName) {
            const type = findType(typeName);
            if (type.test(value)) {
              return value;
            }
            const conversions = type.conversionsTo;
            if (conversions.length === 0) {
              throw new Error("There are no conversions to " + typeName + " defined.");
            }
            for (let i = 0; i < conversions.length; i++) {
              const fromType = findType(conversions[i].from);
              if (fromType.test(value)) {
                return conversions[i].convert(value);
              }
            }
            throw new Error("Cannot convert " + value + " to " + typeName);
          }
          function stringifyParams(params) {
            let separator = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : ",";
            return params.map((p) => p.name).join(separator);
          }
          function parseParam(param) {
            const restParam = param.indexOf("...") === 0;
            const types = !restParam ? param : param.length > 3 ? param.slice(3) : "any";
            const typeDefs = types.split("|").map((s) => findType(s.trim()));
            let hasAny = false;
            let paramName = restParam ? "..." : "";
            const exactTypes = typeDefs.map(function(type) {
              hasAny = type.isAny || hasAny;
              paramName += type.name + "|";
              return {
                name: type.name,
                typeIndex: type.index,
                test: type.test,
                isAny: type.isAny,
                conversion: null,
                conversionIndex: -1
              };
            });
            return {
              types: exactTypes,
              name: paramName.slice(0, -1),
              // remove trailing '|' from above
              hasAny,
              hasConversion: false,
              restParam
            };
          }
          function expandParam(param) {
            const typeNames = param.types.map((t) => t.name);
            const matchingConversions = availableConversions(typeNames);
            let hasAny = param.hasAny;
            let newName = param.name;
            const convertibleTypes = matchingConversions.map(function(conversion) {
              const type = findType(conversion.from);
              hasAny = type.isAny || hasAny;
              newName += "|" + conversion.from;
              return {
                name: conversion.from,
                typeIndex: type.index,
                test: type.test,
                isAny: type.isAny,
                conversion,
                conversionIndex: conversion.index
              };
            });
            return {
              types: param.types.concat(convertibleTypes),
              name: newName,
              hasAny,
              hasConversion: convertibleTypes.length > 0,
              restParam: param.restParam
            };
          }
          function paramTypeSet(param) {
            if (!param.typeSet) {
              param.typeSet = /* @__PURE__ */ new Set();
              param.types.forEach((type) => param.typeSet.add(type.name));
            }
            return param.typeSet;
          }
          function parseSignature(rawSignature) {
            const params = [];
            if (typeof rawSignature !== "string") {
              throw new TypeError("Signatures must be strings");
            }
            const signature = rawSignature.trim();
            if (signature === "") {
              return params;
            }
            const rawParams = signature.split(",");
            for (let i = 0; i < rawParams.length; ++i) {
              const parsedParam = parseParam(rawParams[i].trim());
              if (parsedParam.restParam && i !== rawParams.length - 1) {
                throw new SyntaxError('Unexpected rest parameter "' + rawParams[i] + '": only allowed for the last parameter');
              }
              if (parsedParam.types.length === 0) {
                return null;
              }
              params.push(parsedParam);
            }
            return params;
          }
          function hasRestParam(params) {
            const param = last(params);
            return param ? param.restParam : false;
          }
          function compileTest(param) {
            if (!param || param.types.length === 0) {
              return ok;
            } else if (param.types.length === 1) {
              return findType(param.types[0].name).test;
            } else if (param.types.length === 2) {
              const test0 = findType(param.types[0].name).test;
              const test1 = findType(param.types[1].name).test;
              return function or(x) {
                return test0(x) || test1(x);
              };
            } else {
              const tests = param.types.map(function(type) {
                return findType(type.name).test;
              });
              return function or(x) {
                for (let i = 0; i < tests.length; i++) {
                  if (tests[i](x)) {
                    return true;
                  }
                }
                return false;
              };
            }
          }
          function compileTests(params) {
            let tests, test0, test1;
            if (hasRestParam(params)) {
              tests = initial(params).map(compileTest);
              const varIndex = tests.length;
              const lastTest = compileTest(last(params));
              const testRestParam = function(args) {
                for (let i = varIndex; i < args.length; i++) {
                  if (!lastTest(args[i])) {
                    return false;
                  }
                }
                return true;
              };
              return function testArgs(args) {
                for (let i = 0; i < tests.length; i++) {
                  if (!tests[i](args[i])) {
                    return false;
                  }
                }
                return testRestParam(args) && args.length >= varIndex + 1;
              };
            } else {
              if (params.length === 0) {
                return function testArgs(args) {
                  return args.length === 0;
                };
              } else if (params.length === 1) {
                test0 = compileTest(params[0]);
                return function testArgs(args) {
                  return test0(args[0]) && args.length === 1;
                };
              } else if (params.length === 2) {
                test0 = compileTest(params[0]);
                test1 = compileTest(params[1]);
                return function testArgs(args) {
                  return test0(args[0]) && test1(args[1]) && args.length === 2;
                };
              } else {
                tests = params.map(compileTest);
                return function testArgs(args) {
                  for (let i = 0; i < tests.length; i++) {
                    if (!tests[i](args[i])) {
                      return false;
                    }
                  }
                  return args.length === tests.length;
                };
              }
            }
          }
          function getParamAtIndex(params, index) {
            return index < params.length ? params[index] : hasRestParam(params) ? last(params) : null;
          }
          function getTypeSetAtIndex(params, index) {
            const param = getParamAtIndex(params, index);
            if (!param) {
              return /* @__PURE__ */ new Set();
            }
            return paramTypeSet(param);
          }
          function isExactType(type) {
            return type.conversion === null || type.conversion === void 0;
          }
          function mergeExpectedParams(signatures, index) {
            const typeSet = /* @__PURE__ */ new Set();
            signatures.forEach((signature) => {
              const paramSet = getTypeSetAtIndex(signature.params, index);
              let name18;
              for (name18 of paramSet) {
                typeSet.add(name18);
              }
            });
            return typeSet.has("any") ? ["any"] : Array.from(typeSet);
          }
          function createError(name18, args, signatures) {
            let err, expected;
            const _name = name18 || "unnamed";
            let matchingSignatures = signatures;
            let index;
            for (index = 0; index < args.length; index++) {
              const nextMatchingDefs = [];
              matchingSignatures.forEach((signature) => {
                const param = getParamAtIndex(signature.params, index);
                const test = compileTest(param);
                if ((index < signature.params.length || hasRestParam(signature.params)) && test(args[index])) {
                  nextMatchingDefs.push(signature);
                }
              });
              if (nextMatchingDefs.length === 0) {
                expected = mergeExpectedParams(matchingSignatures, index);
                if (expected.length > 0) {
                  const actualTypes = findTypeNames(args[index]);
                  err = new TypeError("Unexpected type of argument in function " + _name + " (expected: " + expected.join(" or ") + ", actual: " + actualTypes.join(" | ") + ", index: " + index + ")");
                  err.data = {
                    category: "wrongType",
                    fn: _name,
                    index,
                    actual: actualTypes,
                    expected
                  };
                  return err;
                }
              } else {
                matchingSignatures = nextMatchingDefs;
              }
            }
            const lengths = matchingSignatures.map(function(signature) {
              return hasRestParam(signature.params) ? Infinity : signature.params.length;
            });
            if (args.length < Math.min.apply(null, lengths)) {
              expected = mergeExpectedParams(matchingSignatures, index);
              err = new TypeError("Too few arguments in function " + _name + " (expected: " + expected.join(" or ") + ", index: " + args.length + ")");
              err.data = {
                category: "tooFewArgs",
                fn: _name,
                index: args.length,
                expected
              };
              return err;
            }
            const maxLength = Math.max.apply(null, lengths);
            if (args.length > maxLength) {
              err = new TypeError("Too many arguments in function " + _name + " (expected: " + maxLength + ", actual: " + args.length + ")");
              err.data = {
                category: "tooManyArgs",
                fn: _name,
                index: args.length,
                expectedLength: maxLength
              };
              return err;
            }
            const argTypes = [];
            for (let i = 0; i < args.length; ++i) {
              argTypes.push(findTypeNames(args[i]).join("|"));
            }
            err = new TypeError('Arguments of type "' + argTypes.join(", ") + '" do not match any of the defined signatures of function ' + _name + ".");
            err.data = {
              category: "mismatch",
              actual: argTypes
            };
            return err;
          }
          function getLowestTypeIndex(param) {
            let min2 = typeList.length + 1;
            for (let i = 0; i < param.types.length; i++) {
              min2 = Math.min(min2, param.types[i].typeIndex);
            }
            return min2;
          }
          function getLowestConversionIndex(param) {
            let min2 = nConversions + 1;
            for (let i = 0; i < param.types.length; i++) {
              if (!isExactType(param.types[i])) {
                min2 = Math.min(min2, param.types[i].conversionIndex);
              }
            }
            return min2;
          }
          function compareParams(param1, param2) {
            if (param1.hasAny) {
              if (!param2.hasAny) {
                return 0.1;
              }
            } else if (param2.hasAny) {
              return -0.1;
            }
            if (param1.restParam) {
              if (!param2.restParam) {
                return 0.01;
              }
            } else if (param2.restParam) {
              return -0.01;
            }
            const typeDiff = getLowestTypeIndex(param1) - getLowestTypeIndex(param2);
            if (typeDiff < 0) {
              return -1e-3;
            }
            if (typeDiff > 0) {
              return 1e-3;
            }
            const conv1 = getLowestConversionIndex(param1);
            const conv2 = getLowestConversionIndex(param2);
            if (param1.hasConversion) {
              if (!param2.hasConversion) {
                return (1 + conv1) * 1e-6;
              }
            } else if (param2.hasConversion) {
              return -(1 + conv2) * 1e-6;
            }
            const convDiff = conv1 - conv2;
            if (convDiff < 0) {
              return -1e-7;
            }
            if (convDiff > 0) {
              return 1e-7;
            }
            return 0;
          }
          function compareSignatures(signature1, signature2) {
            const pars1 = signature1.params;
            const pars2 = signature2.params;
            const last1 = last(pars1);
            const last2 = last(pars2);
            const hasRest1 = hasRestParam(pars1);
            const hasRest2 = hasRestParam(pars2);
            if (hasRest1 && last1.hasAny) {
              if (!hasRest2 || !last2.hasAny) {
                return 1e7;
              }
            } else if (hasRest2 && last2.hasAny) {
              return -1e7;
            }
            let any1 = 0;
            let conv1 = 0;
            let par;
            for (par of pars1) {
              if (par.hasAny) ++any1;
              if (par.hasConversion) ++conv1;
            }
            let any2 = 0;
            let conv2 = 0;
            for (par of pars2) {
              if (par.hasAny) ++any2;
              if (par.hasConversion) ++conv2;
            }
            if (any1 !== any2) {
              return (any1 - any2) * 1e6;
            }
            if (hasRest1 && last1.hasConversion) {
              if (!hasRest2 || !last2.hasConversion) {
                return 1e5;
              }
            } else if (hasRest2 && last2.hasConversion) {
              return -1e5;
            }
            if (conv1 !== conv2) {
              return (conv1 - conv2) * 1e4;
            }
            if (hasRest1) {
              if (!hasRest2) {
                return 1e3;
              }
            } else if (hasRest2) {
              return -1e3;
            }
            const lengthCriterion = (pars1.length - pars2.length) * (hasRest1 ? -100 : 100);
            if (lengthCriterion !== 0) {
              return lengthCriterion;
            }
            const comparisons = [];
            let tc = 0;
            for (let i = 0; i < pars1.length; ++i) {
              const thisComparison = compareParams(pars1[i], pars2[i]);
              comparisons.push(thisComparison);
              tc += thisComparison;
            }
            if (tc !== 0) {
              return (tc < 0 ? -10 : 10) + tc;
            }
            let c;
            let bonus = 9;
            const decrement = bonus / (comparisons.length + 1);
            for (c of comparisons) {
              if (c !== 0) {
                return (c < 0 ? -bonus : bonus) + c;
              }
              bonus -= decrement;
            }
            return 0;
          }
          function availableConversions(typeNames) {
            if (typeNames.length === 0) {
              return [];
            }
            const types = typeNames.map(findType);
            if (typeNames.length === 1) return types[0].conversionsTo;
            const knownTypes = new Set(typeNames);
            const convertibleTypes = /* @__PURE__ */ new Set();
            for (let i = 0; i < types.length; ++i) {
              for (const match of types[i].conversionsTo) {
                if (!knownTypes.has(match.from)) convertibleTypes.add(match.from);
              }
            }
            const matches = [];
            for (const typeName of convertibleTypes) {
              let bestIndex = nConversions + 1;
              let bestConversion = null;
              for (let i = 0; i < types.length; ++i) {
                for (const match of types[i].conversionsTo) {
                  if (match.from === typeName && match.index < bestIndex) {
                    bestIndex = match.index;
                    bestConversion = match;
                  }
                }
              }
              matches.push(bestConversion);
            }
            return matches;
          }
          function compileArgsPreprocessing(params, fn) {
            let fnConvert = fn;
            let name18 = "";
            if (params.some((p) => p.hasConversion)) {
              const restParam = hasRestParam(params);
              const compiledConversions = params.map(compileArgConversion);
              name18 = compiledConversions.map((conv) => conv.name).join(";");
              fnConvert = function convertArgs() {
                const args = [];
                const last2 = restParam ? arguments.length - 1 : arguments.length;
                for (let i = 0; i < last2; i++) {
                  args[i] = compiledConversions[i](arguments[i]);
                }
                if (restParam) {
                  args[last2] = arguments[last2].map(compiledConversions[last2]);
                }
                return fn.apply(this, args);
              };
            }
            let fnPreprocess = fnConvert;
            if (hasRestParam(params)) {
              const offset = params.length - 1;
              fnPreprocess = function preprocessRestParams() {
                return fnConvert.apply(this, slice(arguments, 0, offset).concat([slice(arguments, offset)]));
              };
            }
            if (name18) Object.defineProperty(fnPreprocess, "name", {
              value: name18
            });
            return fnPreprocess;
          }
          function compileArgConversion(param) {
            let test0, test1, conversion0, conversion1;
            const tests = [];
            const conversions = [];
            let name18 = "";
            param.types.forEach(function(type) {
              if (type.conversion) {
                name18 += type.conversion.from + "~>" + type.conversion.to + ",";
                tests.push(findType(type.conversion.from).test);
                conversions.push(type.conversion.convert);
              }
            });
            if (name18) name18 = name18.slice(0, -1);
            else name18 = "pass";
            let convertor = (arg) => arg;
            switch (conversions.length) {
              case 0:
                break;
              case 1:
                test0 = tests[0];
                conversion0 = conversions[0];
                convertor = function convertArg(arg) {
                  if (test0(arg)) {
                    return conversion0(arg);
                  }
                  return arg;
                };
                break;
              case 2:
                test0 = tests[0];
                test1 = tests[1];
                conversion0 = conversions[0];
                conversion1 = conversions[1];
                convertor = function convertArg(arg) {
                  if (test0(arg)) {
                    return conversion0(arg);
                  }
                  if (test1(arg)) {
                    return conversion1(arg);
                  }
                  return arg;
                };
                break;
              default:
                convertor = function convertArg(arg) {
                  for (let i = 0; i < conversions.length; i++) {
                    if (tests[i](arg)) {
                      return conversions[i](arg);
                    }
                  }
                  return arg;
                };
            }
            Object.defineProperty(convertor, "name", {
              value: name18
            });
            return convertor;
          }
          function splitParams(params) {
            function _splitParams(params2, index, paramsSoFar) {
              if (index < params2.length) {
                const param = params2[index];
                let resultingParams = [];
                if (param.restParam) {
                  const exactTypes = param.types.filter(isExactType);
                  if (exactTypes.length < param.types.length) {
                    resultingParams.push({
                      types: exactTypes,
                      name: "..." + exactTypes.map((t) => t.name).join("|"),
                      hasAny: exactTypes.some((t) => t.isAny),
                      hasConversion: false,
                      restParam: true
                    });
                  }
                  resultingParams.push(param);
                } else {
                  resultingParams = param.types.map(function(type) {
                    return {
                      types: [type],
                      name: type.name,
                      hasAny: type.isAny,
                      hasConversion: type.conversion,
                      restParam: false
                    };
                  });
                }
                return flatMap(resultingParams, function(nextParam) {
                  return _splitParams(params2, index + 1, paramsSoFar.concat([nextParam]));
                });
              } else {
                return [paramsSoFar];
              }
            }
            return _splitParams(params, 0, []);
          }
          function conflicting(params1, params2) {
            const ii = Math.max(params1.length, params2.length);
            for (let i = 0; i < ii; i++) {
              const typeSet1 = getTypeSetAtIndex(params1, i);
              const typeSet2 = getTypeSetAtIndex(params2, i);
              let overlap = false;
              let name18;
              for (name18 of typeSet2) {
                if (typeSet1.has(name18)) {
                  overlap = true;
                  break;
                }
              }
              if (!overlap) {
                return false;
              }
            }
            const len1 = params1.length;
            const len2 = params2.length;
            const restParam1 = hasRestParam(params1);
            const restParam2 = hasRestParam(params2);
            return restParam1 ? restParam2 ? len1 === len2 : len2 >= len1 : restParam2 ? len1 >= len2 : len1 === len2;
          }
          function clearResolutions(functionList) {
            return functionList.map((fn) => {
              if (isReferToSelf(fn)) {
                return referToSelf(fn.referToSelf.callback);
              }
              if (isReferTo(fn)) {
                return makeReferTo(fn.referTo.references, fn.referTo.callback);
              }
              return fn;
            });
          }
          function collectResolutions(references, functionList, signatureMap) {
            const resolvedReferences = [];
            let reference;
            for (reference of references) {
              let resolution = signatureMap[reference];
              if (typeof resolution !== "number") {
                throw new TypeError('No definition for referenced signature "' + reference + '"');
              }
              resolution = functionList[resolution];
              if (typeof resolution !== "function") {
                return false;
              }
              resolvedReferences.push(resolution);
            }
            return resolvedReferences;
          }
          function resolveReferences(functionList, signatureMap, self2) {
            const resolvedFunctions = clearResolutions(functionList);
            const isResolved = new Array(resolvedFunctions.length).fill(false);
            let leftUnresolved = true;
            while (leftUnresolved) {
              leftUnresolved = false;
              let nothingResolved = true;
              for (let i = 0; i < resolvedFunctions.length; ++i) {
                if (isResolved[i]) continue;
                const fn = resolvedFunctions[i];
                if (isReferToSelf(fn)) {
                  resolvedFunctions[i] = fn.referToSelf.callback(self2);
                  resolvedFunctions[i].referToSelf = fn.referToSelf;
                  isResolved[i] = true;
                  nothingResolved = false;
                } else if (isReferTo(fn)) {
                  const resolvedReferences = collectResolutions(fn.referTo.references, resolvedFunctions, signatureMap);
                  if (resolvedReferences) {
                    resolvedFunctions[i] = fn.referTo.callback.apply(this, resolvedReferences);
                    resolvedFunctions[i].referTo = fn.referTo;
                    isResolved[i] = true;
                    nothingResolved = false;
                  } else {
                    leftUnresolved = true;
                  }
                }
              }
              if (nothingResolved && leftUnresolved) {
                throw new SyntaxError("Circular reference detected in resolving typed.referTo");
              }
            }
            return resolvedFunctions;
          }
          function validateDeprecatedThis(signaturesMap) {
            const deprecatedThisRegex = /\bthis(\(|\.signatures\b)/;
            Object.keys(signaturesMap).forEach((signature) => {
              const fn = signaturesMap[signature];
              if (deprecatedThisRegex.test(fn.toString())) {
                throw new SyntaxError("Using `this` to self-reference a function is deprecated since typed-function@3. Use typed.referTo and typed.referToSelf instead.");
              }
            });
          }
          function createTypedFunction(name18, rawSignaturesMap) {
            typed2.createCount++;
            if (Object.keys(rawSignaturesMap).length === 0) {
              throw new SyntaxError("No signatures provided");
            }
            if (typed2.warnAgainstDeprecatedThis) {
              validateDeprecatedThis(rawSignaturesMap);
            }
            const parsedParams = [];
            const originalFunctions = [];
            const signaturesMap = {};
            const preliminarySignatures = [];
            let signature;
            for (signature in rawSignaturesMap) {
              if (!Object.prototype.hasOwnProperty.call(rawSignaturesMap, signature)) {
                continue;
              }
              const params = parseSignature(signature);
              if (!params) continue;
              parsedParams.forEach(function(pp) {
                if (conflicting(pp, params)) {
                  throw new TypeError('Conflicting signatures "' + stringifyParams(pp) + '" and "' + stringifyParams(params) + '".');
                }
              });
              parsedParams.push(params);
              const functionIndex = originalFunctions.length;
              originalFunctions.push(rawSignaturesMap[signature]);
              const conversionParams = params.map(expandParam);
              let sp;
              for (sp of splitParams(conversionParams)) {
                const spName = stringifyParams(sp);
                preliminarySignatures.push({
                  params: sp,
                  name: spName,
                  fn: functionIndex
                });
                if (sp.every((p) => !p.hasConversion)) {
                  signaturesMap[spName] = functionIndex;
                }
              }
            }
            preliminarySignatures.sort(compareSignatures);
            const resolvedFunctions = resolveReferences(originalFunctions, signaturesMap, theTypedFn);
            let s;
            for (s in signaturesMap) {
              if (Object.prototype.hasOwnProperty.call(signaturesMap, s)) {
                signaturesMap[s] = resolvedFunctions[signaturesMap[s]];
              }
            }
            const signatures = [];
            const internalSignatureMap = /* @__PURE__ */ new Map();
            for (s of preliminarySignatures) {
              if (!internalSignatureMap.has(s.name)) {
                s.fn = resolvedFunctions[s.fn];
                signatures.push(s);
                internalSignatureMap.set(s.name, s);
              }
            }
            const ok0 = signatures[0] && signatures[0].params.length <= 2 && !hasRestParam(signatures[0].params);
            const ok1 = signatures[1] && signatures[1].params.length <= 2 && !hasRestParam(signatures[1].params);
            const ok2 = signatures[2] && signatures[2].params.length <= 2 && !hasRestParam(signatures[2].params);
            const ok3 = signatures[3] && signatures[3].params.length <= 2 && !hasRestParam(signatures[3].params);
            const ok4 = signatures[4] && signatures[4].params.length <= 2 && !hasRestParam(signatures[4].params);
            const ok5 = signatures[5] && signatures[5].params.length <= 2 && !hasRestParam(signatures[5].params);
            const allOk = ok0 && ok1 && ok2 && ok3 && ok4 && ok5;
            for (let i = 0; i < signatures.length; ++i) {
              signatures[i].test = compileTests(signatures[i].params);
            }
            const test00 = ok0 ? compileTest(signatures[0].params[0]) : notOk;
            const test10 = ok1 ? compileTest(signatures[1].params[0]) : notOk;
            const test20 = ok2 ? compileTest(signatures[2].params[0]) : notOk;
            const test30 = ok3 ? compileTest(signatures[3].params[0]) : notOk;
            const test40 = ok4 ? compileTest(signatures[4].params[0]) : notOk;
            const test50 = ok5 ? compileTest(signatures[5].params[0]) : notOk;
            const test01 = ok0 ? compileTest(signatures[0].params[1]) : notOk;
            const test11 = ok1 ? compileTest(signatures[1].params[1]) : notOk;
            const test21 = ok2 ? compileTest(signatures[2].params[1]) : notOk;
            const test31 = ok3 ? compileTest(signatures[3].params[1]) : notOk;
            const test41 = ok4 ? compileTest(signatures[4].params[1]) : notOk;
            const test51 = ok5 ? compileTest(signatures[5].params[1]) : notOk;
            for (let i = 0; i < signatures.length; ++i) {
              signatures[i].implementation = compileArgsPreprocessing(signatures[i].params, signatures[i].fn);
            }
            const fn0 = ok0 ? signatures[0].implementation : undef;
            const fn1 = ok1 ? signatures[1].implementation : undef;
            const fn2 = ok2 ? signatures[2].implementation : undef;
            const fn3 = ok3 ? signatures[3].implementation : undef;
            const fn4 = ok4 ? signatures[4].implementation : undef;
            const fn5 = ok5 ? signatures[5].implementation : undef;
            const len0 = ok0 ? signatures[0].params.length : -1;
            const len1 = ok1 ? signatures[1].params.length : -1;
            const len2 = ok2 ? signatures[2].params.length : -1;
            const len3 = ok3 ? signatures[3].params.length : -1;
            const len4 = ok4 ? signatures[4].params.length : -1;
            const len5 = ok5 ? signatures[5].params.length : -1;
            const iStart = allOk ? 6 : 0;
            const iEnd = signatures.length;
            const tests = signatures.map((s2) => s2.test);
            const fns = signatures.map((s2) => s2.implementation);
            const generic = function generic2() {
              for (let i = iStart; i < iEnd; i++) {
                if (tests[i](arguments)) {
                  return fns[i].apply(this, arguments);
                }
              }
              return typed2.onMismatch(name18, arguments, signatures);
            };
            function theTypedFn(arg0, arg1) {
              if (arguments.length === len0 && test00(arg0) && test01(arg1)) {
                return fn0.apply(this, arguments);
              }
              if (arguments.length === len1 && test10(arg0) && test11(arg1)) {
                return fn1.apply(this, arguments);
              }
              if (arguments.length === len2 && test20(arg0) && test21(arg1)) {
                return fn2.apply(this, arguments);
              }
              if (arguments.length === len3 && test30(arg0) && test31(arg1)) {
                return fn3.apply(this, arguments);
              }
              if (arguments.length === len4 && test40(arg0) && test41(arg1)) {
                return fn4.apply(this, arguments);
              }
              if (arguments.length === len5 && test50(arg0) && test51(arg1)) {
                return fn5.apply(this, arguments);
              }
              return generic.apply(this, arguments);
            }
            try {
              Object.defineProperty(theTypedFn, "name", {
                value: name18
              });
            } catch (err) {
            }
            theTypedFn.signatures = signaturesMap;
            theTypedFn._typedFunctionData = {
              signatures,
              signatureMap: internalSignatureMap
            };
            return theTypedFn;
          }
          function _onMismatch(name18, args, signatures) {
            throw createError(name18, args, signatures);
          }
          function initial(arr) {
            return slice(arr, 0, arr.length - 1);
          }
          function last(arr) {
            return arr[arr.length - 1];
          }
          function slice(arr, start, end) {
            return Array.prototype.slice.call(arr, start, end);
          }
          function findInArray(arr, test) {
            for (let i = 0; i < arr.length; i++) {
              if (test(arr[i])) {
                return arr[i];
              }
            }
            return void 0;
          }
          function flatMap(arr, callback) {
            return Array.prototype.concat.apply([], arr.map(callback));
          }
          function referTo() {
            const references = initial(arguments).map((s) => stringifyParams(parseSignature(s)));
            const callback = last(arguments);
            if (typeof callback !== "function") {
              throw new TypeError("Callback function expected as last argument");
            }
            return makeReferTo(references, callback);
          }
          function makeReferTo(references, callback) {
            return {
              referTo: {
                references,
                callback
              }
            };
          }
          function referToSelf(callback) {
            if (typeof callback !== "function") {
              throw new TypeError("Callback function expected as first argument");
            }
            return {
              referToSelf: {
                callback
              }
            };
          }
          function isReferTo(objectOrFn) {
            return objectOrFn && typeof objectOrFn.referTo === "object" && Array.isArray(objectOrFn.referTo.references) && typeof objectOrFn.referTo.callback === "function";
          }
          function isReferToSelf(objectOrFn) {
            return objectOrFn && typeof objectOrFn.referToSelf === "object" && typeof objectOrFn.referToSelf.callback === "function";
          }
          function checkName(nameSoFar, newName) {
            if (!nameSoFar) {
              return newName;
            }
            if (newName && newName !== nameSoFar) {
              const err = new Error("Function names do not match (expected: " + nameSoFar + ", actual: " + newName + ")");
              err.data = {
                actual: newName,
                expected: nameSoFar
              };
              throw err;
            }
            return nameSoFar;
          }
          function getObjectName(obj) {
            let name18;
            for (const key in obj) {
              if (Object.prototype.hasOwnProperty.call(obj, key) && (isTypedFunction(obj[key]) || typeof obj[key].signature === "string")) {
                name18 = checkName(name18, obj[key].name);
              }
            }
            return name18;
          }
          function mergeSignatures(dest, source) {
            let key;
            for (key in source) {
              if (Object.prototype.hasOwnProperty.call(source, key)) {
                if (key in dest) {
                  if (source[key] !== dest[key]) {
                    const err = new Error('Signature "' + key + '" is defined twice');
                    err.data = {
                      signature: key,
                      sourceFunction: source[key],
                      destFunction: dest[key]
                    };
                    throw err;
                  }
                }
                dest[key] = source[key];
              }
            }
          }
          const saveTyped = typed2;
          typed2 = function(maybeName) {
            const named = typeof maybeName === "string";
            const start = named ? 1 : 0;
            let name18 = named ? maybeName : "";
            const allSignatures = {};
            for (let i = start; i < arguments.length; ++i) {
              const item = arguments[i];
              let theseSignatures = {};
              let thisName;
              if (typeof item === "function") {
                thisName = item.name;
                if (typeof item.signature === "string") {
                  theseSignatures[item.signature] = item;
                } else if (isTypedFunction(item)) {
                  theseSignatures = item.signatures;
                }
              } else if (isPlainObject2(item)) {
                theseSignatures = item;
                if (!named) {
                  thisName = getObjectName(item);
                }
              }
              if (Object.keys(theseSignatures).length === 0) {
                const err = new TypeError("Argument to 'typed' at index " + i + " is not a (typed) function, nor an object with signatures as keys and functions as values.");
                err.data = {
                  index: i,
                  argument: item
                };
                throw err;
              }
              if (!named) {
                name18 = checkName(name18, thisName);
              }
              mergeSignatures(allSignatures, theseSignatures);
            }
            return createTypedFunction(name18 || "", allSignatures);
          };
          typed2.create = create;
          typed2.createCount = saveTyped.createCount;
          typed2.onMismatch = _onMismatch;
          typed2.throwMismatchError = _onMismatch;
          typed2.createError = createError;
          typed2.clear = clear;
          typed2.clearConversions = clearConversions;
          typed2.addTypes = addTypes;
          typed2._findType = findType;
          typed2.referTo = referTo;
          typed2.referToSelf = referToSelf;
          typed2.convert = convert;
          typed2.findSignature = findSignature;
          typed2.find = find;
          typed2.isTypedFunction = isTypedFunction;
          typed2.warnAgainstDeprecatedThis = true;
          typed2.addType = function(type, beforeObjectTest) {
            let before = "any";
            if (beforeObjectTest !== false && typeMap.has("Object")) {
              before = "Object";
            }
            typed2.addTypes([type], before);
          };
          function _validateConversion(conversion) {
            if (!conversion || typeof conversion.from !== "string" || typeof conversion.to !== "string" || typeof conversion.convert !== "function") {
              throw new TypeError("Object with properties {from: string, to: string, convert: function} expected");
            }
            if (conversion.to === conversion.from) {
              throw new SyntaxError('Illegal to define conversion from "' + conversion.from + '" to itself.');
            }
          }
          typed2.addConversion = function(conversion) {
            let options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {
              override: false
            };
            _validateConversion(conversion);
            const to = findType(conversion.to);
            const existing = to.conversionsTo.find((other) => other.from === conversion.from);
            if (existing) {
              if (options && options.override) {
                typed2.removeConversion({
                  from: existing.from,
                  to: conversion.to,
                  convert: existing.convert
                });
              } else {
                throw new Error('There is already a conversion from "' + conversion.from + '" to "' + to.name + '"');
              }
            }
            to.conversionsTo.push({
              from: conversion.from,
              to: to.name,
              convert: conversion.convert,
              index: nConversions++
            });
          };
          typed2.addConversions = function(conversions, options) {
            conversions.forEach((conversion) => typed2.addConversion(conversion, options));
          };
          typed2.removeConversion = function(conversion) {
            _validateConversion(conversion);
            const to = findType(conversion.to);
            const existingConversion = findInArray(to.conversionsTo, (c) => c.from === conversion.from);
            if (!existingConversion) {
              throw new Error("Attempt to remove nonexistent conversion from " + conversion.from + " to " + conversion.to);
            }
            if (existingConversion.convert !== conversion.convert) {
              throw new Error("Conversion to remove does not match existing conversion");
            }
            const index = to.conversionsTo.indexOf(existingConversion);
            to.conversionsTo.splice(index, 1);
          };
          typed2.resolve = function(tf, argList) {
            if (!isTypedFunction(tf)) {
              throw new TypeError(NOT_TYPED_FUNCTION);
            }
            const sigs = tf._typedFunctionData.signatures;
            for (let i = 0; i < sigs.length; ++i) {
              if (sigs[i].test(argList)) {
                return sigs[i];
              }
            }
            return null;
          };
          return typed2;
        }
        var typedFunction2 = create();
        return typedFunction2;
      }));
    }
  });

  // node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/utils/number.js
  var require_number = __commonJS({
    "node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/utils/number.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.cbrt = exports.atanh = exports.asinh = exports.acosh = exports.DBL_EPSILON = void 0;
      exports.copysign = copysign;
      exports.cosh = void 0;
      exports.digits = digits2;
      exports.expm1 = void 0;
      exports.format = format4;
      exports.isInteger = isInteger2;
      exports.log2 = exports.log1p = exports.log10 = void 0;
      exports.nearlyEqual = nearlyEqual3;
      exports.normalizeFormatOptions = normalizeFormatOptions2;
      exports.roundDigits = roundDigits2;
      exports.sinh = exports.sign = void 0;
      exports.splitNumber = splitNumber2;
      exports.tanh = void 0;
      exports.toEngineering = toEngineering3;
      exports.toExponential = toExponential3;
      exports.toFixed = toFixed3;
      exports.toPrecision = toPrecision2;
      var _is = require_is();
      function isInteger2(value) {
        if (typeof value === "boolean") {
          return true;
        }
        return isFinite(value) ? value === Math.round(value) : false;
      }
      var sign3 = exports.sign = Math.sign || function(x) {
        if (x > 0) {
          return 1;
        } else if (x < 0) {
          return -1;
        } else {
          return 0;
        }
      };
      var log24 = exports.log2 = Math.log2 || function log25(x) {
        return Math.log(x) / Math.LN2;
      };
      var log104 = exports.log10 = Math.log10 || function log105(x) {
        return Math.log(x) / Math.LN10;
      };
      var log1p2 = exports.log1p = Math.log1p || function(x) {
        return Math.log(x + 1);
      };
      var cbrt4 = exports.cbrt = Math.cbrt || function cbrt5(x) {
        if (x === 0) {
          return x;
        }
        var negate = x < 0;
        var result;
        if (negate) {
          x = -x;
        }
        if (isFinite(x)) {
          result = Math.exp(Math.log(x) / 3);
          result = (x / (result * result) + 2 * result) / 3;
        } else {
          result = x;
        }
        return negate ? -result : result;
      };
      var expm13 = exports.expm1 = Math.expm1 || function expm14(x) {
        return x >= 2e-4 || x <= -2e-4 ? Math.exp(x) - 1 : x + x * x / 2 + x * x * x / 6;
      };
      function formatNumberToBase2(n, base, size2) {
        var prefixes = {
          2: "0b",
          8: "0o",
          16: "0x"
        };
        var prefix = prefixes[base];
        var suffix = "";
        if (size2) {
          if (size2 < 1) {
            throw new Error("size must be in greater than 0");
          }
          if (!isInteger2(size2)) {
            throw new Error("size must be an integer");
          }
          if (n > Math.pow(2, size2 - 1) - 1 || n < -Math.pow(2, size2 - 1)) {
            throw new Error("Value must be in range [-2^".concat(size2 - 1, ", 2^").concat(size2 - 1, "-1]"));
          }
          if (!isInteger2(n)) {
            throw new Error("Value must be an integer");
          }
          if (n < 0) {
            n = n + Math.pow(2, size2);
          }
          suffix = "i".concat(size2);
        }
        var sign4 = "";
        if (n < 0) {
          n = -n;
          sign4 = "-";
        }
        return "".concat(sign4).concat(prefix).concat(n.toString(base)).concat(suffix);
      }
      function format4(value, options) {
        if (typeof options === "function") {
          return options(value);
        }
        if (value === Infinity) {
          return "Infinity";
        } else if (value === -Infinity) {
          return "-Infinity";
        } else if (isNaN(value)) {
          return "NaN";
        }
        var _normalizeFormatOptio = normalizeFormatOptions2(options), notation = _normalizeFormatOptio.notation, precision = _normalizeFormatOptio.precision, wordSize = _normalizeFormatOptio.wordSize;
        switch (notation) {
          case "fixed":
            return toFixed3(value, precision);
          case "exponential":
            return toExponential3(value, precision);
          case "engineering":
            return toEngineering3(value, precision);
          case "bin":
            return formatNumberToBase2(value, 2, wordSize);
          case "oct":
            return formatNumberToBase2(value, 8, wordSize);
          case "hex":
            return formatNumberToBase2(value, 16, wordSize);
          case "auto":
            return toPrecision2(value, precision, options).replace(/((\.\d*?)(0+))($|e)/, function() {
              var digits3 = arguments[2];
              var e = arguments[4];
              return digits3 !== "." ? digits3 + e : e;
            });
          default:
            throw new Error('Unknown notation "' + notation + '". Choose "auto", "exponential", "fixed", "bin", "oct", or "hex.');
        }
      }
      function normalizeFormatOptions2(options) {
        var notation = "auto";
        var precision;
        var wordSize;
        if (options !== void 0) {
          if ((0, _is.isNumber)(options)) {
            precision = options;
          } else if ((0, _is.isBigNumber)(options)) {
            precision = options.toNumber();
          } else if ((0, _is.isObject)(options)) {
            if (options.precision !== void 0) {
              precision = _toNumberOrThrow2(options.precision, function() {
                throw new Error('Option "precision" must be a number or BigNumber');
              });
            }
            if (options.wordSize !== void 0) {
              wordSize = _toNumberOrThrow2(options.wordSize, function() {
                throw new Error('Option "wordSize" must be a number or BigNumber');
              });
            }
            if (options.notation) {
              notation = options.notation;
            }
          } else {
            throw new Error("Unsupported type of options, number, BigNumber, or object expected");
          }
        }
        return {
          notation,
          precision,
          wordSize
        };
      }
      function splitNumber2(value) {
        var match = String(value).toLowerCase().match(/^(-?)(\d+\.?\d*)(e([+-]?\d+))?$/);
        if (!match) {
          throw new SyntaxError("Invalid number " + value);
        }
        var sign4 = match[1];
        var digits3 = match[2];
        var exponent = parseFloat(match[4] || "0");
        var dot2 = digits3.indexOf(".");
        exponent += dot2 !== -1 ? dot2 - 1 : digits3.length - 1;
        var coefficients = digits3.replace(".", "").replace(/^0*/, function(zeros3) {
          exponent -= zeros3.length;
          return "";
        }).replace(/0*$/, "").split("").map(function(d) {
          return parseInt(d);
        });
        if (coefficients.length === 0) {
          coefficients.push(0);
          exponent++;
        }
        return {
          sign: sign4,
          coefficients,
          exponent
        };
      }
      function toEngineering3(value, precision) {
        if (isNaN(value) || !isFinite(value)) {
          return String(value);
        }
        var split = splitNumber2(value);
        var rounded = roundDigits2(split, precision);
        var e = rounded.exponent;
        var c = rounded.coefficients;
        var newExp = e % 3 === 0 ? e : e < 0 ? e - 3 - e % 3 : e - e % 3;
        if ((0, _is.isNumber)(precision)) {
          while (precision > c.length || e - newExp + 1 > c.length) {
            c.push(0);
          }
        } else {
          var missingZeros = Math.abs(e - newExp) - (c.length - 1);
          for (var i = 0; i < missingZeros; i++) {
            c.push(0);
          }
        }
        var expDiff = Math.abs(e - newExp);
        var decimalIdx = 1;
        while (expDiff > 0) {
          decimalIdx++;
          expDiff--;
        }
        var decimals = c.slice(decimalIdx).join("");
        var decimalVal = (0, _is.isNumber)(precision) && decimals.length || decimals.match(/[1-9]/) ? "." + decimals : "";
        var str = c.slice(0, decimalIdx).join("") + decimalVal + "e" + (e >= 0 ? "+" : "") + newExp.toString();
        return rounded.sign + str;
      }
      function toFixed3(value, precision) {
        if (isNaN(value) || !isFinite(value)) {
          return String(value);
        }
        var splitValue = splitNumber2(value);
        var rounded = typeof precision === "number" ? roundDigits2(splitValue, splitValue.exponent + 1 + precision) : splitValue;
        var c = rounded.coefficients;
        var p = rounded.exponent + 1;
        var pp = p + (precision || 0);
        if (c.length < pp) {
          c = c.concat(zeros2(pp - c.length));
        }
        if (p < 0) {
          c = zeros2(-p + 1).concat(c);
          p = 1;
        }
        if (p < c.length) {
          c.splice(p, 0, p === 0 ? "0." : ".");
        }
        return rounded.sign + c.join("");
      }
      function toExponential3(value, precision) {
        if (isNaN(value) || !isFinite(value)) {
          return String(value);
        }
        var split = splitNumber2(value);
        var rounded = precision ? roundDigits2(split, precision) : split;
        var c = rounded.coefficients;
        var e = rounded.exponent;
        if (c.length < precision) {
          c = c.concat(zeros2(precision - c.length));
        }
        var first = c.shift();
        return rounded.sign + first + (c.length > 0 ? "." + c.join("") : "") + "e" + (e >= 0 ? "+" : "") + e;
      }
      function toPrecision2(value, precision, options) {
        if (isNaN(value) || !isFinite(value)) {
          return String(value);
        }
        var lowerExp = _toNumberOrDefault3(options === null || options === void 0 ? void 0 : options.lowerExp, -3);
        var upperExp = _toNumberOrDefault3(options === null || options === void 0 ? void 0 : options.upperExp, 5);
        var split = splitNumber2(value);
        var rounded = precision ? roundDigits2(split, precision) : split;
        if (rounded.exponent < lowerExp || rounded.exponent >= upperExp) {
          return toExponential3(value, precision);
        } else {
          var c = rounded.coefficients;
          var e = rounded.exponent;
          if (c.length < precision) {
            c = c.concat(zeros2(precision - c.length));
          }
          c = c.concat(zeros2(e - c.length + 1 + (c.length < precision ? precision - c.length : 0)));
          c = zeros2(-e).concat(c);
          var dot2 = e > 0 ? e : 0;
          if (dot2 < c.length - 1) {
            c.splice(dot2 + 1, 0, ".");
          }
          return rounded.sign + c.join("");
        }
      }
      function roundDigits2(split, precision) {
        var rounded = {
          sign: split.sign,
          coefficients: split.coefficients,
          exponent: split.exponent
        };
        var c = rounded.coefficients;
        while (precision <= 0) {
          c.unshift(0);
          rounded.exponent++;
          precision++;
        }
        if (c.length > precision) {
          var removed = c.splice(precision, c.length - precision);
          if (removed[0] >= 5) {
            var i = precision - 1;
            c[i]++;
            while (c[i] === 10) {
              c.pop();
              if (i === 0) {
                c.unshift(0);
                rounded.exponent++;
                i++;
              }
              i--;
              c[i]++;
            }
          }
        }
        return rounded;
      }
      function zeros2(length) {
        var arr = [];
        for (var i = 0; i < length; i++) {
          arr.push(0);
        }
        return arr;
      }
      function digits2(value) {
        return value.toExponential().replace(/e.*$/, "").replace(/^0\.?0*|\./, "").length;
      }
      var DBL_EPSILON2 = exports.DBL_EPSILON = Number.EPSILON || 2220446049250313e-31;
      function nearlyEqual3(x, y, epsilon) {
        if (epsilon === null || epsilon === void 0) {
          return x === y;
        }
        if (x === y) {
          return true;
        }
        if (isNaN(x) || isNaN(y)) {
          return false;
        }
        if (isFinite(x) && isFinite(y)) {
          var diff = Math.abs(x - y);
          if (diff <= DBL_EPSILON2) {
            return true;
          } else {
            return diff <= Math.max(Math.abs(x), Math.abs(y)) * epsilon;
          }
        }
        return false;
      }
      var acosh2 = exports.acosh = Math.acosh || function(x) {
        return Math.log(Math.sqrt(x * x - 1) + x);
      };
      var asinh2 = exports.asinh = Math.asinh || function(x) {
        return Math.log(Math.sqrt(x * x + 1) + x);
      };
      var atanh2 = exports.atanh = Math.atanh || function(x) {
        return Math.log((1 + x) / (1 - x)) / 2;
      };
      var cosh3 = exports.cosh = Math.cosh || function(x) {
        return (Math.exp(x) + Math.exp(-x)) / 2;
      };
      var sinh3 = exports.sinh = Math.sinh || function(x) {
        return (Math.exp(x) - Math.exp(-x)) / 2;
      };
      var tanh2 = exports.tanh = Math.tanh || function(x) {
        var e = Math.exp(2 * x);
        return (e - 1) / (e + 1);
      };
      function copysign(x, y) {
        var signx = x > 0 ? true : x < 0 ? false : 1 / x === Infinity;
        var signy = y > 0 ? true : y < 0 ? false : 1 / y === Infinity;
        return signx ^ signy ? -x : x;
      }
      function _toNumberOrThrow2(value, onError) {
        if ((0, _is.isNumber)(value)) {
          return value;
        } else if ((0, _is.isBigNumber)(value)) {
          return value.toNumber();
        } else {
          onError();
        }
      }
      function _toNumberOrDefault3(value, defaultValue) {
        if ((0, _is.isNumber)(value)) {
          return value;
        } else if ((0, _is.isBigNumber)(value)) {
          return value.toNumber();
        } else {
          return defaultValue;
        }
      }
    }
  });

  // node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/utils/factory.js
  var require_factory = __commonJS({
    "node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/utils/factory.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.assertDependencies = assertDependencies2;
      exports.create = create;
      exports.factory = factory2;
      exports.isFactory = isFactory;
      exports.isOptionalDependency = isOptionalDependency2;
      exports.sortFactories = sortFactories;
      exports.stripOptionalNotation = stripOptionalNotation2;
      var _object = require_object();
      function factory2(name18, dependencies19, create2, meta) {
        function assertAndCreate(scope) {
          var deps = (0, _object.pickShallow)(scope, dependencies19.map(stripOptionalNotation2));
          assertDependencies2(name18, dependencies19, scope);
          return create2(deps);
        }
        assertAndCreate.isFactory = true;
        assertAndCreate.fn = name18;
        assertAndCreate.dependencies = dependencies19.slice().sort();
        if (meta) {
          assertAndCreate.meta = meta;
        }
        return assertAndCreate;
      }
      function sortFactories(factories) {
        var factoriesByName = {};
        factories.forEach(function(factory3) {
          factoriesByName[factory3.fn] = factory3;
        });
        function containsDependency(factory3, dependency) {
          if (isFactory(factory3)) {
            if (factory3.dependencies.includes(dependency.fn || dependency.name)) {
              return true;
            }
            if (factory3.dependencies.some(function(d) {
              return containsDependency(factoriesByName[d], dependency);
            })) {
              return true;
            }
          }
          return false;
        }
        var sorted = [];
        function addFactory(factory3) {
          var index = 0;
          while (index < sorted.length && !containsDependency(sorted[index], factory3)) {
            index++;
          }
          sorted.splice(index, 0, factory3);
        }
        factories.filter(isFactory).forEach(addFactory);
        factories.filter(function(factory3) {
          return !isFactory(factory3);
        }).forEach(addFactory);
        return sorted;
      }
      function create(factories) {
        var scope = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
        sortFactories(factories).forEach(function(factory3) {
          return factory3(scope);
        });
        return scope;
      }
      function isFactory(obj) {
        return typeof obj === "function" && typeof obj.fn === "string" && Array.isArray(obj.dependencies);
      }
      function assertDependencies2(name18, dependencies19, scope) {
        var allDefined = dependencies19.filter(function(dependency) {
          return !isOptionalDependency2(dependency);
        }).every(function(dependency) {
          return scope[dependency] !== void 0;
        });
        if (!allDefined) {
          var missingDependencies = dependencies19.filter(function(dependency) {
            return scope[dependency] === void 0;
          });
          throw new Error('Cannot create function "'.concat(name18, '", ') + "some dependencies are missing: ".concat(missingDependencies.map(function(d) {
            return '"'.concat(d, '"');
          }).join(", "), "."));
        }
      }
      function isOptionalDependency2(dependency) {
        return dependency && dependency[0] === "?";
      }
      function stripOptionalNotation2(dependency) {
        return dependency && dependency[0] === "?" ? dependency.slice(1) : dependency;
      }
    }
  });

  // node_modules/.pnpm/@babel+runtime@7.28.4/node_modules/@babel/runtime/helpers/arrayLikeToArray.js
  var require_arrayLikeToArray = __commonJS({
    "node_modules/.pnpm/@babel+runtime@7.28.4/node_modules/@babel/runtime/helpers/arrayLikeToArray.js"(exports, module) {
      function _arrayLikeToArray(r, a) {
        (null == a || a > r.length) && (a = r.length);
        for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e];
        return n;
      }
      module.exports = _arrayLikeToArray, module.exports.__esModule = true, module.exports["default"] = module.exports;
    }
  });

  // node_modules/.pnpm/@babel+runtime@7.28.4/node_modules/@babel/runtime/helpers/arrayWithoutHoles.js
  var require_arrayWithoutHoles = __commonJS({
    "node_modules/.pnpm/@babel+runtime@7.28.4/node_modules/@babel/runtime/helpers/arrayWithoutHoles.js"(exports, module) {
      var arrayLikeToArray = require_arrayLikeToArray();
      function _arrayWithoutHoles(r) {
        if (Array.isArray(r)) return arrayLikeToArray(r);
      }
      module.exports = _arrayWithoutHoles, module.exports.__esModule = true, module.exports["default"] = module.exports;
    }
  });

  // node_modules/.pnpm/@babel+runtime@7.28.4/node_modules/@babel/runtime/helpers/iterableToArray.js
  var require_iterableToArray = __commonJS({
    "node_modules/.pnpm/@babel+runtime@7.28.4/node_modules/@babel/runtime/helpers/iterableToArray.js"(exports, module) {
      function _iterableToArray(r) {
        if ("undefined" != typeof Symbol && null != r[Symbol.iterator] || null != r["@@iterator"]) return Array.from(r);
      }
      module.exports = _iterableToArray, module.exports.__esModule = true, module.exports["default"] = module.exports;
    }
  });

  // node_modules/.pnpm/@babel+runtime@7.28.4/node_modules/@babel/runtime/helpers/unsupportedIterableToArray.js
  var require_unsupportedIterableToArray = __commonJS({
    "node_modules/.pnpm/@babel+runtime@7.28.4/node_modules/@babel/runtime/helpers/unsupportedIterableToArray.js"(exports, module) {
      var arrayLikeToArray = require_arrayLikeToArray();
      function _unsupportedIterableToArray(r, a) {
        if (r) {
          if ("string" == typeof r) return arrayLikeToArray(r, a);
          var t = {}.toString.call(r).slice(8, -1);
          return "Object" === t && r.constructor && (t = r.constructor.name), "Map" === t || "Set" === t ? Array.from(r) : "Arguments" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? arrayLikeToArray(r, a) : void 0;
        }
      }
      module.exports = _unsupportedIterableToArray, module.exports.__esModule = true, module.exports["default"] = module.exports;
    }
  });

  // node_modules/.pnpm/@babel+runtime@7.28.4/node_modules/@babel/runtime/helpers/nonIterableSpread.js
  var require_nonIterableSpread = __commonJS({
    "node_modules/.pnpm/@babel+runtime@7.28.4/node_modules/@babel/runtime/helpers/nonIterableSpread.js"(exports, module) {
      function _nonIterableSpread() {
        throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
      }
      module.exports = _nonIterableSpread, module.exports.__esModule = true, module.exports["default"] = module.exports;
    }
  });

  // node_modules/.pnpm/@babel+runtime@7.28.4/node_modules/@babel/runtime/helpers/toConsumableArray.js
  var require_toConsumableArray = __commonJS({
    "node_modules/.pnpm/@babel+runtime@7.28.4/node_modules/@babel/runtime/helpers/toConsumableArray.js"(exports, module) {
      var arrayWithoutHoles = require_arrayWithoutHoles();
      var iterableToArray = require_iterableToArray();
      var unsupportedIterableToArray = require_unsupportedIterableToArray();
      var nonIterableSpread = require_nonIterableSpread();
      function _toConsumableArray(r) {
        return arrayWithoutHoles(r) || iterableToArray(r) || unsupportedIterableToArray(r) || nonIterableSpread();
      }
      module.exports = _toConsumableArray, module.exports.__esModule = true, module.exports["default"] = module.exports;
    }
  });

  // node_modules/.pnpm/@babel+runtime@7.28.4/node_modules/@babel/runtime/helpers/classCallCheck.js
  var require_classCallCheck = __commonJS({
    "node_modules/.pnpm/@babel+runtime@7.28.4/node_modules/@babel/runtime/helpers/classCallCheck.js"(exports, module) {
      function _classCallCheck(a, n) {
        if (!(a instanceof n)) throw new TypeError("Cannot call a class as a function");
      }
      module.exports = _classCallCheck, module.exports.__esModule = true, module.exports["default"] = module.exports;
    }
  });

  // node_modules/.pnpm/@babel+runtime@7.28.4/node_modules/@babel/runtime/helpers/toPrimitive.js
  var require_toPrimitive = __commonJS({
    "node_modules/.pnpm/@babel+runtime@7.28.4/node_modules/@babel/runtime/helpers/toPrimitive.js"(exports, module) {
      var _typeof = require_typeof()["default"];
      function toPrimitive(t, r) {
        if ("object" != _typeof(t) || !t) return t;
        var e = t[Symbol.toPrimitive];
        if (void 0 !== e) {
          var i = e.call(t, r || "default");
          if ("object" != _typeof(i)) return i;
          throw new TypeError("@@toPrimitive must return a primitive value.");
        }
        return ("string" === r ? String : Number)(t);
      }
      module.exports = toPrimitive, module.exports.__esModule = true, module.exports["default"] = module.exports;
    }
  });

  // node_modules/.pnpm/@babel+runtime@7.28.4/node_modules/@babel/runtime/helpers/toPropertyKey.js
  var require_toPropertyKey = __commonJS({
    "node_modules/.pnpm/@babel+runtime@7.28.4/node_modules/@babel/runtime/helpers/toPropertyKey.js"(exports, module) {
      var _typeof = require_typeof()["default"];
      var toPrimitive = require_toPrimitive();
      function toPropertyKey(t) {
        var i = toPrimitive(t, "string");
        return "symbol" == _typeof(i) ? i : i + "";
      }
      module.exports = toPropertyKey, module.exports.__esModule = true, module.exports["default"] = module.exports;
    }
  });

  // node_modules/.pnpm/@babel+runtime@7.28.4/node_modules/@babel/runtime/helpers/createClass.js
  var require_createClass = __commonJS({
    "node_modules/.pnpm/@babel+runtime@7.28.4/node_modules/@babel/runtime/helpers/createClass.js"(exports, module) {
      var toPropertyKey = require_toPropertyKey();
      function _defineProperties(e, r) {
        for (var t = 0; t < r.length; t++) {
          var o = r[t];
          o.enumerable = o.enumerable || false, o.configurable = true, "value" in o && (o.writable = true), Object.defineProperty(e, toPropertyKey(o.key), o);
        }
      }
      function _createClass(e, r, t) {
        return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, "prototype", {
          writable: false
        }), e;
      }
      module.exports = _createClass, module.exports.__esModule = true, module.exports["default"] = module.exports;
    }
  });

  // node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/utils/customs.js
  var require_customs = __commonJS({
    "node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/utils/customs.js"(exports) {
      "use strict";
      var _interopRequireDefault = require_interopRequireDefault();
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.getSafeMethod = getSafeMethod;
      exports.getSafeProperties = getSafeProperties;
      exports.getSafeProperty = getSafeProperty2;
      exports.hasSafeProperty = hasSafeProperty2;
      exports.isPlainObject = isPlainObject2;
      exports.isSafeMethod = isSafeMethod2;
      exports.isSafeProperty = isSafeProperty2;
      exports.setSafeProperty = setSafeProperty2;
      var _typeof2 = _interopRequireDefault(require_typeof());
      var _object = require_object();
      function getSafeProperty2(object, prop) {
        if (isPlainObject2(object) && isSafeProperty2(object, prop)) {
          return object[prop];
        }
        if (typeof object[prop] === "function" && isSafeMethod2(object, prop)) {
          throw new Error('Cannot access method "' + prop + '" as a property');
        }
        throw new Error('No access to property "' + prop + '"');
      }
      function setSafeProperty2(object, prop, value) {
        if (isPlainObject2(object) && isSafeProperty2(object, prop)) {
          object[prop] = value;
          return value;
        }
        throw new Error('No access to property "' + prop + '"');
      }
      function getSafeProperties(object) {
        return Object.keys(object).filter(function(prop) {
          return (0, _object.hasOwnProperty)(object, prop);
        });
      }
      function hasSafeProperty2(object, prop) {
        return prop in object;
      }
      function isSafeProperty2(object, prop) {
        if (!object || (0, _typeof2["default"])(object) !== "object") {
          return false;
        }
        if ((0, _object.hasOwnProperty)(safeNativeProperties2, prop)) {
          return true;
        }
        if (prop in Object.prototype) {
          return false;
        }
        if (prop in Function.prototype) {
          return false;
        }
        return true;
      }
      function getSafeMethod(object, method) {
        if (!isSafeMethod2(object, method)) {
          throw new Error('No access to method "' + method + '"');
        }
        return object[method];
      }
      function isSafeMethod2(object, method) {
        if (object === null || object === void 0 || typeof object[method] !== "function") {
          return false;
        }
        if ((0, _object.hasOwnProperty)(object, method) && Object.getPrototypeOf && method in Object.getPrototypeOf(object)) {
          return false;
        }
        if ((0, _object.hasOwnProperty)(safeNativeMethods2, method)) {
          return true;
        }
        if (method in Object.prototype) {
          return false;
        }
        if (method in Function.prototype) {
          return false;
        }
        return true;
      }
      function isPlainObject2(object) {
        return (0, _typeof2["default"])(object) === "object" && object && object.constructor === Object;
      }
      var safeNativeProperties2 = {
        length: true,
        name: true
      };
      var safeNativeMethods2 = {
        toString: true,
        valueOf: true,
        toLocaleString: true
      };
    }
  });

  // node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/utils/map.js
  var require_map = __commonJS({
    "node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/utils/map.js"(exports) {
      "use strict";
      var _interopRequireDefault = require_interopRequireDefault();
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.PartitionedMap = exports.ObjectWrappingMap = void 0;
      exports.assign = assign;
      exports.createEmptyMap = createEmptyMap;
      exports.createMap = createMap2;
      exports.isMap = isMap2;
      exports.toObject = toObject;
      var _toConsumableArray2 = _interopRequireDefault(require_toConsumableArray());
      var _classCallCheck2 = _interopRequireDefault(require_classCallCheck());
      var _createClass2 = _interopRequireDefault(require_createClass());
      var _customs = require_customs();
      var _is = require_is();
      function _createForOfIteratorHelper(o, allowArrayLike) {
        var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"];
        if (!it) {
          if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") {
            if (it) o = it;
            var i = 0;
            var F = function F2() {
            };
            return { s: F, n: function n() {
              if (i >= o.length) return { done: true };
              return { done: false, value: o[i++] };
            }, e: function e(_e) {
              throw _e;
            }, f: F };
          }
          throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
        }
        var normalCompletion = true, didErr = false, err;
        return { s: function s() {
          it = it.call(o);
        }, n: function n() {
          var step = it.next();
          normalCompletion = step.done;
          return step;
        }, e: function e(_e2) {
          didErr = true;
          err = _e2;
        }, f: function f() {
          try {
            if (!normalCompletion && it["return"] != null) it["return"]();
          } finally {
            if (didErr) throw err;
          }
        } };
      }
      function _unsupportedIterableToArray(o, minLen) {
        if (!o) return;
        if (typeof o === "string") return _arrayLikeToArray(o, minLen);
        var n = Object.prototype.toString.call(o).slice(8, -1);
        if (n === "Object" && o.constructor) n = o.constructor.name;
        if (n === "Map" || n === "Set") return Array.from(o);
        if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);
      }
      function _arrayLikeToArray(arr, len) {
        if (len == null || len > arr.length) len = arr.length;
        for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];
        return arr2;
      }
      var ObjectWrappingMap2 = exports.ObjectWrappingMap = /* @__PURE__ */ (function() {
        function ObjectWrappingMap3(object) {
          (0, _classCallCheck2["default"])(this, ObjectWrappingMap3);
          this.wrappedObject = object;
          this[Symbol.iterator] = this.entries;
        }
        return (0, _createClass2["default"])(ObjectWrappingMap3, [{
          key: "keys",
          value: function keys() {
            return Object.keys(this.wrappedObject).values();
          }
        }, {
          key: "get",
          value: function get(key) {
            return (0, _customs.getSafeProperty)(this.wrappedObject, key);
          }
        }, {
          key: "set",
          value: function set(key, value) {
            (0, _customs.setSafeProperty)(this.wrappedObject, key, value);
            return this;
          }
        }, {
          key: "has",
          value: function has(key) {
            return (0, _customs.hasSafeProperty)(this.wrappedObject, key);
          }
        }, {
          key: "entries",
          value: function entries() {
            var _this = this;
            return mapIterator2(this.keys(), function(key) {
              return [key, _this.get(key)];
            });
          }
        }, {
          key: "forEach",
          value: function forEach(callback) {
            var _iterator = _createForOfIteratorHelper(this.keys()), _step;
            try {
              for (_iterator.s(); !(_step = _iterator.n()).done; ) {
                var key = _step.value;
                callback(this.get(key), key, this);
              }
            } catch (err) {
              _iterator.e(err);
            } finally {
              _iterator.f();
            }
          }
        }, {
          key: "delete",
          value: function _delete(key) {
            delete this.wrappedObject[key];
          }
        }, {
          key: "clear",
          value: function clear() {
            var _iterator2 = _createForOfIteratorHelper(this.keys()), _step2;
            try {
              for (_iterator2.s(); !(_step2 = _iterator2.n()).done; ) {
                var key = _step2.value;
                this["delete"](key);
              }
            } catch (err) {
              _iterator2.e(err);
            } finally {
              _iterator2.f();
            }
          }
        }, {
          key: "size",
          get: function get() {
            return Object.keys(this.wrappedObject).length;
          }
        }]);
      })();
      var PartitionedMap = exports.PartitionedMap = /* @__PURE__ */ (function() {
        function PartitionedMap2(a, b, bKeys) {
          (0, _classCallCheck2["default"])(this, PartitionedMap2);
          this.a = a;
          this.b = b;
          this.bKeys = bKeys;
          this[Symbol.iterator] = this.entries;
        }
        return (0, _createClass2["default"])(PartitionedMap2, [{
          key: "get",
          value: function get(key) {
            return this.bKeys.has(key) ? this.b.get(key) : this.a.get(key);
          }
        }, {
          key: "set",
          value: function set(key, value) {
            if (this.bKeys.has(key)) {
              this.b.set(key, value);
            } else {
              this.a.set(key, value);
            }
            return this;
          }
        }, {
          key: "has",
          value: function has(key) {
            return this.b.has(key) || this.a.has(key);
          }
        }, {
          key: "keys",
          value: function keys() {
            return new Set([].concat((0, _toConsumableArray2["default"])(this.a.keys()), (0, _toConsumableArray2["default"])(this.b.keys())))[Symbol.iterator]();
          }
        }, {
          key: "entries",
          value: function entries() {
            var _this2 = this;
            return mapIterator2(this.keys(), function(key) {
              return [key, _this2.get(key)];
            });
          }
        }, {
          key: "forEach",
          value: function forEach(callback) {
            var _iterator3 = _createForOfIteratorHelper(this.keys()), _step3;
            try {
              for (_iterator3.s(); !(_step3 = _iterator3.n()).done; ) {
                var key = _step3.value;
                callback(this.get(key), key, this);
              }
            } catch (err) {
              _iterator3.e(err);
            } finally {
              _iterator3.f();
            }
          }
        }, {
          key: "delete",
          value: function _delete(key) {
            return this.bKeys.has(key) ? this.b["delete"](key) : this.a["delete"](key);
          }
        }, {
          key: "clear",
          value: function clear() {
            this.a.clear();
            this.b.clear();
          }
        }, {
          key: "size",
          get: function get() {
            return (0, _toConsumableArray2["default"])(this.keys()).length;
          }
        }]);
      })();
      function mapIterator2(it, callback) {
        return {
          next: function next() {
            var n = it.next();
            return n.done ? n : {
              value: callback(n.value),
              done: false
            };
          }
        };
      }
      function createEmptyMap() {
        return /* @__PURE__ */ new Map();
      }
      function createMap2(mapOrObject) {
        if (!mapOrObject) {
          return createEmptyMap();
        }
        if (isMap2(mapOrObject)) {
          return mapOrObject;
        }
        if ((0, _is.isObject)(mapOrObject)) {
          return new ObjectWrappingMap2(mapOrObject);
        }
        throw new Error("createMap can create maps from objects or Maps");
      }
      function toObject(map) {
        if (map instanceof ObjectWrappingMap2) {
          return map.wrappedObject;
        }
        var object = {};
        var _iterator4 = _createForOfIteratorHelper(map.keys()), _step4;
        try {
          for (_iterator4.s(); !(_step4 = _iterator4.n()).done; ) {
            var key = _step4.value;
            var value = map.get(key);
            (0, _customs.setSafeProperty)(object, key, value);
          }
        } catch (err) {
          _iterator4.e(err);
        } finally {
          _iterator4.f();
        }
        return object;
      }
      function isMap2(object) {
        if (!object) {
          return false;
        }
        return object instanceof Map || object instanceof ObjectWrappingMap2 || typeof object.set === "function" && typeof object.get === "function" && typeof object.keys === "function" && typeof object.has === "function";
      }
      function assign(map) {
        for (var _len = arguments.length, objects = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
          objects[_key - 1] = arguments[_key];
        }
        for (var _i = 0, _objects = objects; _i < _objects.length; _i++) {
          var args = _objects[_i];
          if (!args) {
            continue;
          }
          if (isMap2(args)) {
            var _iterator5 = _createForOfIteratorHelper(args.keys()), _step5;
            try {
              for (_iterator5.s(); !(_step5 = _iterator5.n()).done; ) {
                var key = _step5.value;
                map.set(key, args.get(key));
              }
            } catch (err) {
              _iterator5.e(err);
            } finally {
              _iterator5.f();
            }
          } else if ((0, _is.isObject)(args)) {
            for (var _i2 = 0, _Object$keys = Object.keys(args); _i2 < _Object$keys.length; _i2++) {
              var _key2 = _Object$keys[_i2];
              map.set(_key2, args[_key2]);
            }
          }
        }
        return map;
      }
    }
  });

  // node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/core/function/typed.js
  var require_typed = __commonJS({
    "node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/core/function/typed.js"(exports) {
      "use strict";
      var _interopRequireDefault = require_interopRequireDefault();
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.createTyped = void 0;
      var _is = require_is();
      var _typedFunction = _interopRequireDefault(require_typed_function());
      var _number = require_number();
      var _factory = require_factory();
      var _map = require_map();
      var _createTyped22 = function _createTyped3() {
        _createTyped22 = _typedFunction["default"].create;
        return _typedFunction["default"];
      };
      var dependencies19 = ["?BigNumber", "?Complex", "?DenseMatrix", "?Fraction"];
      var createTyped3 = exports.createTyped = /* @__PURE__ */ (0, _factory.factory)("typed", dependencies19, function createTyped4(_ref) {
        var BigNumber2 = _ref.BigNumber, Complex3 = _ref.Complex, DenseMatrix2 = _ref.DenseMatrix, Fraction3 = _ref.Fraction;
        var typed2 = _createTyped22();
        typed2.clear();
        typed2.addTypes([
          {
            name: "number",
            test: _is.isNumber
          },
          {
            name: "Complex",
            test: _is.isComplex
          },
          {
            name: "BigNumber",
            test: _is.isBigNumber
          },
          {
            name: "Fraction",
            test: _is.isFraction
          },
          {
            name: "Unit",
            test: _is.isUnit
          },
          // The following type matches a valid variable name, i.e., an alphanumeric
          // string starting with an alphabetic character. It is used (at least)
          // in the definition of the derivative() function, as the argument telling
          // what to differentiate over must (currently) be a variable.
          {
            name: "identifier",
            test: function test(s) {
              return _is.isString && /^(?:[A-Za-z\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0370-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u048A-\u052F\u0531-\u0556\u0559\u0560-\u0588\u05D0-\u05EA\u05EF-\u05F2\u0620-\u064A\u066E\u066F\u0671-\u06D3\u06D5\u06E5\u06E6\u06EE\u06EF\u06FA-\u06FC\u06FF\u0710\u0712-\u072F\u074D-\u07A5\u07B1\u07CA-\u07EA\u07F4\u07F5\u07FA\u0800-\u0815\u081A\u0824\u0828\u0840-\u0858\u0860-\u086A\u0870-\u0887\u0889-\u088E\u08A0-\u08C9\u0904-\u0939\u093D\u0950\u0958-\u0961\u0971-\u0980\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BD\u09CE\u09DC\u09DD\u09DF-\u09E1\u09F0\u09F1\u09FC\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A59-\u0A5C\u0A5E\u0A72-\u0A74\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABD\u0AD0\u0AE0\u0AE1\u0AF9\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3D\u0B5C\u0B5D\u0B5F-\u0B61\u0B71\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BD0\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D\u0C58-\u0C5A\u0C5D\u0C60\u0C61\u0C80\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBD\u0CDD\u0CDE\u0CE0\u0CE1\u0CF1\u0CF2\u0D04-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D\u0D4E\u0D54-\u0D56\u0D5F-\u0D61\u0D7A-\u0D7F\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0E01-\u0E30\u0E32\u0E33\u0E40-\u0E46\u0E81\u0E82\u0E84\u0E86-\u0E8A\u0E8C-\u0EA3\u0EA5\u0EA7-\u0EB0\u0EB2\u0EB3\u0EBD\u0EC0-\u0EC4\u0EC6\u0EDC-\u0EDF\u0F00\u0F40-\u0F47\u0F49-\u0F6C\u0F88-\u0F8C\u1000-\u102A\u103F\u1050-\u1055\u105A-\u105D\u1061\u1065\u1066\u106E-\u1070\u1075-\u1081\u108E\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16F1-\u16F8\u1700-\u1711\u171F-\u1731\u1740-\u1751\u1760-\u176C\u176E-\u1770\u1780-\u17B3\u17D7\u17DC\u1820-\u1878\u1880-\u1884\u1887-\u18A8\u18AA\u18B0-\u18F5\u1900-\u191E\u1950-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u1A00-\u1A16\u1A20-\u1A54\u1AA7\u1B05-\u1B33\u1B45-\u1B4C\u1B83-\u1BA0\u1BAE\u1BAF\u1BBA-\u1BE5\u1C00-\u1C23\u1C4D-\u1C4F\u1C5A-\u1C7D\u1C80-\u1C88\u1C90-\u1CBA\u1CBD-\u1CBF\u1CE9-\u1CEC\u1CEE-\u1CF3\u1CF5\u1CF6\u1CFA\u1D00-\u1DBF\u1E00-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u2071\u207F\u2090-\u209C\u2102\u2107\u210A-\u2113\u2115\u2119-\u211D\u2124\u2126\u2128\u212A-\u212D\u212F-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2183\u2184\u2C00-\u2CE4\u2CEB-\u2CEE\u2CF2\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D80-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u2E2F\u3005\u3006\u3031-\u3035\u303B\u303C\u3041-\u3096\u309D-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312F\u3131-\u318E\u31A0-\u31BF\u31F0-\u31FF\u3400-\u4DBF\u4E00-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA61F\uA62A\uA62B\uA640-\uA66E\uA67F-\uA69D\uA6A0-\uA6E5\uA717-\uA71F\uA722-\uA788\uA78B-\uA7CA\uA7D0\uA7D1\uA7D3\uA7D5-\uA7D9\uA7F2-\uA801\uA803-\uA805\uA807-\uA80A\uA80C-\uA822\uA840-\uA873\uA882-\uA8B3\uA8F2-\uA8F7\uA8FB\uA8FD\uA8FE\uA90A-\uA925\uA930-\uA946\uA960-\uA97C\uA984-\uA9B2\uA9CF\uA9E0-\uA9E4\uA9E6-\uA9EF\uA9FA-\uA9FE\uAA00-\uAA28\uAA40-\uAA42\uAA44-\uAA4B\uAA60-\uAA76\uAA7A\uAA7E-\uAAAF\uAAB1\uAAB5\uAAB6\uAAB9-\uAABD\uAAC0\uAAC2\uAADB-\uAADD\uAAE0-\uAAEA\uAAF2-\uAAF4\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB69\uAB70-\uABE2\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D\uFB1F-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE70-\uFE74\uFE76-\uFEFC\uFF21-\uFF3A\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]|\uD800[\uDC00-\uDC0B\uDC0D-\uDC26\uDC28-\uDC3A\uDC3C\uDC3D\uDC3F-\uDC4D\uDC50-\uDC5D\uDC80-\uDCFA\uDE80-\uDE9C\uDEA0-\uDED0\uDF00-\uDF1F\uDF2D-\uDF40\uDF42-\uDF49\uDF50-\uDF75\uDF80-\uDF9D\uDFA0-\uDFC3\uDFC8-\uDFCF]|\uD801[\uDC00-\uDC9D\uDCB0-\uDCD3\uDCD8-\uDCFB\uDD00-\uDD27\uDD30-\uDD63\uDD70-\uDD7A\uDD7C-\uDD8A\uDD8C-\uDD92\uDD94\uDD95\uDD97-\uDDA1\uDDA3-\uDDB1\uDDB3-\uDDB9\uDDBB\uDDBC\uDE00-\uDF36\uDF40-\uDF55\uDF60-\uDF67\uDF80-\uDF85\uDF87-\uDFB0\uDFB2-\uDFBA]|\uD802[\uDC00-\uDC05\uDC08\uDC0A-\uDC35\uDC37\uDC38\uDC3C\uDC3F-\uDC55\uDC60-\uDC76\uDC80-\uDC9E\uDCE0-\uDCF2\uDCF4\uDCF5\uDD00-\uDD15\uDD20-\uDD39\uDD80-\uDDB7\uDDBE\uDDBF\uDE00\uDE10-\uDE13\uDE15-\uDE17\uDE19-\uDE35\uDE60-\uDE7C\uDE80-\uDE9C\uDEC0-\uDEC7\uDEC9-\uDEE4\uDF00-\uDF35\uDF40-\uDF55\uDF60-\uDF72\uDF80-\uDF91]|\uD803[\uDC00-\uDC48\uDC80-\uDCB2\uDCC0-\uDCF2\uDD00-\uDD23\uDE80-\uDEA9\uDEB0\uDEB1\uDF00-\uDF1C\uDF27\uDF30-\uDF45\uDF70-\uDF81\uDFB0-\uDFC4\uDFE0-\uDFF6]|\uD804[\uDC03-\uDC37\uDC71\uDC72\uDC75\uDC83-\uDCAF\uDCD0-\uDCE8\uDD03-\uDD26\uDD44\uDD47\uDD50-\uDD72\uDD76\uDD83-\uDDB2\uDDC1-\uDDC4\uDDDA\uDDDC\uDE00-\uDE11\uDE13-\uDE2B\uDE3F\uDE40\uDE80-\uDE86\uDE88\uDE8A-\uDE8D\uDE8F-\uDE9D\uDE9F-\uDEA8\uDEB0-\uDEDE\uDF05-\uDF0C\uDF0F\uDF10\uDF13-\uDF28\uDF2A-\uDF30\uDF32\uDF33\uDF35-\uDF39\uDF3D\uDF50\uDF5D-\uDF61]|\uD805[\uDC00-\uDC34\uDC47-\uDC4A\uDC5F-\uDC61\uDC80-\uDCAF\uDCC4\uDCC5\uDCC7\uDD80-\uDDAE\uDDD8-\uDDDB\uDE00-\uDE2F\uDE44\uDE80-\uDEAA\uDEB8\uDF00-\uDF1A\uDF40-\uDF46]|\uD806[\uDC00-\uDC2B\uDCA0-\uDCDF\uDCFF-\uDD06\uDD09\uDD0C-\uDD13\uDD15\uDD16\uDD18-\uDD2F\uDD3F\uDD41\uDDA0-\uDDA7\uDDAA-\uDDD0\uDDE1\uDDE3\uDE00\uDE0B-\uDE32\uDE3A\uDE50\uDE5C-\uDE89\uDE9D\uDEB0-\uDEF8]|\uD807[\uDC00-\uDC08\uDC0A-\uDC2E\uDC40\uDC72-\uDC8F\uDD00-\uDD06\uDD08\uDD09\uDD0B-\uDD30\uDD46\uDD60-\uDD65\uDD67\uDD68\uDD6A-\uDD89\uDD98\uDEE0-\uDEF2\uDF02\uDF04-\uDF10\uDF12-\uDF33\uDFB0]|\uD808[\uDC00-\uDF99]|\uD809[\uDC80-\uDD43]|\uD80B[\uDF90-\uDFF0]|[\uD80C\uD81C-\uD820\uD822\uD840-\uD868\uD86A-\uD86C\uD86F-\uD872\uD874-\uD879\uD880-\uD883\uD885-\uD887][\uDC00-\uDFFF]|\uD80D[\uDC00-\uDC2F\uDC41-\uDC46]|\uD811[\uDC00-\uDE46]|\uD81A[\uDC00-\uDE38\uDE40-\uDE5E\uDE70-\uDEBE\uDED0-\uDEED\uDF00-\uDF2F\uDF40-\uDF43\uDF63-\uDF77\uDF7D-\uDF8F]|\uD81B[\uDE40-\uDE7F\uDF00-\uDF4A\uDF50\uDF93-\uDF9F\uDFE0\uDFE1\uDFE3]|\uD821[\uDC00-\uDFF7]|\uD823[\uDC00-\uDCD5\uDD00-\uDD08]|\uD82B[\uDFF0-\uDFF3\uDFF5-\uDFFB\uDFFD\uDFFE]|\uD82C[\uDC00-\uDD22\uDD32\uDD50-\uDD52\uDD55\uDD64-\uDD67\uDD70-\uDEFB]|\uD82F[\uDC00-\uDC6A\uDC70-\uDC7C\uDC80-\uDC88\uDC90-\uDC99]|\uD835[\uDC00-\uDC54\uDC56-\uDC9C\uDC9E\uDC9F\uDCA2\uDCA5\uDCA6\uDCA9-\uDCAC\uDCAE-\uDCB9\uDCBB\uDCBD-\uDCC3\uDCC5-\uDD05\uDD07-\uDD0A\uDD0D-\uDD14\uDD16-\uDD1C\uDD1E-\uDD39\uDD3B-\uDD3E\uDD40-\uDD44\uDD46\uDD4A-\uDD50\uDD52-\uDEA5\uDEA8-\uDEC0\uDEC2-\uDEDA\uDEDC-\uDEFA\uDEFC-\uDF14\uDF16-\uDF34\uDF36-\uDF4E\uDF50-\uDF6E\uDF70-\uDF88\uDF8A-\uDFA8\uDFAA-\uDFC2\uDFC4-\uDFCB]|\uD837[\uDF00-\uDF1E\uDF25-\uDF2A]|\uD838[\uDC30-\uDC6D\uDD00-\uDD2C\uDD37-\uDD3D\uDD4E\uDE90-\uDEAD\uDEC0-\uDEEB]|\uD839[\uDCD0-\uDCEB\uDFE0-\uDFE6\uDFE8-\uDFEB\uDFED\uDFEE\uDFF0-\uDFFE]|\uD83A[\uDC00-\uDCC4\uDD00-\uDD43\uDD4B]|\uD83B[\uDE00-\uDE03\uDE05-\uDE1F\uDE21\uDE22\uDE24\uDE27\uDE29-\uDE32\uDE34-\uDE37\uDE39\uDE3B\uDE42\uDE47\uDE49\uDE4B\uDE4D-\uDE4F\uDE51\uDE52\uDE54\uDE57\uDE59\uDE5B\uDE5D\uDE5F\uDE61\uDE62\uDE64\uDE67-\uDE6A\uDE6C-\uDE72\uDE74-\uDE77\uDE79-\uDE7C\uDE7E\uDE80-\uDE89\uDE8B-\uDE9B\uDEA1-\uDEA3\uDEA5-\uDEA9\uDEAB-\uDEBB]|\uD869[\uDC00-\uDEDF\uDF00-\uDFFF]|\uD86D[\uDC00-\uDF39\uDF40-\uDFFF]|\uD86E[\uDC00-\uDC1D\uDC20-\uDFFF]|\uD873[\uDC00-\uDEA1\uDEB0-\uDFFF]|\uD87A[\uDC00-\uDFE0]|\uD87E[\uDC00-\uDE1D]|\uD884[\uDC00-\uDF4A\uDF50-\uDFFF]|\uD888[\uDC00-\uDFAF])(?:[0-9A-Za-z\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0370-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u048A-\u052F\u0531-\u0556\u0559\u0560-\u0588\u05D0-\u05EA\u05EF-\u05F2\u0620-\u064A\u066E\u066F\u0671-\u06D3\u06D5\u06E5\u06E6\u06EE\u06EF\u06FA-\u06FC\u06FF\u0710\u0712-\u072F\u074D-\u07A5\u07B1\u07CA-\u07EA\u07F4\u07F5\u07FA\u0800-\u0815\u081A\u0824\u0828\u0840-\u0858\u0860-\u086A\u0870-\u0887\u0889-\u088E\u08A0-\u08C9\u0904-\u0939\u093D\u0950\u0958-\u0961\u0971-\u0980\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BD\u09CE\u09DC\u09DD\u09DF-\u09E1\u09F0\u09F1\u09FC\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A59-\u0A5C\u0A5E\u0A72-\u0A74\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABD\u0AD0\u0AE0\u0AE1\u0AF9\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3D\u0B5C\u0B5D\u0B5F-\u0B61\u0B71\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BD0\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D\u0C58-\u0C5A\u0C5D\u0C60\u0C61\u0C80\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBD\u0CDD\u0CDE\u0CE0\u0CE1\u0CF1\u0CF2\u0D04-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D\u0D4E\u0D54-\u0D56\u0D5F-\u0D61\u0D7A-\u0D7F\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0E01-\u0E30\u0E32\u0E33\u0E40-\u0E46\u0E81\u0E82\u0E84\u0E86-\u0E8A\u0E8C-\u0EA3\u0EA5\u0EA7-\u0EB0\u0EB2\u0EB3\u0EBD\u0EC0-\u0EC4\u0EC6\u0EDC-\u0EDF\u0F00\u0F40-\u0F47\u0F49-\u0F6C\u0F88-\u0F8C\u1000-\u102A\u103F\u1050-\u1055\u105A-\u105D\u1061\u1065\u1066\u106E-\u1070\u1075-\u1081\u108E\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16F1-\u16F8\u1700-\u1711\u171F-\u1731\u1740-\u1751\u1760-\u176C\u176E-\u1770\u1780-\u17B3\u17D7\u17DC\u1820-\u1878\u1880-\u1884\u1887-\u18A8\u18AA\u18B0-\u18F5\u1900-\u191E\u1950-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u1A00-\u1A16\u1A20-\u1A54\u1AA7\u1B05-\u1B33\u1B45-\u1B4C\u1B83-\u1BA0\u1BAE\u1BAF\u1BBA-\u1BE5\u1C00-\u1C23\u1C4D-\u1C4F\u1C5A-\u1C7D\u1C80-\u1C88\u1C90-\u1CBA\u1CBD-\u1CBF\u1CE9-\u1CEC\u1CEE-\u1CF3\u1CF5\u1CF6\u1CFA\u1D00-\u1DBF\u1E00-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u2071\u207F\u2090-\u209C\u2102\u2107\u210A-\u2113\u2115\u2119-\u211D\u2124\u2126\u2128\u212A-\u212D\u212F-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2183\u2184\u2C00-\u2CE4\u2CEB-\u2CEE\u2CF2\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D80-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u2E2F\u3005\u3006\u3031-\u3035\u303B\u303C\u3041-\u3096\u309D-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312F\u3131-\u318E\u31A0-\u31BF\u31F0-\u31FF\u3400-\u4DBF\u4E00-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA61F\uA62A\uA62B\uA640-\uA66E\uA67F-\uA69D\uA6A0-\uA6E5\uA717-\uA71F\uA722-\uA788\uA78B-\uA7CA\uA7D0\uA7D1\uA7D3\uA7D5-\uA7D9\uA7F2-\uA801\uA803-\uA805\uA807-\uA80A\uA80C-\uA822\uA840-\uA873\uA882-\uA8B3\uA8F2-\uA8F7\uA8FB\uA8FD\uA8FE\uA90A-\uA925\uA930-\uA946\uA960-\uA97C\uA984-\uA9B2\uA9CF\uA9E0-\uA9E4\uA9E6-\uA9EF\uA9FA-\uA9FE\uAA00-\uAA28\uAA40-\uAA42\uAA44-\uAA4B\uAA60-\uAA76\uAA7A\uAA7E-\uAAAF\uAAB1\uAAB5\uAAB6\uAAB9-\uAABD\uAAC0\uAAC2\uAADB-\uAADD\uAAE0-\uAAEA\uAAF2-\uAAF4\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB69\uAB70-\uABE2\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D\uFB1F-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE70-\uFE74\uFE76-\uFEFC\uFF21-\uFF3A\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]|\uD800[\uDC00-\uDC0B\uDC0D-\uDC26\uDC28-\uDC3A\uDC3C\uDC3D\uDC3F-\uDC4D\uDC50-\uDC5D\uDC80-\uDCFA\uDE80-\uDE9C\uDEA0-\uDED0\uDF00-\uDF1F\uDF2D-\uDF40\uDF42-\uDF49\uDF50-\uDF75\uDF80-\uDF9D\uDFA0-\uDFC3\uDFC8-\uDFCF]|\uD801[\uDC00-\uDC9D\uDCB0-\uDCD3\uDCD8-\uDCFB\uDD00-\uDD27\uDD30-\uDD63\uDD70-\uDD7A\uDD7C-\uDD8A\uDD8C-\uDD92\uDD94\uDD95\uDD97-\uDDA1\uDDA3-\uDDB1\uDDB3-\uDDB9\uDDBB\uDDBC\uDE00-\uDF36\uDF40-\uDF55\uDF60-\uDF67\uDF80-\uDF85\uDF87-\uDFB0\uDFB2-\uDFBA]|\uD802[\uDC00-\uDC05\uDC08\uDC0A-\uDC35\uDC37\uDC38\uDC3C\uDC3F-\uDC55\uDC60-\uDC76\uDC80-\uDC9E\uDCE0-\uDCF2\uDCF4\uDCF5\uDD00-\uDD15\uDD20-\uDD39\uDD80-\uDDB7\uDDBE\uDDBF\uDE00\uDE10-\uDE13\uDE15-\uDE17\uDE19-\uDE35\uDE60-\uDE7C\uDE80-\uDE9C\uDEC0-\uDEC7\uDEC9-\uDEE4\uDF00-\uDF35\uDF40-\uDF55\uDF60-\uDF72\uDF80-\uDF91]|\uD803[\uDC00-\uDC48\uDC80-\uDCB2\uDCC0-\uDCF2\uDD00-\uDD23\uDE80-\uDEA9\uDEB0\uDEB1\uDF00-\uDF1C\uDF27\uDF30-\uDF45\uDF70-\uDF81\uDFB0-\uDFC4\uDFE0-\uDFF6]|\uD804[\uDC03-\uDC37\uDC71\uDC72\uDC75\uDC83-\uDCAF\uDCD0-\uDCE8\uDD03-\uDD26\uDD44\uDD47\uDD50-\uDD72\uDD76\uDD83-\uDDB2\uDDC1-\uDDC4\uDDDA\uDDDC\uDE00-\uDE11\uDE13-\uDE2B\uDE3F\uDE40\uDE80-\uDE86\uDE88\uDE8A-\uDE8D\uDE8F-\uDE9D\uDE9F-\uDEA8\uDEB0-\uDEDE\uDF05-\uDF0C\uDF0F\uDF10\uDF13-\uDF28\uDF2A-\uDF30\uDF32\uDF33\uDF35-\uDF39\uDF3D\uDF50\uDF5D-\uDF61]|\uD805[\uDC00-\uDC34\uDC47-\uDC4A\uDC5F-\uDC61\uDC80-\uDCAF\uDCC4\uDCC5\uDCC7\uDD80-\uDDAE\uDDD8-\uDDDB\uDE00-\uDE2F\uDE44\uDE80-\uDEAA\uDEB8\uDF00-\uDF1A\uDF40-\uDF46]|\uD806[\uDC00-\uDC2B\uDCA0-\uDCDF\uDCFF-\uDD06\uDD09\uDD0C-\uDD13\uDD15\uDD16\uDD18-\uDD2F\uDD3F\uDD41\uDDA0-\uDDA7\uDDAA-\uDDD0\uDDE1\uDDE3\uDE00\uDE0B-\uDE32\uDE3A\uDE50\uDE5C-\uDE89\uDE9D\uDEB0-\uDEF8]|\uD807[\uDC00-\uDC08\uDC0A-\uDC2E\uDC40\uDC72-\uDC8F\uDD00-\uDD06\uDD08\uDD09\uDD0B-\uDD30\uDD46\uDD60-\uDD65\uDD67\uDD68\uDD6A-\uDD89\uDD98\uDEE0-\uDEF2\uDF02\uDF04-\uDF10\uDF12-\uDF33\uDFB0]|\uD808[\uDC00-\uDF99]|\uD809[\uDC80-\uDD43]|\uD80B[\uDF90-\uDFF0]|[\uD80C\uD81C-\uD820\uD822\uD840-\uD868\uD86A-\uD86C\uD86F-\uD872\uD874-\uD879\uD880-\uD883\uD885-\uD887][\uDC00-\uDFFF]|\uD80D[\uDC00-\uDC2F\uDC41-\uDC46]|\uD811[\uDC00-\uDE46]|\uD81A[\uDC00-\uDE38\uDE40-\uDE5E\uDE70-\uDEBE\uDED0-\uDEED\uDF00-\uDF2F\uDF40-\uDF43\uDF63-\uDF77\uDF7D-\uDF8F]|\uD81B[\uDE40-\uDE7F\uDF00-\uDF4A\uDF50\uDF93-\uDF9F\uDFE0\uDFE1\uDFE3]|\uD821[\uDC00-\uDFF7]|\uD823[\uDC00-\uDCD5\uDD00-\uDD08]|\uD82B[\uDFF0-\uDFF3\uDFF5-\uDFFB\uDFFD\uDFFE]|\uD82C[\uDC00-\uDD22\uDD32\uDD50-\uDD52\uDD55\uDD64-\uDD67\uDD70-\uDEFB]|\uD82F[\uDC00-\uDC6A\uDC70-\uDC7C\uDC80-\uDC88\uDC90-\uDC99]|\uD835[\uDC00-\uDC54\uDC56-\uDC9C\uDC9E\uDC9F\uDCA2\uDCA5\uDCA6\uDCA9-\uDCAC\uDCAE-\uDCB9\uDCBB\uDCBD-\uDCC3\uDCC5-\uDD05\uDD07-\uDD0A\uDD0D-\uDD14\uDD16-\uDD1C\uDD1E-\uDD39\uDD3B-\uDD3E\uDD40-\uDD44\uDD46\uDD4A-\uDD50\uDD52-\uDEA5\uDEA8-\uDEC0\uDEC2-\uDEDA\uDEDC-\uDEFA\uDEFC-\uDF14\uDF16-\uDF34\uDF36-\uDF4E\uDF50-\uDF6E\uDF70-\uDF88\uDF8A-\uDFA8\uDFAA-\uDFC2\uDFC4-\uDFCB]|\uD837[\uDF00-\uDF1E\uDF25-\uDF2A]|\uD838[\uDC30-\uDC6D\uDD00-\uDD2C\uDD37-\uDD3D\uDD4E\uDE90-\uDEAD\uDEC0-\uDEEB]|\uD839[\uDCD0-\uDCEB\uDFE0-\uDFE6\uDFE8-\uDFEB\uDFED\uDFEE\uDFF0-\uDFFE]|\uD83A[\uDC00-\uDCC4\uDD00-\uDD43\uDD4B]|\uD83B[\uDE00-\uDE03\uDE05-\uDE1F\uDE21\uDE22\uDE24\uDE27\uDE29-\uDE32\uDE34-\uDE37\uDE39\uDE3B\uDE42\uDE47\uDE49\uDE4B\uDE4D-\uDE4F\uDE51\uDE52\uDE54\uDE57\uDE59\uDE5B\uDE5D\uDE5F\uDE61\uDE62\uDE64\uDE67-\uDE6A\uDE6C-\uDE72\uDE74-\uDE77\uDE79-\uDE7C\uDE7E\uDE80-\uDE89\uDE8B-\uDE9B\uDEA1-\uDEA3\uDEA5-\uDEA9\uDEAB-\uDEBB]|\uD869[\uDC00-\uDEDF\uDF00-\uDFFF]|\uD86D[\uDC00-\uDF39\uDF40-\uDFFF]|\uD86E[\uDC00-\uDC1D\uDC20-\uDFFF]|\uD873[\uDC00-\uDEA1\uDEB0-\uDFFF]|\uD87A[\uDC00-\uDFE0]|\uD87E[\uDC00-\uDE1D]|\uD884[\uDC00-\uDF4A\uDF50-\uDFFF]|\uD888[\uDC00-\uDFAF])*$/.test(s);
            }
          },
          {
            name: "string",
            test: _is.isString
          },
          {
            name: "Chain",
            test: _is.isChain
          },
          {
            name: "Array",
            test: _is.isArray
          },
          {
            name: "Matrix",
            test: _is.isMatrix
          },
          {
            name: "DenseMatrix",
            test: _is.isDenseMatrix
          },
          {
            name: "SparseMatrix",
            test: _is.isSparseMatrix
          },
          {
            name: "Range",
            test: _is.isRange
          },
          {
            name: "Index",
            test: _is.isIndex
          },
          {
            name: "boolean",
            test: _is.isBoolean
          },
          {
            name: "ResultSet",
            test: _is.isResultSet
          },
          {
            name: "Help",
            test: _is.isHelp
          },
          {
            name: "function",
            test: _is.isFunction
          },
          {
            name: "Date",
            test: _is.isDate
          },
          {
            name: "RegExp",
            test: _is.isRegExp
          },
          {
            name: "null",
            test: _is.isNull
          },
          {
            name: "undefined",
            test: _is.isUndefined
          },
          {
            name: "AccessorNode",
            test: _is.isAccessorNode
          },
          {
            name: "ArrayNode",
            test: _is.isArrayNode
          },
          {
            name: "AssignmentNode",
            test: _is.isAssignmentNode
          },
          {
            name: "BlockNode",
            test: _is.isBlockNode
          },
          {
            name: "ConditionalNode",
            test: _is.isConditionalNode
          },
          {
            name: "ConstantNode",
            test: _is.isConstantNode
          },
          {
            name: "FunctionNode",
            test: _is.isFunctionNode
          },
          {
            name: "FunctionAssignmentNode",
            test: _is.isFunctionAssignmentNode
          },
          {
            name: "IndexNode",
            test: _is.isIndexNode
          },
          {
            name: "Node",
            test: _is.isNode
          },
          {
            name: "ObjectNode",
            test: _is.isObjectNode
          },
          {
            name: "OperatorNode",
            test: _is.isOperatorNode
          },
          {
            name: "ParenthesisNode",
            test: _is.isParenthesisNode
          },
          {
            name: "RangeNode",
            test: _is.isRangeNode
          },
          {
            name: "RelationalNode",
            test: _is.isRelationalNode
          },
          {
            name: "SymbolNode",
            test: _is.isSymbolNode
          },
          {
            name: "Map",
            test: _map.isMap
          },
          {
            name: "Object",
            test: _is.isObject
          }
          // order 'Object' last, it matches on other classes too
        ]);
        typed2.addConversions([{
          from: "number",
          to: "BigNumber",
          convert: function convert(x) {
            if (!BigNumber2) {
              throwNoBignumber2(x);
            }
            if ((0, _number.digits)(x) > 15) {
              throw new TypeError("Cannot implicitly convert a number with >15 significant digits to BigNumber (value: " + x + "). Use function bignumber(x) to convert to BigNumber.");
            }
            return new BigNumber2(x);
          }
        }, {
          from: "number",
          to: "Complex",
          convert: function convert(x) {
            if (!Complex3) {
              throwNoComplex2(x);
            }
            return new Complex3(x, 0);
          }
        }, {
          from: "BigNumber",
          to: "Complex",
          convert: function convert(x) {
            if (!Complex3) {
              throwNoComplex2(x);
            }
            return new Complex3(x.toNumber(), 0);
          }
        }, {
          from: "Fraction",
          to: "BigNumber",
          convert: function convert(x) {
            throw new TypeError("Cannot implicitly convert a Fraction to BigNumber or vice versa. Use function bignumber(x) to convert to BigNumber or fraction(x) to convert to Fraction.");
          }
        }, {
          from: "Fraction",
          to: "Complex",
          convert: function convert(x) {
            if (!Complex3) {
              throwNoComplex2(x);
            }
            return new Complex3(x.valueOf(), 0);
          }
        }, {
          from: "number",
          to: "Fraction",
          convert: function convert(x) {
            if (!Fraction3) {
              throwNoFraction2(x);
            }
            var f = new Fraction3(x);
            if (f.valueOf() !== x) {
              throw new TypeError("Cannot implicitly convert a number to a Fraction when there will be a loss of precision (value: " + x + "). Use function fraction(x) to convert to Fraction.");
            }
            return f;
          }
        }, {
          // FIXME: add conversion from Fraction to number, for example for `sqrt(fraction(1,3))`
          //  from: 'Fraction',
          //  to: 'number',
          //  convert: function (x) {
          //    return x.valueOf()
          //  }
          // }, {
          from: "string",
          to: "number",
          convert: function convert(x) {
            var n = Number(x);
            if (isNaN(n)) {
              throw new Error('Cannot convert "' + x + '" to a number');
            }
            return n;
          }
        }, {
          from: "string",
          to: "BigNumber",
          convert: function convert(x) {
            if (!BigNumber2) {
              throwNoBignumber2(x);
            }
            try {
              return new BigNumber2(x);
            } catch (err) {
              throw new Error('Cannot convert "' + x + '" to BigNumber');
            }
          }
        }, {
          from: "string",
          to: "Fraction",
          convert: function convert(x) {
            if (!Fraction3) {
              throwNoFraction2(x);
            }
            try {
              return new Fraction3(x);
            } catch (err) {
              throw new Error('Cannot convert "' + x + '" to Fraction');
            }
          }
        }, {
          from: "string",
          to: "Complex",
          convert: function convert(x) {
            if (!Complex3) {
              throwNoComplex2(x);
            }
            try {
              return new Complex3(x);
            } catch (err) {
              throw new Error('Cannot convert "' + x + '" to Complex');
            }
          }
        }, {
          from: "boolean",
          to: "number",
          convert: function convert(x) {
            return +x;
          }
        }, {
          from: "boolean",
          to: "BigNumber",
          convert: function convert(x) {
            if (!BigNumber2) {
              throwNoBignumber2(x);
            }
            return new BigNumber2(+x);
          }
        }, {
          from: "boolean",
          to: "Fraction",
          convert: function convert(x) {
            if (!Fraction3) {
              throwNoFraction2(x);
            }
            return new Fraction3(+x);
          }
        }, {
          from: "boolean",
          to: "string",
          convert: function convert(x) {
            return String(x);
          }
        }, {
          from: "Array",
          to: "Matrix",
          convert: function convert(array) {
            if (!DenseMatrix2) {
              throwNoMatrix2();
            }
            return new DenseMatrix2(array);
          }
        }, {
          from: "Matrix",
          to: "Array",
          convert: function convert(matrix2) {
            return matrix2.valueOf();
          }
        }]);
        typed2.onMismatch = function(name18, args, signatures) {
          var usualError = typed2.createError(name18, args, signatures);
          if (["wrongType", "mismatch"].includes(usualError.data.category) && args.length === 1 && (0, _is.isCollection)(args[0]) && // check if the function can be unary:
          signatures.some(function(sig) {
            return !sig.params.includes(",");
          })) {
            var err = new TypeError("Function '".concat(name18, "' doesn't apply to matrices. To call it ") + "elementwise on a matrix 'M', try 'map(M, ".concat(name18, ")'."));
            err.data = usualError.data;
            throw err;
          }
          throw usualError;
        };
        typed2.onMismatch = function(name18, args, signatures) {
          var usualError = typed2.createError(name18, args, signatures);
          if (["wrongType", "mismatch"].includes(usualError.data.category) && args.length === 1 && (0, _is.isCollection)(args[0]) && // check if the function can be unary:
          signatures.some(function(sig) {
            return !sig.params.includes(",");
          })) {
            var err = new TypeError("Function '".concat(name18, "' doesn't apply to matrices. To call it ") + "elementwise on a matrix 'M', try 'map(M, ".concat(name18, ")'."));
            err.data = usualError.data;
            throw err;
          }
          throw usualError;
        };
        return typed2;
      });
      function throwNoBignumber2(x) {
        throw new Error("Cannot convert value ".concat(x, " into a BigNumber: no class 'BigNumber' provided"));
      }
      function throwNoComplex2(x) {
        throw new Error("Cannot convert value ".concat(x, " into a Complex number: no class 'Complex' provided"));
      }
      function throwNoMatrix2() {
        throw new Error("Cannot convert array into a Matrix: no class 'DenseMatrix' provided");
      }
      function throwNoFraction2(x) {
        throw new Error("Cannot convert value ".concat(x, " into a Fraction, no class 'Fraction' provided."));
      }
    }
  });

  // node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/type/resultset/ResultSet.js
  var require_ResultSet = __commonJS({
    "node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/type/resultset/ResultSet.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.createResultSet = void 0;
      var _factory = require_factory();
      var name18 = "ResultSet";
      var dependencies19 = [];
      var createResultSet2 = exports.createResultSet = /* @__PURE__ */ (0, _factory.factory)(name18, dependencies19, function() {
        function ResultSet(entries) {
          if (!(this instanceof ResultSet)) {
            throw new SyntaxError("Constructor must be called with the new operator");
          }
          this.entries = entries || [];
        }
        ResultSet.prototype.type = "ResultSet";
        ResultSet.prototype.isResultSet = true;
        ResultSet.prototype.valueOf = function() {
          return this.entries;
        };
        ResultSet.prototype.toString = function() {
          return "[" + this.entries.join(", ") + "]";
        };
        ResultSet.prototype.toJSON = function() {
          return {
            mathjs: "ResultSet",
            entries: this.entries
          };
        };
        ResultSet.fromJSON = function(json) {
          return new ResultSet(json.entries);
        };
        return ResultSet;
      }, {
        isClass: true
      });
    }
  });

  // node_modules/.pnpm/decimal.js@10.6.0/node_modules/decimal.js/decimal.js
  var require_decimal = __commonJS({
    "node_modules/.pnpm/decimal.js@10.6.0/node_modules/decimal.js/decimal.js"(exports, module) {
      (function(globalScope) {
        "use strict";
        var EXP_LIMIT2 = 9e15, MAX_DIGITS2 = 1e9, NUMERALS2 = "0123456789abcdef", LN102 = "2.3025850929940456840179914546843642076011014886287729760333279009675726096773524802359972050895982983419677840422862486334095254650828067566662873690987816894829072083255546808437998948262331985283935053089653777326288461633662222876982198867465436674744042432743651550489343149393914796194044002221051017141748003688084012647080685567743216228355220114804663715659121373450747856947683463616792101806445070648000277502684916746550586856935673420670581136429224554405758925724208241314695689016758940256776311356919292033376587141660230105703089634572075440370847469940168269282808481184289314848524948644871927809676271275775397027668605952496716674183485704422507197965004714951050492214776567636938662976979522110718264549734772662425709429322582798502585509785265383207606726317164309505995087807523710333101197857547331541421808427543863591778117054309827482385045648019095610299291824318237525357709750539565187697510374970888692180205189339507238539205144634197265287286965110862571492198849978748873771345686209167058", PI2 = "3.1415926535897932384626433832795028841971693993751058209749445923078164062862089986280348253421170679821480865132823066470938446095505822317253594081284811174502841027019385211055596446229489549303819644288109756659334461284756482337867831652712019091456485669234603486104543266482133936072602491412737245870066063155881748815209209628292540917153643678925903600113305305488204665213841469519415116094330572703657595919530921861173819326117931051185480744623799627495673518857527248912279381830119491298336733624406566430860213949463952247371907021798609437027705392171762931767523846748184676694051320005681271452635608277857713427577896091736371787214684409012249534301465495853710507922796892589235420199561121290219608640344181598136297747713099605187072113499999983729780499510597317328160963185950244594553469083026425223082533446850352619311881710100031378387528865875332083814206171776691473035982534904287554687311595628638823537875937519577818577805321712268066130019278766111959092164201989380952572010654858632789", DEFAULTS2 = {
          // These values must be integers within the stated ranges (inclusive).
          // Most of these values can be changed at run-time using the `Decimal.config` method.
          // The maximum number of significant digits of the result of a calculation or base conversion.
          // E.g. `Decimal.config({ precision: 20 });`
          precision: 20,
          // 1 to MAX_DIGITS
          // The rounding mode used when rounding to `precision`.
          //
          // ROUND_UP         0 Away from zero.
          // ROUND_DOWN       1 Towards zero.
          // ROUND_CEIL       2 Towards +Infinity.
          // ROUND_FLOOR      3 Towards -Infinity.
          // ROUND_HALF_UP    4 Towards nearest neighbour. If equidistant, up.
          // ROUND_HALF_DOWN  5 Towards nearest neighbour. If equidistant, down.
          // ROUND_HALF_EVEN  6 Towards nearest neighbour. If equidistant, towards even neighbour.
          // ROUND_HALF_CEIL  7 Towards nearest neighbour. If equidistant, towards +Infinity.
          // ROUND_HALF_FLOOR 8 Towards nearest neighbour. If equidistant, towards -Infinity.
          //
          // E.g.
          // `Decimal.rounding = 4;`
          // `Decimal.rounding = Decimal.ROUND_HALF_UP;`
          rounding: 4,
          // 0 to 8
          // The modulo mode used when calculating the modulus: a mod n.
          // The quotient (q = a / n) is calculated according to the corresponding rounding mode.
          // The remainder (r) is calculated as: r = a - n * q.
          //
          // UP         0 The remainder is positive if the dividend is negative, else is negative.
          // DOWN       1 The remainder has the same sign as the dividend (JavaScript %).
          // FLOOR      3 The remainder has the same sign as the divisor (Python %).
          // HALF_EVEN  6 The IEEE 754 remainder function.
          // EUCLID     9 Euclidian division. q = sign(n) * floor(a / abs(n)). Always positive.
          //
          // Truncated division (1), floored division (3), the IEEE 754 remainder (6), and Euclidian
          // division (9) are commonly used for the modulus operation. The other rounding modes can also
          // be used, but they may not give useful results.
          modulo: 1,
          // 0 to 9
          // The exponent value at and beneath which `toString` returns exponential notation.
          // JavaScript numbers: -7
          toExpNeg: -7,
          // 0 to -EXP_LIMIT
          // The exponent value at and above which `toString` returns exponential notation.
          // JavaScript numbers: 21
          toExpPos: 21,
          // 0 to EXP_LIMIT
          // The minimum exponent value, beneath which underflow to zero occurs.
          // JavaScript numbers: -324  (5e-324)
          minE: -EXP_LIMIT2,
          // -1 to -EXP_LIMIT
          // The maximum exponent value, above which overflow to Infinity occurs.
          // JavaScript numbers: 308  (1.7976931348623157e+308)
          maxE: EXP_LIMIT2,
          // 1 to EXP_LIMIT
          // Whether to use cryptographically-secure random number generation, if available.
          crypto: false
          // true/false
        }, Decimal2, inexact2, noConflict, quadrant2, external2 = true, decimalError2 = "[DecimalError] ", invalidArgument2 = decimalError2 + "Invalid argument: ", precisionLimitExceeded2 = decimalError2 + "Precision limit exceeded", cryptoUnavailable2 = decimalError2 + "crypto unavailable", tag2 = "[object Decimal]", mathfloor2 = Math.floor, mathpow2 = Math.pow, isBinary2 = /^0b([01]+(\.[01]*)?|\.[01]+)(p[+-]?\d+)?$/i, isHex2 = /^0x([0-9a-f]+(\.[0-9a-f]*)?|\.[0-9a-f]+)(p[+-]?\d+)?$/i, isOctal2 = /^0o([0-7]+(\.[0-7]*)?|\.[0-7]+)(p[+-]?\d+)?$/i, isDecimal2 = /^(\d+(\.\d*)?|\.\d+)(e[+-]?\d+)?$/i, BASE2 = 1e7, LOG_BASE2 = 7, MAX_SAFE_INTEGER2 = 9007199254740991, LN10_PRECISION2 = LN102.length - 1, PI_PRECISION2 = PI2.length - 1, P3 = { toStringTag: tag2 };
        P3.absoluteValue = P3.abs = function() {
          var x = new this.constructor(this);
          if (x.s < 0) x.s = 1;
          return finalise2(x);
        };
        P3.ceil = function() {
          return finalise2(new this.constructor(this), this.e + 1, 2);
        };
        P3.clampedTo = P3.clamp = function(min3, max3) {
          var k, x = this, Ctor = x.constructor;
          min3 = new Ctor(min3);
          max3 = new Ctor(max3);
          if (!min3.s || !max3.s) return new Ctor(NaN);
          if (min3.gt(max3)) throw Error(invalidArgument2 + max3);
          k = x.cmp(min3);
          return k < 0 ? min3 : x.cmp(max3) > 0 ? max3 : new Ctor(x);
        };
        P3.comparedTo = P3.cmp = function(y) {
          var i, j, xdL, ydL, x = this, xd = x.d, yd = (y = new x.constructor(y)).d, xs = x.s, ys = y.s;
          if (!xd || !yd) {
            return !xs || !ys ? NaN : xs !== ys ? xs : xd === yd ? 0 : !xd ^ xs < 0 ? 1 : -1;
          }
          if (!xd[0] || !yd[0]) return xd[0] ? xs : yd[0] ? -ys : 0;
          if (xs !== ys) return xs;
          if (x.e !== y.e) return x.e > y.e ^ xs < 0 ? 1 : -1;
          xdL = xd.length;
          ydL = yd.length;
          for (i = 0, j = xdL < ydL ? xdL : ydL; i < j; ++i) {
            if (xd[i] !== yd[i]) return xd[i] > yd[i] ^ xs < 0 ? 1 : -1;
          }
          return xdL === ydL ? 0 : xdL > ydL ^ xs < 0 ? 1 : -1;
        };
        P3.cosine = P3.cos = function() {
          var pr, rm, x = this, Ctor = x.constructor;
          if (!x.d) return new Ctor(NaN);
          if (!x.d[0]) return new Ctor(1);
          pr = Ctor.precision;
          rm = Ctor.rounding;
          Ctor.precision = pr + Math.max(x.e, x.sd()) + LOG_BASE2;
          Ctor.rounding = 1;
          x = cosine2(Ctor, toLessThanHalfPi2(Ctor, x));
          Ctor.precision = pr;
          Ctor.rounding = rm;
          return finalise2(quadrant2 == 2 || quadrant2 == 3 ? x.neg() : x, pr, rm, true);
        };
        P3.cubeRoot = P3.cbrt = function() {
          var e, m, n, r, rep, s, sd, t, t3, t3plusx, x = this, Ctor = x.constructor;
          if (!x.isFinite() || x.isZero()) return new Ctor(x);
          external2 = false;
          s = x.s * mathpow2(x.s * x, 1 / 3);
          if (!s || Math.abs(s) == 1 / 0) {
            n = digitsToString2(x.d);
            e = x.e;
            if (s = (e - n.length + 1) % 3) n += s == 1 || s == -2 ? "0" : "00";
            s = mathpow2(n, 1 / 3);
            e = mathfloor2((e + 1) / 3) - (e % 3 == (e < 0 ? -1 : 2));
            if (s == 1 / 0) {
              n = "5e" + e;
            } else {
              n = s.toExponential();
              n = n.slice(0, n.indexOf("e") + 1) + e;
            }
            r = new Ctor(n);
            r.s = x.s;
          } else {
            r = new Ctor(s.toString());
          }
          sd = (e = Ctor.precision) + 3;
          for (; ; ) {
            t = r;
            t3 = t.times(t).times(t);
            t3plusx = t3.plus(x);
            r = divide2(t3plusx.plus(x).times(t), t3plusx.plus(t3), sd + 2, 1);
            if (digitsToString2(t.d).slice(0, sd) === (n = digitsToString2(r.d)).slice(0, sd)) {
              n = n.slice(sd - 3, sd + 1);
              if (n == "9999" || !rep && n == "4999") {
                if (!rep) {
                  finalise2(t, e + 1, 0);
                  if (t.times(t).times(t).eq(x)) {
                    r = t;
                    break;
                  }
                }
                sd += 4;
                rep = 1;
              } else {
                if (!+n || !+n.slice(1) && n.charAt(0) == "5") {
                  finalise2(r, e + 1, 1);
                  m = !r.times(r).times(r).eq(x);
                }
                break;
              }
            }
          }
          external2 = true;
          return finalise2(r, e, Ctor.rounding, m);
        };
        P3.decimalPlaces = P3.dp = function() {
          var w, d = this.d, n = NaN;
          if (d) {
            w = d.length - 1;
            n = (w - mathfloor2(this.e / LOG_BASE2)) * LOG_BASE2;
            w = d[w];
            if (w) for (; w % 10 == 0; w /= 10) n--;
            if (n < 0) n = 0;
          }
          return n;
        };
        P3.dividedBy = P3.div = function(y) {
          return divide2(this, new this.constructor(y));
        };
        P3.dividedToIntegerBy = P3.divToInt = function(y) {
          var x = this, Ctor = x.constructor;
          return finalise2(divide2(x, new Ctor(y), 0, 1, 1), Ctor.precision, Ctor.rounding);
        };
        P3.equals = P3.eq = function(y) {
          return this.cmp(y) === 0;
        };
        P3.floor = function() {
          return finalise2(new this.constructor(this), this.e + 1, 3);
        };
        P3.greaterThan = P3.gt = function(y) {
          return this.cmp(y) > 0;
        };
        P3.greaterThanOrEqualTo = P3.gte = function(y) {
          var k = this.cmp(y);
          return k == 1 || k === 0;
        };
        P3.hyperbolicCosine = P3.cosh = function() {
          var k, n, pr, rm, len, x = this, Ctor = x.constructor, one = new Ctor(1);
          if (!x.isFinite()) return new Ctor(x.s ? 1 / 0 : NaN);
          if (x.isZero()) return one;
          pr = Ctor.precision;
          rm = Ctor.rounding;
          Ctor.precision = pr + Math.max(x.e, x.sd()) + 4;
          Ctor.rounding = 1;
          len = x.d.length;
          if (len < 32) {
            k = Math.ceil(len / 3);
            n = (1 / tinyPow2(4, k)).toString();
          } else {
            k = 16;
            n = "2.3283064365386962890625e-10";
          }
          x = taylorSeries2(Ctor, 1, x.times(n), new Ctor(1), true);
          var cosh2_x, i = k, d8 = new Ctor(8);
          for (; i--; ) {
            cosh2_x = x.times(x);
            x = one.minus(cosh2_x.times(d8.minus(cosh2_x.times(d8))));
          }
          return finalise2(x, Ctor.precision = pr, Ctor.rounding = rm, true);
        };
        P3.hyperbolicSine = P3.sinh = function() {
          var k, pr, rm, len, x = this, Ctor = x.constructor;
          if (!x.isFinite() || x.isZero()) return new Ctor(x);
          pr = Ctor.precision;
          rm = Ctor.rounding;
          Ctor.precision = pr + Math.max(x.e, x.sd()) + 4;
          Ctor.rounding = 1;
          len = x.d.length;
          if (len < 3) {
            x = taylorSeries2(Ctor, 2, x, x, true);
          } else {
            k = 1.4 * Math.sqrt(len);
            k = k > 16 ? 16 : k | 0;
            x = x.times(1 / tinyPow2(5, k));
            x = taylorSeries2(Ctor, 2, x, x, true);
            var sinh2_x, d5 = new Ctor(5), d16 = new Ctor(16), d20 = new Ctor(20);
            for (; k--; ) {
              sinh2_x = x.times(x);
              x = x.times(d5.plus(sinh2_x.times(d16.times(sinh2_x).plus(d20))));
            }
          }
          Ctor.precision = pr;
          Ctor.rounding = rm;
          return finalise2(x, pr, rm, true);
        };
        P3.hyperbolicTangent = P3.tanh = function() {
          var pr, rm, x = this, Ctor = x.constructor;
          if (!x.isFinite()) return new Ctor(x.s);
          if (x.isZero()) return new Ctor(x);
          pr = Ctor.precision;
          rm = Ctor.rounding;
          Ctor.precision = pr + 7;
          Ctor.rounding = 1;
          return divide2(x.sinh(), x.cosh(), Ctor.precision = pr, Ctor.rounding = rm);
        };
        P3.inverseCosine = P3.acos = function() {
          var x = this, Ctor = x.constructor, k = x.abs().cmp(1), pr = Ctor.precision, rm = Ctor.rounding;
          if (k !== -1) {
            return k === 0 ? x.isNeg() ? getPi2(Ctor, pr, rm) : new Ctor(0) : new Ctor(NaN);
          }
          if (x.isZero()) return getPi2(Ctor, pr + 4, rm).times(0.5);
          Ctor.precision = pr + 6;
          Ctor.rounding = 1;
          x = new Ctor(1).minus(x).div(x.plus(1)).sqrt().atan();
          Ctor.precision = pr;
          Ctor.rounding = rm;
          return x.times(2);
        };
        P3.inverseHyperbolicCosine = P3.acosh = function() {
          var pr, rm, x = this, Ctor = x.constructor;
          if (x.lte(1)) return new Ctor(x.eq(1) ? 0 : NaN);
          if (!x.isFinite()) return new Ctor(x);
          pr = Ctor.precision;
          rm = Ctor.rounding;
          Ctor.precision = pr + Math.max(Math.abs(x.e), x.sd()) + 4;
          Ctor.rounding = 1;
          external2 = false;
          x = x.times(x).minus(1).sqrt().plus(x);
          external2 = true;
          Ctor.precision = pr;
          Ctor.rounding = rm;
          return x.ln();
        };
        P3.inverseHyperbolicSine = P3.asinh = function() {
          var pr, rm, x = this, Ctor = x.constructor;
          if (!x.isFinite() || x.isZero()) return new Ctor(x);
          pr = Ctor.precision;
          rm = Ctor.rounding;
          Ctor.precision = pr + 2 * Math.max(Math.abs(x.e), x.sd()) + 6;
          Ctor.rounding = 1;
          external2 = false;
          x = x.times(x).plus(1).sqrt().plus(x);
          external2 = true;
          Ctor.precision = pr;
          Ctor.rounding = rm;
          return x.ln();
        };
        P3.inverseHyperbolicTangent = P3.atanh = function() {
          var pr, rm, wpr, xsd, x = this, Ctor = x.constructor;
          if (!x.isFinite()) return new Ctor(NaN);
          if (x.e >= 0) return new Ctor(x.abs().eq(1) ? x.s / 0 : x.isZero() ? x : NaN);
          pr = Ctor.precision;
          rm = Ctor.rounding;
          xsd = x.sd();
          if (Math.max(xsd, pr) < 2 * -x.e - 1) return finalise2(new Ctor(x), pr, rm, true);
          Ctor.precision = wpr = xsd - x.e;
          x = divide2(x.plus(1), new Ctor(1).minus(x), wpr + pr, 1);
          Ctor.precision = pr + 4;
          Ctor.rounding = 1;
          x = x.ln();
          Ctor.precision = pr;
          Ctor.rounding = rm;
          return x.times(0.5);
        };
        P3.inverseSine = P3.asin = function() {
          var halfPi, k, pr, rm, x = this, Ctor = x.constructor;
          if (x.isZero()) return new Ctor(x);
          k = x.abs().cmp(1);
          pr = Ctor.precision;
          rm = Ctor.rounding;
          if (k !== -1) {
            if (k === 0) {
              halfPi = getPi2(Ctor, pr + 4, rm).times(0.5);
              halfPi.s = x.s;
              return halfPi;
            }
            return new Ctor(NaN);
          }
          Ctor.precision = pr + 6;
          Ctor.rounding = 1;
          x = x.div(new Ctor(1).minus(x.times(x)).sqrt().plus(1)).atan();
          Ctor.precision = pr;
          Ctor.rounding = rm;
          return x.times(2);
        };
        P3.inverseTangent = P3.atan = function() {
          var i, j, k, n, px, t, r, wpr, x2, x = this, Ctor = x.constructor, pr = Ctor.precision, rm = Ctor.rounding;
          if (!x.isFinite()) {
            if (!x.s) return new Ctor(NaN);
            if (pr + 4 <= PI_PRECISION2) {
              r = getPi2(Ctor, pr + 4, rm).times(0.5);
              r.s = x.s;
              return r;
            }
          } else if (x.isZero()) {
            return new Ctor(x);
          } else if (x.abs().eq(1) && pr + 4 <= PI_PRECISION2) {
            r = getPi2(Ctor, pr + 4, rm).times(0.25);
            r.s = x.s;
            return r;
          }
          Ctor.precision = wpr = pr + 10;
          Ctor.rounding = 1;
          k = Math.min(28, wpr / LOG_BASE2 + 2 | 0);
          for (i = k; i; --i) x = x.div(x.times(x).plus(1).sqrt().plus(1));
          external2 = false;
          j = Math.ceil(wpr / LOG_BASE2);
          n = 1;
          x2 = x.times(x);
          r = new Ctor(x);
          px = x;
          for (; i !== -1; ) {
            px = px.times(x2);
            t = r.minus(px.div(n += 2));
            px = px.times(x2);
            r = t.plus(px.div(n += 2));
            if (r.d[j] !== void 0) for (i = j; r.d[i] === t.d[i] && i--; ) ;
          }
          if (k) r = r.times(2 << k - 1);
          external2 = true;
          return finalise2(r, Ctor.precision = pr, Ctor.rounding = rm, true);
        };
        P3.isFinite = function() {
          return !!this.d;
        };
        P3.isInteger = P3.isInt = function() {
          return !!this.d && mathfloor2(this.e / LOG_BASE2) > this.d.length - 2;
        };
        P3.isNaN = function() {
          return !this.s;
        };
        P3.isNegative = P3.isNeg = function() {
          return this.s < 0;
        };
        P3.isPositive = P3.isPos = function() {
          return this.s > 0;
        };
        P3.isZero = function() {
          return !!this.d && this.d[0] === 0;
        };
        P3.lessThan = P3.lt = function(y) {
          return this.cmp(y) < 0;
        };
        P3.lessThanOrEqualTo = P3.lte = function(y) {
          return this.cmp(y) < 1;
        };
        P3.logarithm = P3.log = function(base) {
          var isBase10, d, denominator, k, inf, num, sd, r, arg = this, Ctor = arg.constructor, pr = Ctor.precision, rm = Ctor.rounding, guard = 5;
          if (base == null) {
            base = new Ctor(10);
            isBase10 = true;
          } else {
            base = new Ctor(base);
            d = base.d;
            if (base.s < 0 || !d || !d[0] || base.eq(1)) return new Ctor(NaN);
            isBase10 = base.eq(10);
          }
          d = arg.d;
          if (arg.s < 0 || !d || !d[0] || arg.eq(1)) {
            return new Ctor(d && !d[0] ? -1 / 0 : arg.s != 1 ? NaN : d ? 0 : 1 / 0);
          }
          if (isBase10) {
            if (d.length > 1) {
              inf = true;
            } else {
              for (k = d[0]; k % 10 === 0; ) k /= 10;
              inf = k !== 1;
            }
          }
          external2 = false;
          sd = pr + guard;
          num = naturalLogarithm2(arg, sd);
          denominator = isBase10 ? getLn102(Ctor, sd + 10) : naturalLogarithm2(base, sd);
          r = divide2(num, denominator, sd, 1);
          if (checkRoundingDigits2(r.d, k = pr, rm)) {
            do {
              sd += 10;
              num = naturalLogarithm2(arg, sd);
              denominator = isBase10 ? getLn102(Ctor, sd + 10) : naturalLogarithm2(base, sd);
              r = divide2(num, denominator, sd, 1);
              if (!inf) {
                if (+digitsToString2(r.d).slice(k + 1, k + 15) + 1 == 1e14) {
                  r = finalise2(r, pr + 1, 0);
                }
                break;
              }
            } while (checkRoundingDigits2(r.d, k += 10, rm));
          }
          external2 = true;
          return finalise2(r, pr, rm);
        };
        P3.minus = P3.sub = function(y) {
          var d, e, i, j, k, len, pr, rm, xd, xe, xLTy, yd, x = this, Ctor = x.constructor;
          y = new Ctor(y);
          if (!x.d || !y.d) {
            if (!x.s || !y.s) y = new Ctor(NaN);
            else if (x.d) y.s = -y.s;
            else y = new Ctor(y.d || x.s !== y.s ? x : NaN);
            return y;
          }
          if (x.s != y.s) {
            y.s = -y.s;
            return x.plus(y);
          }
          xd = x.d;
          yd = y.d;
          pr = Ctor.precision;
          rm = Ctor.rounding;
          if (!xd[0] || !yd[0]) {
            if (yd[0]) y.s = -y.s;
            else if (xd[0]) y = new Ctor(x);
            else return new Ctor(rm === 3 ? -0 : 0);
            return external2 ? finalise2(y, pr, rm) : y;
          }
          e = mathfloor2(y.e / LOG_BASE2);
          xe = mathfloor2(x.e / LOG_BASE2);
          xd = xd.slice();
          k = xe - e;
          if (k) {
            xLTy = k < 0;
            if (xLTy) {
              d = xd;
              k = -k;
              len = yd.length;
            } else {
              d = yd;
              e = xe;
              len = xd.length;
            }
            i = Math.max(Math.ceil(pr / LOG_BASE2), len) + 2;
            if (k > i) {
              k = i;
              d.length = 1;
            }
            d.reverse();
            for (i = k; i--; ) d.push(0);
            d.reverse();
          } else {
            i = xd.length;
            len = yd.length;
            xLTy = i < len;
            if (xLTy) len = i;
            for (i = 0; i < len; i++) {
              if (xd[i] != yd[i]) {
                xLTy = xd[i] < yd[i];
                break;
              }
            }
            k = 0;
          }
          if (xLTy) {
            d = xd;
            xd = yd;
            yd = d;
            y.s = -y.s;
          }
          len = xd.length;
          for (i = yd.length - len; i > 0; --i) xd[len++] = 0;
          for (i = yd.length; i > k; ) {
            if (xd[--i] < yd[i]) {
              for (j = i; j && xd[--j] === 0; ) xd[j] = BASE2 - 1;
              --xd[j];
              xd[i] += BASE2;
            }
            xd[i] -= yd[i];
          }
          for (; xd[--len] === 0; ) xd.pop();
          for (; xd[0] === 0; xd.shift()) --e;
          if (!xd[0]) return new Ctor(rm === 3 ? -0 : 0);
          y.d = xd;
          y.e = getBase10Exponent2(xd, e);
          return external2 ? finalise2(y, pr, rm) : y;
        };
        P3.modulo = P3.mod = function(y) {
          var q, x = this, Ctor = x.constructor;
          y = new Ctor(y);
          if (!x.d || !y.s || y.d && !y.d[0]) return new Ctor(NaN);
          if (!y.d || x.d && !x.d[0]) {
            return finalise2(new Ctor(x), Ctor.precision, Ctor.rounding);
          }
          external2 = false;
          if (Ctor.modulo == 9) {
            q = divide2(x, y.abs(), 0, 3, 1);
            q.s *= y.s;
          } else {
            q = divide2(x, y, 0, Ctor.modulo, 1);
          }
          q = q.times(y);
          external2 = true;
          return x.minus(q);
        };
        P3.naturalExponential = P3.exp = function() {
          return naturalExponential2(this);
        };
        P3.naturalLogarithm = P3.ln = function() {
          return naturalLogarithm2(this);
        };
        P3.negated = P3.neg = function() {
          var x = new this.constructor(this);
          x.s = -x.s;
          return finalise2(x);
        };
        P3.plus = P3.add = function(y) {
          var carry, d, e, i, k, len, pr, rm, xd, yd, x = this, Ctor = x.constructor;
          y = new Ctor(y);
          if (!x.d || !y.d) {
            if (!x.s || !y.s) y = new Ctor(NaN);
            else if (!x.d) y = new Ctor(y.d || x.s === y.s ? x : NaN);
            return y;
          }
          if (x.s != y.s) {
            y.s = -y.s;
            return x.minus(y);
          }
          xd = x.d;
          yd = y.d;
          pr = Ctor.precision;
          rm = Ctor.rounding;
          if (!xd[0] || !yd[0]) {
            if (!yd[0]) y = new Ctor(x);
            return external2 ? finalise2(y, pr, rm) : y;
          }
          k = mathfloor2(x.e / LOG_BASE2);
          e = mathfloor2(y.e / LOG_BASE2);
          xd = xd.slice();
          i = k - e;
          if (i) {
            if (i < 0) {
              d = xd;
              i = -i;
              len = yd.length;
            } else {
              d = yd;
              e = k;
              len = xd.length;
            }
            k = Math.ceil(pr / LOG_BASE2);
            len = k > len ? k + 1 : len + 1;
            if (i > len) {
              i = len;
              d.length = 1;
            }
            d.reverse();
            for (; i--; ) d.push(0);
            d.reverse();
          }
          len = xd.length;
          i = yd.length;
          if (len - i < 0) {
            i = len;
            d = yd;
            yd = xd;
            xd = d;
          }
          for (carry = 0; i; ) {
            carry = (xd[--i] = xd[i] + yd[i] + carry) / BASE2 | 0;
            xd[i] %= BASE2;
          }
          if (carry) {
            xd.unshift(carry);
            ++e;
          }
          for (len = xd.length; xd[--len] == 0; ) xd.pop();
          y.d = xd;
          y.e = getBase10Exponent2(xd, e);
          return external2 ? finalise2(y, pr, rm) : y;
        };
        P3.precision = P3.sd = function(z) {
          var k, x = this;
          if (z !== void 0 && z !== !!z && z !== 1 && z !== 0) throw Error(invalidArgument2 + z);
          if (x.d) {
            k = getPrecision2(x.d);
            if (z && x.e + 1 > k) k = x.e + 1;
          } else {
            k = NaN;
          }
          return k;
        };
        P3.round = function() {
          var x = this, Ctor = x.constructor;
          return finalise2(new Ctor(x), x.e + 1, Ctor.rounding);
        };
        P3.sine = P3.sin = function() {
          var pr, rm, x = this, Ctor = x.constructor;
          if (!x.isFinite()) return new Ctor(NaN);
          if (x.isZero()) return new Ctor(x);
          pr = Ctor.precision;
          rm = Ctor.rounding;
          Ctor.precision = pr + Math.max(x.e, x.sd()) + LOG_BASE2;
          Ctor.rounding = 1;
          x = sine2(Ctor, toLessThanHalfPi2(Ctor, x));
          Ctor.precision = pr;
          Ctor.rounding = rm;
          return finalise2(quadrant2 > 2 ? x.neg() : x, pr, rm, true);
        };
        P3.squareRoot = P3.sqrt = function() {
          var m, n, sd, r, rep, t, x = this, d = x.d, e = x.e, s = x.s, Ctor = x.constructor;
          if (s !== 1 || !d || !d[0]) {
            return new Ctor(!s || s < 0 && (!d || d[0]) ? NaN : d ? x : 1 / 0);
          }
          external2 = false;
          s = Math.sqrt(+x);
          if (s == 0 || s == 1 / 0) {
            n = digitsToString2(d);
            if ((n.length + e) % 2 == 0) n += "0";
            s = Math.sqrt(n);
            e = mathfloor2((e + 1) / 2) - (e < 0 || e % 2);
            if (s == 1 / 0) {
              n = "5e" + e;
            } else {
              n = s.toExponential();
              n = n.slice(0, n.indexOf("e") + 1) + e;
            }
            r = new Ctor(n);
          } else {
            r = new Ctor(s.toString());
          }
          sd = (e = Ctor.precision) + 3;
          for (; ; ) {
            t = r;
            r = t.plus(divide2(x, t, sd + 2, 1)).times(0.5);
            if (digitsToString2(t.d).slice(0, sd) === (n = digitsToString2(r.d)).slice(0, sd)) {
              n = n.slice(sd - 3, sd + 1);
              if (n == "9999" || !rep && n == "4999") {
                if (!rep) {
                  finalise2(t, e + 1, 0);
                  if (t.times(t).eq(x)) {
                    r = t;
                    break;
                  }
                }
                sd += 4;
                rep = 1;
              } else {
                if (!+n || !+n.slice(1) && n.charAt(0) == "5") {
                  finalise2(r, e + 1, 1);
                  m = !r.times(r).eq(x);
                }
                break;
              }
            }
          }
          external2 = true;
          return finalise2(r, e, Ctor.rounding, m);
        };
        P3.tangent = P3.tan = function() {
          var pr, rm, x = this, Ctor = x.constructor;
          if (!x.isFinite()) return new Ctor(NaN);
          if (x.isZero()) return new Ctor(x);
          pr = Ctor.precision;
          rm = Ctor.rounding;
          Ctor.precision = pr + 10;
          Ctor.rounding = 1;
          x = x.sin();
          x.s = 1;
          x = divide2(x, new Ctor(1).minus(x.times(x)).sqrt(), pr + 10, 0);
          Ctor.precision = pr;
          Ctor.rounding = rm;
          return finalise2(quadrant2 == 2 || quadrant2 == 4 ? x.neg() : x, pr, rm, true);
        };
        P3.times = P3.mul = function(y) {
          var carry, e, i, k, r, rL, t, xdL, ydL, x = this, Ctor = x.constructor, xd = x.d, yd = (y = new Ctor(y)).d;
          y.s *= x.s;
          if (!xd || !xd[0] || !yd || !yd[0]) {
            return new Ctor(!y.s || xd && !xd[0] && !yd || yd && !yd[0] && !xd ? NaN : !xd || !yd ? y.s / 0 : y.s * 0);
          }
          e = mathfloor2(x.e / LOG_BASE2) + mathfloor2(y.e / LOG_BASE2);
          xdL = xd.length;
          ydL = yd.length;
          if (xdL < ydL) {
            r = xd;
            xd = yd;
            yd = r;
            rL = xdL;
            xdL = ydL;
            ydL = rL;
          }
          r = [];
          rL = xdL + ydL;
          for (i = rL; i--; ) r.push(0);
          for (i = ydL; --i >= 0; ) {
            carry = 0;
            for (k = xdL + i; k > i; ) {
              t = r[k] + yd[i] * xd[k - i - 1] + carry;
              r[k--] = t % BASE2 | 0;
              carry = t / BASE2 | 0;
            }
            r[k] = (r[k] + carry) % BASE2 | 0;
          }
          for (; !r[--rL]; ) r.pop();
          if (carry) ++e;
          else r.shift();
          y.d = r;
          y.e = getBase10Exponent2(r, e);
          return external2 ? finalise2(y, Ctor.precision, Ctor.rounding) : y;
        };
        P3.toBinary = function(sd, rm) {
          return toStringBinary2(this, 2, sd, rm);
        };
        P3.toDecimalPlaces = P3.toDP = function(dp, rm) {
          var x = this, Ctor = x.constructor;
          x = new Ctor(x);
          if (dp === void 0) return x;
          checkInt322(dp, 0, MAX_DIGITS2);
          if (rm === void 0) rm = Ctor.rounding;
          else checkInt322(rm, 0, 8);
          return finalise2(x, dp + x.e + 1, rm);
        };
        P3.toExponential = function(dp, rm) {
          var str, x = this, Ctor = x.constructor;
          if (dp === void 0) {
            str = finiteToString2(x, true);
          } else {
            checkInt322(dp, 0, MAX_DIGITS2);
            if (rm === void 0) rm = Ctor.rounding;
            else checkInt322(rm, 0, 8);
            x = finalise2(new Ctor(x), dp + 1, rm);
            str = finiteToString2(x, true, dp + 1);
          }
          return x.isNeg() && !x.isZero() ? "-" + str : str;
        };
        P3.toFixed = function(dp, rm) {
          var str, y, x = this, Ctor = x.constructor;
          if (dp === void 0) {
            str = finiteToString2(x);
          } else {
            checkInt322(dp, 0, MAX_DIGITS2);
            if (rm === void 0) rm = Ctor.rounding;
            else checkInt322(rm, 0, 8);
            y = finalise2(new Ctor(x), dp + x.e + 1, rm);
            str = finiteToString2(y, false, dp + y.e + 1);
          }
          return x.isNeg() && !x.isZero() ? "-" + str : str;
        };
        P3.toFraction = function(maxD) {
          var d, d0, d1, d2, e, k, n, n0, n12, pr, q, r, x = this, xd = x.d, Ctor = x.constructor;
          if (!xd) return new Ctor(x);
          n12 = d0 = new Ctor(1);
          d1 = n0 = new Ctor(0);
          d = new Ctor(d1);
          e = d.e = getPrecision2(xd) - x.e - 1;
          k = e % LOG_BASE2;
          d.d[0] = mathpow2(10, k < 0 ? LOG_BASE2 + k : k);
          if (maxD == null) {
            maxD = e > 0 ? d : n12;
          } else {
            n = new Ctor(maxD);
            if (!n.isInt() || n.lt(n12)) throw Error(invalidArgument2 + n);
            maxD = n.gt(d) ? e > 0 ? d : n12 : n;
          }
          external2 = false;
          n = new Ctor(digitsToString2(xd));
          pr = Ctor.precision;
          Ctor.precision = e = xd.length * LOG_BASE2 * 2;
          for (; ; ) {
            q = divide2(n, d, 0, 1, 1);
            d2 = d0.plus(q.times(d1));
            if (d2.cmp(maxD) == 1) break;
            d0 = d1;
            d1 = d2;
            d2 = n12;
            n12 = n0.plus(q.times(d2));
            n0 = d2;
            d2 = d;
            d = n.minus(q.times(d2));
            n = d2;
          }
          d2 = divide2(maxD.minus(d0), d1, 0, 1, 1);
          n0 = n0.plus(d2.times(n12));
          d0 = d0.plus(d2.times(d1));
          n0.s = n12.s = x.s;
          r = divide2(n12, d1, e, 1).minus(x).abs().cmp(divide2(n0, d0, e, 1).minus(x).abs()) < 1 ? [n12, d1] : [n0, d0];
          Ctor.precision = pr;
          external2 = true;
          return r;
        };
        P3.toHexadecimal = P3.toHex = function(sd, rm) {
          return toStringBinary2(this, 16, sd, rm);
        };
        P3.toNearest = function(y, rm) {
          var x = this, Ctor = x.constructor;
          x = new Ctor(x);
          if (y == null) {
            if (!x.d) return x;
            y = new Ctor(1);
            rm = Ctor.rounding;
          } else {
            y = new Ctor(y);
            if (rm === void 0) {
              rm = Ctor.rounding;
            } else {
              checkInt322(rm, 0, 8);
            }
            if (!x.d) return y.s ? x : y;
            if (!y.d) {
              if (y.s) y.s = x.s;
              return y;
            }
          }
          if (y.d[0]) {
            external2 = false;
            x = divide2(x, y, 0, rm, 1).times(y);
            external2 = true;
            finalise2(x);
          } else {
            y.s = x.s;
            x = y;
          }
          return x;
        };
        P3.toNumber = function() {
          return +this;
        };
        P3.toOctal = function(sd, rm) {
          return toStringBinary2(this, 8, sd, rm);
        };
        P3.toPower = P3.pow = function(y) {
          var e, k, pr, r, rm, s, x = this, Ctor = x.constructor, yn = +(y = new Ctor(y));
          if (!x.d || !y.d || !x.d[0] || !y.d[0]) return new Ctor(mathpow2(+x, yn));
          x = new Ctor(x);
          if (x.eq(1)) return x;
          pr = Ctor.precision;
          rm = Ctor.rounding;
          if (y.eq(1)) return finalise2(x, pr, rm);
          e = mathfloor2(y.e / LOG_BASE2);
          if (e >= y.d.length - 1 && (k = yn < 0 ? -yn : yn) <= MAX_SAFE_INTEGER2) {
            r = intPow2(Ctor, x, k, pr);
            return y.s < 0 ? new Ctor(1).div(r) : finalise2(r, pr, rm);
          }
          s = x.s;
          if (s < 0) {
            if (e < y.d.length - 1) return new Ctor(NaN);
            if ((y.d[e] & 1) == 0) s = 1;
            if (x.e == 0 && x.d[0] == 1 && x.d.length == 1) {
              x.s = s;
              return x;
            }
          }
          k = mathpow2(+x, yn);
          e = k == 0 || !isFinite(k) ? mathfloor2(yn * (Math.log("0." + digitsToString2(x.d)) / Math.LN10 + x.e + 1)) : new Ctor(k + "").e;
          if (e > Ctor.maxE + 1 || e < Ctor.minE - 1) return new Ctor(e > 0 ? s / 0 : 0);
          external2 = false;
          Ctor.rounding = x.s = 1;
          k = Math.min(12, (e + "").length);
          r = naturalExponential2(y.times(naturalLogarithm2(x, pr + k)), pr);
          if (r.d) {
            r = finalise2(r, pr + 5, 1);
            if (checkRoundingDigits2(r.d, pr, rm)) {
              e = pr + 10;
              r = finalise2(naturalExponential2(y.times(naturalLogarithm2(x, e + k)), e), e + 5, 1);
              if (+digitsToString2(r.d).slice(pr + 1, pr + 15) + 1 == 1e14) {
                r = finalise2(r, pr + 1, 0);
              }
            }
          }
          r.s = s;
          external2 = true;
          Ctor.rounding = rm;
          return finalise2(r, pr, rm);
        };
        P3.toPrecision = function(sd, rm) {
          var str, x = this, Ctor = x.constructor;
          if (sd === void 0) {
            str = finiteToString2(x, x.e <= Ctor.toExpNeg || x.e >= Ctor.toExpPos);
          } else {
            checkInt322(sd, 1, MAX_DIGITS2);
            if (rm === void 0) rm = Ctor.rounding;
            else checkInt322(rm, 0, 8);
            x = finalise2(new Ctor(x), sd, rm);
            str = finiteToString2(x, sd <= x.e || x.e <= Ctor.toExpNeg, sd);
          }
          return x.isNeg() && !x.isZero() ? "-" + str : str;
        };
        P3.toSignificantDigits = P3.toSD = function(sd, rm) {
          var x = this, Ctor = x.constructor;
          if (sd === void 0) {
            sd = Ctor.precision;
            rm = Ctor.rounding;
          } else {
            checkInt322(sd, 1, MAX_DIGITS2);
            if (rm === void 0) rm = Ctor.rounding;
            else checkInt322(rm, 0, 8);
          }
          return finalise2(new Ctor(x), sd, rm);
        };
        P3.toString = function() {
          var x = this, Ctor = x.constructor, str = finiteToString2(x, x.e <= Ctor.toExpNeg || x.e >= Ctor.toExpPos);
          return x.isNeg() && !x.isZero() ? "-" + str : str;
        };
        P3.truncated = P3.trunc = function() {
          return finalise2(new this.constructor(this), this.e + 1, 1);
        };
        P3.valueOf = P3.toJSON = function() {
          var x = this, Ctor = x.constructor, str = finiteToString2(x, x.e <= Ctor.toExpNeg || x.e >= Ctor.toExpPos);
          return x.isNeg() ? "-" + str : str;
        };
        function digitsToString2(d) {
          var i, k, ws, indexOfLastWord = d.length - 1, str = "", w = d[0];
          if (indexOfLastWord > 0) {
            str += w;
            for (i = 1; i < indexOfLastWord; i++) {
              ws = d[i] + "";
              k = LOG_BASE2 - ws.length;
              if (k) str += getZeroString2(k);
              str += ws;
            }
            w = d[i];
            ws = w + "";
            k = LOG_BASE2 - ws.length;
            if (k) str += getZeroString2(k);
          } else if (w === 0) {
            return "0";
          }
          for (; w % 10 === 0; ) w /= 10;
          return str + w;
        }
        function checkInt322(i, min3, max3) {
          if (i !== ~~i || i < min3 || i > max3) {
            throw Error(invalidArgument2 + i);
          }
        }
        function checkRoundingDigits2(d, i, rm, repeating) {
          var di, k, r, rd;
          for (k = d[0]; k >= 10; k /= 10) --i;
          if (--i < 0) {
            i += LOG_BASE2;
            di = 0;
          } else {
            di = Math.ceil((i + 1) / LOG_BASE2);
            i %= LOG_BASE2;
          }
          k = mathpow2(10, LOG_BASE2 - i);
          rd = d[di] % k | 0;
          if (repeating == null) {
            if (i < 3) {
              if (i == 0) rd = rd / 100 | 0;
              else if (i == 1) rd = rd / 10 | 0;
              r = rm < 4 && rd == 99999 || rm > 3 && rd == 49999 || rd == 5e4 || rd == 0;
            } else {
              r = (rm < 4 && rd + 1 == k || rm > 3 && rd + 1 == k / 2) && (d[di + 1] / k / 100 | 0) == mathpow2(10, i - 2) - 1 || (rd == k / 2 || rd == 0) && (d[di + 1] / k / 100 | 0) == 0;
            }
          } else {
            if (i < 4) {
              if (i == 0) rd = rd / 1e3 | 0;
              else if (i == 1) rd = rd / 100 | 0;
              else if (i == 2) rd = rd / 10 | 0;
              r = (repeating || rm < 4) && rd == 9999 || !repeating && rm > 3 && rd == 4999;
            } else {
              r = ((repeating || rm < 4) && rd + 1 == k || !repeating && rm > 3 && rd + 1 == k / 2) && (d[di + 1] / k / 1e3 | 0) == mathpow2(10, i - 3) - 1;
            }
          }
          return r;
        }
        function convertBase2(str, baseIn, baseOut) {
          var j, arr = [0], arrL, i = 0, strL = str.length;
          for (; i < strL; ) {
            for (arrL = arr.length; arrL--; ) arr[arrL] *= baseIn;
            arr[0] += NUMERALS2.indexOf(str.charAt(i++));
            for (j = 0; j < arr.length; j++) {
              if (arr[j] > baseOut - 1) {
                if (arr[j + 1] === void 0) arr[j + 1] = 0;
                arr[j + 1] += arr[j] / baseOut | 0;
                arr[j] %= baseOut;
              }
            }
          }
          return arr.reverse();
        }
        function cosine2(Ctor, x) {
          var k, len, y;
          if (x.isZero()) return x;
          len = x.d.length;
          if (len < 32) {
            k = Math.ceil(len / 3);
            y = (1 / tinyPow2(4, k)).toString();
          } else {
            k = 16;
            y = "2.3283064365386962890625e-10";
          }
          Ctor.precision += k;
          x = taylorSeries2(Ctor, 1, x.times(y), new Ctor(1));
          for (var i = k; i--; ) {
            var cos2x = x.times(x);
            x = cos2x.times(cos2x).minus(cos2x).times(8).plus(1);
          }
          Ctor.precision -= k;
          return x;
        }
        var divide2 = /* @__PURE__ */ (function() {
          function multiplyInteger(x, k, base) {
            var temp, carry = 0, i = x.length;
            for (x = x.slice(); i--; ) {
              temp = x[i] * k + carry;
              x[i] = temp % base | 0;
              carry = temp / base | 0;
            }
            if (carry) x.unshift(carry);
            return x;
          }
          function compare(a, b, aL, bL) {
            var i, r;
            if (aL != bL) {
              r = aL > bL ? 1 : -1;
            } else {
              for (i = r = 0; i < aL; i++) {
                if (a[i] != b[i]) {
                  r = a[i] > b[i] ? 1 : -1;
                  break;
                }
              }
            }
            return r;
          }
          function subtract(a, b, aL, base) {
            var i = 0;
            for (; aL--; ) {
              a[aL] -= i;
              i = a[aL] < b[aL] ? 1 : 0;
              a[aL] = i * base + a[aL] - b[aL];
            }
            for (; !a[0] && a.length > 1; ) a.shift();
          }
          return function(x, y, pr, rm, dp, base) {
            var cmp, e, i, k, logBase, more, prod, prodL, q, qd, rem, remL, rem0, sd, t, xi, xL, yd0, yL, yz, Ctor = x.constructor, sign4 = x.s == y.s ? 1 : -1, xd = x.d, yd = y.d;
            if (!xd || !xd[0] || !yd || !yd[0]) {
              return new Ctor(
                // Return NaN if either NaN, or both Infinity or 0.
                !x.s || !y.s || (xd ? yd && xd[0] == yd[0] : !yd) ? NaN : (
                  // Return 0 if x is 0 or y is Infinity, or return Infinity as y is 0.
                  xd && xd[0] == 0 || !yd ? sign4 * 0 : sign4 / 0
                )
              );
            }
            if (base) {
              logBase = 1;
              e = x.e - y.e;
            } else {
              base = BASE2;
              logBase = LOG_BASE2;
              e = mathfloor2(x.e / logBase) - mathfloor2(y.e / logBase);
            }
            yL = yd.length;
            xL = xd.length;
            q = new Ctor(sign4);
            qd = q.d = [];
            for (i = 0; yd[i] == (xd[i] || 0); i++) ;
            if (yd[i] > (xd[i] || 0)) e--;
            if (pr == null) {
              sd = pr = Ctor.precision;
              rm = Ctor.rounding;
            } else if (dp) {
              sd = pr + (x.e - y.e) + 1;
            } else {
              sd = pr;
            }
            if (sd < 0) {
              qd.push(1);
              more = true;
            } else {
              sd = sd / logBase + 2 | 0;
              i = 0;
              if (yL == 1) {
                k = 0;
                yd = yd[0];
                sd++;
                for (; (i < xL || k) && sd--; i++) {
                  t = k * base + (xd[i] || 0);
                  qd[i] = t / yd | 0;
                  k = t % yd | 0;
                }
                more = k || i < xL;
              } else {
                k = base / (yd[0] + 1) | 0;
                if (k > 1) {
                  yd = multiplyInteger(yd, k, base);
                  xd = multiplyInteger(xd, k, base);
                  yL = yd.length;
                  xL = xd.length;
                }
                xi = yL;
                rem = xd.slice(0, yL);
                remL = rem.length;
                for (; remL < yL; ) rem[remL++] = 0;
                yz = yd.slice();
                yz.unshift(0);
                yd0 = yd[0];
                if (yd[1] >= base / 2) ++yd0;
                do {
                  k = 0;
                  cmp = compare(yd, rem, yL, remL);
                  if (cmp < 0) {
                    rem0 = rem[0];
                    if (yL != remL) rem0 = rem0 * base + (rem[1] || 0);
                    k = rem0 / yd0 | 0;
                    if (k > 1) {
                      if (k >= base) k = base - 1;
                      prod = multiplyInteger(yd, k, base);
                      prodL = prod.length;
                      remL = rem.length;
                      cmp = compare(prod, rem, prodL, remL);
                      if (cmp == 1) {
                        k--;
                        subtract(prod, yL < prodL ? yz : yd, prodL, base);
                      }
                    } else {
                      if (k == 0) cmp = k = 1;
                      prod = yd.slice();
                    }
                    prodL = prod.length;
                    if (prodL < remL) prod.unshift(0);
                    subtract(rem, prod, remL, base);
                    if (cmp == -1) {
                      remL = rem.length;
                      cmp = compare(yd, rem, yL, remL);
                      if (cmp < 1) {
                        k++;
                        subtract(rem, yL < remL ? yz : yd, remL, base);
                      }
                    }
                    remL = rem.length;
                  } else if (cmp === 0) {
                    k++;
                    rem = [0];
                  }
                  qd[i++] = k;
                  if (cmp && rem[0]) {
                    rem[remL++] = xd[xi] || 0;
                  } else {
                    rem = [xd[xi]];
                    remL = 1;
                  }
                } while ((xi++ < xL || rem[0] !== void 0) && sd--);
                more = rem[0] !== void 0;
              }
              if (!qd[0]) qd.shift();
            }
            if (logBase == 1) {
              q.e = e;
              inexact2 = more;
            } else {
              for (i = 1, k = qd[0]; k >= 10; k /= 10) i++;
              q.e = i + e * logBase - 1;
              finalise2(q, dp ? pr + q.e + 1 : pr, rm, more);
            }
            return q;
          };
        })();
        function finalise2(x, sd, rm, isTruncated) {
          var digits2, i, j, k, rd, roundUp, w, xd, xdi, Ctor = x.constructor;
          out: if (sd != null) {
            xd = x.d;
            if (!xd) return x;
            for (digits2 = 1, k = xd[0]; k >= 10; k /= 10) digits2++;
            i = sd - digits2;
            if (i < 0) {
              i += LOG_BASE2;
              j = sd;
              w = xd[xdi = 0];
              rd = w / mathpow2(10, digits2 - j - 1) % 10 | 0;
            } else {
              xdi = Math.ceil((i + 1) / LOG_BASE2);
              k = xd.length;
              if (xdi >= k) {
                if (isTruncated) {
                  for (; k++ <= xdi; ) xd.push(0);
                  w = rd = 0;
                  digits2 = 1;
                  i %= LOG_BASE2;
                  j = i - LOG_BASE2 + 1;
                } else {
                  break out;
                }
              } else {
                w = k = xd[xdi];
                for (digits2 = 1; k >= 10; k /= 10) digits2++;
                i %= LOG_BASE2;
                j = i - LOG_BASE2 + digits2;
                rd = j < 0 ? 0 : w / mathpow2(10, digits2 - j - 1) % 10 | 0;
              }
            }
            isTruncated = isTruncated || sd < 0 || xd[xdi + 1] !== void 0 || (j < 0 ? w : w % mathpow2(10, digits2 - j - 1));
            roundUp = rm < 4 ? (rd || isTruncated) && (rm == 0 || rm == (x.s < 0 ? 3 : 2)) : rd > 5 || rd == 5 && (rm == 4 || isTruncated || rm == 6 && // Check whether the digit to the left of the rounding digit is odd.
            (i > 0 ? j > 0 ? w / mathpow2(10, digits2 - j) : 0 : xd[xdi - 1]) % 10 & 1 || rm == (x.s < 0 ? 8 : 7));
            if (sd < 1 || !xd[0]) {
              xd.length = 0;
              if (roundUp) {
                sd -= x.e + 1;
                xd[0] = mathpow2(10, (LOG_BASE2 - sd % LOG_BASE2) % LOG_BASE2);
                x.e = -sd || 0;
              } else {
                xd[0] = x.e = 0;
              }
              return x;
            }
            if (i == 0) {
              xd.length = xdi;
              k = 1;
              xdi--;
            } else {
              xd.length = xdi + 1;
              k = mathpow2(10, LOG_BASE2 - i);
              xd[xdi] = j > 0 ? (w / mathpow2(10, digits2 - j) % mathpow2(10, j) | 0) * k : 0;
            }
            if (roundUp) {
              for (; ; ) {
                if (xdi == 0) {
                  for (i = 1, j = xd[0]; j >= 10; j /= 10) i++;
                  j = xd[0] += k;
                  for (k = 1; j >= 10; j /= 10) k++;
                  if (i != k) {
                    x.e++;
                    if (xd[0] == BASE2) xd[0] = 1;
                  }
                  break;
                } else {
                  xd[xdi] += k;
                  if (xd[xdi] != BASE2) break;
                  xd[xdi--] = 0;
                  k = 1;
                }
              }
            }
            for (i = xd.length; xd[--i] === 0; ) xd.pop();
          }
          if (external2) {
            if (x.e > Ctor.maxE) {
              x.d = null;
              x.e = NaN;
            } else if (x.e < Ctor.minE) {
              x.e = 0;
              x.d = [0];
            }
          }
          return x;
        }
        function finiteToString2(x, isExp, sd) {
          if (!x.isFinite()) return nonFiniteToString2(x);
          var k, e = x.e, str = digitsToString2(x.d), len = str.length;
          if (isExp) {
            if (sd && (k = sd - len) > 0) {
              str = str.charAt(0) + "." + str.slice(1) + getZeroString2(k);
            } else if (len > 1) {
              str = str.charAt(0) + "." + str.slice(1);
            }
            str = str + (x.e < 0 ? "e" : "e+") + x.e;
          } else if (e < 0) {
            str = "0." + getZeroString2(-e - 1) + str;
            if (sd && (k = sd - len) > 0) str += getZeroString2(k);
          } else if (e >= len) {
            str += getZeroString2(e + 1 - len);
            if (sd && (k = sd - e - 1) > 0) str = str + "." + getZeroString2(k);
          } else {
            if ((k = e + 1) < len) str = str.slice(0, k) + "." + str.slice(k);
            if (sd && (k = sd - len) > 0) {
              if (e + 1 === len) str += ".";
              str += getZeroString2(k);
            }
          }
          return str;
        }
        function getBase10Exponent2(digits2, e) {
          var w = digits2[0];
          for (e *= LOG_BASE2; w >= 10; w /= 10) e++;
          return e;
        }
        function getLn102(Ctor, sd, pr) {
          if (sd > LN10_PRECISION2) {
            external2 = true;
            if (pr) Ctor.precision = pr;
            throw Error(precisionLimitExceeded2);
          }
          return finalise2(new Ctor(LN102), sd, 1, true);
        }
        function getPi2(Ctor, sd, rm) {
          if (sd > PI_PRECISION2) throw Error(precisionLimitExceeded2);
          return finalise2(new Ctor(PI2), sd, rm, true);
        }
        function getPrecision2(digits2) {
          var w = digits2.length - 1, len = w * LOG_BASE2 + 1;
          w = digits2[w];
          if (w) {
            for (; w % 10 == 0; w /= 10) len--;
            for (w = digits2[0]; w >= 10; w /= 10) len++;
          }
          return len;
        }
        function getZeroString2(k) {
          var zs = "";
          for (; k--; ) zs += "0";
          return zs;
        }
        function intPow2(Ctor, x, n, pr) {
          var isTruncated, r = new Ctor(1), k = Math.ceil(pr / LOG_BASE2 + 4);
          external2 = false;
          for (; ; ) {
            if (n % 2) {
              r = r.times(x);
              if (truncate2(r.d, k)) isTruncated = true;
            }
            n = mathfloor2(n / 2);
            if (n === 0) {
              n = r.d.length - 1;
              if (isTruncated && r.d[n] === 0) ++r.d[n];
              break;
            }
            x = x.times(x);
            truncate2(x.d, k);
          }
          external2 = true;
          return r;
        }
        function isOdd2(n) {
          return n.d[n.d.length - 1] & 1;
        }
        function maxOrMin2(Ctor, args, n) {
          var k, y, x = new Ctor(args[0]), i = 0;
          for (; ++i < args.length; ) {
            y = new Ctor(args[i]);
            if (!y.s) {
              x = y;
              break;
            }
            k = x.cmp(y);
            if (k === n || k === 0 && x.s === n) {
              x = y;
            }
          }
          return x;
        }
        function naturalExponential2(x, sd) {
          var denominator, guard, j, pow3, sum3, t, wpr, rep = 0, i = 0, k = 0, Ctor = x.constructor, rm = Ctor.rounding, pr = Ctor.precision;
          if (!x.d || !x.d[0] || x.e > 17) {
            return new Ctor(x.d ? !x.d[0] ? 1 : x.s < 0 ? 0 : 1 / 0 : x.s ? x.s < 0 ? 0 : x : 0 / 0);
          }
          if (sd == null) {
            external2 = false;
            wpr = pr;
          } else {
            wpr = sd;
          }
          t = new Ctor(0.03125);
          while (x.e > -2) {
            x = x.times(t);
            k += 5;
          }
          guard = Math.log(mathpow2(2, k)) / Math.LN10 * 2 + 5 | 0;
          wpr += guard;
          denominator = pow3 = sum3 = new Ctor(1);
          Ctor.precision = wpr;
          for (; ; ) {
            pow3 = finalise2(pow3.times(x), wpr, 1);
            denominator = denominator.times(++i);
            t = sum3.plus(divide2(pow3, denominator, wpr, 1));
            if (digitsToString2(t.d).slice(0, wpr) === digitsToString2(sum3.d).slice(0, wpr)) {
              j = k;
              while (j--) sum3 = finalise2(sum3.times(sum3), wpr, 1);
              if (sd == null) {
                if (rep < 3 && checkRoundingDigits2(sum3.d, wpr - guard, rm, rep)) {
                  Ctor.precision = wpr += 10;
                  denominator = pow3 = t = new Ctor(1);
                  i = 0;
                  rep++;
                } else {
                  return finalise2(sum3, Ctor.precision = pr, rm, external2 = true);
                }
              } else {
                Ctor.precision = pr;
                return sum3;
              }
            }
            sum3 = t;
          }
        }
        function naturalLogarithm2(y, sd) {
          var c, c0, denominator, e, numerator, rep, sum3, t, wpr, x1, x2, n = 1, guard = 10, x = y, xd = x.d, Ctor = x.constructor, rm = Ctor.rounding, pr = Ctor.precision;
          if (x.s < 0 || !xd || !xd[0] || !x.e && xd[0] == 1 && xd.length == 1) {
            return new Ctor(xd && !xd[0] ? -1 / 0 : x.s != 1 ? NaN : xd ? 0 : x);
          }
          if (sd == null) {
            external2 = false;
            wpr = pr;
          } else {
            wpr = sd;
          }
          Ctor.precision = wpr += guard;
          c = digitsToString2(xd);
          c0 = c.charAt(0);
          if (Math.abs(e = x.e) < 15e14) {
            while (c0 < 7 && c0 != 1 || c0 == 1 && c.charAt(1) > 3) {
              x = x.times(y);
              c = digitsToString2(x.d);
              c0 = c.charAt(0);
              n++;
            }
            e = x.e;
            if (c0 > 1) {
              x = new Ctor("0." + c);
              e++;
            } else {
              x = new Ctor(c0 + "." + c.slice(1));
            }
          } else {
            t = getLn102(Ctor, wpr + 2, pr).times(e + "");
            x = naturalLogarithm2(new Ctor(c0 + "." + c.slice(1)), wpr - guard).plus(t);
            Ctor.precision = pr;
            return sd == null ? finalise2(x, pr, rm, external2 = true) : x;
          }
          x1 = x;
          sum3 = numerator = x = divide2(x.minus(1), x.plus(1), wpr, 1);
          x2 = finalise2(x.times(x), wpr, 1);
          denominator = 3;
          for (; ; ) {
            numerator = finalise2(numerator.times(x2), wpr, 1);
            t = sum3.plus(divide2(numerator, new Ctor(denominator), wpr, 1));
            if (digitsToString2(t.d).slice(0, wpr) === digitsToString2(sum3.d).slice(0, wpr)) {
              sum3 = sum3.times(2);
              if (e !== 0) sum3 = sum3.plus(getLn102(Ctor, wpr + 2, pr).times(e + ""));
              sum3 = divide2(sum3, new Ctor(n), wpr, 1);
              if (sd == null) {
                if (checkRoundingDigits2(sum3.d, wpr - guard, rm, rep)) {
                  Ctor.precision = wpr += guard;
                  t = numerator = x = divide2(x1.minus(1), x1.plus(1), wpr, 1);
                  x2 = finalise2(x.times(x), wpr, 1);
                  denominator = rep = 1;
                } else {
                  return finalise2(sum3, Ctor.precision = pr, rm, external2 = true);
                }
              } else {
                Ctor.precision = pr;
                return sum3;
              }
            }
            sum3 = t;
            denominator += 2;
          }
        }
        function nonFiniteToString2(x) {
          return String(x.s * x.s / 0);
        }
        function parseDecimal2(x, str) {
          var e, i, len;
          if ((e = str.indexOf(".")) > -1) str = str.replace(".", "");
          if ((i = str.search(/e/i)) > 0) {
            if (e < 0) e = i;
            e += +str.slice(i + 1);
            str = str.substring(0, i);
          } else if (e < 0) {
            e = str.length;
          }
          for (i = 0; str.charCodeAt(i) === 48; i++) ;
          for (len = str.length; str.charCodeAt(len - 1) === 48; --len) ;
          str = str.slice(i, len);
          if (str) {
            len -= i;
            x.e = e = e - i - 1;
            x.d = [];
            i = (e + 1) % LOG_BASE2;
            if (e < 0) i += LOG_BASE2;
            if (i < len) {
              if (i) x.d.push(+str.slice(0, i));
              for (len -= LOG_BASE2; i < len; ) x.d.push(+str.slice(i, i += LOG_BASE2));
              str = str.slice(i);
              i = LOG_BASE2 - str.length;
            } else {
              i -= len;
            }
            for (; i--; ) str += "0";
            x.d.push(+str);
            if (external2) {
              if (x.e > x.constructor.maxE) {
                x.d = null;
                x.e = NaN;
              } else if (x.e < x.constructor.minE) {
                x.e = 0;
                x.d = [0];
              }
            }
          } else {
            x.e = 0;
            x.d = [0];
          }
          return x;
        }
        function parseOther2(x, str) {
          var base, Ctor, divisor, i, isFloat, len, p, xd, xe;
          if (str.indexOf("_") > -1) {
            str = str.replace(/(\d)_(?=\d)/g, "$1");
            if (isDecimal2.test(str)) return parseDecimal2(x, str);
          } else if (str === "Infinity" || str === "NaN") {
            if (!+str) x.s = NaN;
            x.e = NaN;
            x.d = null;
            return x;
          }
          if (isHex2.test(str)) {
            base = 16;
            str = str.toLowerCase();
          } else if (isBinary2.test(str)) {
            base = 2;
          } else if (isOctal2.test(str)) {
            base = 8;
          } else {
            throw Error(invalidArgument2 + str);
          }
          i = str.search(/p/i);
          if (i > 0) {
            p = +str.slice(i + 1);
            str = str.substring(2, i);
          } else {
            str = str.slice(2);
          }
          i = str.indexOf(".");
          isFloat = i >= 0;
          Ctor = x.constructor;
          if (isFloat) {
            str = str.replace(".", "");
            len = str.length;
            i = len - i;
            divisor = intPow2(Ctor, new Ctor(base), i, i * 2);
          }
          xd = convertBase2(str, base, BASE2);
          xe = xd.length - 1;
          for (i = xe; xd[i] === 0; --i) xd.pop();
          if (i < 0) return new Ctor(x.s * 0);
          x.e = getBase10Exponent2(xd, xe);
          x.d = xd;
          external2 = false;
          if (isFloat) x = divide2(x, divisor, len * 4);
          if (p) x = x.times(Math.abs(p) < 54 ? mathpow2(2, p) : Decimal2.pow(2, p));
          external2 = true;
          return x;
        }
        function sine2(Ctor, x) {
          var k, len = x.d.length;
          if (len < 3) {
            return x.isZero() ? x : taylorSeries2(Ctor, 2, x, x);
          }
          k = 1.4 * Math.sqrt(len);
          k = k > 16 ? 16 : k | 0;
          x = x.times(1 / tinyPow2(5, k));
          x = taylorSeries2(Ctor, 2, x, x);
          var sin2_x, d5 = new Ctor(5), d16 = new Ctor(16), d20 = new Ctor(20);
          for (; k--; ) {
            sin2_x = x.times(x);
            x = x.times(d5.plus(sin2_x.times(d16.times(sin2_x).minus(d20))));
          }
          return x;
        }
        function taylorSeries2(Ctor, n, x, y, isHyperbolic) {
          var j, t, u, x2, i = 1, pr = Ctor.precision, k = Math.ceil(pr / LOG_BASE2);
          external2 = false;
          x2 = x.times(x);
          u = new Ctor(y);
          for (; ; ) {
            t = divide2(u.times(x2), new Ctor(n++ * n++), pr, 1);
            u = isHyperbolic ? y.plus(t) : y.minus(t);
            y = divide2(t.times(x2), new Ctor(n++ * n++), pr, 1);
            t = u.plus(y);
            if (t.d[k] !== void 0) {
              for (j = k; t.d[j] === u.d[j] && j--; ) ;
              if (j == -1) break;
            }
            j = u;
            u = y;
            y = t;
            t = j;
            i++;
          }
          external2 = true;
          t.d.length = k + 1;
          return t;
        }
        function tinyPow2(b, e) {
          var n = b;
          while (--e) n *= b;
          return n;
        }
        function toLessThanHalfPi2(Ctor, x) {
          var t, isNeg = x.s < 0, pi = getPi2(Ctor, Ctor.precision, 1), halfPi = pi.times(0.5);
          x = x.abs();
          if (x.lte(halfPi)) {
            quadrant2 = isNeg ? 4 : 1;
            return x;
          }
          t = x.divToInt(pi);
          if (t.isZero()) {
            quadrant2 = isNeg ? 3 : 2;
          } else {
            x = x.minus(t.times(pi));
            if (x.lte(halfPi)) {
              quadrant2 = isOdd2(t) ? isNeg ? 2 : 3 : isNeg ? 4 : 1;
              return x;
            }
            quadrant2 = isOdd2(t) ? isNeg ? 1 : 4 : isNeg ? 3 : 2;
          }
          return x.minus(pi).abs();
        }
        function toStringBinary2(x, baseOut, sd, rm) {
          var base, e, i, k, len, roundUp, str, xd, y, Ctor = x.constructor, isExp = sd !== void 0;
          if (isExp) {
            checkInt322(sd, 1, MAX_DIGITS2);
            if (rm === void 0) rm = Ctor.rounding;
            else checkInt322(rm, 0, 8);
          } else {
            sd = Ctor.precision;
            rm = Ctor.rounding;
          }
          if (!x.isFinite()) {
            str = nonFiniteToString2(x);
          } else {
            str = finiteToString2(x);
            i = str.indexOf(".");
            if (isExp) {
              base = 2;
              if (baseOut == 16) {
                sd = sd * 4 - 3;
              } else if (baseOut == 8) {
                sd = sd * 3 - 2;
              }
            } else {
              base = baseOut;
            }
            if (i >= 0) {
              str = str.replace(".", "");
              y = new Ctor(1);
              y.e = str.length - i;
              y.d = convertBase2(finiteToString2(y), 10, base);
              y.e = y.d.length;
            }
            xd = convertBase2(str, 10, base);
            e = len = xd.length;
            for (; xd[--len] == 0; ) xd.pop();
            if (!xd[0]) {
              str = isExp ? "0p+0" : "0";
            } else {
              if (i < 0) {
                e--;
              } else {
                x = new Ctor(x);
                x.d = xd;
                x.e = e;
                x = divide2(x, y, sd, rm, 0, base);
                xd = x.d;
                e = x.e;
                roundUp = inexact2;
              }
              i = xd[sd];
              k = base / 2;
              roundUp = roundUp || xd[sd + 1] !== void 0;
              roundUp = rm < 4 ? (i !== void 0 || roundUp) && (rm === 0 || rm === (x.s < 0 ? 3 : 2)) : i > k || i === k && (rm === 4 || roundUp || rm === 6 && xd[sd - 1] & 1 || rm === (x.s < 0 ? 8 : 7));
              xd.length = sd;
              if (roundUp) {
                for (; ++xd[--sd] > base - 1; ) {
                  xd[sd] = 0;
                  if (!sd) {
                    ++e;
                    xd.unshift(1);
                  }
                }
              }
              for (len = xd.length; !xd[len - 1]; --len) ;
              for (i = 0, str = ""; i < len; i++) str += NUMERALS2.charAt(xd[i]);
              if (isExp) {
                if (len > 1) {
                  if (baseOut == 16 || baseOut == 8) {
                    i = baseOut == 16 ? 4 : 3;
                    for (--len; len % i; len++) str += "0";
                    xd = convertBase2(str, base, baseOut);
                    for (len = xd.length; !xd[len - 1]; --len) ;
                    for (i = 1, str = "1."; i < len; i++) str += NUMERALS2.charAt(xd[i]);
                  } else {
                    str = str.charAt(0) + "." + str.slice(1);
                  }
                }
                str = str + (e < 0 ? "p" : "p+") + e;
              } else if (e < 0) {
                for (; ++e; ) str = "0" + str;
                str = "0." + str;
              } else {
                if (++e > len) for (e -= len; e--; ) str += "0";
                else if (e < len) str = str.slice(0, e) + "." + str.slice(e);
              }
            }
            str = (baseOut == 16 ? "0x" : baseOut == 2 ? "0b" : baseOut == 8 ? "0o" : "") + str;
          }
          return x.s < 0 ? "-" + str : str;
        }
        function truncate2(arr, len) {
          if (arr.length > len) {
            arr.length = len;
            return true;
          }
        }
        function abs2(x) {
          return new this(x).abs();
        }
        function acos2(x) {
          return new this(x).acos();
        }
        function acosh2(x) {
          return new this(x).acosh();
        }
        function add2(x, y) {
          return new this(x).plus(y);
        }
        function asin2(x) {
          return new this(x).asin();
        }
        function asinh2(x) {
          return new this(x).asinh();
        }
        function atan3(x) {
          return new this(x).atan();
        }
        function atanh2(x) {
          return new this(x).atanh();
        }
        function atan22(y, x) {
          y = new this(y);
          x = new this(x);
          var r, pr = this.precision, rm = this.rounding, wpr = pr + 4;
          if (!y.s || !x.s) {
            r = new this(NaN);
          } else if (!y.d && !x.d) {
            r = getPi2(this, wpr, 1).times(x.s > 0 ? 0.25 : 0.75);
            r.s = y.s;
          } else if (!x.d || y.isZero()) {
            r = x.s < 0 ? getPi2(this, pr, rm) : new this(0);
            r.s = y.s;
          } else if (!y.d || x.isZero()) {
            r = getPi2(this, wpr, 1).times(0.5);
            r.s = y.s;
          } else if (x.s < 0) {
            this.precision = wpr;
            this.rounding = 1;
            r = this.atan(divide2(y, x, wpr, 1));
            x = getPi2(this, wpr, 1);
            this.precision = pr;
            this.rounding = rm;
            r = y.s < 0 ? r.minus(x) : r.plus(x);
          } else {
            r = this.atan(divide2(y, x, wpr, 1));
          }
          return r;
        }
        function cbrt4(x) {
          return new this(x).cbrt();
        }
        function ceil2(x) {
          return finalise2(x = new this(x), x.e + 1, 2);
        }
        function clamp2(x, min3, max3) {
          return new this(x).clamp(min3, max3);
        }
        function config4(obj) {
          if (!obj || typeof obj !== "object") throw Error(decimalError2 + "Object expected");
          var i, p, v, useDefaults = obj.defaults === true, ps = [
            "precision",
            1,
            MAX_DIGITS2,
            "rounding",
            0,
            8,
            "toExpNeg",
            -EXP_LIMIT2,
            0,
            "toExpPos",
            0,
            EXP_LIMIT2,
            "maxE",
            0,
            EXP_LIMIT2,
            "minE",
            -EXP_LIMIT2,
            0,
            "modulo",
            0,
            9
          ];
          for (i = 0; i < ps.length; i += 3) {
            if (p = ps[i], useDefaults) this[p] = DEFAULTS2[p];
            if ((v = obj[p]) !== void 0) {
              if (mathfloor2(v) === v && v >= ps[i + 1] && v <= ps[i + 2]) this[p] = v;
              else throw Error(invalidArgument2 + p + ": " + v);
            }
          }
          if (p = "crypto", useDefaults) this[p] = DEFAULTS2[p];
          if ((v = obj[p]) !== void 0) {
            if (v === true || v === false || v === 0 || v === 1) {
              if (v) {
                if (typeof crypto != "undefined" && crypto && (crypto.getRandomValues || crypto.randomBytes)) {
                  this[p] = true;
                } else {
                  throw Error(cryptoUnavailable2);
                }
              } else {
                this[p] = false;
              }
            } else {
              throw Error(invalidArgument2 + p + ": " + v);
            }
          }
          return this;
        }
        function cos2(x) {
          return new this(x).cos();
        }
        function cosh3(x) {
          return new this(x).cosh();
        }
        function clone4(obj) {
          var i, p, ps;
          function Decimal3(v) {
            var e, i2, t, x = this;
            if (!(x instanceof Decimal3)) return new Decimal3(v);
            x.constructor = Decimal3;
            if (isDecimalInstance2(v)) {
              x.s = v.s;
              if (external2) {
                if (!v.d || v.e > Decimal3.maxE) {
                  x.e = NaN;
                  x.d = null;
                } else if (v.e < Decimal3.minE) {
                  x.e = 0;
                  x.d = [0];
                } else {
                  x.e = v.e;
                  x.d = v.d.slice();
                }
              } else {
                x.e = v.e;
                x.d = v.d ? v.d.slice() : v.d;
              }
              return;
            }
            t = typeof v;
            if (t === "number") {
              if (v === 0) {
                x.s = 1 / v < 0 ? -1 : 1;
                x.e = 0;
                x.d = [0];
                return;
              }
              if (v < 0) {
                v = -v;
                x.s = -1;
              } else {
                x.s = 1;
              }
              if (v === ~~v && v < 1e7) {
                for (e = 0, i2 = v; i2 >= 10; i2 /= 10) e++;
                if (external2) {
                  if (e > Decimal3.maxE) {
                    x.e = NaN;
                    x.d = null;
                  } else if (e < Decimal3.minE) {
                    x.e = 0;
                    x.d = [0];
                  } else {
                    x.e = e;
                    x.d = [v];
                  }
                } else {
                  x.e = e;
                  x.d = [v];
                }
                return;
              }
              if (v * 0 !== 0) {
                if (!v) x.s = NaN;
                x.e = NaN;
                x.d = null;
                return;
              }
              return parseDecimal2(x, v.toString());
            }
            if (t === "string") {
              if ((i2 = v.charCodeAt(0)) === 45) {
                v = v.slice(1);
                x.s = -1;
              } else {
                if (i2 === 43) v = v.slice(1);
                x.s = 1;
              }
              return isDecimal2.test(v) ? parseDecimal2(x, v) : parseOther2(x, v);
            }
            if (t === "bigint") {
              if (v < 0) {
                v = -v;
                x.s = -1;
              } else {
                x.s = 1;
              }
              return parseDecimal2(x, v.toString());
            }
            throw Error(invalidArgument2 + v);
          }
          Decimal3.prototype = P3;
          Decimal3.ROUND_UP = 0;
          Decimal3.ROUND_DOWN = 1;
          Decimal3.ROUND_CEIL = 2;
          Decimal3.ROUND_FLOOR = 3;
          Decimal3.ROUND_HALF_UP = 4;
          Decimal3.ROUND_HALF_DOWN = 5;
          Decimal3.ROUND_HALF_EVEN = 6;
          Decimal3.ROUND_HALF_CEIL = 7;
          Decimal3.ROUND_HALF_FLOOR = 8;
          Decimal3.EUCLID = 9;
          Decimal3.config = Decimal3.set = config4;
          Decimal3.clone = clone4;
          Decimal3.isDecimal = isDecimalInstance2;
          Decimal3.abs = abs2;
          Decimal3.acos = acos2;
          Decimal3.acosh = acosh2;
          Decimal3.add = add2;
          Decimal3.asin = asin2;
          Decimal3.asinh = asinh2;
          Decimal3.atan = atan3;
          Decimal3.atanh = atanh2;
          Decimal3.atan2 = atan22;
          Decimal3.cbrt = cbrt4;
          Decimal3.ceil = ceil2;
          Decimal3.clamp = clamp2;
          Decimal3.cos = cos2;
          Decimal3.cosh = cosh3;
          Decimal3.div = div2;
          Decimal3.exp = exp2;
          Decimal3.floor = floor2;
          Decimal3.hypot = hypot3;
          Decimal3.ln = ln2;
          Decimal3.log = log3;
          Decimal3.log10 = log104;
          Decimal3.log2 = log24;
          Decimal3.max = max2;
          Decimal3.min = min2;
          Decimal3.mod = mod2;
          Decimal3.mul = mul2;
          Decimal3.pow = pow2;
          Decimal3.random = random2;
          Decimal3.round = round2;
          Decimal3.sign = sign3;
          Decimal3.sin = sin2;
          Decimal3.sinh = sinh3;
          Decimal3.sqrt = sqrt2;
          Decimal3.sub = sub2;
          Decimal3.sum = sum2;
          Decimal3.tan = tan2;
          Decimal3.tanh = tanh2;
          Decimal3.trunc = trunc2;
          if (obj === void 0) obj = {};
          if (obj) {
            if (obj.defaults !== true) {
              ps = ["precision", "rounding", "toExpNeg", "toExpPos", "maxE", "minE", "modulo", "crypto"];
              for (i = 0; i < ps.length; ) if (!obj.hasOwnProperty(p = ps[i++])) obj[p] = this[p];
            }
          }
          Decimal3.config(obj);
          return Decimal3;
        }
        function div2(x, y) {
          return new this(x).div(y);
        }
        function exp2(x) {
          return new this(x).exp();
        }
        function floor2(x) {
          return finalise2(x = new this(x), x.e + 1, 3);
        }
        function hypot3() {
          var i, n, t = new this(0);
          external2 = false;
          for (i = 0; i < arguments.length; ) {
            n = new this(arguments[i++]);
            if (!n.d) {
              if (n.s) {
                external2 = true;
                return new this(1 / 0);
              }
              t = n;
            } else if (t.d) {
              t = t.plus(n.times(n));
            }
          }
          external2 = true;
          return t.sqrt();
        }
        function isDecimalInstance2(obj) {
          return obj instanceof Decimal2 || obj && obj.toStringTag === tag2 || false;
        }
        function ln2(x) {
          return new this(x).ln();
        }
        function log3(x, y) {
          return new this(x).log(y);
        }
        function log24(x) {
          return new this(x).log(2);
        }
        function log104(x) {
          return new this(x).log(10);
        }
        function max2() {
          return maxOrMin2(this, arguments, -1);
        }
        function min2() {
          return maxOrMin2(this, arguments, 1);
        }
        function mod2(x, y) {
          return new this(x).mod(y);
        }
        function mul2(x, y) {
          return new this(x).mul(y);
        }
        function pow2(x, y) {
          return new this(x).pow(y);
        }
        function random2(sd) {
          var d, e, k, n, i = 0, r = new this(1), rd = [];
          if (sd === void 0) sd = this.precision;
          else checkInt322(sd, 1, MAX_DIGITS2);
          k = Math.ceil(sd / LOG_BASE2);
          if (!this.crypto) {
            for (; i < k; ) rd[i++] = Math.random() * 1e7 | 0;
          } else if (crypto.getRandomValues) {
            d = crypto.getRandomValues(new Uint32Array(k));
            for (; i < k; ) {
              n = d[i];
              if (n >= 429e7) {
                d[i] = crypto.getRandomValues(new Uint32Array(1))[0];
              } else {
                rd[i++] = n % 1e7;
              }
            }
          } else if (crypto.randomBytes) {
            d = crypto.randomBytes(k *= 4);
            for (; i < k; ) {
              n = d[i] + (d[i + 1] << 8) + (d[i + 2] << 16) + ((d[i + 3] & 127) << 24);
              if (n >= 214e7) {
                crypto.randomBytes(4).copy(d, i);
              } else {
                rd.push(n % 1e7);
                i += 4;
              }
            }
            i = k / 4;
          } else {
            throw Error(cryptoUnavailable2);
          }
          k = rd[--i];
          sd %= LOG_BASE2;
          if (k && sd) {
            n = mathpow2(10, LOG_BASE2 - sd);
            rd[i] = (k / n | 0) * n;
          }
          for (; rd[i] === 0; i--) rd.pop();
          if (i < 0) {
            e = 0;
            rd = [0];
          } else {
            e = -1;
            for (; rd[0] === 0; e -= LOG_BASE2) rd.shift();
            for (k = 1, n = rd[0]; n >= 10; n /= 10) k++;
            if (k < LOG_BASE2) e -= LOG_BASE2 - k;
          }
          r.e = e;
          r.d = rd;
          return r;
        }
        function round2(x) {
          return finalise2(x = new this(x), x.e + 1, this.rounding);
        }
        function sign3(x) {
          x = new this(x);
          return x.d ? x.d[0] ? x.s : 0 * x.s : x.s || NaN;
        }
        function sin2(x) {
          return new this(x).sin();
        }
        function sinh3(x) {
          return new this(x).sinh();
        }
        function sqrt2(x) {
          return new this(x).sqrt();
        }
        function sub2(x, y) {
          return new this(x).sub(y);
        }
        function sum2() {
          var i = 0, args = arguments, x = new this(args[i]);
          external2 = false;
          for (; x.s && ++i < args.length; ) x = x.plus(args[i]);
          external2 = true;
          return finalise2(x, this.precision, this.rounding);
        }
        function tan2(x) {
          return new this(x).tan();
        }
        function tanh2(x) {
          return new this(x).tanh();
        }
        function trunc2(x) {
          return finalise2(x = new this(x), x.e + 1, 1);
        }
        Decimal2 = clone4(DEFAULTS2);
        Decimal2.prototype.constructor = Decimal2;
        Decimal2["default"] = Decimal2.Decimal = Decimal2;
        LN102 = new Decimal2(LN102);
        PI2 = new Decimal2(PI2);
        if (typeof define == "function" && define.amd) {
          define(function() {
            return Decimal2;
          });
        } else if (typeof module != "undefined" && module.exports) {
          if (typeof Symbol == "function" && typeof Symbol.iterator == "symbol") {
            P3[Symbol["for"]("nodejs.util.inspect.custom")] = P3.toString;
            P3[Symbol.toStringTag] = "Decimal";
          }
          module.exports = Decimal2;
        } else {
          if (!globalScope) {
            globalScope = typeof self != "undefined" && self && self.self == self ? self : window;
          }
          noConflict = globalScope.Decimal;
          Decimal2.noConflict = function() {
            globalScope.Decimal = noConflict;
            return Decimal2;
          };
          globalScope.Decimal = Decimal2;
        }
      })(exports);
    }
  });

  // node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/type/bignumber/BigNumber.js
  var require_BigNumber = __commonJS({
    "node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/type/bignumber/BigNumber.js"(exports) {
      "use strict";
      var _interopRequireDefault = require_interopRequireDefault();
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.createBigNumberClass = void 0;
      var _decimal = _interopRequireDefault(require_decimal());
      var _factory = require_factory();
      var name18 = "BigNumber";
      var dependencies19 = ["?on", "config"];
      var createBigNumberClass2 = exports.createBigNumberClass = /* @__PURE__ */ (0, _factory.factory)(name18, dependencies19, function(_ref) {
        var on = _ref.on, config4 = _ref.config;
        var BigNumber2 = _decimal["default"].clone({
          precision: config4.precision,
          modulo: _decimal["default"].EUCLID
        });
        BigNumber2.prototype = Object.create(BigNumber2.prototype);
        BigNumber2.prototype.type = "BigNumber";
        BigNumber2.prototype.isBigNumber = true;
        BigNumber2.prototype.toJSON = function() {
          return {
            mathjs: "BigNumber",
            value: this.toString()
          };
        };
        BigNumber2.fromJSON = function(json) {
          return new BigNumber2(json.value);
        };
        if (on) {
          on("config", function(curr, prev) {
            if (curr.precision !== prev.precision) {
              BigNumber2.config({
                precision: curr.precision
              });
            }
          });
        }
        return BigNumber2;
      }, {
        isClass: true
      });
    }
  });

  // node_modules/.pnpm/complex.js@2.4.3/node_modules/complex.js/dist/complex.js
  var require_complex = __commonJS({
    "node_modules/.pnpm/complex.js@2.4.3/node_modules/complex.js/dist/complex.js"(exports, module) {
      "use strict";
      var cosh3 = Math.cosh || function(x) {
        return Math.abs(x) < 1e-9 ? 1 - x : (Math.exp(x) + Math.exp(-x)) * 0.5;
      };
      var sinh3 = Math.sinh || function(x) {
        return Math.abs(x) < 1e-9 ? x : (Math.exp(x) - Math.exp(-x)) * 0.5;
      };
      var cosm12 = (x) => {
        const s = Math.sin(0.5 * x);
        return -2 * s * s;
      };
      var hypot3 = function(x, y) {
        x = Math.abs(x);
        y = Math.abs(y);
        if (x < y) [x, y] = [y, x];
        if (x < 1e8) return Math.sqrt(x * x + y * y);
        y /= x;
        return x * Math.sqrt(1 + y * y);
      };
      var parser_exit2 = function() {
        throw SyntaxError("Invalid Param");
      };
      function logHypot2(a, b) {
        const _a = Math.abs(a);
        const _b = Math.abs(b);
        if (a === 0) {
          return Math.log(_b);
        }
        if (b === 0) {
          return Math.log(_a);
        }
        if (_a < 3e3 && _b < 3e3) {
          return Math.log(a * a + b * b) * 0.5;
        }
        a = a * 0.5;
        b = b * 0.5;
        return 0.5 * Math.log(a * a + b * b) + Math.LN2;
      }
      var P3 = { "re": 0, "im": 0 };
      var parse2 = function(a, b) {
        const z = P3;
        if (a === void 0 || a === null) {
          z["re"] = z["im"] = 0;
        } else if (b !== void 0) {
          z["re"] = a;
          z["im"] = b;
        } else
          switch (typeof a) {
            case "object":
              if ("im" in a && "re" in a) {
                z["re"] = a["re"];
                z["im"] = a["im"];
              } else if ("abs" in a && "arg" in a) {
                if (!isFinite(a["abs"]) && isFinite(a["arg"])) {
                  return Complex3["INFINITY"];
                }
                z["re"] = a["abs"] * Math.cos(a["arg"]);
                z["im"] = a["abs"] * Math.sin(a["arg"]);
              } else if ("r" in a && "phi" in a) {
                if (!isFinite(a["r"]) && isFinite(a["phi"])) {
                  return Complex3["INFINITY"];
                }
                z["re"] = a["r"] * Math.cos(a["phi"]);
                z["im"] = a["r"] * Math.sin(a["phi"]);
              } else if (a.length === 2) {
                z["re"] = a[0];
                z["im"] = a[1];
              } else {
                parser_exit2();
              }
              break;
            case "string":
              z["im"] = /* void */
              z["re"] = 0;
              const tokens = a.replace(/_/g, "").match(/\d+\.?\d*e[+-]?\d+|\d+\.?\d*|\.\d+|./g);
              let plus = 1;
              let minus = 0;
              if (tokens === null) {
                parser_exit2();
              }
              for (let i = 0; i < tokens.length; i++) {
                const c = tokens[i];
                if (c === " " || c === "	" || c === "\n") {
                } else if (c === "+") {
                  plus++;
                } else if (c === "-") {
                  minus++;
                } else if (c === "i" || c === "I") {
                  if (plus + minus === 0) {
                    parser_exit2();
                  }
                  if (tokens[i + 1] !== " " && !isNaN(tokens[i + 1])) {
                    z["im"] += parseFloat((minus % 2 ? "-" : "") + tokens[i + 1]);
                    i++;
                  } else {
                    z["im"] += parseFloat((minus % 2 ? "-" : "") + "1");
                  }
                  plus = minus = 0;
                } else {
                  if (plus + minus === 0 || isNaN(c)) {
                    parser_exit2();
                  }
                  if (tokens[i + 1] === "i" || tokens[i + 1] === "I") {
                    z["im"] += parseFloat((minus % 2 ? "-" : "") + c);
                    i++;
                  } else {
                    z["re"] += parseFloat((minus % 2 ? "-" : "") + c);
                  }
                  plus = minus = 0;
                }
              }
              if (plus + minus > 0) {
                parser_exit2();
              }
              break;
            case "number":
              z["im"] = 0;
              z["re"] = a;
              break;
            default:
              parser_exit2();
          }
        if (isNaN(z["re"]) || isNaN(z["im"])) {
        }
        return z;
      };
      function Complex3(a, b) {
        if (!(this instanceof Complex3)) {
          return new Complex3(a, b);
        }
        const z = parse2(a, b);
        this["re"] = z["re"];
        this["im"] = z["im"];
      }
      Complex3.prototype = {
        "re": 0,
        "im": 0,
        /**
         * Calculates the sign of a complex number, which is a normalized complex
         *
         * @returns {Complex}
         */
        "sign": function() {
          const abs2 = hypot3(this["re"], this["im"]);
          return new Complex3(
            this["re"] / abs2,
            this["im"] / abs2
          );
        },
        /**
         * Adds two complex numbers
         *
         * @returns {Complex}
         */
        "add": function(a, b) {
          const z = parse2(a, b);
          const tInfin = this["isInfinite"]();
          const zInfin = !(isFinite(z["re"]) && isFinite(z["im"]));
          if (tInfin || zInfin) {
            if (tInfin && zInfin) {
              return Complex3["NAN"];
            }
            return Complex3["INFINITY"];
          }
          return new Complex3(
            this["re"] + z["re"],
            this["im"] + z["im"]
          );
        },
        /**
         * Subtracts two complex numbers
         *
         * @returns {Complex}
         */
        "sub": function(a, b) {
          const z = parse2(a, b);
          const tInfin = this["isInfinite"]();
          const zInfin = !(isFinite(z["re"]) && isFinite(z["im"]));
          if (tInfin || zInfin) {
            if (tInfin && zInfin) {
              return Complex3["NAN"];
            }
            return Complex3["INFINITY"];
          }
          return new Complex3(
            this["re"] - z["re"],
            this["im"] - z["im"]
          );
        },
        /**
         * Multiplies two complex numbers
         *
         * @returns {Complex}
         */
        "mul": function(a, b) {
          const z = parse2(a, b);
          const tInfin = this["isInfinite"]();
          const zInfin = !(isFinite(z["re"]) && isFinite(z["im"]));
          const tIsZero = this["re"] === 0 && this["im"] === 0;
          const zIsZero = z["re"] === 0 && z["im"] === 0;
          if (tInfin && zIsZero || zInfin && tIsZero) {
            return Complex3["NAN"];
          }
          if (tInfin || zInfin) {
            return Complex3["INFINITY"];
          }
          if (z["im"] === 0 && this["im"] === 0) {
            return new Complex3(this["re"] * z["re"], 0);
          }
          return new Complex3(
            this["re"] * z["re"] - this["im"] * z["im"],
            this["re"] * z["im"] + this["im"] * z["re"]
          );
        },
        /**
         * Divides two complex numbers
         *
         * @returns {Complex}
         */
        "div": function(a, b) {
          const z = parse2(a, b);
          const tInfin = this["isInfinite"]();
          const zInfin = !(isFinite(z["re"]) && isFinite(z["im"]));
          const tIsZero = this["re"] === 0 && this["im"] === 0;
          const zIsZero = z["re"] === 0 && z["im"] === 0;
          if (tIsZero && zIsZero || tInfin && zInfin) {
            return Complex3["NAN"];
          }
          if (zIsZero || tInfin) {
            return Complex3["INFINITY"];
          }
          if (tIsZero || zInfin) {
            return Complex3["ZERO"];
          }
          if (0 === z["im"]) {
            return new Complex3(this["re"] / z["re"], this["im"] / z["re"]);
          }
          if (Math.abs(z["re"]) < Math.abs(z["im"])) {
            const x = z["re"] / z["im"];
            const t = z["re"] * x + z["im"];
            return new Complex3(
              (this["re"] * x + this["im"]) / t,
              (this["im"] * x - this["re"]) / t
            );
          } else {
            const x = z["im"] / z["re"];
            const t = z["im"] * x + z["re"];
            return new Complex3(
              (this["re"] + this["im"] * x) / t,
              (this["im"] - this["re"] * x) / t
            );
          }
        },
        /**
         * Calculate the power of two complex numbers
         *
         * @returns {Complex}
         */
        "pow": function(a, b) {
          const z = parse2(a, b);
          const tIsZero = this["re"] === 0 && this["im"] === 0;
          const zIsZero = z["re"] === 0 && z["im"] === 0;
          if (zIsZero) {
            return Complex3["ONE"];
          }
          if (z["im"] === 0) {
            if (this["im"] === 0 && this["re"] > 0) {
              return new Complex3(Math.pow(this["re"], z["re"]), 0);
            } else if (this["re"] === 0) {
              switch ((z["re"] % 4 + 4) % 4) {
                case 0:
                  return new Complex3(Math.pow(this["im"], z["re"]), 0);
                case 1:
                  return new Complex3(0, Math.pow(this["im"], z["re"]));
                case 2:
                  return new Complex3(-Math.pow(this["im"], z["re"]), 0);
                case 3:
                  return new Complex3(0, -Math.pow(this["im"], z["re"]));
              }
            }
          }
          if (tIsZero && z["re"] > 0) {
            return Complex3["ZERO"];
          }
          const arg = Math.atan2(this["im"], this["re"]);
          const loh = logHypot2(this["re"], this["im"]);
          let re = Math.exp(z["re"] * loh - z["im"] * arg);
          let im = z["im"] * loh + z["re"] * arg;
          return new Complex3(
            re * Math.cos(im),
            re * Math.sin(im)
          );
        },
        /**
         * Calculate the complex square root
         *
         * @returns {Complex}
         */
        "sqrt": function() {
          const a = this["re"];
          const b = this["im"];
          if (b === 0) {
            if (a >= 0) {
              return new Complex3(Math.sqrt(a), 0);
            } else {
              return new Complex3(0, Math.sqrt(-a));
            }
          }
          const r = hypot3(a, b);
          let re = Math.sqrt(0.5 * (r + Math.abs(a)));
          let im = Math.abs(b) / (2 * re);
          if (a >= 0) {
            return new Complex3(re, b < 0 ? -im : im);
          } else {
            return new Complex3(im, b < 0 ? -re : re);
          }
        },
        /**
         * Calculate the complex exponent
         *
         * @returns {Complex}
         */
        "exp": function() {
          const er = Math.exp(this["re"]);
          if (this["im"] === 0) {
            return new Complex3(er, 0);
          }
          return new Complex3(
            er * Math.cos(this["im"]),
            er * Math.sin(this["im"])
          );
        },
        /**
         * Calculate the complex exponent and subtracts one.
         *
         * This may be more accurate than `Complex(x).exp().sub(1)` if
         * `x` is small.
         *
         * @returns {Complex}
         */
        "expm1": function() {
          const a = this["re"];
          const b = this["im"];
          return new Complex3(
            Math.expm1(a) * Math.cos(b) + cosm12(b),
            Math.exp(a) * Math.sin(b)
          );
        },
        /**
         * Calculate the natural log
         *
         * @returns {Complex}
         */
        "log": function() {
          const a = this["re"];
          const b = this["im"];
          if (b === 0 && a > 0) {
            return new Complex3(Math.log(a), 0);
          }
          return new Complex3(
            logHypot2(a, b),
            Math.atan2(b, a)
          );
        },
        /**
         * Calculate the magnitude of the complex number
         *
         * @returns {number}
         */
        "abs": function() {
          return hypot3(this["re"], this["im"]);
        },
        /**
         * Calculate the angle of the complex number
         *
         * @returns {number}
         */
        "arg": function() {
          return Math.atan2(this["im"], this["re"]);
        },
        /**
         * Calculate the sine of the complex number
         *
         * @returns {Complex}
         */
        "sin": function() {
          const a = this["re"];
          const b = this["im"];
          return new Complex3(
            Math.sin(a) * cosh3(b),
            Math.cos(a) * sinh3(b)
          );
        },
        /**
         * Calculate the cosine
         *
         * @returns {Complex}
         */
        "cos": function() {
          const a = this["re"];
          const b = this["im"];
          return new Complex3(
            Math.cos(a) * cosh3(b),
            -Math.sin(a) * sinh3(b)
          );
        },
        /**
         * Calculate the tangent
         *
         * @returns {Complex}
         */
        "tan": function() {
          const a = 2 * this["re"];
          const b = 2 * this["im"];
          const d = Math.cos(a) + cosh3(b);
          return new Complex3(
            Math.sin(a) / d,
            sinh3(b) / d
          );
        },
        /**
         * Calculate the cotangent
         *
         * @returns {Complex}
         */
        "cot": function() {
          const a = 2 * this["re"];
          const b = 2 * this["im"];
          const d = Math.cos(a) - cosh3(b);
          return new Complex3(
            -Math.sin(a) / d,
            sinh3(b) / d
          );
        },
        /**
         * Calculate the secant
         *
         * @returns {Complex}
         */
        "sec": function() {
          const a = this["re"];
          const b = this["im"];
          const d = 0.5 * cosh3(2 * b) + 0.5 * Math.cos(2 * a);
          return new Complex3(
            Math.cos(a) * cosh3(b) / d,
            Math.sin(a) * sinh3(b) / d
          );
        },
        /**
         * Calculate the cosecans
         *
         * @returns {Complex}
         */
        "csc": function() {
          const a = this["re"];
          const b = this["im"];
          const d = 0.5 * cosh3(2 * b) - 0.5 * Math.cos(2 * a);
          return new Complex3(
            Math.sin(a) * cosh3(b) / d,
            -Math.cos(a) * sinh3(b) / d
          );
        },
        /**
         * Calculate the complex arcus sinus
         *
         * @returns {Complex}
         */
        "asin": function() {
          const a = this["re"];
          const b = this["im"];
          const t1 = new Complex3(
            b * b - a * a + 1,
            -2 * a * b
          )["sqrt"]();
          const t2 = new Complex3(
            t1["re"] - b,
            t1["im"] + a
          )["log"]();
          return new Complex3(t2["im"], -t2["re"]);
        },
        /**
         * Calculate the complex arcus cosinus
         *
         * @returns {Complex}
         */
        "acos": function() {
          const a = this["re"];
          const b = this["im"];
          const t1 = new Complex3(
            b * b - a * a + 1,
            -2 * a * b
          )["sqrt"]();
          const t2 = new Complex3(
            t1["re"] - b,
            t1["im"] + a
          )["log"]();
          return new Complex3(Math.PI / 2 - t2["im"], t2["re"]);
        },
        /**
         * Calculate the complex arcus tangent
         *
         * @returns {Complex}
         */
        "atan": function() {
          const a = this["re"];
          const b = this["im"];
          if (a === 0) {
            if (b === 1) {
              return new Complex3(0, Infinity);
            }
            if (b === -1) {
              return new Complex3(0, -Infinity);
            }
          }
          const d = a * a + (1 - b) * (1 - b);
          const t1 = new Complex3(
            (1 - b * b - a * a) / d,
            -2 * a / d
          ).log();
          return new Complex3(-0.5 * t1["im"], 0.5 * t1["re"]);
        },
        /**
         * Calculate the complex arcus cotangent
         *
         * @returns {Complex}
         */
        "acot": function() {
          const a = this["re"];
          const b = this["im"];
          if (b === 0) {
            return new Complex3(Math.atan2(1, a), 0);
          }
          const d = a * a + b * b;
          return d !== 0 ? new Complex3(
            a / d,
            -b / d
          ).atan() : new Complex3(
            a !== 0 ? a / 0 : 0,
            b !== 0 ? -b / 0 : 0
          ).atan();
        },
        /**
         * Calculate the complex arcus secant
         *
         * @returns {Complex}
         */
        "asec": function() {
          const a = this["re"];
          const b = this["im"];
          if (a === 0 && b === 0) {
            return new Complex3(0, Infinity);
          }
          const d = a * a + b * b;
          return d !== 0 ? new Complex3(
            a / d,
            -b / d
          ).acos() : new Complex3(
            a !== 0 ? a / 0 : 0,
            b !== 0 ? -b / 0 : 0
          ).acos();
        },
        /**
         * Calculate the complex arcus cosecans
         *
         * @returns {Complex}
         */
        "acsc": function() {
          const a = this["re"];
          const b = this["im"];
          if (a === 0 && b === 0) {
            return new Complex3(Math.PI / 2, Infinity);
          }
          const d = a * a + b * b;
          return d !== 0 ? new Complex3(
            a / d,
            -b / d
          ).asin() : new Complex3(
            a !== 0 ? a / 0 : 0,
            b !== 0 ? -b / 0 : 0
          ).asin();
        },
        /**
         * Calculate the complex sinh
         *
         * @returns {Complex}
         */
        "sinh": function() {
          const a = this["re"];
          const b = this["im"];
          return new Complex3(
            sinh3(a) * Math.cos(b),
            cosh3(a) * Math.sin(b)
          );
        },
        /**
         * Calculate the complex cosh
         *
         * @returns {Complex}
         */
        "cosh": function() {
          const a = this["re"];
          const b = this["im"];
          return new Complex3(
            cosh3(a) * Math.cos(b),
            sinh3(a) * Math.sin(b)
          );
        },
        /**
         * Calculate the complex tanh
         *
         * @returns {Complex}
         */
        "tanh": function() {
          const a = 2 * this["re"];
          const b = 2 * this["im"];
          const d = cosh3(a) + Math.cos(b);
          return new Complex3(
            sinh3(a) / d,
            Math.sin(b) / d
          );
        },
        /**
         * Calculate the complex coth
         *
         * @returns {Complex}
         */
        "coth": function() {
          const a = 2 * this["re"];
          const b = 2 * this["im"];
          const d = cosh3(a) - Math.cos(b);
          return new Complex3(
            sinh3(a) / d,
            -Math.sin(b) / d
          );
        },
        /**
         * Calculate the complex csch
         *
         * @returns {Complex}
         */
        "csch": function() {
          const a = this["re"];
          const b = this["im"];
          const d = Math.cos(2 * b) - cosh3(2 * a);
          return new Complex3(
            -2 * sinh3(a) * Math.cos(b) / d,
            2 * cosh3(a) * Math.sin(b) / d
          );
        },
        /**
         * Calculate the complex sech
         *
         * @returns {Complex}
         */
        "sech": function() {
          const a = this["re"];
          const b = this["im"];
          const d = Math.cos(2 * b) + cosh3(2 * a);
          return new Complex3(
            2 * cosh3(a) * Math.cos(b) / d,
            -2 * sinh3(a) * Math.sin(b) / d
          );
        },
        /**
         * Calculate the complex asinh
         *
         * @returns {Complex}
         */
        "asinh": function() {
          const a = this["re"];
          const b = this["im"];
          if (b === 0) {
            if (a === 0) {
              return new Complex3(0, 0);
            }
            const x = Math.abs(a);
            const r = Math.log(x + Math.sqrt(x * x + 1));
            return new Complex3(a < 0 ? -r : r, 0);
          }
          const re2 = a * a - b * b + 1;
          const im2 = 2 * a * b;
          const t = new Complex3(re2, im2)["sqrt"]();
          return new Complex3(a + t["re"], b + t["im"])["log"]();
        },
        /**
         * Calculate the complex acosh
         *
         * @returns {Complex}
         */
        "acosh": function() {
          const a = this["re"];
          const b = this["im"];
          if (b === 0) {
            if (a > 1) {
              return new Complex3(
                Math.log(a + Math.sqrt(a - 1) * Math.sqrt(a + 1)),
                0
              );
            }
            if (a < -1) {
              const t = Math.sqrt(a * a - 1);
              return new Complex3(Math.log(-a + t), Math.PI);
            }
            return new Complex3(0, Math.acos(a));
          }
          const t1 = new Complex3(a - 1, b)["sqrt"]();
          const t2 = new Complex3(a + 1, b)["sqrt"]();
          return new Complex3(
            a + t1["re"] * t2["re"] - t1["im"] * t2["im"],
            b + t1["re"] * t2["im"] + t1["im"] * t2["re"]
          )["log"]();
        },
        /**
         * Calculate the complex atanh
         *
         * @returns {Complex}
         */
        "atanh": function() {
          const a = this["re"];
          const b = this["im"];
          if (b === 0) {
            if (a === 0) {
              return new Complex3(0, 0);
            }
            if (a === 1) {
              return new Complex3(Infinity, 0);
            }
            if (a === -1) {
              return new Complex3(-Infinity, 0);
            }
            if (-1 < a && a < 1) {
              return new Complex3(
                0.5 * Math.log((1 + a) / (1 - a)),
                0
              );
            }
            if (a > 1) {
              const t2 = (a + 1) / (a - 1);
              return new Complex3(
                0.5 * Math.log(t2),
                -Math.PI / 2
              );
            }
            const t = (1 + a) / (1 - a);
            return new Complex3(
              0.5 * Math.log(-t),
              // log((1 - a)/(1 + a))
              Math.PI / 2
            );
          }
          const oneMinus = 1 - a;
          const onePlus = 1 + a;
          const d = oneMinus * oneMinus + b * b;
          if (d === 0) {
            return new Complex3(
              a !== -1 ? a / 0 : 0,
              b !== 0 ? b / 0 : 0
            );
          }
          const xr = (onePlus * oneMinus - b * b) / d;
          const xi = (b * oneMinus + onePlus * b) / d;
          return new Complex3(
            logHypot2(xr, xi) / 2,
            Math.atan2(xi, xr) / 2
          );
        },
        /**
         * Calculate the complex acoth
         *
         * @returns {Complex}
         */
        "acoth": function() {
          const a = this["re"];
          const b = this["im"];
          if (a === 0 && b === 0) {
            return new Complex3(0, Math.PI / 2);
          }
          const d = a * a + b * b;
          if (d !== 0) {
            return new Complex3(a / d, -b / d)["atanh"]();
          }
          return new Complex3(
            a !== 0 ? a / 0 : 0,
            b !== 0 ? -b / 0 : 0
          )["atanh"]();
        },
        /**
         * Calculate the complex acsch
         *
         * @returns {Complex}
         */
        "acsch": function() {
          const a = this["re"];
          const b = this["im"];
          if (b === 0) {
            if (a === 0) {
              return new Complex3(Infinity, 0);
            }
            const inv = 1 / a;
            return new Complex3(
              Math.log(inv + Math.sqrt(inv * inv + 1)),
              0
            );
          }
          const d = a * a + b * b;
          if (d !== 0) {
            return new Complex3(a / d, -b / d)["asinh"]();
          }
          return new Complex3(
            a !== 0 ? a / 0 : 0,
            b !== 0 ? -b / 0 : 0
          )["asinh"]();
        },
        /**
         * Calculate the complex asech
         *
         * @returns {Complex}
         */
        "asech": function() {
          const a = this["re"];
          const b = this["im"];
          if (this["isZero"]()) {
            return Complex3["INFINITY"];
          }
          const d = a * a + b * b;
          if (d !== 0) {
            return new Complex3(a / d, -b / d)["acosh"]();
          }
          return new Complex3(
            a !== 0 ? a / 0 : 0,
            b !== 0 ? -b / 0 : 0
          )["acosh"]();
        },
        /**
         * Calculate the complex inverse 1/z
         *
         * @returns {Complex}
         */
        "inverse": function() {
          if (this["isZero"]()) {
            return Complex3["INFINITY"];
          }
          if (this["isInfinite"]()) {
            return Complex3["ZERO"];
          }
          const a = this["re"];
          const b = this["im"];
          const d = a * a + b * b;
          return new Complex3(a / d, -b / d);
        },
        /**
         * Returns the complex conjugate
         *
         * @returns {Complex}
         */
        "conjugate": function() {
          return new Complex3(this["re"], -this["im"]);
        },
        /**
         * Gets the negated complex number
         *
         * @returns {Complex}
         */
        "neg": function() {
          return new Complex3(-this["re"], -this["im"]);
        },
        /**
         * Ceils the actual complex number
         *
         * @returns {Complex}
         */
        "ceil": function(places) {
          places = Math.pow(10, places || 0);
          return new Complex3(
            Math.ceil(this["re"] * places) / places,
            Math.ceil(this["im"] * places) / places
          );
        },
        /**
         * Floors the actual complex number
         *
         * @returns {Complex}
         */
        "floor": function(places) {
          places = Math.pow(10, places || 0);
          return new Complex3(
            Math.floor(this["re"] * places) / places,
            Math.floor(this["im"] * places) / places
          );
        },
        /**
         * Ceils the actual complex number
         *
         * @returns {Complex}
         */
        "round": function(places) {
          places = Math.pow(10, places || 0);
          return new Complex3(
            Math.round(this["re"] * places) / places,
            Math.round(this["im"] * places) / places
          );
        },
        /**
         * Compares two complex numbers
         *
         * **Note:** new Complex(Infinity).equals(Infinity) === false
         *
         * @returns {boolean}
         */
        "equals": function(a, b) {
          const z = parse2(a, b);
          return Math.abs(z["re"] - this["re"]) <= Complex3["EPSILON"] && Math.abs(z["im"] - this["im"]) <= Complex3["EPSILON"];
        },
        /**
         * Clones the actual object
         *
         * @returns {Complex}
         */
        "clone": function() {
          return new Complex3(this["re"], this["im"]);
        },
        /**
         * Gets a string of the actual complex number
         *
         * @returns {string}
         */
        "toString": function() {
          let a = this["re"];
          let b = this["im"];
          let ret = "";
          if (this["isNaN"]()) {
            return "NaN";
          }
          if (this["isInfinite"]()) {
            return "Infinity";
          }
          if (Math.abs(a) < Complex3["EPSILON"]) {
            a = 0;
          }
          if (Math.abs(b) < Complex3["EPSILON"]) {
            b = 0;
          }
          if (b === 0) {
            return ret + a;
          }
          if (a !== 0) {
            ret += a;
            ret += " ";
            if (b < 0) {
              b = -b;
              ret += "-";
            } else {
              ret += "+";
            }
            ret += " ";
          } else if (b < 0) {
            b = -b;
            ret += "-";
          }
          if (1 !== b) {
            ret += b;
          }
          return ret + "i";
        },
        /**
         * Returns the actual number as a vector
         *
         * @returns {Array}
         */
        "toVector": function() {
          return [this["re"], this["im"]];
        },
        /**
         * Returns the actual real value of the current object
         *
         * @returns {number|null}
         */
        "valueOf": function() {
          if (this["im"] === 0) {
            return this["re"];
          }
          return null;
        },
        /**
         * Determines whether a complex number is not on the Riemann sphere.
         *
         * @returns {boolean}
         */
        "isNaN": function() {
          return isNaN(this["re"]) || isNaN(this["im"]);
        },
        /**
         * Determines whether or not a complex number is at the zero pole of the
         * Riemann sphere.
         *
         * @returns {boolean}
         */
        "isZero": function() {
          return this["im"] === 0 && this["re"] === 0;
        },
        /**
         * Determines whether a complex number is not at the infinity pole of the
         * Riemann sphere.
         *
         * @returns {boolean}
         */
        "isFinite": function() {
          return isFinite(this["re"]) && isFinite(this["im"]);
        },
        /**
         * Determines whether or not a complex number is at the infinity pole of the
         * Riemann sphere.
         *
         * @returns {boolean}
         */
        "isInfinite": function() {
          return !this["isFinite"]();
        }
      };
      Complex3["ZERO"] = new Complex3(0, 0);
      Complex3["ONE"] = new Complex3(1, 0);
      Complex3["I"] = new Complex3(0, 1);
      Complex3["PI"] = new Complex3(Math.PI, 0);
      Complex3["E"] = new Complex3(Math.E, 0);
      Complex3["INFINITY"] = new Complex3(Infinity, Infinity);
      Complex3["NAN"] = new Complex3(NaN, NaN);
      Complex3["EPSILON"] = 1e-15;
      Object.defineProperty(Complex3, "__esModule", { "value": true });
      Complex3["default"] = Complex3;
      Complex3["Complex"] = Complex3;
      module["exports"] = Complex3;
    }
  });

  // node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/type/complex/Complex.js
  var require_Complex = __commonJS({
    "node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/type/complex/Complex.js"(exports) {
      "use strict";
      var _interopRequireDefault = require_interopRequireDefault();
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.createComplexClass = void 0;
      var _typeof2 = _interopRequireDefault(require_typeof());
      var _complex = _interopRequireDefault(require_complex());
      var _number = require_number();
      var _is = require_is();
      var _factory = require_factory();
      var name18 = "Complex";
      var dependencies19 = [];
      var createComplexClass2 = exports.createComplexClass = /* @__PURE__ */ (0, _factory.factory)(name18, dependencies19, function() {
        Object.defineProperty(_complex["default"], "name", {
          value: "Complex"
        });
        _complex["default"].prototype.constructor = _complex["default"];
        _complex["default"].prototype.type = "Complex";
        _complex["default"].prototype.isComplex = true;
        _complex["default"].prototype.toJSON = function() {
          return {
            mathjs: "Complex",
            re: this.re,
            im: this.im
          };
        };
        _complex["default"].prototype.toPolar = function() {
          return {
            r: this.abs(),
            phi: this.arg()
          };
        };
        _complex["default"].prototype.format = function(options) {
          var str = "";
          var im = this.im;
          var re = this.re;
          var strRe = (0, _number.format)(this.re, options);
          var strIm = (0, _number.format)(this.im, options);
          var precision = (0, _is.isNumber)(options) ? options : options ? options.precision : null;
          if (precision !== null) {
            var epsilon = Math.pow(10, -precision);
            if (Math.abs(re / im) < epsilon) {
              re = 0;
            }
            if (Math.abs(im / re) < epsilon) {
              im = 0;
            }
          }
          if (im === 0) {
            str = strRe;
          } else if (re === 0) {
            if (im === 1) {
              str = "i";
            } else if (im === -1) {
              str = "-i";
            } else {
              str = strIm + "i";
            }
          } else {
            if (im < 0) {
              if (im === -1) {
                str = strRe + " - i";
              } else {
                str = strRe + " - " + strIm.substring(1) + "i";
              }
            } else {
              if (im === 1) {
                str = strRe + " + i";
              } else {
                str = strRe + " + " + strIm + "i";
              }
            }
          }
          return str;
        };
        _complex["default"].fromPolar = function(args) {
          switch (arguments.length) {
            case 1: {
              var arg = arguments[0];
              if ((0, _typeof2["default"])(arg) === "object") {
                return (0, _complex["default"])(arg);
              } else {
                throw new TypeError("Input has to be an object with r and phi keys.");
              }
            }
            case 2: {
              var r = arguments[0];
              var phi = arguments[1];
              if ((0, _is.isNumber)(r)) {
                if ((0, _is.isUnit)(phi) && phi.hasBase("ANGLE")) {
                  phi = phi.toNumber("rad");
                }
                if ((0, _is.isNumber)(phi)) {
                  return new _complex["default"]({
                    r,
                    phi
                  });
                }
                throw new TypeError("Phi is not a number nor an angle unit.");
              } else {
                throw new TypeError("Radius r is not a number.");
              }
            }
            default:
              throw new SyntaxError("Wrong number of arguments in function fromPolar");
          }
        };
        _complex["default"].prototype.valueOf = _complex["default"].prototype.toString;
        _complex["default"].fromJSON = function(json) {
          return new _complex["default"](json);
        };
        _complex["default"].compare = function(a, b) {
          if (a.re > b.re) {
            return 1;
          }
          if (a.re < b.re) {
            return -1;
          }
          if (a.im > b.im) {
            return 1;
          }
          if (a.im < b.im) {
            return -1;
          }
          return 0;
        };
        return _complex["default"];
      }, {
        isClass: true
      });
    }
  });

  // node_modules/.pnpm/fraction.js@4.3.4/node_modules/fraction.js/fraction.js
  var require_fraction = __commonJS({
    "node_modules/.pnpm/fraction.js@4.3.4/node_modules/fraction.js/fraction.js"(exports, module) {
      (function(root) {
        "use strict";
        var MAX_CYCLE_LEN = 2e3;
        var P3 = {
          "s": 1,
          "n": 0,
          "d": 1
        };
        function assign(n, s) {
          if (isNaN(n = parseInt(n, 10))) {
            throw InvalidParameter();
          }
          return n * s;
        }
        function newFraction(n, d) {
          if (d === 0) {
            throw DivisionByZero();
          }
          var f = Object.create(Fraction3.prototype);
          f["s"] = n < 0 ? -1 : 1;
          n = n < 0 ? -n : n;
          var a = gcd(n, d);
          f["n"] = n / a;
          f["d"] = d / a;
          return f;
        }
        function factorize(num) {
          var factors = {};
          var n = num;
          var i = 2;
          var s = 4;
          while (s <= n) {
            while (n % i === 0) {
              n /= i;
              factors[i] = (factors[i] || 0) + 1;
            }
            s += 1 + 2 * i++;
          }
          if (n !== num) {
            if (n > 1)
              factors[n] = (factors[n] || 0) + 1;
          } else {
            factors[num] = (factors[num] || 0) + 1;
          }
          return factors;
        }
        var parse2 = function(p1, p2) {
          var n = 0, d = 1, s = 1;
          var v = 0, w = 0, x = 0, y = 1, z = 1;
          var A = 0, B = 1;
          var C = 1, D = 1;
          var N = 1e7;
          var M;
          if (p1 === void 0 || p1 === null) {
          } else if (p2 !== void 0) {
            n = p1;
            d = p2;
            s = n * d;
            if (n % 1 !== 0 || d % 1 !== 0) {
              throw NonIntegerParameter();
            }
          } else
            switch (typeof p1) {
              case "object": {
                if ("d" in p1 && "n" in p1) {
                  n = p1["n"];
                  d = p1["d"];
                  if ("s" in p1)
                    n *= p1["s"];
                } else if (0 in p1) {
                  n = p1[0];
                  if (1 in p1)
                    d = p1[1];
                } else {
                  throw InvalidParameter();
                }
                s = n * d;
                break;
              }
              case "number": {
                if (p1 < 0) {
                  s = p1;
                  p1 = -p1;
                }
                if (p1 % 1 === 0) {
                  n = p1;
                } else if (p1 > 0) {
                  if (p1 >= 1) {
                    z = Math.pow(10, Math.floor(1 + Math.log(p1) / Math.LN10));
                    p1 /= z;
                  }
                  while (B <= N && D <= N) {
                    M = (A + C) / (B + D);
                    if (p1 === M) {
                      if (B + D <= N) {
                        n = A + C;
                        d = B + D;
                      } else if (D > B) {
                        n = C;
                        d = D;
                      } else {
                        n = A;
                        d = B;
                      }
                      break;
                    } else {
                      if (p1 > M) {
                        A += C;
                        B += D;
                      } else {
                        C += A;
                        D += B;
                      }
                      if (B > N) {
                        n = C;
                        d = D;
                      } else {
                        n = A;
                        d = B;
                      }
                    }
                  }
                  n *= z;
                } else if (isNaN(p1) || isNaN(p2)) {
                  d = n = NaN;
                }
                break;
              }
              case "string": {
                B = p1.match(/\d+|./g);
                if (B === null)
                  throw InvalidParameter();
                if (B[A] === "-") {
                  s = -1;
                  A++;
                } else if (B[A] === "+") {
                  A++;
                }
                if (B.length === A + 1) {
                  w = assign(B[A++], s);
                } else if (B[A + 1] === "." || B[A] === ".") {
                  if (B[A] !== ".") {
                    v = assign(B[A++], s);
                  }
                  A++;
                  if (A + 1 === B.length || B[A + 1] === "(" && B[A + 3] === ")" || B[A + 1] === "'" && B[A + 3] === "'") {
                    w = assign(B[A], s);
                    y = Math.pow(10, B[A].length);
                    A++;
                  }
                  if (B[A] === "(" && B[A + 2] === ")" || B[A] === "'" && B[A + 2] === "'") {
                    x = assign(B[A + 1], s);
                    z = Math.pow(10, B[A + 1].length) - 1;
                    A += 3;
                  }
                } else if (B[A + 1] === "/" || B[A + 1] === ":") {
                  w = assign(B[A], s);
                  y = assign(B[A + 2], 1);
                  A += 3;
                } else if (B[A + 3] === "/" && B[A + 1] === " ") {
                  v = assign(B[A], s);
                  w = assign(B[A + 2], s);
                  y = assign(B[A + 4], 1);
                  A += 5;
                }
                if (B.length <= A) {
                  d = y * z;
                  s = /* void */
                  n = x + d * v + z * w;
                  break;
                }
              }
              default:
                throw InvalidParameter();
            }
          if (d === 0) {
            throw DivisionByZero();
          }
          P3["s"] = s < 0 ? -1 : 1;
          P3["n"] = Math.abs(n);
          P3["d"] = Math.abs(d);
        };
        function modpow(b, e, m) {
          var r = 1;
          for (; e > 0; b = b * b % m, e >>= 1) {
            if (e & 1) {
              r = r * b % m;
            }
          }
          return r;
        }
        function cycleLen(n, d) {
          for (; d % 2 === 0; d /= 2) {
          }
          for (; d % 5 === 0; d /= 5) {
          }
          if (d === 1)
            return 0;
          var rem = 10 % d;
          var t = 1;
          for (; rem !== 1; t++) {
            rem = rem * 10 % d;
            if (t > MAX_CYCLE_LEN)
              return 0;
          }
          return t;
        }
        function cycleStart(n, d, len) {
          var rem1 = 1;
          var rem2 = modpow(10, len, d);
          for (var t = 0; t < 300; t++) {
            if (rem1 === rem2)
              return t;
            rem1 = rem1 * 10 % d;
            rem2 = rem2 * 10 % d;
          }
          return 0;
        }
        function gcd(a, b) {
          if (!a)
            return b;
          if (!b)
            return a;
          while (1) {
            a %= b;
            if (!a)
              return b;
            b %= a;
            if (!b)
              return a;
          }
        }
        ;
        function Fraction3(a, b) {
          parse2(a, b);
          if (this instanceof Fraction3) {
            a = gcd(P3["d"], P3["n"]);
            this["s"] = P3["s"];
            this["n"] = P3["n"] / a;
            this["d"] = P3["d"] / a;
          } else {
            return newFraction(P3["s"] * P3["n"], P3["d"]);
          }
        }
        var DivisionByZero = function() {
          return new Error("Division by Zero");
        };
        var InvalidParameter = function() {
          return new Error("Invalid argument");
        };
        var NonIntegerParameter = function() {
          return new Error("Parameters must be integer");
        };
        Fraction3.prototype = {
          "s": 1,
          "n": 0,
          "d": 1,
          /**
           * Calculates the absolute value
           *
           * Ex: new Fraction(-4).abs() => 4
           **/
          "abs": function() {
            return newFraction(this["n"], this["d"]);
          },
          /**
           * Inverts the sign of the current fraction
           *
           * Ex: new Fraction(-4).neg() => 4
           **/
          "neg": function() {
            return newFraction(-this["s"] * this["n"], this["d"]);
          },
          /**
           * Adds two rational numbers
           *
           * Ex: new Fraction({n: 2, d: 3}).add("14.9") => 467 / 30
           **/
          "add": function(a, b) {
            parse2(a, b);
            return newFraction(
              this["s"] * this["n"] * P3["d"] + P3["s"] * this["d"] * P3["n"],
              this["d"] * P3["d"]
            );
          },
          /**
           * Subtracts two rational numbers
           *
           * Ex: new Fraction({n: 2, d: 3}).add("14.9") => -427 / 30
           **/
          "sub": function(a, b) {
            parse2(a, b);
            return newFraction(
              this["s"] * this["n"] * P3["d"] - P3["s"] * this["d"] * P3["n"],
              this["d"] * P3["d"]
            );
          },
          /**
           * Multiplies two rational numbers
           *
           * Ex: new Fraction("-17.(345)").mul(3) => 5776 / 111
           **/
          "mul": function(a, b) {
            parse2(a, b);
            return newFraction(
              this["s"] * P3["s"] * this["n"] * P3["n"],
              this["d"] * P3["d"]
            );
          },
          /**
           * Divides two rational numbers
           *
           * Ex: new Fraction("-17.(345)").inverse().div(3)
           **/
          "div": function(a, b) {
            parse2(a, b);
            return newFraction(
              this["s"] * P3["s"] * this["n"] * P3["d"],
              this["d"] * P3["n"]
            );
          },
          /**
           * Clones the actual object
           *
           * Ex: new Fraction("-17.(345)").clone()
           **/
          "clone": function() {
            return newFraction(this["s"] * this["n"], this["d"]);
          },
          /**
           * Calculates the modulo of two rational numbers - a more precise fmod
           *
           * Ex: new Fraction('4.(3)').mod([7, 8]) => (13/3) % (7/8) = (5/6)
           **/
          "mod": function(a, b) {
            if (isNaN(this["n"]) || isNaN(this["d"])) {
              return new Fraction3(NaN);
            }
            if (a === void 0) {
              return newFraction(this["s"] * this["n"] % this["d"], 1);
            }
            parse2(a, b);
            if (0 === P3["n"] && 0 === this["d"]) {
              throw DivisionByZero();
            }
            return newFraction(
              this["s"] * (P3["d"] * this["n"]) % (P3["n"] * this["d"]),
              P3["d"] * this["d"]
            );
          },
          /**
           * Calculates the fractional gcd of two rational numbers
           *
           * Ex: new Fraction(5,8).gcd(3,7) => 1/56
           */
          "gcd": function(a, b) {
            parse2(a, b);
            return newFraction(gcd(P3["n"], this["n"]) * gcd(P3["d"], this["d"]), P3["d"] * this["d"]);
          },
          /**
           * Calculates the fractional lcm of two rational numbers
           *
           * Ex: new Fraction(5,8).lcm(3,7) => 15
           */
          "lcm": function(a, b) {
            parse2(a, b);
            if (P3["n"] === 0 && this["n"] === 0) {
              return newFraction(0, 1);
            }
            return newFraction(P3["n"] * this["n"], gcd(P3["n"], this["n"]) * gcd(P3["d"], this["d"]));
          },
          /**
           * Calculates the ceil of a rational number
           *
           * Ex: new Fraction('4.(3)').ceil() => (5 / 1)
           **/
          "ceil": function(places) {
            places = Math.pow(10, places || 0);
            if (isNaN(this["n"]) || isNaN(this["d"])) {
              return new Fraction3(NaN);
            }
            return newFraction(Math.ceil(places * this["s"] * this["n"] / this["d"]), places);
          },
          /**
           * Calculates the floor of a rational number
           *
           * Ex: new Fraction('4.(3)').floor() => (4 / 1)
           **/
          "floor": function(places) {
            places = Math.pow(10, places || 0);
            if (isNaN(this["n"]) || isNaN(this["d"])) {
              return new Fraction3(NaN);
            }
            return newFraction(Math.floor(places * this["s"] * this["n"] / this["d"]), places);
          },
          /**
           * Rounds a rational numbers
           *
           * Ex: new Fraction('4.(3)').round() => (4 / 1)
           **/
          "round": function(places) {
            places = Math.pow(10, places || 0);
            if (isNaN(this["n"]) || isNaN(this["d"])) {
              return new Fraction3(NaN);
            }
            return newFraction(Math.round(places * this["s"] * this["n"] / this["d"]), places);
          },
          /**
           * Gets the inverse of the fraction, means numerator and denominator are exchanged
           *
           * Ex: new Fraction([-3, 4]).inverse() => -4 / 3
           **/
          "inverse": function() {
            return newFraction(this["s"] * this["d"], this["n"]);
          },
          /**
           * Calculates the fraction to some rational exponent, if possible
           *
           * Ex: new Fraction(-1,2).pow(-3) => -8
           */
          "pow": function(a, b) {
            parse2(a, b);
            if (P3["d"] === 1) {
              if (P3["s"] < 0) {
                return newFraction(Math.pow(this["s"] * this["d"], P3["n"]), Math.pow(this["n"], P3["n"]));
              } else {
                return newFraction(Math.pow(this["s"] * this["n"], P3["n"]), Math.pow(this["d"], P3["n"]));
              }
            }
            if (this["s"] < 0) return null;
            var N = factorize(this["n"]);
            var D = factorize(this["d"]);
            var n = 1;
            var d = 1;
            for (var k in N) {
              if (k === "1") continue;
              if (k === "0") {
                n = 0;
                break;
              }
              N[k] *= P3["n"];
              if (N[k] % P3["d"] === 0) {
                N[k] /= P3["d"];
              } else return null;
              n *= Math.pow(k, N[k]);
            }
            for (var k in D) {
              if (k === "1") continue;
              D[k] *= P3["n"];
              if (D[k] % P3["d"] === 0) {
                D[k] /= P3["d"];
              } else return null;
              d *= Math.pow(k, D[k]);
            }
            if (P3["s"] < 0) {
              return newFraction(d, n);
            }
            return newFraction(n, d);
          },
          /**
           * Check if two rational numbers are the same
           *
           * Ex: new Fraction(19.6).equals([98, 5]);
           **/
          "equals": function(a, b) {
            parse2(a, b);
            return this["s"] * this["n"] * P3["d"] === P3["s"] * P3["n"] * this["d"];
          },
          /**
           * Check if two rational numbers are the same
           *
           * Ex: new Fraction(19.6).equals([98, 5]);
           **/
          "compare": function(a, b) {
            parse2(a, b);
            var t = this["s"] * this["n"] * P3["d"] - P3["s"] * P3["n"] * this["d"];
            return (0 < t) - (t < 0);
          },
          "simplify": function(eps) {
            if (isNaN(this["n"]) || isNaN(this["d"])) {
              return this;
            }
            eps = eps || 1e-3;
            var thisABS = this["abs"]();
            var cont = thisABS["toContinued"]();
            for (var i = 1; i < cont.length; i++) {
              var s = newFraction(cont[i - 1], 1);
              for (var k = i - 2; k >= 0; k--) {
                s = s["inverse"]()["add"](cont[k]);
              }
              if (Math.abs(s["sub"](thisABS).valueOf()) < eps) {
                return s["mul"](this["s"]);
              }
            }
            return this;
          },
          /**
           * Check if two rational numbers are divisible
           *
           * Ex: new Fraction(19.6).divisible(1.5);
           */
          "divisible": function(a, b) {
            parse2(a, b);
            return !(!(P3["n"] * this["d"]) || this["n"] * P3["d"] % (P3["n"] * this["d"]));
          },
          /**
           * Returns a decimal representation of the fraction
           *
           * Ex: new Fraction("100.'91823'").valueOf() => 100.91823918239183
           **/
          "valueOf": function() {
            return this["s"] * this["n"] / this["d"];
          },
          /**
           * Returns a string-fraction representation of a Fraction object
           *
           * Ex: new Fraction("1.'3'").toFraction(true) => "4 1/3"
           **/
          "toFraction": function(excludeWhole) {
            var whole, str = "";
            var n = this["n"];
            var d = this["d"];
            if (this["s"] < 0) {
              str += "-";
            }
            if (d === 1) {
              str += n;
            } else {
              if (excludeWhole && (whole = Math.floor(n / d)) > 0) {
                str += whole;
                str += " ";
                n %= d;
              }
              str += n;
              str += "/";
              str += d;
            }
            return str;
          },
          /**
           * Returns a latex representation of a Fraction object
           *
           * Ex: new Fraction("1.'3'").toLatex() => "\frac{4}{3}"
           **/
          "toLatex": function(excludeWhole) {
            var whole, str = "";
            var n = this["n"];
            var d = this["d"];
            if (this["s"] < 0) {
              str += "-";
            }
            if (d === 1) {
              str += n;
            } else {
              if (excludeWhole && (whole = Math.floor(n / d)) > 0) {
                str += whole;
                n %= d;
              }
              str += "\\frac{";
              str += n;
              str += "}{";
              str += d;
              str += "}";
            }
            return str;
          },
          /**
           * Returns an array of continued fraction elements
           *
           * Ex: new Fraction("7/8").toContinued() => [0,1,7]
           */
          "toContinued": function() {
            var t;
            var a = this["n"];
            var b = this["d"];
            var res = [];
            if (isNaN(a) || isNaN(b)) {
              return res;
            }
            do {
              res.push(Math.floor(a / b));
              t = a % b;
              a = b;
              b = t;
            } while (a !== 1);
            return res;
          },
          /**
           * Creates a string representation of a fraction with all digits
           *
           * Ex: new Fraction("100.'91823'").toString() => "100.(91823)"
           **/
          "toString": function(dec) {
            var N = this["n"];
            var D = this["d"];
            if (isNaN(N) || isNaN(D)) {
              return "NaN";
            }
            dec = dec || 15;
            var cycLen = cycleLen(N, D);
            var cycOff = cycleStart(N, D, cycLen);
            var str = this["s"] < 0 ? "-" : "";
            str += N / D | 0;
            N %= D;
            N *= 10;
            if (N)
              str += ".";
            if (cycLen) {
              for (var i = cycOff; i--; ) {
                str += N / D | 0;
                N %= D;
                N *= 10;
              }
              str += "(";
              for (var i = cycLen; i--; ) {
                str += N / D | 0;
                N %= D;
                N *= 10;
              }
              str += ")";
            } else {
              for (var i = dec; N && i--; ) {
                str += N / D | 0;
                N %= D;
                N *= 10;
              }
            }
            return str;
          }
        };
        if (typeof exports === "object") {
          Object.defineProperty(Fraction3, "__esModule", { "value": true });
          Fraction3["default"] = Fraction3;
          Fraction3["Fraction"] = Fraction3;
          module["exports"] = Fraction3;
        } else {
          root["Fraction"] = Fraction3;
        }
      })(exports);
    }
  });

  // node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/type/fraction/Fraction.js
  var require_Fraction = __commonJS({
    "node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/type/fraction/Fraction.js"(exports) {
      "use strict";
      var _interopRequireDefault = require_interopRequireDefault();
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.createFractionClass = void 0;
      var _fraction = _interopRequireDefault(require_fraction());
      var _factory = require_factory();
      var name18 = "Fraction";
      var dependencies19 = [];
      var createFractionClass2 = exports.createFractionClass = /* @__PURE__ */ (0, _factory.factory)(name18, dependencies19, function() {
        Object.defineProperty(_fraction["default"], "name", {
          value: "Fraction"
        });
        _fraction["default"].prototype.constructor = _fraction["default"];
        _fraction["default"].prototype.type = "Fraction";
        _fraction["default"].prototype.isFraction = true;
        _fraction["default"].prototype.toJSON = function() {
          return {
            mathjs: "Fraction",
            n: this.s * this.n,
            d: this.d
          };
        };
        _fraction["default"].fromJSON = function(json) {
          return new _fraction["default"](json);
        };
        return _fraction["default"];
      }, {
        isClass: true
      });
    }
  });

  // node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/type/matrix/Range.js
  var require_Range = __commonJS({
    "node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/type/matrix/Range.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.createRangeClass = void 0;
      var _is = require_is();
      var _number = require_number();
      var _factory = require_factory();
      var name18 = "Range";
      var dependencies19 = [];
      var createRangeClass2 = exports.createRangeClass = /* @__PURE__ */ (0, _factory.factory)(name18, dependencies19, function() {
        function Range(start, end, step) {
          if (!(this instanceof Range)) {
            throw new SyntaxError("Constructor must be called with the new operator");
          }
          var hasStart = start !== null && start !== void 0;
          var hasEnd = end !== null && end !== void 0;
          var hasStep = step !== null && step !== void 0;
          if (hasStart) {
            if ((0, _is.isBigNumber)(start)) {
              start = start.toNumber();
            } else if (typeof start !== "number") {
              throw new TypeError("Parameter start must be a number");
            }
          }
          if (hasEnd) {
            if ((0, _is.isBigNumber)(end)) {
              end = end.toNumber();
            } else if (typeof end !== "number") {
              throw new TypeError("Parameter end must be a number");
            }
          }
          if (hasStep) {
            if ((0, _is.isBigNumber)(step)) {
              step = step.toNumber();
            } else if (typeof step !== "number") {
              throw new TypeError("Parameter step must be a number");
            }
          }
          this.start = hasStart ? parseFloat(start) : 0;
          this.end = hasEnd ? parseFloat(end) : 0;
          this.step = hasStep ? parseFloat(step) : 1;
        }
        Range.prototype.type = "Range";
        Range.prototype.isRange = true;
        Range.parse = function(str) {
          if (typeof str !== "string") {
            return null;
          }
          var args = str.split(":");
          var nums = args.map(function(arg) {
            return parseFloat(arg);
          });
          var invalid = nums.some(function(num) {
            return isNaN(num);
          });
          if (invalid) {
            return null;
          }
          switch (nums.length) {
            case 2:
              return new Range(nums[0], nums[1]);
            case 3:
              return new Range(nums[0], nums[2], nums[1]);
            default:
              return null;
          }
        };
        Range.prototype.clone = function() {
          return new Range(this.start, this.end, this.step);
        };
        Range.prototype.size = function() {
          var len = 0;
          var start = this.start;
          var step = this.step;
          var end = this.end;
          var diff = end - start;
          if ((0, _number.sign)(step) === (0, _number.sign)(diff)) {
            len = Math.ceil(diff / step);
          } else if (diff === 0) {
            len = 0;
          }
          if (isNaN(len)) {
            len = 0;
          }
          return [len];
        };
        Range.prototype.min = function() {
          var size2 = this.size()[0];
          if (size2 > 0) {
            if (this.step > 0) {
              return this.start;
            } else {
              return this.start + (size2 - 1) * this.step;
            }
          } else {
            return void 0;
          }
        };
        Range.prototype.max = function() {
          var size2 = this.size()[0];
          if (size2 > 0) {
            if (this.step > 0) {
              return this.start + (size2 - 1) * this.step;
            } else {
              return this.start;
            }
          } else {
            return void 0;
          }
        };
        Range.prototype.forEach = function(callback) {
          var x = this.start;
          var step = this.step;
          var end = this.end;
          var i = 0;
          if (step > 0) {
            while (x < end) {
              callback(x, [i], this);
              x += step;
              i++;
            }
          } else if (step < 0) {
            while (x > end) {
              callback(x, [i], this);
              x += step;
              i++;
            }
          }
        };
        Range.prototype.map = function(callback) {
          var array = [];
          this.forEach(function(value, index, obj) {
            array[index[0]] = callback(value, index, obj);
          });
          return array;
        };
        Range.prototype.toArray = function() {
          var array = [];
          this.forEach(function(value, index) {
            array[index[0]] = value;
          });
          return array;
        };
        Range.prototype.valueOf = function() {
          return this.toArray();
        };
        Range.prototype.format = function(options) {
          var str = (0, _number.format)(this.start, options);
          if (this.step !== 1) {
            str += ":" + (0, _number.format)(this.step, options);
          }
          str += ":" + (0, _number.format)(this.end, options);
          return str;
        };
        Range.prototype.toString = function() {
          return this.format();
        };
        Range.prototype.toJSON = function() {
          return {
            mathjs: "Range",
            start: this.start,
            end: this.end,
            step: this.step
          };
        };
        Range.fromJSON = function(json) {
          return new Range(json.start, json.end, json.step);
        };
        return Range;
      }, {
        isClass: true
      });
    }
  });

  // node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/type/matrix/Matrix.js
  var require_Matrix = __commonJS({
    "node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/type/matrix/Matrix.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.createMatrixClass = void 0;
      var _factory = require_factory();
      var name18 = "Matrix";
      var dependencies19 = [];
      var createMatrixClass2 = exports.createMatrixClass = /* @__PURE__ */ (0, _factory.factory)(name18, dependencies19, function() {
        function Matrix2() {
          if (!(this instanceof Matrix2)) {
            throw new SyntaxError("Constructor must be called with the new operator");
          }
        }
        Matrix2.prototype.type = "Matrix";
        Matrix2.prototype.isMatrix = true;
        Matrix2.prototype.storage = function() {
          throw new Error("Cannot invoke storage on a Matrix interface");
        };
        Matrix2.prototype.datatype = function() {
          throw new Error("Cannot invoke datatype on a Matrix interface");
        };
        Matrix2.prototype.create = function(data, datatype) {
          throw new Error("Cannot invoke create on a Matrix interface");
        };
        Matrix2.prototype.subset = function(index, replacement, defaultValue) {
          throw new Error("Cannot invoke subset on a Matrix interface");
        };
        Matrix2.prototype.get = function(index) {
          throw new Error("Cannot invoke get on a Matrix interface");
        };
        Matrix2.prototype.set = function(index, value, defaultValue) {
          throw new Error("Cannot invoke set on a Matrix interface");
        };
        Matrix2.prototype.resize = function(size2, defaultValue) {
          throw new Error("Cannot invoke resize on a Matrix interface");
        };
        Matrix2.prototype.reshape = function(size2, defaultValue) {
          throw new Error("Cannot invoke reshape on a Matrix interface");
        };
        Matrix2.prototype.clone = function() {
          throw new Error("Cannot invoke clone on a Matrix interface");
        };
        Matrix2.prototype.size = function() {
          throw new Error("Cannot invoke size on a Matrix interface");
        };
        Matrix2.prototype.map = function(callback, skipZeros) {
          throw new Error("Cannot invoke map on a Matrix interface");
        };
        Matrix2.prototype.forEach = function(callback) {
          throw new Error("Cannot invoke forEach on a Matrix interface");
        };
        Matrix2.prototype[Symbol.iterator] = function() {
          throw new Error("Cannot iterate a Matrix interface");
        };
        Matrix2.prototype.toArray = function() {
          throw new Error("Cannot invoke toArray on a Matrix interface");
        };
        Matrix2.prototype.valueOf = function() {
          throw new Error("Cannot invoke valueOf on a Matrix interface");
        };
        Matrix2.prototype.format = function(options) {
          throw new Error("Cannot invoke format on a Matrix interface");
        };
        Matrix2.prototype.toString = function() {
          throw new Error("Cannot invoke toString on a Matrix interface");
        };
        return Matrix2;
      }, {
        isClass: true
      });
    }
  });

  // node_modules/.pnpm/@babel+runtime@7.28.4/node_modules/@babel/runtime/helpers/OverloadYield.js
  var require_OverloadYield = __commonJS({
    "node_modules/.pnpm/@babel+runtime@7.28.4/node_modules/@babel/runtime/helpers/OverloadYield.js"(exports, module) {
      function _OverloadYield(e, d) {
        this.v = e, this.k = d;
      }
      module.exports = _OverloadYield, module.exports.__esModule = true, module.exports["default"] = module.exports;
    }
  });

  // node_modules/.pnpm/@babel+runtime@7.28.4/node_modules/@babel/runtime/helpers/regeneratorDefine.js
  var require_regeneratorDefine = __commonJS({
    "node_modules/.pnpm/@babel+runtime@7.28.4/node_modules/@babel/runtime/helpers/regeneratorDefine.js"(exports, module) {
      function _regeneratorDefine(e, r, n, t) {
        var i = Object.defineProperty;
        try {
          i({}, "", {});
        } catch (e2) {
          i = 0;
        }
        module.exports = _regeneratorDefine = function regeneratorDefine(e2, r2, n3, t2) {
          function o(r3, n4) {
            _regeneratorDefine(e2, r3, function(e3) {
              return this._invoke(r3, n4, e3);
            });
          }
          r2 ? i ? i(e2, r2, {
            value: n3,
            enumerable: !t2,
            configurable: !t2,
            writable: !t2
          }) : e2[r2] = n3 : (o("next", 0), o("throw", 1), o("return", 2));
        }, module.exports.__esModule = true, module.exports["default"] = module.exports, _regeneratorDefine(e, r, n, t);
      }
      module.exports = _regeneratorDefine, module.exports.__esModule = true, module.exports["default"] = module.exports;
    }
  });

  // node_modules/.pnpm/@babel+runtime@7.28.4/node_modules/@babel/runtime/helpers/regenerator.js
  var require_regenerator = __commonJS({
    "node_modules/.pnpm/@babel+runtime@7.28.4/node_modules/@babel/runtime/helpers/regenerator.js"(exports, module) {
      var regeneratorDefine = require_regeneratorDefine();
      function _regenerator() {
        var e, t, r = "function" == typeof Symbol ? Symbol : {}, n = r.iterator || "@@iterator", o = r.toStringTag || "@@toStringTag";
        function i(r2, n3, o2, i2) {
          var c2 = n3 && n3.prototype instanceof Generator ? n3 : Generator, u2 = Object.create(c2.prototype);
          return regeneratorDefine(u2, "_invoke", (function(r3, n4, o3) {
            var i3, c3, u3, f2 = 0, p = o3 || [], y = false, G = {
              p: 0,
              n: 0,
              v: e,
              a: d,
              f: d.bind(e, 4),
              d: function d2(t2, r4) {
                return i3 = t2, c3 = 0, u3 = e, G.n = r4, a;
              }
            };
            function d(r4, n5) {
              for (c3 = r4, u3 = n5, t = 0; !y && f2 && !o4 && t < p.length; t++) {
                var o4, i4 = p[t], d2 = G.p, l = i4[2];
                r4 > 3 ? (o4 = l === n5) && (u3 = i4[(c3 = i4[4]) ? 5 : (c3 = 3, 3)], i4[4] = i4[5] = e) : i4[0] <= d2 && ((o4 = r4 < 2 && d2 < i4[1]) ? (c3 = 0, G.v = n5, G.n = i4[1]) : d2 < l && (o4 = r4 < 3 || i4[0] > n5 || n5 > l) && (i4[4] = r4, i4[5] = n5, G.n = l, c3 = 0));
              }
              if (o4 || r4 > 1) return a;
              throw y = true, n5;
            }
            return function(o4, p2, l) {
              if (f2 > 1) throw TypeError("Generator is already running");
              for (y && 1 === p2 && d(p2, l), c3 = p2, u3 = l; (t = c3 < 2 ? e : u3) || !y; ) {
                i3 || (c3 ? c3 < 3 ? (c3 > 1 && (G.n = -1), d(c3, u3)) : G.n = u3 : G.v = u3);
                try {
                  if (f2 = 2, i3) {
                    if (c3 || (o4 = "next"), t = i3[o4]) {
                      if (!(t = t.call(i3, u3))) throw TypeError("iterator result is not an object");
                      if (!t.done) return t;
                      u3 = t.value, c3 < 2 && (c3 = 0);
                    } else 1 === c3 && (t = i3["return"]) && t.call(i3), c3 < 2 && (u3 = TypeError("The iterator does not provide a '" + o4 + "' method"), c3 = 1);
                    i3 = e;
                  } else if ((t = (y = G.n < 0) ? u3 : r3.call(n4, G)) !== a) break;
                } catch (t2) {
                  i3 = e, c3 = 1, u3 = t2;
                } finally {
                  f2 = 1;
                }
              }
              return {
                value: t,
                done: y
              };
            };
          })(r2, o2, i2), true), u2;
        }
        var a = {};
        function Generator() {
        }
        function GeneratorFunction() {
        }
        function GeneratorFunctionPrototype() {
        }
        t = Object.getPrototypeOf;
        var c = [][n] ? t(t([][n]())) : (regeneratorDefine(t = {}, n, function() {
          return this;
        }), t), u = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(c);
        function f(e2) {
          return Object.setPrototypeOf ? Object.setPrototypeOf(e2, GeneratorFunctionPrototype) : (e2.__proto__ = GeneratorFunctionPrototype, regeneratorDefine(e2, o, "GeneratorFunction")), e2.prototype = Object.create(u), e2;
        }
        return GeneratorFunction.prototype = GeneratorFunctionPrototype, regeneratorDefine(u, "constructor", GeneratorFunctionPrototype), regeneratorDefine(GeneratorFunctionPrototype, "constructor", GeneratorFunction), GeneratorFunction.displayName = "GeneratorFunction", regeneratorDefine(GeneratorFunctionPrototype, o, "GeneratorFunction"), regeneratorDefine(u), regeneratorDefine(u, o, "Generator"), regeneratorDefine(u, n, function() {
          return this;
        }), regeneratorDefine(u, "toString", function() {
          return "[object Generator]";
        }), (module.exports = _regenerator = function _regenerator2() {
          return {
            w: i,
            m: f
          };
        }, module.exports.__esModule = true, module.exports["default"] = module.exports)();
      }
      module.exports = _regenerator, module.exports.__esModule = true, module.exports["default"] = module.exports;
    }
  });

  // node_modules/.pnpm/@babel+runtime@7.28.4/node_modules/@babel/runtime/helpers/regeneratorAsyncIterator.js
  var require_regeneratorAsyncIterator = __commonJS({
    "node_modules/.pnpm/@babel+runtime@7.28.4/node_modules/@babel/runtime/helpers/regeneratorAsyncIterator.js"(exports, module) {
      var OverloadYield = require_OverloadYield();
      var regeneratorDefine = require_regeneratorDefine();
      function AsyncIterator(t, e) {
        function n(r2, o, i, f) {
          try {
            var c = t[r2](o), u = c.value;
            return u instanceof OverloadYield ? e.resolve(u.v).then(function(t2) {
              n("next", t2, i, f);
            }, function(t2) {
              n("throw", t2, i, f);
            }) : e.resolve(u).then(function(t2) {
              c.value = t2, i(c);
            }, function(t2) {
              return n("throw", t2, i, f);
            });
          } catch (t2) {
            f(t2);
          }
        }
        var r;
        this.next || (regeneratorDefine(AsyncIterator.prototype), regeneratorDefine(AsyncIterator.prototype, "function" == typeof Symbol && Symbol.asyncIterator || "@asyncIterator", function() {
          return this;
        })), regeneratorDefine(this, "_invoke", function(t2, o, i) {
          function f() {
            return new e(function(e2, r2) {
              n(t2, i, e2, r2);
            });
          }
          return r = r ? r.then(f, f) : f();
        }, true);
      }
      module.exports = AsyncIterator, module.exports.__esModule = true, module.exports["default"] = module.exports;
    }
  });

  // node_modules/.pnpm/@babel+runtime@7.28.4/node_modules/@babel/runtime/helpers/regeneratorAsyncGen.js
  var require_regeneratorAsyncGen = __commonJS({
    "node_modules/.pnpm/@babel+runtime@7.28.4/node_modules/@babel/runtime/helpers/regeneratorAsyncGen.js"(exports, module) {
      var regenerator = require_regenerator();
      var regeneratorAsyncIterator = require_regeneratorAsyncIterator();
      function _regeneratorAsyncGen(r, e, t, o, n) {
        return new regeneratorAsyncIterator(regenerator().w(r, e, t, o), n || Promise);
      }
      module.exports = _regeneratorAsyncGen, module.exports.__esModule = true, module.exports["default"] = module.exports;
    }
  });

  // node_modules/.pnpm/@babel+runtime@7.28.4/node_modules/@babel/runtime/helpers/regeneratorAsync.js
  var require_regeneratorAsync = __commonJS({
    "node_modules/.pnpm/@babel+runtime@7.28.4/node_modules/@babel/runtime/helpers/regeneratorAsync.js"(exports, module) {
      var regeneratorAsyncGen = require_regeneratorAsyncGen();
      function _regeneratorAsync(n, e, r, t, o) {
        var a = regeneratorAsyncGen(n, e, r, t, o);
        return a.next().then(function(n3) {
          return n3.done ? n3.value : a.next();
        });
      }
      module.exports = _regeneratorAsync, module.exports.__esModule = true, module.exports["default"] = module.exports;
    }
  });

  // node_modules/.pnpm/@babel+runtime@7.28.4/node_modules/@babel/runtime/helpers/regeneratorKeys.js
  var require_regeneratorKeys = __commonJS({
    "node_modules/.pnpm/@babel+runtime@7.28.4/node_modules/@babel/runtime/helpers/regeneratorKeys.js"(exports, module) {
      function _regeneratorKeys(e) {
        var n = Object(e), r = [];
        for (var t in n) r.unshift(t);
        return function e2() {
          for (; r.length; ) if ((t = r.pop()) in n) return e2.value = t, e2.done = false, e2;
          return e2.done = true, e2;
        };
      }
      module.exports = _regeneratorKeys, module.exports.__esModule = true, module.exports["default"] = module.exports;
    }
  });

  // node_modules/.pnpm/@babel+runtime@7.28.4/node_modules/@babel/runtime/helpers/regeneratorValues.js
  var require_regeneratorValues = __commonJS({
    "node_modules/.pnpm/@babel+runtime@7.28.4/node_modules/@babel/runtime/helpers/regeneratorValues.js"(exports, module) {
      var _typeof = require_typeof()["default"];
      function _regeneratorValues(e) {
        if (null != e) {
          var t = e["function" == typeof Symbol && Symbol.iterator || "@@iterator"], r = 0;
          if (t) return t.call(e);
          if ("function" == typeof e.next) return e;
          if (!isNaN(e.length)) return {
            next: function next() {
              return e && r >= e.length && (e = void 0), {
                value: e && e[r++],
                done: !e
              };
            }
          };
        }
        throw new TypeError(_typeof(e) + " is not iterable");
      }
      module.exports = _regeneratorValues, module.exports.__esModule = true, module.exports["default"] = module.exports;
    }
  });

  // node_modules/.pnpm/@babel+runtime@7.28.4/node_modules/@babel/runtime/helpers/regeneratorRuntime.js
  var require_regeneratorRuntime = __commonJS({
    "node_modules/.pnpm/@babel+runtime@7.28.4/node_modules/@babel/runtime/helpers/regeneratorRuntime.js"(exports, module) {
      var OverloadYield = require_OverloadYield();
      var regenerator = require_regenerator();
      var regeneratorAsync = require_regeneratorAsync();
      var regeneratorAsyncGen = require_regeneratorAsyncGen();
      var regeneratorAsyncIterator = require_regeneratorAsyncIterator();
      var regeneratorKeys = require_regeneratorKeys();
      var regeneratorValues = require_regeneratorValues();
      function _regeneratorRuntime() {
        "use strict";
        var r = regenerator(), e = r.m(_regeneratorRuntime), t = (Object.getPrototypeOf ? Object.getPrototypeOf(e) : e.__proto__).constructor;
        function n(r2) {
          var e2 = "function" == typeof r2 && r2.constructor;
          return !!e2 && (e2 === t || "GeneratorFunction" === (e2.displayName || e2.name));
        }
        var o = {
          "throw": 1,
          "return": 2,
          "break": 3,
          "continue": 3
        };
        function a(r2) {
          var e2, t2;
          return function(n3) {
            e2 || (e2 = {
              stop: function stop() {
                return t2(n3.a, 2);
              },
              "catch": function _catch() {
                return n3.v;
              },
              abrupt: function abrupt(r3, e3) {
                return t2(n3.a, o[r3], e3);
              },
              delegateYield: function delegateYield(r3, o2, a2) {
                return e2.resultName = o2, t2(n3.d, regeneratorValues(r3), a2);
              },
              finish: function finish(r3) {
                return t2(n3.f, r3);
              }
            }, t2 = function t3(r3, _t, o2) {
              n3.p = e2.prev, n3.n = e2.next;
              try {
                return r3(_t, o2);
              } finally {
                e2.next = n3.n;
              }
            }), e2.resultName && (e2[e2.resultName] = n3.v, e2.resultName = void 0), e2.sent = n3.v, e2.next = n3.n;
            try {
              return r2.call(this, e2);
            } finally {
              n3.p = e2.prev, n3.n = e2.next;
            }
          };
        }
        return (module.exports = _regeneratorRuntime = function _regeneratorRuntime2() {
          return {
            wrap: function wrap(e2, t2, n3, o2) {
              return r.w(a(e2), t2, n3, o2 && o2.reverse());
            },
            isGeneratorFunction: n,
            mark: r.m,
            awrap: function awrap(r2, e2) {
              return new OverloadYield(r2, e2);
            },
            AsyncIterator: regeneratorAsyncIterator,
            async: function async(r2, e2, t2, o2, u) {
              return (n(e2) ? regeneratorAsyncGen : regeneratorAsync)(a(r2), e2, t2, o2, u);
            },
            keys: regeneratorKeys,
            values: regeneratorValues
          };
        }, module.exports.__esModule = true, module.exports["default"] = module.exports)();
      }
      module.exports = _regeneratorRuntime, module.exports.__esModule = true, module.exports["default"] = module.exports;
    }
  });

  // node_modules/.pnpm/@babel+runtime@7.28.4/node_modules/@babel/runtime/regenerator/index.js
  var require_regenerator2 = __commonJS({
    "node_modules/.pnpm/@babel+runtime@7.28.4/node_modules/@babel/runtime/regenerator/index.js"(exports, module) {
      var runtime = require_regeneratorRuntime()();
      module.exports = runtime;
      try {
        regeneratorRuntime = runtime;
      } catch (accidentalStrictMode) {
        if (typeof globalThis === "object") {
          globalThis.regeneratorRuntime = runtime;
        } else {
          Function("r", "regeneratorRuntime = r")(runtime);
        }
      }
    }
  });

  // node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/utils/bignumber/formatter.js
  var require_formatter = __commonJS({
    "node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/utils/bignumber/formatter.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.format = format4;
      exports.toEngineering = toEngineering3;
      exports.toExponential = toExponential3;
      exports.toFixed = toFixed3;
      var _is = require_is();
      var _number = require_number();
      function formatBigNumberToBase2(n, base, size2) {
        var BigNumberCtor = n.constructor;
        var big2 = new BigNumberCtor(2);
        var suffix = "";
        if (size2) {
          if (size2 < 1) {
            throw new Error("size must be in greater than 0");
          }
          if (!(0, _number.isInteger)(size2)) {
            throw new Error("size must be an integer");
          }
          if (n.greaterThan(big2.pow(size2 - 1).sub(1)) || n.lessThan(big2.pow(size2 - 1).mul(-1))) {
            throw new Error("Value must be in range [-2^".concat(size2 - 1, ", 2^").concat(size2 - 1, "-1]"));
          }
          if (!n.isInteger()) {
            throw new Error("Value must be an integer");
          }
          if (n.lessThan(0)) {
            n = n.add(big2.pow(size2));
          }
          suffix = "i".concat(size2);
        }
        switch (base) {
          case 2:
            return "".concat(n.toBinary()).concat(suffix);
          case 8:
            return "".concat(n.toOctal()).concat(suffix);
          case 16:
            return "".concat(n.toHexadecimal()).concat(suffix);
          default:
            throw new Error("Base ".concat(base, " not supported "));
        }
      }
      function format4(value, options) {
        if (typeof options === "function") {
          return options(value);
        }
        if (!value.isFinite()) {
          return value.isNaN() ? "NaN" : value.gt(0) ? "Infinity" : "-Infinity";
        }
        var _normalizeFormatOptio = (0, _number.normalizeFormatOptions)(options), notation = _normalizeFormatOptio.notation, precision = _normalizeFormatOptio.precision, wordSize = _normalizeFormatOptio.wordSize;
        switch (notation) {
          case "fixed":
            return toFixed3(value, precision);
          case "exponential":
            return toExponential3(value, precision);
          case "engineering":
            return toEngineering3(value, precision);
          case "bin":
            return formatBigNumberToBase2(value, 2, wordSize);
          case "oct":
            return formatBigNumberToBase2(value, 8, wordSize);
          case "hex":
            return formatBigNumberToBase2(value, 16, wordSize);
          case "auto": {
            var lowerExp = _toNumberOrDefault3(options === null || options === void 0 ? void 0 : options.lowerExp, -3);
            var upperExp = _toNumberOrDefault3(options === null || options === void 0 ? void 0 : options.upperExp, 5);
            if (value.isZero()) return "0";
            var str;
            var rounded = value.toSignificantDigits(precision);
            var exp2 = rounded.e;
            if (exp2 >= lowerExp && exp2 < upperExp) {
              str = rounded.toFixed();
            } else {
              str = toExponential3(value, precision);
            }
            return str.replace(/((\.\d*?)(0+))($|e)/, function() {
              var digits2 = arguments[2];
              var e = arguments[4];
              return digits2 !== "." ? digits2 + e : e;
            });
          }
          default:
            throw new Error('Unknown notation "' + notation + '". Choose "auto", "exponential", "fixed", "bin", "oct", or "hex.');
        }
      }
      function toEngineering3(value, precision) {
        var e = value.e;
        var newExp = e % 3 === 0 ? e : e < 0 ? e - 3 - e % 3 : e - e % 3;
        var valueWithoutExp = value.mul(Math.pow(10, -newExp));
        var valueStr = valueWithoutExp.toPrecision(precision);
        if (valueStr.includes("e")) {
          var BigNumber2 = value.constructor;
          valueStr = new BigNumber2(valueStr).toFixed();
        }
        return valueStr + "e" + (e >= 0 ? "+" : "") + newExp.toString();
      }
      function toExponential3(value, precision) {
        if (precision !== void 0) {
          return value.toExponential(precision - 1);
        } else {
          return value.toExponential();
        }
      }
      function toFixed3(value, precision) {
        return value.toFixed(precision);
      }
      function _toNumberOrDefault3(value, defaultValue) {
        if ((0, _is.isNumber)(value)) {
          return value;
        } else if ((0, _is.isBigNumber)(value)) {
          return value.toNumber();
        } else {
          return defaultValue;
        }
      }
    }
  });

  // node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/utils/string.js
  var require_string = __commonJS({
    "node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/utils/string.js"(exports) {
      "use strict";
      var _interopRequireDefault = require_interopRequireDefault();
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.compareText = compareText;
      exports.endsWith = endsWith;
      exports.escape = escape;
      exports.format = format4;
      exports.stringify = stringify2;
      var _typeof2 = _interopRequireDefault(require_typeof());
      var _is = require_is();
      var _number = require_number();
      var _formatter = require_formatter();
      function endsWith(text, search) {
        var start = text.length - search.length;
        var end = text.length;
        return text.substring(start, end) === search;
      }
      function format4(value, options) {
        var result = _format2(value, options);
        if (options && (0, _typeof2["default"])(options) === "object" && "truncate" in options && result.length > options.truncate) {
          return result.substring(0, options.truncate - 3) + "...";
        }
        return result;
      }
      function _format2(value, options) {
        if (typeof value === "number") {
          return (0, _number.format)(value, options);
        }
        if ((0, _is.isBigNumber)(value)) {
          return (0, _formatter.format)(value, options);
        }
        if (looksLikeFraction2(value)) {
          if (!options || options.fraction !== "decimal") {
            return value.s * value.n + "/" + value.d;
          } else {
            return value.toString();
          }
        }
        if (Array.isArray(value)) {
          return formatArray2(value, options);
        }
        if ((0, _is.isString)(value)) {
          return stringify2(value);
        }
        if (typeof value === "function") {
          return value.syntax ? String(value.syntax) : "function";
        }
        if (value && (0, _typeof2["default"])(value) === "object") {
          if (typeof value.format === "function") {
            return value.format(options);
          } else if (value && value.toString(options) !== {}.toString()) {
            return value.toString(options);
          } else {
            var entries = Object.keys(value).map(function(key) {
              return stringify2(key) + ": " + format4(value[key], options);
            });
            return "{" + entries.join(", ") + "}";
          }
        }
        return String(value);
      }
      function stringify2(value) {
        var text = String(value);
        var escaped = "";
        var i = 0;
        while (i < text.length) {
          var c = text.charAt(i);
          escaped += c in controlCharacters2 ? controlCharacters2[c] : c;
          i++;
        }
        return '"' + escaped + '"';
      }
      var controlCharacters2 = {
        '"': '\\"',
        "\\": "\\\\",
        "\b": "\\b",
        "\f": "\\f",
        "\n": "\\n",
        "\r": "\\r",
        "	": "\\t"
      };
      function escape(value) {
        var text = String(value);
        text = text.replace(/&/g, "&amp;").replace(/"/g, "&quot;").replace(/'/g, "&#39;").replace(/</g, "&lt;").replace(/>/g, "&gt;");
        return text;
      }
      function formatArray2(array, options) {
        if (Array.isArray(array)) {
          var str = "[";
          var len = array.length;
          for (var i = 0; i < len; i++) {
            if (i !== 0) {
              str += ", ";
            }
            str += formatArray2(array[i], options);
          }
          str += "]";
          return str;
        } else {
          return format4(array, options);
        }
      }
      function looksLikeFraction2(value) {
        return value && (0, _typeof2["default"])(value) === "object" && typeof value.s === "number" && typeof value.n === "number" && typeof value.d === "number" || false;
      }
      function compareText(x, y) {
        if (!(0, _is.isString)(x)) {
          throw new TypeError("Unexpected type of argument in function compareText (expected: string or Array or Matrix, actual: " + (0, _is.typeOf)(x) + ", index: 0)");
        }
        if (!(0, _is.isString)(y)) {
          throw new TypeError("Unexpected type of argument in function compareText (expected: string or Array or Matrix, actual: " + (0, _is.typeOf)(y) + ", index: 1)");
        }
        return x === y ? 0 : x > y ? 1 : -1;
      }
    }
  });

  // node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/error/DimensionError.js
  var require_DimensionError = __commonJS({
    "node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/error/DimensionError.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.DimensionError = DimensionError2;
      function DimensionError2(actual, expected, relation) {
        if (!(this instanceof DimensionError2)) {
          throw new SyntaxError("Constructor must be called with the new operator");
        }
        this.actual = actual;
        this.expected = expected;
        this.relation = relation;
        this.message = "Dimension mismatch (" + (Array.isArray(actual) ? "[" + actual.join(", ") + "]" : actual) + " " + (this.relation || "!=") + " " + (Array.isArray(expected) ? "[" + expected.join(", ") + "]" : expected) + ")";
        this.stack = new Error().stack;
      }
      DimensionError2.prototype = new RangeError();
      DimensionError2.prototype.constructor = RangeError;
      DimensionError2.prototype.name = "DimensionError";
      DimensionError2.prototype.isDimensionError = true;
    }
  });

  // node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/error/IndexError.js
  var require_IndexError = __commonJS({
    "node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/error/IndexError.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.IndexError = IndexError2;
      function IndexError2(index, min2, max2) {
        if (!(this instanceof IndexError2)) {
          throw new SyntaxError("Constructor must be called with the new operator");
        }
        this.index = index;
        if (arguments.length < 3) {
          this.min = 0;
          this.max = min2;
        } else {
          this.min = min2;
          this.max = max2;
        }
        if (this.min !== void 0 && this.index < this.min) {
          this.message = "Index out of range (" + this.index + " < " + this.min + ")";
        } else if (this.max !== void 0 && this.index >= this.max) {
          this.message = "Index out of range (" + this.index + " > " + (this.max - 1) + ")";
        } else {
          this.message = "Index out of range (" + this.index + ")";
        }
        this.stack = new Error().stack;
      }
      IndexError2.prototype = new RangeError();
      IndexError2.prototype.constructor = RangeError;
      IndexError2.prototype.name = "IndexError";
      IndexError2.prototype.isIndexError = true;
    }
  });

  // node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/utils/array.js
  var require_array = __commonJS({
    "node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/utils/array.js"(exports) {
      "use strict";
      var _interopRequireDefault = require_interopRequireDefault();
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.arraySize = arraySize2;
      exports.broadcastArrays = broadcastArrays;
      exports.broadcastSizes = broadcastSizes2;
      exports.broadcastTo = broadcastTo2;
      exports.checkBroadcastingRules = checkBroadcastingRules2;
      exports.clone = clone4;
      exports.concat = concat2;
      exports.filter = filter;
      exports.filterRegExp = filterRegExp;
      exports.flatten = flatten2;
      exports.forEach = forEach;
      exports.generalize = generalize;
      exports.getArrayDataType = getArrayDataType2;
      exports.identify = identify;
      exports.initial = initial;
      exports.isEmptyIndex = isEmptyIndex;
      exports.join = join;
      exports.last = last;
      exports.map = map;
      exports.processSizesWildcard = processSizesWildcard2;
      exports.reshape = reshape2;
      exports.resize = resize2;
      exports.squeeze = squeeze;
      exports.stretch = stretch2;
      exports.unsqueeze = unsqueeze2;
      exports.validate = validate2;
      exports.validateIndex = validateIndex2;
      exports.validateIndexSourceSize = validateIndexSourceSize;
      var _extends2 = _interopRequireDefault(require_extends());
      var _toConsumableArray2 = _interopRequireDefault(require_toConsumableArray());
      var _number = require_number();
      var _is = require_is();
      var _string = require_string();
      var _DimensionError = require_DimensionError();
      var _IndexError = require_IndexError();
      var _object = require_object();
      function arraySize2(x) {
        var s = [];
        while (Array.isArray(x)) {
          s.push(x.length);
          x = x[0];
        }
        return s;
      }
      function _validate2(array, size2, dim) {
        var i;
        var len = array.length;
        if (len !== size2[dim]) {
          throw new _DimensionError.DimensionError(len, size2[dim]);
        }
        if (dim < size2.length - 1) {
          var dimNext = dim + 1;
          for (i = 0; i < len; i++) {
            var child = array[i];
            if (!Array.isArray(child)) {
              throw new _DimensionError.DimensionError(size2.length - 1, size2.length, "<");
            }
            _validate2(array[i], size2, dimNext);
          }
        } else {
          for (i = 0; i < len; i++) {
            if (Array.isArray(array[i])) {
              throw new _DimensionError.DimensionError(size2.length + 1, size2.length, ">");
            }
          }
        }
      }
      function validate2(array, size2) {
        var isScalar = size2.length === 0;
        if (isScalar) {
          if (Array.isArray(array)) {
            throw new _DimensionError.DimensionError(array.length, 0);
          }
        } else {
          _validate2(array, size2, 0);
        }
      }
      function validateIndexSourceSize(value, index) {
        var valueSize = value.isMatrix ? value._size : arraySize2(value);
        var sourceSize = index._sourceSize;
        sourceSize.forEach(function(sourceDim, i) {
          if (sourceDim !== null && sourceDim !== valueSize[i]) {
            throw new _DimensionError.DimensionError(sourceDim, valueSize[i]);
          }
        });
      }
      function validateIndex2(index, length) {
        if (index !== void 0) {
          if (!(0, _is.isNumber)(index) || !(0, _number.isInteger)(index)) {
            throw new TypeError("Index must be an integer (value: " + index + ")");
          }
          if (index < 0 || typeof length === "number" && index >= length) {
            throw new _IndexError.IndexError(index, length);
          }
        }
      }
      function isEmptyIndex(index) {
        for (var i = 0; i < index._dimensions.length; ++i) {
          var dimension = index._dimensions[i];
          if (dimension._data && (0, _is.isArray)(dimension._data)) {
            if (dimension._size[0] === 0) {
              return true;
            }
          } else if (dimension.isRange) {
            if (dimension.start === dimension.end) {
              return true;
            }
          } else if ((0, _is.isString)(dimension)) {
            if (dimension.length === 0) {
              return true;
            }
          }
        }
        return false;
      }
      function resize2(array, size2, defaultValue) {
        if (!Array.isArray(size2)) {
          throw new TypeError("Array expected");
        }
        if (size2.length === 0) {
          throw new Error("Resizing to scalar is not supported");
        }
        size2.forEach(function(value) {
          if (!(0, _is.isNumber)(value) || !(0, _number.isInteger)(value) || value < 0) {
            throw new TypeError("Invalid size, must contain positive integers (size: " + (0, _string.format)(size2) + ")");
          }
        });
        if ((0, _is.isNumber)(array) || (0, _is.isBigNumber)(array)) {
          array = [array];
        }
        var _defaultValue = defaultValue !== void 0 ? defaultValue : 0;
        _resize2(array, size2, 0, _defaultValue);
        return array;
      }
      function _resize2(array, size2, dim, defaultValue) {
        var i;
        var elem;
        var oldLen = array.length;
        var newLen = size2[dim];
        var minLen = Math.min(oldLen, newLen);
        array.length = newLen;
        if (dim < size2.length - 1) {
          var dimNext = dim + 1;
          for (i = 0; i < minLen; i++) {
            elem = array[i];
            if (!Array.isArray(elem)) {
              elem = [elem];
              array[i] = elem;
            }
            _resize2(elem, size2, dimNext, defaultValue);
          }
          for (i = minLen; i < newLen; i++) {
            elem = [];
            array[i] = elem;
            _resize2(elem, size2, dimNext, defaultValue);
          }
        } else {
          for (i = 0; i < minLen; i++) {
            while (Array.isArray(array[i])) {
              array[i] = array[i][0];
            }
          }
          for (i = minLen; i < newLen; i++) {
            array[i] = defaultValue;
          }
        }
      }
      function reshape2(array, sizes) {
        var flatArray = flatten2(array);
        var currentLength = flatArray.length;
        if (!Array.isArray(array) || !Array.isArray(sizes)) {
          throw new TypeError("Array expected");
        }
        if (sizes.length === 0) {
          throw new _DimensionError.DimensionError(0, currentLength, "!=");
        }
        sizes = processSizesWildcard2(sizes, currentLength);
        var newLength = product2(sizes);
        if (currentLength !== newLength) {
          throw new _DimensionError.DimensionError(newLength, currentLength, "!=");
        }
        try {
          return _reshape2(flatArray, sizes);
        } catch (e) {
          if (e instanceof _DimensionError.DimensionError) {
            throw new _DimensionError.DimensionError(newLength, currentLength, "!=");
          }
          throw e;
        }
      }
      function processSizesWildcard2(sizes, currentLength) {
        var newLength = product2(sizes);
        var processedSizes = sizes.slice();
        var WILDCARD = -1;
        var wildCardIndex = sizes.indexOf(WILDCARD);
        var isMoreThanOneWildcard = sizes.indexOf(WILDCARD, wildCardIndex + 1) >= 0;
        if (isMoreThanOneWildcard) {
          throw new Error("More than one wildcard in sizes");
        }
        var hasWildcard = wildCardIndex >= 0;
        var canReplaceWildcard = currentLength % newLength === 0;
        if (hasWildcard) {
          if (canReplaceWildcard) {
            processedSizes[wildCardIndex] = -currentLength / newLength;
          } else {
            throw new Error("Could not replace wildcard, since " + currentLength + " is no multiple of " + -newLength);
          }
        }
        return processedSizes;
      }
      function product2(array) {
        return array.reduce(function(prev, curr) {
          return prev * curr;
        }, 1);
      }
      function _reshape2(array, sizes) {
        var tmpArray = array;
        var tmpArray2;
        for (var sizeIndex = sizes.length - 1; sizeIndex > 0; sizeIndex--) {
          var size2 = sizes[sizeIndex];
          tmpArray2 = [];
          var length = tmpArray.length / size2;
          for (var i = 0; i < length; i++) {
            tmpArray2.push(tmpArray.slice(i * size2, (i + 1) * size2));
          }
          tmpArray = tmpArray2;
        }
        return tmpArray;
      }
      function squeeze(array, size2) {
        var s = size2 || arraySize2(array);
        while (Array.isArray(array) && array.length === 1) {
          array = array[0];
          s.shift();
        }
        var dims = s.length;
        while (s[dims - 1] === 1) {
          dims--;
        }
        if (dims < s.length) {
          array = _squeeze(array, dims, 0);
          s.length = dims;
        }
        return array;
      }
      function _squeeze(array, dims, dim) {
        var i, ii;
        if (dim < dims) {
          var next = dim + 1;
          for (i = 0, ii = array.length; i < ii; i++) {
            array[i] = _squeeze(array[i], dims, next);
          }
        } else {
          while (Array.isArray(array)) {
            array = array[0];
          }
        }
        return array;
      }
      function unsqueeze2(array, dims, outer, size2) {
        var s = size2 || arraySize2(array);
        if (outer) {
          for (var i = 0; i < outer; i++) {
            array = [array];
            s.unshift(1);
          }
        }
        array = _unsqueeze2(array, dims, 0);
        while (s.length < dims) {
          s.push(1);
        }
        return array;
      }
      function _unsqueeze2(array, dims, dim) {
        var i, ii;
        if (Array.isArray(array)) {
          var next = dim + 1;
          for (i = 0, ii = array.length; i < ii; i++) {
            array[i] = _unsqueeze2(array[i], dims, next);
          }
        } else {
          for (var d = dim; d < dims; d++) {
            array = [array];
          }
        }
        return array;
      }
      function flatten2(array) {
        if (!Array.isArray(array)) {
          return array;
        }
        var flat = [];
        array.forEach(function callback(value) {
          if (Array.isArray(value)) {
            value.forEach(callback);
          } else {
            flat.push(value);
          }
        });
        return flat;
      }
      function map(array, callback) {
        return Array.prototype.map.call(array, callback);
      }
      function forEach(array, callback) {
        Array.prototype.forEach.call(array, callback);
      }
      function filter(array, callback) {
        if (arraySize2(array).length !== 1) {
          throw new Error("Only one dimensional matrices supported");
        }
        return Array.prototype.filter.call(array, callback);
      }
      function filterRegExp(array, regexp) {
        if (arraySize2(array).length !== 1) {
          throw new Error("Only one dimensional matrices supported");
        }
        return Array.prototype.filter.call(array, function(entry) {
          return regexp.test(entry);
        });
      }
      function join(array, separator) {
        return Array.prototype.join.call(array, separator);
      }
      function identify(a) {
        if (!Array.isArray(a)) {
          throw new TypeError("Array input expected");
        }
        if (a.length === 0) {
          return a;
        }
        var b = [];
        var count = 0;
        b[0] = {
          value: a[0],
          identifier: 0
        };
        for (var i = 1; i < a.length; i++) {
          if (a[i] === a[i - 1]) {
            count++;
          } else {
            count = 0;
          }
          b.push({
            value: a[i],
            identifier: count
          });
        }
        return b;
      }
      function generalize(a) {
        if (!Array.isArray(a)) {
          throw new TypeError("Array input expected");
        }
        if (a.length === 0) {
          return a;
        }
        var b = [];
        for (var i = 0; i < a.length; i++) {
          b.push(a[i].value);
        }
        return b;
      }
      function getArrayDataType2(array, typeOf2) {
        var type;
        var length = 0;
        for (var i = 0; i < array.length; i++) {
          var item = array[i];
          var _isArray = Array.isArray(item);
          if (i === 0 && _isArray) {
            length = item.length;
          }
          if (_isArray && item.length !== length) {
            return void 0;
          }
          var itemType = _isArray ? getArrayDataType2(item, typeOf2) : typeOf2(item);
          if (type === void 0) {
            type = itemType;
          } else if (type !== itemType) {
            return "mixed";
          } else {
          }
        }
        return type;
      }
      function last(array) {
        return array[array.length - 1];
      }
      function initial(array) {
        return array.slice(0, array.length - 1);
      }
      function concatRecursive2(a, b, concatDim, dim) {
        if (dim < concatDim) {
          if (a.length !== b.length) {
            throw new _DimensionError.DimensionError(a.length, b.length);
          }
          var c = [];
          for (var i = 0; i < a.length; i++) {
            c[i] = concatRecursive2(a[i], b[i], concatDim, dim + 1);
          }
          return c;
        } else {
          return a.concat(b);
        }
      }
      function concat2() {
        var arrays = Array.prototype.slice.call(arguments, 0, -1);
        var concatDim = Array.prototype.slice.call(arguments, -1);
        if (arrays.length === 1) {
          return arrays[0];
        }
        if (arrays.length > 1) {
          return arrays.slice(1).reduce(function(A, B) {
            return concatRecursive2(A, B, concatDim, 0);
          }, arrays[0]);
        } else {
          throw new Error("Wrong number of arguments in function concat");
        }
      }
      function broadcastSizes2() {
        for (var _len = arguments.length, sizes = new Array(_len), _key = 0; _key < _len; _key++) {
          sizes[_key] = arguments[_key];
        }
        var dimensions = sizes.map(function(s) {
          return s.length;
        });
        var N = Math.max.apply(Math, (0, _toConsumableArray2["default"])(dimensions));
        var sizeMax = new Array(N).fill(null);
        for (var i = 0; i < sizes.length; i++) {
          var size2 = sizes[i];
          var dim = dimensions[i];
          for (var j = 0; j < dim; j++) {
            var n = N - dim + j;
            if (size2[j] > sizeMax[n]) {
              sizeMax[n] = size2[j];
            }
          }
        }
        for (var _i = 0; _i < sizes.length; _i++) {
          checkBroadcastingRules2(sizes[_i], sizeMax);
        }
        return sizeMax;
      }
      function checkBroadcastingRules2(size2, toSize) {
        var N = toSize.length;
        var dim = size2.length;
        for (var j = 0; j < dim; j++) {
          var n = N - dim + j;
          if (size2[j] < toSize[n] && size2[j] > 1 || size2[j] > toSize[n]) {
            throw new Error("shape missmatch: missmatch is found in arg with shape (".concat(size2, ") not possible to broadcast dimension ").concat(dim, " with size ").concat(size2[j], " to size ").concat(toSize[n]));
          }
        }
      }
      function broadcastTo2(array, toSize) {
        var Asize = arraySize2(array);
        if ((0, _object.deepStrictEqual)(Asize, toSize)) {
          return array;
        }
        checkBroadcastingRules2(Asize, toSize);
        var broadcastedSize = broadcastSizes2(Asize, toSize);
        var N = broadcastedSize.length;
        var paddedSize = [].concat((0, _toConsumableArray2["default"])(Array(N - Asize.length).fill(1)), (0, _toConsumableArray2["default"])(Asize));
        var A = clone4(array);
        if (Asize.length < N) {
          A = reshape2(A, paddedSize);
          Asize = arraySize2(A);
        }
        for (var dim = 0; dim < N; dim++) {
          if (Asize[dim] < broadcastedSize[dim]) {
            A = stretch2(A, broadcastedSize[dim], dim);
            Asize = arraySize2(A);
          }
        }
        return A;
      }
      function broadcastArrays() {
        for (var _len2 = arguments.length, arrays = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
          arrays[_key2] = arguments[_key2];
        }
        if (arrays.length === 0) {
          throw new Error("Insuficient number of argumnets in function broadcastArrays");
        }
        if (arrays.length === 1) {
          return arrays[0];
        }
        var sizes = arrays.map(function(array) {
          return arraySize2(array);
        });
        var broadcastedSize = broadcastSizes2.apply(void 0, (0, _toConsumableArray2["default"])(sizes));
        var broadcastedArrays = [];
        arrays.forEach(function(array) {
          broadcastedArrays.push(broadcastTo2(array, broadcastedSize));
        });
        return broadcastedArrays;
      }
      function stretch2(arrayToStretch, sizeToStretch, dimToStretch) {
        return concat2.apply(void 0, (0, _toConsumableArray2["default"])(Array(sizeToStretch).fill(arrayToStretch)).concat([dimToStretch]));
      }
      function clone4(array) {
        return (0, _extends2["default"])([], array);
      }
    }
  });

  // node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/utils/lruQueue.js
  var require_lruQueue = __commonJS({
    "node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/utils/lruQueue.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.lruQueue = lruQueue;
      function lruQueue(limit) {
        var size2 = 0;
        var base = 1;
        var queue = /* @__PURE__ */ Object.create(null);
        var map = /* @__PURE__ */ Object.create(null);
        var index = 0;
        var del = function del2(id) {
          var oldIndex = map[id];
          if (!oldIndex) return;
          delete queue[oldIndex];
          delete map[id];
          --size2;
          if (base !== oldIndex) return;
          if (!size2) {
            index = 0;
            base = 1;
            return;
          }
          while (!Object.prototype.hasOwnProperty.call(queue, ++base)) {
          }
        };
        limit = Math.abs(limit);
        return {
          hit: function hit(id) {
            var oldIndex = map[id];
            var nuIndex = ++index;
            queue[nuIndex] = id;
            map[id] = nuIndex;
            if (!oldIndex) {
              ++size2;
              if (size2 <= limit) return void 0;
              id = queue[base];
              del(id);
              return id;
            }
            delete queue[oldIndex];
            if (base !== oldIndex) return void 0;
            while (!Object.prototype.hasOwnProperty.call(queue, ++base)) {
            }
            return void 0;
          },
          "delete": del,
          clear: function clear() {
            size2 = index = 0;
            base = 1;
            queue = /* @__PURE__ */ Object.create(null);
            map = /* @__PURE__ */ Object.create(null);
          }
        };
      }
    }
  });

  // node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/utils/function.js
  var require_function = __commonJS({
    "node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/utils/function.js"(exports) {
      "use strict";
      var _interopRequireDefault = require_interopRequireDefault();
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.maxArgumentCount = maxArgumentCount2;
      exports.memoize = memoize;
      exports.memoizeCompare = memoizeCompare;
      var _typeof2 = _interopRequireDefault(require_typeof());
      var _lruQueue = require_lruQueue();
      function memoize(fn) {
        var _ref = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, hasher = _ref.hasher, limit = _ref.limit;
        limit = limit == null ? Number.POSITIVE_INFINITY : limit;
        hasher = hasher == null ? JSON.stringify : hasher;
        return function memoize2() {
          if ((0, _typeof2["default"])(memoize2.cache) !== "object") {
            memoize2.cache = {
              values: /* @__PURE__ */ new Map(),
              lru: (0, _lruQueue.lruQueue)(limit || Number.POSITIVE_INFINITY)
            };
          }
          var args = [];
          for (var i = 0; i < arguments.length; i++) {
            args[i] = arguments[i];
          }
          var hash = hasher(args);
          if (memoize2.cache.values.has(hash)) {
            memoize2.cache.lru.hit(hash);
            return memoize2.cache.values.get(hash);
          }
          var newVal = fn.apply(fn, args);
          memoize2.cache.values.set(hash, newVal);
          memoize2.cache.values["delete"](memoize2.cache.lru.hit(hash));
          return newVal;
        };
      }
      function memoizeCompare(fn, isEqual) {
        var memoize2 = function memoize3() {
          var args = [];
          for (var i = 0; i < arguments.length; i++) {
            args[i] = arguments[i];
          }
          for (var c = 0; c < memoize3.cache.length; c++) {
            var cached = memoize3.cache[c];
            if (isEqual(args, cached.args)) {
              return cached.res;
            }
          }
          var res = fn.apply(fn, args);
          memoize3.cache.unshift({
            args,
            res
          });
          return res;
        };
        memoize2.cache = [];
        return memoize2;
      }
      function maxArgumentCount2(fn) {
        return Object.keys(fn.signatures || {}).reduce(function(args, signature) {
          var count = (signature.match(/,/g) || []).length + 1;
          return Math.max(args, count);
        }, -1);
      }
    }
  });

  // node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/type/matrix/DenseMatrix.js
  var require_DenseMatrix = __commonJS({
    "node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/type/matrix/DenseMatrix.js"(exports) {
      "use strict";
      var _interopRequireDefault = require_interopRequireDefault();
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.createDenseMatrixClass = void 0;
      var _regenerator = _interopRequireDefault(require_regenerator2());
      var _is = require_is();
      var _array = require_array();
      var _string = require_string();
      var _number = require_number();
      var _object = require_object();
      var _DimensionError = require_DimensionError();
      var _factory = require_factory();
      var _function = require_function();
      function _createForOfIteratorHelper(o, allowArrayLike) {
        var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"];
        if (!it) {
          if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") {
            if (it) o = it;
            var i = 0;
            var F = function F2() {
            };
            return { s: F, n: function n() {
              if (i >= o.length) return { done: true };
              return { done: false, value: o[i++] };
            }, e: function e(_e) {
              throw _e;
            }, f: F };
          }
          throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
        }
        var normalCompletion = true, didErr = false, err;
        return { s: function s() {
          it = it.call(o);
        }, n: function n() {
          var step = it.next();
          normalCompletion = step.done;
          return step;
        }, e: function e(_e2) {
          didErr = true;
          err = _e2;
        }, f: function f() {
          try {
            if (!normalCompletion && it["return"] != null) it["return"]();
          } finally {
            if (didErr) throw err;
          }
        } };
      }
      function _unsupportedIterableToArray(o, minLen) {
        if (!o) return;
        if (typeof o === "string") return _arrayLikeToArray(o, minLen);
        var n = Object.prototype.toString.call(o).slice(8, -1);
        if (n === "Object" && o.constructor) n = o.constructor.name;
        if (n === "Map" || n === "Set") return Array.from(o);
        if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);
      }
      function _arrayLikeToArray(arr, len) {
        if (len == null || len > arr.length) len = arr.length;
        for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];
        return arr2;
      }
      var name18 = "DenseMatrix";
      var dependencies19 = ["Matrix"];
      var createDenseMatrixClass2 = exports.createDenseMatrixClass = /* @__PURE__ */ (0, _factory.factory)(name18, dependencies19, function(_ref) {
        var Matrix2 = _ref.Matrix;
        function DenseMatrix2(data, datatype) {
          if (!(this instanceof DenseMatrix2)) {
            throw new SyntaxError("Constructor must be called with the new operator");
          }
          if (datatype && !(0, _is.isString)(datatype)) {
            throw new Error("Invalid datatype: " + datatype);
          }
          if ((0, _is.isMatrix)(data)) {
            if (data.type === "DenseMatrix") {
              this._data = (0, _object.clone)(data._data);
              this._size = (0, _object.clone)(data._size);
              this._datatype = datatype || data._datatype;
            } else {
              this._data = data.toArray();
              this._size = data.size();
              this._datatype = datatype || data._datatype;
            }
          } else if (data && (0, _is.isArray)(data.data) && (0, _is.isArray)(data.size)) {
            this._data = data.data;
            this._size = data.size;
            (0, _array.validate)(this._data, this._size);
            this._datatype = datatype || data.datatype;
          } else if ((0, _is.isArray)(data)) {
            this._data = preprocess(data);
            this._size = (0, _array.arraySize)(this._data);
            (0, _array.validate)(this._data, this._size);
            this._datatype = datatype;
          } else if (data) {
            throw new TypeError("Unsupported type of data (" + (0, _is.typeOf)(data) + ")");
          } else {
            this._data = [];
            this._size = [0];
            this._datatype = datatype;
          }
        }
        DenseMatrix2.prototype = new Matrix2();
        DenseMatrix2.prototype.createDenseMatrix = function(data, datatype) {
          return new DenseMatrix2(data, datatype);
        };
        Object.defineProperty(DenseMatrix2, "name", {
          value: "DenseMatrix"
        });
        DenseMatrix2.prototype.constructor = DenseMatrix2;
        DenseMatrix2.prototype.type = "DenseMatrix";
        DenseMatrix2.prototype.isDenseMatrix = true;
        DenseMatrix2.prototype.getDataType = function() {
          return (0, _array.getArrayDataType)(this._data, _is.typeOf);
        };
        DenseMatrix2.prototype.storage = function() {
          return "dense";
        };
        DenseMatrix2.prototype.datatype = function() {
          return this._datatype;
        };
        DenseMatrix2.prototype.create = function(data, datatype) {
          return new DenseMatrix2(data, datatype);
        };
        DenseMatrix2.prototype.subset = function(index, replacement, defaultValue) {
          switch (arguments.length) {
            case 1:
              return _get(this, index);
            // intentional fall through
            case 2:
            case 3:
              return _set(this, index, replacement, defaultValue);
            default:
              throw new SyntaxError("Wrong number of arguments");
          }
        };
        DenseMatrix2.prototype.get = function(index) {
          if (!(0, _is.isArray)(index)) {
            throw new TypeError("Array expected");
          }
          if (index.length !== this._size.length) {
            throw new _DimensionError.DimensionError(index.length, this._size.length);
          }
          for (var x = 0; x < index.length; x++) {
            (0, _array.validateIndex)(index[x], this._size[x]);
          }
          var data = this._data;
          for (var i = 0, ii = index.length; i < ii; i++) {
            var indexI = index[i];
            (0, _array.validateIndex)(indexI, data.length);
            data = data[indexI];
          }
          return data;
        };
        DenseMatrix2.prototype.set = function(index, value, defaultValue) {
          if (!(0, _is.isArray)(index)) {
            throw new TypeError("Array expected");
          }
          if (index.length < this._size.length) {
            throw new _DimensionError.DimensionError(index.length, this._size.length, "<");
          }
          var i, ii, indexI;
          var size2 = index.map(function(i2) {
            return i2 + 1;
          });
          _fit(this, size2, defaultValue);
          var data = this._data;
          for (i = 0, ii = index.length - 1; i < ii; i++) {
            indexI = index[i];
            (0, _array.validateIndex)(indexI, data.length);
            data = data[indexI];
          }
          indexI = index[index.length - 1];
          (0, _array.validateIndex)(indexI, data.length);
          data[indexI] = value;
          return this;
        };
        function _get(matrix2, index) {
          if (!(0, _is.isIndex)(index)) {
            throw new TypeError("Invalid index");
          }
          var isScalar = index.isScalar();
          if (isScalar) {
            return matrix2.get(index.min());
          } else {
            var size2 = index.size();
            if (size2.length !== matrix2._size.length) {
              throw new _DimensionError.DimensionError(size2.length, matrix2._size.length);
            }
            var min2 = index.min();
            var max2 = index.max();
            for (var i = 0, ii = matrix2._size.length; i < ii; i++) {
              (0, _array.validateIndex)(min2[i], matrix2._size[i]);
              (0, _array.validateIndex)(max2[i], matrix2._size[i]);
            }
            return new DenseMatrix2(_getSubmatrix(matrix2._data, index, size2.length, 0), matrix2._datatype);
          }
        }
        function _getSubmatrix(data, index, dims, dim) {
          var last = dim === dims - 1;
          var range = index.dimension(dim);
          if (last) {
            return range.map(function(i) {
              (0, _array.validateIndex)(i, data.length);
              return data[i];
            }).valueOf();
          } else {
            return range.map(function(i) {
              (0, _array.validateIndex)(i, data.length);
              var child = data[i];
              return _getSubmatrix(child, index, dims, dim + 1);
            }).valueOf();
          }
        }
        function _set(matrix2, index, submatrix, defaultValue) {
          if (!index || index.isIndex !== true) {
            throw new TypeError("Invalid index");
          }
          var iSize = index.size();
          var isScalar = index.isScalar();
          var sSize;
          if ((0, _is.isMatrix)(submatrix)) {
            sSize = submatrix.size();
            submatrix = submatrix.valueOf();
          } else {
            sSize = (0, _array.arraySize)(submatrix);
          }
          if (isScalar) {
            if (sSize.length !== 0) {
              throw new TypeError("Scalar expected");
            }
            matrix2.set(index.min(), submatrix, defaultValue);
          } else {
            if (!(0, _object.deepStrictEqual)(sSize, iSize)) {
              try {
                if (sSize.length === 0) {
                  submatrix = (0, _array.broadcastTo)([submatrix], iSize);
                } else {
                  submatrix = (0, _array.broadcastTo)(submatrix, iSize);
                }
                sSize = (0, _array.arraySize)(submatrix);
              } catch (_unused) {
              }
            }
            if (iSize.length < matrix2._size.length) {
              throw new _DimensionError.DimensionError(iSize.length, matrix2._size.length, "<");
            }
            if (sSize.length < iSize.length) {
              var i = 0;
              var outer = 0;
              while (iSize[i] === 1 && sSize[i] === 1) {
                i++;
              }
              while (iSize[i] === 1) {
                outer++;
                i++;
              }
              submatrix = (0, _array.unsqueeze)(submatrix, iSize.length, outer, sSize);
            }
            if (!(0, _object.deepStrictEqual)(iSize, sSize)) {
              throw new _DimensionError.DimensionError(iSize, sSize, ">");
            }
            var size2 = index.max().map(function(i2) {
              return i2 + 1;
            });
            _fit(matrix2, size2, defaultValue);
            var dims = iSize.length;
            var dim = 0;
            _setSubmatrix(matrix2._data, index, submatrix, dims, dim);
          }
          return matrix2;
        }
        function _setSubmatrix(data, index, submatrix, dims, dim) {
          var last = dim === dims - 1;
          var range = index.dimension(dim);
          if (last) {
            range.forEach(function(dataIndex, subIndex) {
              (0, _array.validateIndex)(dataIndex);
              data[dataIndex] = submatrix[subIndex[0]];
            });
          } else {
            range.forEach(function(dataIndex, subIndex) {
              (0, _array.validateIndex)(dataIndex);
              _setSubmatrix(data[dataIndex], index, submatrix[subIndex[0]], dims, dim + 1);
            });
          }
        }
        DenseMatrix2.prototype.resize = function(size2, defaultValue, copy) {
          if (!(0, _is.isCollection)(size2)) {
            throw new TypeError("Array or Matrix expected");
          }
          var sizeArray = size2.valueOf().map(function(value) {
            return Array.isArray(value) && value.length === 1 ? value[0] : value;
          });
          var m = copy ? this.clone() : this;
          return _resize2(m, sizeArray, defaultValue);
        };
        function _resize2(matrix2, size2, defaultValue) {
          if (size2.length === 0) {
            var v = matrix2._data;
            while ((0, _is.isArray)(v)) {
              v = v[0];
            }
            return v;
          }
          matrix2._size = size2.slice(0);
          matrix2._data = (0, _array.resize)(matrix2._data, matrix2._size, defaultValue);
          return matrix2;
        }
        DenseMatrix2.prototype.reshape = function(size2, copy) {
          var m = copy ? this.clone() : this;
          m._data = (0, _array.reshape)(m._data, size2);
          var currentLength = m._size.reduce(function(length, size3) {
            return length * size3;
          });
          m._size = (0, _array.processSizesWildcard)(size2, currentLength);
          return m;
        };
        function _fit(matrix2, size2, defaultValue) {
          var newSize = matrix2._size.slice(0);
          var changed = false;
          while (newSize.length < size2.length) {
            newSize.push(0);
            changed = true;
          }
          for (var i = 0, ii = size2.length; i < ii; i++) {
            if (size2[i] > newSize[i]) {
              newSize[i] = size2[i];
              changed = true;
            }
          }
          if (changed) {
            _resize2(matrix2, newSize, defaultValue);
          }
        }
        DenseMatrix2.prototype.clone = function() {
          var m = new DenseMatrix2({
            data: (0, _object.clone)(this._data),
            size: (0, _object.clone)(this._size),
            datatype: this._datatype
          });
          return m;
        };
        DenseMatrix2.prototype.size = function() {
          return this._size.slice(0);
        };
        DenseMatrix2.prototype.map = function(callback) {
          var me = this;
          var args = (0, _function.maxArgumentCount)(callback);
          var recurse = function recurse2(value, index) {
            if ((0, _is.isArray)(value)) {
              return value.map(function(child, i) {
                return recurse2(child, index.concat(i));
              });
            } else {
              if (args === 1) {
                return callback(value);
              } else if (args === 2) {
                return callback(value, index);
              } else {
                return callback(value, index, me);
              }
            }
          };
          var data = recurse(this._data, []);
          var datatype = this._datatype !== void 0 ? (0, _array.getArrayDataType)(data, _is.typeOf) : void 0;
          return new DenseMatrix2(data, datatype);
        };
        DenseMatrix2.prototype.forEach = function(callback) {
          var me = this;
          var recurse = function recurse2(value, index) {
            if ((0, _is.isArray)(value)) {
              value.forEach(function(child, i) {
                recurse2(child, index.concat(i));
              });
            } else {
              callback(value, index, me);
            }
          };
          recurse(this._data, []);
        };
        DenseMatrix2.prototype[Symbol.iterator] = /* @__PURE__ */ _regenerator["default"].mark(function _callee() {
          var recurse;
          return _regenerator["default"].wrap(function _callee$(_context2) {
            while (1) switch (_context2.prev = _context2.next) {
              case 0:
                recurse = /* @__PURE__ */ _regenerator["default"].mark(function recurse2(value, index) {
                  var i;
                  return _regenerator["default"].wrap(function recurse$(_context) {
                    while (1) switch (_context.prev = _context.next) {
                      case 0:
                        if (!(0, _is.isArray)(value)) {
                          _context.next = 9;
                          break;
                        }
                        i = 0;
                      case 2:
                        if (!(i < value.length)) {
                          _context.next = 7;
                          break;
                        }
                        return _context.delegateYield(recurse2(value[i], index.concat(i)), "t0", 4);
                      case 4:
                        i++;
                        _context.next = 2;
                        break;
                      case 7:
                        _context.next = 11;
                        break;
                      case 9:
                        _context.next = 11;
                        return {
                          value,
                          index
                        };
                      case 11:
                      case "end":
                        return _context.stop();
                    }
                  }, recurse2);
                });
                return _context2.delegateYield(recurse(this._data, []), "t0", 2);
              case 2:
              case "end":
                return _context2.stop();
            }
          }, _callee, this);
        });
        DenseMatrix2.prototype.rows = function() {
          var result = [];
          var s = this.size();
          if (s.length !== 2) {
            throw new TypeError("Rows can only be returned for a 2D matrix.");
          }
          var data = this._data;
          var _iterator = _createForOfIteratorHelper(data), _step;
          try {
            for (_iterator.s(); !(_step = _iterator.n()).done; ) {
              var row = _step.value;
              result.push(new DenseMatrix2([row], this._datatype));
            }
          } catch (err) {
            _iterator.e(err);
          } finally {
            _iterator.f();
          }
          return result;
        };
        DenseMatrix2.prototype.columns = function() {
          var _this = this;
          var result = [];
          var s = this.size();
          if (s.length !== 2) {
            throw new TypeError("Rows can only be returned for a 2D matrix.");
          }
          var data = this._data;
          var _loop = function _loop2(i2) {
            var col = data.map(function(row) {
              return [row[i2]];
            });
            result.push(new DenseMatrix2(col, _this._datatype));
          };
          for (var i = 0; i < s[1]; i++) {
            _loop(i);
          }
          return result;
        };
        DenseMatrix2.prototype.toArray = function() {
          return (0, _object.clone)(this._data);
        };
        DenseMatrix2.prototype.valueOf = function() {
          return this._data;
        };
        DenseMatrix2.prototype.format = function(options) {
          return (0, _string.format)(this._data, options);
        };
        DenseMatrix2.prototype.toString = function() {
          return (0, _string.format)(this._data);
        };
        DenseMatrix2.prototype.toJSON = function() {
          return {
            mathjs: "DenseMatrix",
            data: this._data,
            size: this._size,
            datatype: this._datatype
          };
        };
        DenseMatrix2.prototype.diagonal = function(k) {
          if (k) {
            if ((0, _is.isBigNumber)(k)) {
              k = k.toNumber();
            }
            if (!(0, _is.isNumber)(k) || !(0, _number.isInteger)(k)) {
              throw new TypeError("The parameter k must be an integer number");
            }
          } else {
            k = 0;
          }
          var kSuper = k > 0 ? k : 0;
          var kSub = k < 0 ? -k : 0;
          var rows = this._size[0];
          var columns = this._size[1];
          var n = Math.min(rows - kSub, columns - kSuper);
          var data = [];
          for (var i = 0; i < n; i++) {
            data[i] = this._data[i + kSub][i + kSuper];
          }
          return new DenseMatrix2({
            data,
            size: [n],
            datatype: this._datatype
          });
        };
        DenseMatrix2.diagonal = function(size2, value, k, defaultValue) {
          if (!(0, _is.isArray)(size2)) {
            throw new TypeError("Array expected, size parameter");
          }
          if (size2.length !== 2) {
            throw new Error("Only two dimensions matrix are supported");
          }
          size2 = size2.map(function(s) {
            if ((0, _is.isBigNumber)(s)) {
              s = s.toNumber();
            }
            if (!(0, _is.isNumber)(s) || !(0, _number.isInteger)(s) || s < 1) {
              throw new Error("Size values must be positive integers");
            }
            return s;
          });
          if (k) {
            if ((0, _is.isBigNumber)(k)) {
              k = k.toNumber();
            }
            if (!(0, _is.isNumber)(k) || !(0, _number.isInteger)(k)) {
              throw new TypeError("The parameter k must be an integer number");
            }
          } else {
            k = 0;
          }
          var kSuper = k > 0 ? k : 0;
          var kSub = k < 0 ? -k : 0;
          var rows = size2[0];
          var columns = size2[1];
          var n = Math.min(rows - kSub, columns - kSuper);
          var _value;
          if ((0, _is.isArray)(value)) {
            if (value.length !== n) {
              throw new Error("Invalid value array length");
            }
            _value = function _value2(i) {
              return value[i];
            };
          } else if ((0, _is.isMatrix)(value)) {
            var ms = value.size();
            if (ms.length !== 1 || ms[0] !== n) {
              throw new Error("Invalid matrix length");
            }
            _value = function _value2(i) {
              return value.get([i]);
            };
          } else {
            _value = function _value2() {
              return value;
            };
          }
          if (!defaultValue) {
            defaultValue = (0, _is.isBigNumber)(_value(0)) ? _value(0).mul(0) : 0;
          }
          var data = [];
          if (size2.length > 0) {
            data = (0, _array.resize)(data, size2, defaultValue);
            for (var d = 0; d < n; d++) {
              data[d + kSub][d + kSuper] = _value(d);
            }
          }
          return new DenseMatrix2({
            data,
            size: [rows, columns]
          });
        };
        DenseMatrix2.fromJSON = function(json) {
          return new DenseMatrix2(json);
        };
        DenseMatrix2.prototype.swapRows = function(i, j) {
          if (!(0, _is.isNumber)(i) || !(0, _number.isInteger)(i) || !(0, _is.isNumber)(j) || !(0, _number.isInteger)(j)) {
            throw new Error("Row index must be positive integers");
          }
          if (this._size.length !== 2) {
            throw new Error("Only two dimensional matrix is supported");
          }
          (0, _array.validateIndex)(i, this._size[0]);
          (0, _array.validateIndex)(j, this._size[0]);
          DenseMatrix2._swapRows(i, j, this._data);
          return this;
        };
        DenseMatrix2._swapRows = function(i, j, data) {
          var vi = data[i];
          data[i] = data[j];
          data[j] = vi;
        };
        function preprocess(data) {
          if ((0, _is.isMatrix)(data)) {
            return preprocess(data.valueOf());
          }
          if ((0, _is.isArray)(data)) {
            return data.map(preprocess);
          }
          return data;
        }
        return DenseMatrix2;
      }, {
        isClass: true
      });
    }
  });

  // node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/function/utils/clone.js
  var require_clone = __commonJS({
    "node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/function/utils/clone.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.createClone = void 0;
      var _object = require_object();
      var _factory = require_factory();
      var name18 = "clone";
      var dependencies19 = ["typed"];
      var createClone2 = exports.createClone = /* @__PURE__ */ (0, _factory.factory)(name18, dependencies19, function(_ref) {
        var typed2 = _ref.typed;
        return typed2(name18, {
          any: _object.clone
        });
      });
    }
  });

  // node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/utils/switch.js
  var require_switch = __commonJS({
    "node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/utils/switch.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports._switch = _switch;
      function _switch(mat) {
        var I = mat.length;
        var J = mat[0].length;
        var i, j;
        var ret = [];
        for (j = 0; j < J; j++) {
          var tmp = [];
          for (i = 0; i < I; i++) {
            tmp.push(mat[i][j]);
          }
          ret.push(tmp);
        }
        return ret;
      }
    }
  });

  // node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/utils/collection.js
  var require_collection = __commonJS({
    "node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/utils/collection.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.containsCollections = containsCollections;
      exports.deepForEach = deepForEach;
      exports.deepMap = deepMap2;
      exports.reduce = reduce;
      exports.scatter = scatter;
      var _is = require_is();
      var _IndexError = require_IndexError();
      var _array = require_array();
      var _switch2 = require_switch();
      function containsCollections(array) {
        for (var i = 0; i < array.length; i++) {
          if ((0, _is.isCollection)(array[i])) {
            return true;
          }
        }
        return false;
      }
      function deepForEach(array, callback) {
        if ((0, _is.isMatrix)(array)) {
          array = array.valueOf();
        }
        for (var i = 0, ii = array.length; i < ii; i++) {
          var value = array[i];
          if (Array.isArray(value)) {
            deepForEach(value, callback);
          } else {
            callback(value);
          }
        }
      }
      function deepMap2(array, callback, skipZeros) {
        if (array && typeof array.map === "function") {
          return array.map(function(x) {
            return deepMap2(x, callback, skipZeros);
          });
        } else {
          return callback(array);
        }
      }
      function reduce(mat, dim, callback) {
        var size2 = Array.isArray(mat) ? (0, _array.arraySize)(mat) : mat.size();
        if (dim < 0 || dim >= size2.length) {
          throw new _IndexError.IndexError(dim, size2.length);
        }
        if ((0, _is.isMatrix)(mat)) {
          return mat.create(_reduce(mat.valueOf(), dim, callback));
        } else {
          return _reduce(mat, dim, callback);
        }
      }
      function _reduce(mat, dim, callback) {
        var i, ret, val, tran;
        if (dim <= 0) {
          if (!Array.isArray(mat[0])) {
            val = mat[0];
            for (i = 1; i < mat.length; i++) {
              val = callback(val, mat[i]);
            }
            return val;
          } else {
            tran = (0, _switch2._switch)(mat);
            ret = [];
            for (i = 0; i < tran.length; i++) {
              ret[i] = _reduce(tran[i], dim - 1, callback);
            }
            return ret;
          }
        } else {
          ret = [];
          for (i = 0; i < mat.length; i++) {
            ret[i] = _reduce(mat[i], dim - 1, callback);
          }
          return ret;
        }
      }
      function scatter(a, j, w, x, u, mark, cindex, f, inverse, update, value) {
        var avalues = a._values;
        var aindex = a._index;
        var aptr = a._ptr;
        var k, k0, k1, i;
        if (x) {
          for (k0 = aptr[j], k1 = aptr[j + 1], k = k0; k < k1; k++) {
            i = aindex[k];
            if (w[i] !== mark) {
              w[i] = mark;
              cindex.push(i);
              if (update) {
                x[i] = inverse ? f(avalues[k], value) : f(value, avalues[k]);
                u[i] = mark;
              } else {
                x[i] = avalues[k];
              }
            } else {
              x[i] = inverse ? f(avalues[k], x[i]) : f(x[i], avalues[k]);
              u[i] = mark;
            }
          }
        } else {
          for (k0 = aptr[j], k1 = aptr[j + 1], k = k0; k < k1; k++) {
            i = aindex[k];
            if (w[i] !== mark) {
              w[i] = mark;
              cindex.push(i);
            } else {
              u[i] = mark;
            }
          }
        }
      }
    }
  });

  // node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/function/utils/isInteger.js
  var require_isInteger = __commonJS({
    "node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/function/utils/isInteger.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.createIsInteger = void 0;
      var _collection = require_collection();
      var _number = require_number();
      var _factory = require_factory();
      var name18 = "isInteger";
      var dependencies19 = ["typed"];
      var createIsInteger2 = exports.createIsInteger = /* @__PURE__ */ (0, _factory.factory)(name18, dependencies19, function(_ref) {
        var typed2 = _ref.typed;
        return typed2(name18, {
          number: _number.isInteger,
          // TODO: what to do with isInteger(add(0.1, 0.2))  ?
          BigNumber: function BigNumber2(x) {
            return x.isInt();
          },
          Fraction: function Fraction3(x) {
            return x.d === 1 && isFinite(x.n);
          },
          "Array | Matrix": typed2.referToSelf(function(self2) {
            return function(x) {
              return (0, _collection.deepMap)(x, self2);
            };
          })
        });
      });
    }
  });

  // node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/plain/number/arithmetic.js
  var require_arithmetic = __commonJS({
    "node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/plain/number/arithmetic.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.absNumber = absNumber2;
      exports.addNumber = addNumber2;
      exports.cbrtNumber = cbrtNumber2;
      exports.cubeNumber = cubeNumber2;
      exports.divideNumber = divideNumber2;
      exports.expNumber = expNumber2;
      exports.expm1Number = expm1Number2;
      exports.gcdNumber = gcdNumber2;
      exports.lcmNumber = lcmNumber2;
      exports.log10Number = log10Number2;
      exports.log1pNumber = log1pNumber2;
      exports.log2Number = log2Number2;
      exports.logNumber = logNumber;
      exports.modNumber = modNumber2;
      exports.multiplyNumber = multiplyNumber2;
      exports.normNumber = normNumber2;
      exports.nthRootNumber = nthRootNumber;
      exports.powNumber = powNumber2;
      exports.roundNumber = roundNumber;
      exports.signNumber = signNumber2;
      exports.sqrtNumber = sqrtNumber2;
      exports.squareNumber = squareNumber2;
      exports.subtractNumber = subtractNumber2;
      exports.unaryMinusNumber = unaryMinusNumber2;
      exports.unaryPlusNumber = unaryPlusNumber2;
      exports.xgcdNumber = xgcdNumber2;
      var _number = require_number();
      var n12 = "number";
      var n22 = "number, number";
      function absNumber2(a) {
        return Math.abs(a);
      }
      absNumber2.signature = n12;
      function addNumber2(a, b) {
        return a + b;
      }
      addNumber2.signature = n22;
      function subtractNumber2(a, b) {
        return a - b;
      }
      subtractNumber2.signature = n22;
      function multiplyNumber2(a, b) {
        return a * b;
      }
      multiplyNumber2.signature = n22;
      function divideNumber2(a, b) {
        return a / b;
      }
      divideNumber2.signature = n22;
      function unaryMinusNumber2(x) {
        return -x;
      }
      unaryMinusNumber2.signature = n12;
      function unaryPlusNumber2(x) {
        return x;
      }
      unaryPlusNumber2.signature = n12;
      function cbrtNumber2(x) {
        return (0, _number.cbrt)(x);
      }
      cbrtNumber2.signature = n12;
      function cubeNumber2(x) {
        return x * x * x;
      }
      cubeNumber2.signature = n12;
      function expNumber2(x) {
        return Math.exp(x);
      }
      expNumber2.signature = n12;
      function expm1Number2(x) {
        return (0, _number.expm1)(x);
      }
      expm1Number2.signature = n12;
      function gcdNumber2(a, b) {
        if (!(0, _number.isInteger)(a) || !(0, _number.isInteger)(b)) {
          throw new Error("Parameters in function gcd must be integer numbers");
        }
        var r;
        while (b !== 0) {
          r = a % b;
          a = b;
          b = r;
        }
        return a < 0 ? -a : a;
      }
      gcdNumber2.signature = n22;
      function lcmNumber2(a, b) {
        if (!(0, _number.isInteger)(a) || !(0, _number.isInteger)(b)) {
          throw new Error("Parameters in function lcm must be integer numbers");
        }
        if (a === 0 || b === 0) {
          return 0;
        }
        var t;
        var prod = a * b;
        while (b !== 0) {
          t = b;
          b = a % t;
          a = t;
        }
        return Math.abs(prod / a);
      }
      lcmNumber2.signature = n22;
      function logNumber(x, y) {
        if (y) {
          return Math.log(x) / Math.log(y);
        }
        return Math.log(x);
      }
      function log10Number2(x) {
        return (0, _number.log10)(x);
      }
      log10Number2.signature = n12;
      function log2Number2(x) {
        return (0, _number.log2)(x);
      }
      log2Number2.signature = n12;
      function log1pNumber2(x) {
        return (0, _number.log1p)(x);
      }
      log1pNumber2.signature = n12;
      function modNumber2(x, y) {
        return y === 0 ? x : x - y * Math.floor(x / y);
      }
      modNumber2.signature = n22;
      function nthRootNumber(a) {
        var root = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 2;
        var inv = root < 0;
        if (inv) {
          root = -root;
        }
        if (root === 0) {
          throw new Error("Root must be non-zero");
        }
        if (a < 0 && Math.abs(root) % 2 !== 1) {
          throw new Error("Root must be odd when a is negative.");
        }
        if (a === 0) {
          return inv ? Infinity : 0;
        }
        if (!isFinite(a)) {
          return inv ? 0 : a;
        }
        var x = Math.pow(Math.abs(a), 1 / root);
        x = a < 0 ? -x : x;
        return inv ? 1 / x : x;
      }
      function signNumber2(x) {
        return (0, _number.sign)(x);
      }
      signNumber2.signature = n12;
      function sqrtNumber2(x) {
        return Math.sqrt(x);
      }
      sqrtNumber2.signature = n12;
      function squareNumber2(x) {
        return x * x;
      }
      squareNumber2.signature = n12;
      function xgcdNumber2(a, b) {
        var t;
        var q;
        var r;
        var x = 0;
        var lastx = 1;
        var y = 1;
        var lasty = 0;
        if (!(0, _number.isInteger)(a) || !(0, _number.isInteger)(b)) {
          throw new Error("Parameters in function xgcd must be integer numbers");
        }
        while (b) {
          q = Math.floor(a / b);
          r = a - q * b;
          t = x;
          x = lastx - q * x;
          lastx = t;
          t = y;
          y = lasty - q * y;
          lasty = t;
          a = b;
          b = r;
        }
        var res;
        if (a < 0) {
          res = [-a, -lastx, -lasty];
        } else {
          res = [a, a ? lastx : 0, lasty];
        }
        return res;
      }
      xgcdNumber2.signature = n22;
      function powNumber2(x, y) {
        if (x * x < 1 && y === Infinity || x * x > 1 && y === -Infinity) {
          return 0;
        }
        return Math.pow(x, y);
      }
      powNumber2.signature = n22;
      function roundNumber(value) {
        var decimals = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0;
        if (!(0, _number.isInteger)(decimals) || decimals < 0 || decimals > 15) {
          throw new Error("Number of decimals in function round must be an integer from 0 to 15 inclusive");
        }
        return parseFloat((0, _number.toFixed)(value, decimals));
      }
      function normNumber2(x) {
        return Math.abs(x);
      }
      normNumber2.signature = n12;
    }
  });

  // node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/plain/number/bitwise.js
  var require_bitwise = __commonJS({
    "node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/plain/number/bitwise.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.bitAndNumber = bitAndNumber;
      exports.bitNotNumber = bitNotNumber;
      exports.bitOrNumber = bitOrNumber;
      exports.bitXorNumber = bitXorNumber;
      exports.leftShiftNumber = leftShiftNumber;
      exports.rightArithShiftNumber = rightArithShiftNumber;
      exports.rightLogShiftNumber = rightLogShiftNumber;
      var _number = require_number();
      var n12 = "number";
      var n22 = "number, number";
      function bitAndNumber(x, y) {
        if (!(0, _number.isInteger)(x) || !(0, _number.isInteger)(y)) {
          throw new Error("Integers expected in function bitAnd");
        }
        return x & y;
      }
      bitAndNumber.signature = n22;
      function bitNotNumber(x) {
        if (!(0, _number.isInteger)(x)) {
          throw new Error("Integer expected in function bitNot");
        }
        return ~x;
      }
      bitNotNumber.signature = n12;
      function bitOrNumber(x, y) {
        if (!(0, _number.isInteger)(x) || !(0, _number.isInteger)(y)) {
          throw new Error("Integers expected in function bitOr");
        }
        return x | y;
      }
      bitOrNumber.signature = n22;
      function bitXorNumber(x, y) {
        if (!(0, _number.isInteger)(x) || !(0, _number.isInteger)(y)) {
          throw new Error("Integers expected in function bitXor");
        }
        return x ^ y;
      }
      bitXorNumber.signature = n22;
      function leftShiftNumber(x, y) {
        if (!(0, _number.isInteger)(x) || !(0, _number.isInteger)(y)) {
          throw new Error("Integers expected in function leftShift");
        }
        return x << y;
      }
      leftShiftNumber.signature = n22;
      function rightArithShiftNumber(x, y) {
        if (!(0, _number.isInteger)(x) || !(0, _number.isInteger)(y)) {
          throw new Error("Integers expected in function rightArithShift");
        }
        return x >> y;
      }
      rightArithShiftNumber.signature = n22;
      function rightLogShiftNumber(x, y) {
        if (!(0, _number.isInteger)(x) || !(0, _number.isInteger)(y)) {
          throw new Error("Integers expected in function rightLogShift");
        }
        return x >>> y;
      }
      rightLogShiftNumber.signature = n22;
    }
  });

  // node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/utils/product.js
  var require_product = __commonJS({
    "node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/utils/product.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.product = product2;
      function product2(i, n) {
        if (n < i) {
          return 1;
        }
        if (n === i) {
          return n;
        }
        var half = n + i >> 1;
        return product2(i, half) * product2(half + 1, n);
      }
    }
  });

  // node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/plain/number/combinations.js
  var require_combinations = __commonJS({
    "node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/plain/number/combinations.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.combinationsNumber = combinationsNumber;
      var _number = require_number();
      var _product = require_product();
      function combinationsNumber(n, k) {
        if (!(0, _number.isInteger)(n) || n < 0) {
          throw new TypeError("Positive integer value expected in function combinations");
        }
        if (!(0, _number.isInteger)(k) || k < 0) {
          throw new TypeError("Positive integer value expected in function combinations");
        }
        if (k > n) {
          throw new TypeError("k must be less than or equal to n");
        }
        var nMinusk = n - k;
        var answer = 1;
        var firstnumerator = k < nMinusk ? nMinusk + 1 : k + 1;
        var nextdivisor = 2;
        var lastdivisor = k < nMinusk ? k : nMinusk;
        for (var nextnumerator = firstnumerator; nextnumerator <= n; ++nextnumerator) {
          answer *= nextnumerator;
          while (nextdivisor <= lastdivisor && answer % nextdivisor === 0) {
            answer /= nextdivisor;
            ++nextdivisor;
          }
        }
        if (nextdivisor <= lastdivisor) {
          answer /= (0, _product.product)(nextdivisor, lastdivisor);
        }
        return answer;
      }
      combinationsNumber.signature = "number, number";
    }
  });

  // node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/plain/number/constants.js
  var require_constants = __commonJS({
    "node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/plain/number/constants.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.tau = exports.pi = exports.phi = exports.e = void 0;
      var pi = exports.pi = Math.PI;
      var tau = exports.tau = 2 * Math.PI;
      var e = exports.e = Math.E;
      var phi = exports.phi = 1.618033988749895;
    }
  });

  // node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/plain/number/logical.js
  var require_logical = __commonJS({
    "node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/plain/number/logical.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.andNumber = andNumber;
      exports.notNumber = notNumber;
      exports.orNumber = orNumber;
      exports.xorNumber = xorNumber;
      var n12 = "number";
      var n22 = "number, number";
      function notNumber(x) {
        return !x;
      }
      notNumber.signature = n12;
      function orNumber(x, y) {
        return !!(x || y);
      }
      orNumber.signature = n22;
      function xorNumber(x, y) {
        return !!x !== !!y;
      }
      xorNumber.signature = n22;
      function andNumber(x, y) {
        return !!(x && y);
      }
      andNumber.signature = n22;
    }
  });

  // node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/plain/number/relational.js
  var require_relational = __commonJS({
    "node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/plain/number/relational.js"() {
      "use strict";
    }
  });

  // node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/plain/number/probability.js
  var require_probability = __commonJS({
    "node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/plain/number/probability.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.gammaG = void 0;
      exports.gammaNumber = gammaNumber;
      exports.lgammaN = exports.lgammaG = exports.gammaP = void 0;
      exports.lgammaNumber = lgammaNumber;
      exports.lnSqrt2PI = exports.lgammaSeries = void 0;
      var _number = require_number();
      var _product = require_product();
      function gammaNumber(n) {
        var x;
        if ((0, _number.isInteger)(n)) {
          if (n <= 0) {
            return isFinite(n) ? Infinity : NaN;
          }
          if (n > 171) {
            return Infinity;
          }
          return (0, _product.product)(1, n - 1);
        }
        if (n < 0.5) {
          return Math.PI / (Math.sin(Math.PI * n) * gammaNumber(1 - n));
        }
        if (n >= 171.35) {
          return Infinity;
        }
        if (n > 85) {
          var twoN = n * n;
          var threeN = twoN * n;
          var fourN = threeN * n;
          var fiveN = fourN * n;
          return Math.sqrt(2 * Math.PI / n) * Math.pow(n / Math.E, n) * (1 + 1 / (12 * n) + 1 / (288 * twoN) - 139 / (51840 * threeN) - 571 / (2488320 * fourN) + 163879 / (209018880 * fiveN) + 5246819 / (75246796800 * fiveN * n));
        }
        --n;
        x = gammaP[0];
        for (var i = 1; i < gammaP.length; ++i) {
          x += gammaP[i] / (n + i);
        }
        var t = n + gammaG + 0.5;
        return Math.sqrt(2 * Math.PI) * Math.pow(t, n + 0.5) * Math.exp(-t) * x;
      }
      gammaNumber.signature = "number";
      var gammaG = exports.gammaG = 4.7421875;
      var gammaP = exports.gammaP = [0.9999999999999971, 57.15623566586292, -59.59796035547549, 14.136097974741746, -0.4919138160976202, 3399464998481189e-20, 4652362892704858e-20, -9837447530487956e-20, 1580887032249125e-19, -21026444172410488e-20, 21743961811521265e-20, -1643181065367639e-19, 8441822398385275e-20, -26190838401581408e-21, 36899182659531625e-22];
      var lnSqrt2PI = exports.lnSqrt2PI = 0.9189385332046728;
      var lgammaG = exports.lgammaG = 5;
      var lgammaN = exports.lgammaN = 7;
      var lgammaSeries = exports.lgammaSeries = [1.000000000190015, 76.18009172947146, -86.50532032941678, 24.01409824083091, -1.231739572450155, 0.001208650973866179, -5395239384953e-18];
      function lgammaNumber(n) {
        if (n < 0) return NaN;
        if (n === 0) return Infinity;
        if (!isFinite(n)) return n;
        if (n < 0.5) {
          return Math.log(Math.PI / Math.sin(Math.PI * n)) - lgammaNumber(1 - n);
        }
        n = n - 1;
        var base = n + lgammaG + 0.5;
        var sum2 = lgammaSeries[0];
        for (var i = lgammaN - 1; i >= 1; i--) {
          sum2 += lgammaSeries[i] / (n + i);
        }
        return lnSqrt2PI + (n + 0.5) * Math.log(base) - base + Math.log(sum2);
      }
      lgammaNumber.signature = "number";
    }
  });

  // node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/plain/number/trigonometry.js
  var require_trigonometry = __commonJS({
    "node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/plain/number/trigonometry.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.acosNumber = acosNumber;
      exports.acoshNumber = acoshNumber;
      exports.acotNumber = acotNumber;
      exports.acothNumber = acothNumber;
      exports.acscNumber = acscNumber;
      exports.acschNumber = acschNumber;
      exports.asecNumber = asecNumber;
      exports.asechNumber = asechNumber;
      exports.asinNumber = asinNumber;
      exports.asinhNumber = asinhNumber;
      exports.atan2Number = atan2Number;
      exports.atanNumber = atanNumber;
      exports.atanhNumber = atanhNumber;
      exports.cosNumber = cosNumber;
      exports.coshNumber = coshNumber;
      exports.cotNumber = cotNumber;
      exports.cothNumber = cothNumber;
      exports.cscNumber = cscNumber;
      exports.cschNumber = cschNumber;
      exports.secNumber = secNumber;
      exports.sechNumber = sechNumber;
      exports.sinNumber = sinNumber;
      exports.sinhNumber = sinhNumber;
      exports.tanNumber = tanNumber;
      exports.tanhNumber = tanhNumber;
      var _number = require_number();
      var n12 = "number";
      var n22 = "number, number";
      function acosNumber(x) {
        return Math.acos(x);
      }
      acosNumber.signature = n12;
      function acoshNumber(x) {
        return (0, _number.acosh)(x);
      }
      acoshNumber.signature = n12;
      function acotNumber(x) {
        return Math.atan(1 / x);
      }
      acotNumber.signature = n12;
      function acothNumber(x) {
        return isFinite(x) ? (Math.log((x + 1) / x) + Math.log(x / (x - 1))) / 2 : 0;
      }
      acothNumber.signature = n12;
      function acscNumber(x) {
        return Math.asin(1 / x);
      }
      acscNumber.signature = n12;
      function acschNumber(x) {
        var xInv = 1 / x;
        return Math.log(xInv + Math.sqrt(xInv * xInv + 1));
      }
      acschNumber.signature = n12;
      function asecNumber(x) {
        return Math.acos(1 / x);
      }
      asecNumber.signature = n12;
      function asechNumber(x) {
        var xInv = 1 / x;
        var ret = Math.sqrt(xInv * xInv - 1);
        return Math.log(ret + xInv);
      }
      asechNumber.signature = n12;
      function asinNumber(x) {
        return Math.asin(x);
      }
      asinNumber.signature = n12;
      function asinhNumber(x) {
        return (0, _number.asinh)(x);
      }
      asinhNumber.signature = n12;
      function atanNumber(x) {
        return Math.atan(x);
      }
      atanNumber.signature = n12;
      function atan2Number(y, x) {
        return Math.atan2(y, x);
      }
      atan2Number.signature = n22;
      function atanhNumber(x) {
        return (0, _number.atanh)(x);
      }
      atanhNumber.signature = n12;
      function cosNumber(x) {
        return Math.cos(x);
      }
      cosNumber.signature = n12;
      function coshNumber(x) {
        return (0, _number.cosh)(x);
      }
      coshNumber.signature = n12;
      function cotNumber(x) {
        return 1 / Math.tan(x);
      }
      cotNumber.signature = n12;
      function cothNumber(x) {
        var e = Math.exp(2 * x);
        return (e + 1) / (e - 1);
      }
      cothNumber.signature = n12;
      function cscNumber(x) {
        return 1 / Math.sin(x);
      }
      cscNumber.signature = n12;
      function cschNumber(x) {
        if (x === 0) {
          return Number.POSITIVE_INFINITY;
        } else {
          return Math.abs(2 / (Math.exp(x) - Math.exp(-x))) * (0, _number.sign)(x);
        }
      }
      cschNumber.signature = n12;
      function secNumber(x) {
        return 1 / Math.cos(x);
      }
      secNumber.signature = n12;
      function sechNumber(x) {
        return 2 / (Math.exp(x) + Math.exp(-x));
      }
      sechNumber.signature = n12;
      function sinNumber(x) {
        return Math.sin(x);
      }
      sinNumber.signature = n12;
      function sinhNumber(x) {
        return (0, _number.sinh)(x);
      }
      sinhNumber.signature = n12;
      function tanNumber(x) {
        return Math.tan(x);
      }
      tanNumber.signature = n12;
      function tanhNumber(x) {
        return (0, _number.tanh)(x);
      }
      tanhNumber.signature = n12;
    }
  });

  // node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/plain/number/utils.js
  var require_utils = __commonJS({
    "node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/plain/number/utils.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.isIntegerNumber = isIntegerNumber;
      exports.isNaNNumber = isNaNNumber;
      exports.isNegativeNumber = isNegativeNumber;
      exports.isPositiveNumber = isPositiveNumber;
      exports.isZeroNumber = isZeroNumber;
      var _number = require_number();
      var n12 = "number";
      function isIntegerNumber(x) {
        return (0, _number.isInteger)(x);
      }
      isIntegerNumber.signature = n12;
      function isNegativeNumber(x) {
        return x < 0;
      }
      isNegativeNumber.signature = n12;
      function isPositiveNumber(x) {
        return x > 0;
      }
      isPositiveNumber.signature = n12;
      function isZeroNumber(x) {
        return x === 0;
      }
      isZeroNumber.signature = n12;
      function isNaNNumber(x) {
        return Number.isNaN(x);
      }
      isNaNNumber.signature = n12;
    }
  });

  // node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/plain/number/index.js
  var require_number2 = __commonJS({
    "node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/plain/number/index.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      var _arithmetic = require_arithmetic();
      Object.keys(_arithmetic).forEach(function(key) {
        if (key === "default" || key === "__esModule") return;
        if (key in exports && exports[key] === _arithmetic[key]) return;
        Object.defineProperty(exports, key, {
          enumerable: true,
          get: function get() {
            return _arithmetic[key];
          }
        });
      });
      var _bitwise = require_bitwise();
      Object.keys(_bitwise).forEach(function(key) {
        if (key === "default" || key === "__esModule") return;
        if (key in exports && exports[key] === _bitwise[key]) return;
        Object.defineProperty(exports, key, {
          enumerable: true,
          get: function get() {
            return _bitwise[key];
          }
        });
      });
      var _combinations = require_combinations();
      Object.keys(_combinations).forEach(function(key) {
        if (key === "default" || key === "__esModule") return;
        if (key in exports && exports[key] === _combinations[key]) return;
        Object.defineProperty(exports, key, {
          enumerable: true,
          get: function get() {
            return _combinations[key];
          }
        });
      });
      var _constants = require_constants();
      Object.keys(_constants).forEach(function(key) {
        if (key === "default" || key === "__esModule") return;
        if (key in exports && exports[key] === _constants[key]) return;
        Object.defineProperty(exports, key, {
          enumerable: true,
          get: function get() {
            return _constants[key];
          }
        });
      });
      var _logical = require_logical();
      Object.keys(_logical).forEach(function(key) {
        if (key === "default" || key === "__esModule") return;
        if (key in exports && exports[key] === _logical[key]) return;
        Object.defineProperty(exports, key, {
          enumerable: true,
          get: function get() {
            return _logical[key];
          }
        });
      });
      var _relational = require_relational();
      Object.keys(_relational).forEach(function(key) {
        if (key === "default" || key === "__esModule") return;
        if (key in exports && exports[key] === _relational[key]) return;
        Object.defineProperty(exports, key, {
          enumerable: true,
          get: function get() {
            return _relational[key];
          }
        });
      });
      var _probability = require_probability();
      Object.keys(_probability).forEach(function(key) {
        if (key === "default" || key === "__esModule") return;
        if (key in exports && exports[key] === _probability[key]) return;
        Object.defineProperty(exports, key, {
          enumerable: true,
          get: function get() {
            return _probability[key];
          }
        });
      });
      var _trigonometry = require_trigonometry();
      Object.keys(_trigonometry).forEach(function(key) {
        if (key === "default" || key === "__esModule") return;
        if (key in exports && exports[key] === _trigonometry[key]) return;
        Object.defineProperty(exports, key, {
          enumerable: true,
          get: function get() {
            return _trigonometry[key];
          }
        });
      });
      var _utils = require_utils();
      Object.keys(_utils).forEach(function(key) {
        if (key === "default" || key === "__esModule") return;
        if (key in exports && exports[key] === _utils[key]) return;
        Object.defineProperty(exports, key, {
          enumerable: true,
          get: function get() {
            return _utils[key];
          }
        });
      });
    }
  });

  // node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/function/utils/isNegative.js
  var require_isNegative = __commonJS({
    "node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/function/utils/isNegative.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.createIsNegative = void 0;
      var _collection = require_collection();
      var _factory = require_factory();
      var _index = require_number2();
      var name18 = "isNegative";
      var dependencies19 = ["typed"];
      var createIsNegative2 = exports.createIsNegative = /* @__PURE__ */ (0, _factory.factory)(name18, dependencies19, function(_ref) {
        var typed2 = _ref.typed;
        return typed2(name18, {
          number: _index.isNegativeNumber,
          BigNumber: function BigNumber2(x) {
            return x.isNeg() && !x.isZero() && !x.isNaN();
          },
          Fraction: function Fraction3(x) {
            return x.s < 0;
          },
          Unit: typed2.referToSelf(function(self2) {
            return function(x) {
              return typed2.find(self2, x.valueType())(x.value);
            };
          }),
          "Array | Matrix": typed2.referToSelf(function(self2) {
            return function(x) {
              return (0, _collection.deepMap)(x, self2);
            };
          })
        });
      });
    }
  });

  // node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/function/utils/isNumeric.js
  var require_isNumeric = __commonJS({
    "node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/function/utils/isNumeric.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.createIsNumeric = void 0;
      var _collection = require_collection();
      var _factory = require_factory();
      var name18 = "isNumeric";
      var dependencies19 = ["typed"];
      var createIsNumeric2 = exports.createIsNumeric = /* @__PURE__ */ (0, _factory.factory)(name18, dependencies19, function(_ref) {
        var typed2 = _ref.typed;
        return typed2(name18, {
          "number | BigNumber | Fraction | boolean": function numberBigNumberFractionBoolean() {
            return true;
          },
          "Complex | Unit | string | null | undefined | Node": function ComplexUnitStringNullUndefinedNode() {
            return false;
          },
          "Array | Matrix": typed2.referToSelf(function(self2) {
            return function(x) {
              return (0, _collection.deepMap)(x, self2);
            };
          })
        });
      });
    }
  });

  // node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/function/utils/hasNumericValue.js
  var require_hasNumericValue = __commonJS({
    "node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/function/utils/hasNumericValue.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.createHasNumericValue = void 0;
      var _factory = require_factory();
      var name18 = "hasNumericValue";
      var dependencies19 = ["typed", "isNumeric"];
      var createHasNumericValue2 = exports.createHasNumericValue = /* @__PURE__ */ (0, _factory.factory)(name18, dependencies19, function(_ref) {
        var typed2 = _ref.typed, isNumeric = _ref.isNumeric;
        return typed2(name18, {
          "boolean": function boolean() {
            return true;
          },
          string: function string(x) {
            return x.trim().length > 0 && !isNaN(Number(x));
          },
          any: function any(x) {
            return isNumeric(x);
          }
        });
      });
    }
  });

  // node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/function/utils/isPositive.js
  var require_isPositive = __commonJS({
    "node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/function/utils/isPositive.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.createIsPositive = void 0;
      var _collection = require_collection();
      var _factory = require_factory();
      var _index = require_number2();
      var name18 = "isPositive";
      var dependencies19 = ["typed"];
      var createIsPositive2 = exports.createIsPositive = /* @__PURE__ */ (0, _factory.factory)(name18, dependencies19, function(_ref) {
        var typed2 = _ref.typed;
        return typed2(name18, {
          number: _index.isPositiveNumber,
          BigNumber: function BigNumber2(x) {
            return !x.isNeg() && !x.isZero() && !x.isNaN();
          },
          Fraction: function Fraction3(x) {
            return x.s > 0 && x.n > 0;
          },
          Unit: typed2.referToSelf(function(self2) {
            return function(x) {
              return typed2.find(self2, x.valueType())(x.value);
            };
          }),
          "Array | Matrix": typed2.referToSelf(function(self2) {
            return function(x) {
              return (0, _collection.deepMap)(x, self2);
            };
          })
        });
      });
    }
  });

  // node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/function/utils/isZero.js
  var require_isZero = __commonJS({
    "node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/function/utils/isZero.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.createIsZero = void 0;
      var _collection = require_collection();
      var _factory = require_factory();
      var _index = require_number2();
      var name18 = "isZero";
      var dependencies19 = ["typed"];
      var createIsZero2 = exports.createIsZero = /* @__PURE__ */ (0, _factory.factory)(name18, dependencies19, function(_ref) {
        var typed2 = _ref.typed;
        return typed2(name18, {
          number: _index.isZeroNumber,
          BigNumber: function BigNumber2(x) {
            return x.isZero();
          },
          Complex: function Complex3(x) {
            return x.re === 0 && x.im === 0;
          },
          Fraction: function Fraction3(x) {
            return x.d === 1 && x.n === 0;
          },
          Unit: typed2.referToSelf(function(self2) {
            return function(x) {
              return typed2.find(self2, x.valueType())(x.value);
            };
          }),
          "Array | Matrix": typed2.referToSelf(function(self2) {
            return function(x) {
              return (0, _collection.deepMap)(x, self2);
            };
          })
        });
      });
    }
  });

  // node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/function/utils/isNaN.js
  var require_isNaN = __commonJS({
    "node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/function/utils/isNaN.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.createIsNaN = void 0;
      var _collection = require_collection();
      var _factory = require_factory();
      var _index = require_number2();
      var name18 = "isNaN";
      var dependencies19 = ["typed"];
      var createIsNaN2 = exports.createIsNaN = /* @__PURE__ */ (0, _factory.factory)(name18, dependencies19, function(_ref) {
        var typed2 = _ref.typed;
        return typed2(name18, {
          number: _index.isNaNNumber,
          BigNumber: function BigNumber2(x) {
            return x.isNaN();
          },
          Fraction: function Fraction3(x) {
            return false;
          },
          Complex: function Complex3(x) {
            return x.isNaN();
          },
          Unit: function Unit(x) {
            return Number.isNaN(x.value);
          },
          "Array | Matrix": typed2.referToSelf(function(self2) {
            return function(x) {
              return (0, _collection.deepMap)(x, self2);
            };
          })
        });
      });
    }
  });

  // node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/function/utils/typeOf.js
  var require_typeOf = __commonJS({
    "node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/function/utils/typeOf.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.createTypeOf = void 0;
      var _factory = require_factory();
      var _is = require_is();
      var name18 = "typeOf";
      var dependencies19 = ["typed"];
      var createTypeOf2 = exports.createTypeOf = /* @__PURE__ */ (0, _factory.factory)(name18, dependencies19, function(_ref) {
        var typed2 = _ref.typed;
        return typed2(name18, {
          any: _is.typeOf
        });
      });
    }
  });

  // node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/utils/bignumber/nearlyEqual.js
  var require_nearlyEqual = __commonJS({
    "node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/utils/bignumber/nearlyEqual.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.nearlyEqual = nearlyEqual3;
      function nearlyEqual3(x, y, epsilon) {
        if (epsilon === null || epsilon === void 0) {
          return x.eq(y);
        }
        if (x.eq(y)) {
          return true;
        }
        if (x.isNaN() || y.isNaN()) {
          return false;
        }
        if (x.isFinite() && y.isFinite()) {
          var diff = x.minus(y).abs();
          if (diff.isZero()) {
            return true;
          } else {
            var max2 = x.constructor.max(x.abs(), y.abs());
            return diff.lte(max2.times(epsilon));
          }
        }
        return false;
      }
    }
  });

  // node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/utils/complex.js
  var require_complex2 = __commonJS({
    "node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/utils/complex.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.complexEquals = complexEquals2;
      var _number = require_number();
      function complexEquals2(x, y, epsilon) {
        return (0, _number.nearlyEqual)(x.re, y.re, epsilon) && (0, _number.nearlyEqual)(x.im, y.im, epsilon);
      }
    }
  });

  // node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/function/relational/compareUnits.js
  var require_compareUnits = __commonJS({
    "node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/function/relational/compareUnits.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.createCompareUnits = void 0;
      var _factory = require_factory();
      var createCompareUnits2 = exports.createCompareUnits = /* @__PURE__ */ (0, _factory.factory)("compareUnits", ["typed"], function(_ref) {
        var typed2 = _ref.typed;
        return {
          "Unit, Unit": typed2.referToSelf(function(self2) {
            return function(x, y) {
              if (!x.equalBase(y)) {
                throw new Error("Cannot compare units with different base");
              }
              return typed2.find(self2, [x.valueType(), y.valueType()])(x.value, y.value);
            };
          })
        };
      });
    }
  });

  // node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/function/relational/equalScalar.js
  var require_equalScalar = __commonJS({
    "node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/function/relational/equalScalar.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.createEqualScalarNumber = exports.createEqualScalar = void 0;
      var _nearlyEqual = require_nearlyEqual();
      var _number = require_number();
      var _factory = require_factory();
      var _complex = require_complex2();
      var _compareUnits = require_compareUnits();
      var name18 = "equalScalar";
      var dependencies19 = ["typed", "config"];
      var createEqualScalar2 = exports.createEqualScalar = /* @__PURE__ */ (0, _factory.factory)(name18, dependencies19, function(_ref) {
        var typed2 = _ref.typed, config4 = _ref.config;
        var compareUnits = (0, _compareUnits.createCompareUnits)({
          typed: typed2
        });
        return typed2(name18, {
          "boolean, boolean": function booleanBoolean(x, y) {
            return x === y;
          },
          "number, number": function numberNumber(x, y) {
            return (0, _number.nearlyEqual)(x, y, config4.epsilon);
          },
          "BigNumber, BigNumber": function BigNumberBigNumber(x, y) {
            return x.eq(y) || (0, _nearlyEqual.nearlyEqual)(x, y, config4.epsilon);
          },
          "Fraction, Fraction": function FractionFraction(x, y) {
            return x.equals(y);
          },
          "Complex, Complex": function ComplexComplex(x, y) {
            return (0, _complex.complexEquals)(x, y, config4.epsilon);
          }
        }, compareUnits);
      });
      var createEqualScalarNumber2 = exports.createEqualScalarNumber = (0, _factory.factory)(name18, ["typed", "config"], function(_ref2) {
        var typed2 = _ref2.typed, config4 = _ref2.config;
        return typed2(name18, {
          "number, number": function numberNumber(x, y) {
            return (0, _number.nearlyEqual)(x, y, config4.epsilon);
          }
        });
      });
    }
  });

  // node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/type/matrix/SparseMatrix.js
  var require_SparseMatrix = __commonJS({
    "node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/type/matrix/SparseMatrix.js"(exports) {
      "use strict";
      var _interopRequireDefault = require_interopRequireDefault();
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.createSparseMatrixClass = void 0;
      var _regenerator = _interopRequireDefault(require_regenerator2());
      var _is = require_is();
      var _number = require_number();
      var _string = require_string();
      var _object = require_object();
      var _array = require_array();
      var _factory = require_factory();
      var _DimensionError = require_DimensionError();
      var _function = require_function();
      var name18 = "SparseMatrix";
      var dependencies19 = ["typed", "equalScalar", "Matrix"];
      var createSparseMatrixClass2 = exports.createSparseMatrixClass = /* @__PURE__ */ (0, _factory.factory)(name18, dependencies19, function(_ref) {
        var typed2 = _ref.typed, equalScalar2 = _ref.equalScalar, Matrix2 = _ref.Matrix;
        function SparseMatrix2(data, datatype) {
          if (!(this instanceof SparseMatrix2)) {
            throw new SyntaxError("Constructor must be called with the new operator");
          }
          if (datatype && !(0, _is.isString)(datatype)) {
            throw new Error("Invalid datatype: " + datatype);
          }
          if ((0, _is.isMatrix)(data)) {
            _createFromMatrix(this, data, datatype);
          } else if (data && (0, _is.isArray)(data.index) && (0, _is.isArray)(data.ptr) && (0, _is.isArray)(data.size)) {
            this._values = data.values;
            this._index = data.index;
            this._ptr = data.ptr;
            this._size = data.size;
            this._datatype = datatype || data.datatype;
          } else if ((0, _is.isArray)(data)) {
            _createFromArray(this, data, datatype);
          } else if (data) {
            throw new TypeError("Unsupported type of data (" + (0, _is.typeOf)(data) + ")");
          } else {
            this._values = [];
            this._index = [];
            this._ptr = [0];
            this._size = [0, 0];
            this._datatype = datatype;
          }
        }
        function _createFromMatrix(matrix2, source, datatype) {
          if (source.type === "SparseMatrix") {
            matrix2._values = source._values ? (0, _object.clone)(source._values) : void 0;
            matrix2._index = (0, _object.clone)(source._index);
            matrix2._ptr = (0, _object.clone)(source._ptr);
            matrix2._size = (0, _object.clone)(source._size);
            matrix2._datatype = datatype || source._datatype;
          } else {
            _createFromArray(matrix2, source.valueOf(), datatype || source._datatype);
          }
        }
        function _createFromArray(matrix2, data, datatype) {
          matrix2._values = [];
          matrix2._index = [];
          matrix2._ptr = [];
          matrix2._datatype = datatype;
          var rows = data.length;
          var columns = 0;
          var eq = equalScalar2;
          var zero = 0;
          if ((0, _is.isString)(datatype)) {
            eq = typed2.find(equalScalar2, [datatype, datatype]) || equalScalar2;
            zero = typed2.convert(0, datatype);
          }
          if (rows > 0) {
            var j = 0;
            do {
              matrix2._ptr.push(matrix2._index.length);
              for (var i = 0; i < rows; i++) {
                var row = data[i];
                if ((0, _is.isArray)(row)) {
                  if (j === 0 && columns < row.length) {
                    columns = row.length;
                  }
                  if (j < row.length) {
                    var v = row[j];
                    if (!eq(v, zero)) {
                      matrix2._values.push(v);
                      matrix2._index.push(i);
                    }
                  }
                } else {
                  if (j === 0 && columns < 1) {
                    columns = 1;
                  }
                  if (!eq(row, zero)) {
                    matrix2._values.push(row);
                    matrix2._index.push(i);
                  }
                }
              }
              j++;
            } while (j < columns);
          }
          matrix2._ptr.push(matrix2._index.length);
          matrix2._size = [rows, columns];
        }
        SparseMatrix2.prototype = new Matrix2();
        SparseMatrix2.prototype.createSparseMatrix = function(data, datatype) {
          return new SparseMatrix2(data, datatype);
        };
        Object.defineProperty(SparseMatrix2, "name", {
          value: "SparseMatrix"
        });
        SparseMatrix2.prototype.constructor = SparseMatrix2;
        SparseMatrix2.prototype.type = "SparseMatrix";
        SparseMatrix2.prototype.isSparseMatrix = true;
        SparseMatrix2.prototype.getDataType = function() {
          return (0, _array.getArrayDataType)(this._values, _is.typeOf);
        };
        SparseMatrix2.prototype.storage = function() {
          return "sparse";
        };
        SparseMatrix2.prototype.datatype = function() {
          return this._datatype;
        };
        SparseMatrix2.prototype.create = function(data, datatype) {
          return new SparseMatrix2(data, datatype);
        };
        SparseMatrix2.prototype.density = function() {
          var rows = this._size[0];
          var columns = this._size[1];
          return rows !== 0 && columns !== 0 ? this._index.length / (rows * columns) : 0;
        };
        SparseMatrix2.prototype.subset = function(index, replacement, defaultValue) {
          if (!this._values) {
            throw new Error("Cannot invoke subset on a Pattern only matrix");
          }
          switch (arguments.length) {
            case 1:
              return _getsubset(this, index);
            // intentional fall through
            case 2:
            case 3:
              return _setsubset(this, index, replacement, defaultValue);
            default:
              throw new SyntaxError("Wrong number of arguments");
          }
        };
        function _getsubset(matrix2, idx) {
          if (!(0, _is.isIndex)(idx)) {
            throw new TypeError("Invalid index");
          }
          var isScalar = idx.isScalar();
          if (isScalar) {
            return matrix2.get(idx.min());
          }
          var size2 = idx.size();
          if (size2.length !== matrix2._size.length) {
            throw new _DimensionError.DimensionError(size2.length, matrix2._size.length);
          }
          var i, ii, k, kk;
          var min2 = idx.min();
          var max2 = idx.max();
          for (i = 0, ii = matrix2._size.length; i < ii; i++) {
            (0, _array.validateIndex)(min2[i], matrix2._size[i]);
            (0, _array.validateIndex)(max2[i], matrix2._size[i]);
          }
          var mvalues = matrix2._values;
          var mindex = matrix2._index;
          var mptr = matrix2._ptr;
          var rows = idx.dimension(0);
          var columns = idx.dimension(1);
          var w = [];
          var pv = [];
          rows.forEach(function(i2, r) {
            pv[i2] = r[0];
            w[i2] = true;
          });
          var values = mvalues ? [] : void 0;
          var index = [];
          var ptr = [];
          columns.forEach(function(j) {
            ptr.push(index.length);
            for (k = mptr[j], kk = mptr[j + 1]; k < kk; k++) {
              i = mindex[k];
              if (w[i] === true) {
                index.push(pv[i]);
                if (values) {
                  values.push(mvalues[k]);
                }
              }
            }
          });
          ptr.push(index.length);
          return new SparseMatrix2({
            values,
            index,
            ptr,
            size: size2,
            datatype: matrix2._datatype
          });
        }
        function _setsubset(matrix2, index, submatrix, defaultValue) {
          if (!index || index.isIndex !== true) {
            throw new TypeError("Invalid index");
          }
          var iSize = index.size();
          var isScalar = index.isScalar();
          var sSize;
          if ((0, _is.isMatrix)(submatrix)) {
            sSize = submatrix.size();
            submatrix = submatrix.toArray();
          } else {
            sSize = (0, _array.arraySize)(submatrix);
          }
          if (isScalar) {
            if (sSize.length !== 0) {
              throw new TypeError("Scalar expected");
            }
            matrix2.set(index.min(), submatrix, defaultValue);
          } else {
            if (iSize.length !== 1 && iSize.length !== 2) {
              throw new _DimensionError.DimensionError(iSize.length, matrix2._size.length, "<");
            }
            if (sSize.length < iSize.length) {
              var i = 0;
              var outer = 0;
              while (iSize[i] === 1 && sSize[i] === 1) {
                i++;
              }
              while (iSize[i] === 1) {
                outer++;
                i++;
              }
              submatrix = (0, _array.unsqueeze)(submatrix, iSize.length, outer, sSize);
            }
            if (!(0, _object.deepStrictEqual)(iSize, sSize)) {
              throw new _DimensionError.DimensionError(iSize, sSize, ">");
            }
            if (iSize.length === 1) {
              var range = index.dimension(0);
              range.forEach(function(dataIndex, subIndex) {
                (0, _array.validateIndex)(dataIndex);
                matrix2.set([dataIndex, 0], submatrix[subIndex[0]], defaultValue);
              });
            } else {
              var firstDimensionRange = index.dimension(0);
              var secondDimensionRange = index.dimension(1);
              firstDimensionRange.forEach(function(firstDataIndex, firstSubIndex) {
                (0, _array.validateIndex)(firstDataIndex);
                secondDimensionRange.forEach(function(secondDataIndex, secondSubIndex) {
                  (0, _array.validateIndex)(secondDataIndex);
                  matrix2.set([firstDataIndex, secondDataIndex], submatrix[firstSubIndex[0]][secondSubIndex[0]], defaultValue);
                });
              });
            }
          }
          return matrix2;
        }
        SparseMatrix2.prototype.get = function(index) {
          if (!(0, _is.isArray)(index)) {
            throw new TypeError("Array expected");
          }
          if (index.length !== this._size.length) {
            throw new _DimensionError.DimensionError(index.length, this._size.length);
          }
          if (!this._values) {
            throw new Error("Cannot invoke get on a Pattern only matrix");
          }
          var i = index[0];
          var j = index[1];
          (0, _array.validateIndex)(i, this._size[0]);
          (0, _array.validateIndex)(j, this._size[1]);
          var k = _getValueIndex(i, this._ptr[j], this._ptr[j + 1], this._index);
          if (k < this._ptr[j + 1] && this._index[k] === i) {
            return this._values[k];
          }
          return 0;
        };
        SparseMatrix2.prototype.set = function(index, v, defaultValue) {
          if (!(0, _is.isArray)(index)) {
            throw new TypeError("Array expected");
          }
          if (index.length !== this._size.length) {
            throw new _DimensionError.DimensionError(index.length, this._size.length);
          }
          if (!this._values) {
            throw new Error("Cannot invoke set on a Pattern only matrix");
          }
          var i = index[0];
          var j = index[1];
          var rows = this._size[0];
          var columns = this._size[1];
          var eq = equalScalar2;
          var zero = 0;
          if ((0, _is.isString)(this._datatype)) {
            eq = typed2.find(equalScalar2, [this._datatype, this._datatype]) || equalScalar2;
            zero = typed2.convert(0, this._datatype);
          }
          if (i > rows - 1 || j > columns - 1) {
            _resize2(this, Math.max(i + 1, rows), Math.max(j + 1, columns), defaultValue);
            rows = this._size[0];
            columns = this._size[1];
          }
          (0, _array.validateIndex)(i, rows);
          (0, _array.validateIndex)(j, columns);
          var k = _getValueIndex(i, this._ptr[j], this._ptr[j + 1], this._index);
          if (k < this._ptr[j + 1] && this._index[k] === i) {
            if (!eq(v, zero)) {
              this._values[k] = v;
            } else {
              _remove(k, j, this._values, this._index, this._ptr);
            }
          } else {
            if (!eq(v, zero)) {
              _insert(k, i, j, v, this._values, this._index, this._ptr);
            }
          }
          return this;
        };
        function _getValueIndex(i, top, bottom, index) {
          if (bottom - top === 0) {
            return bottom;
          }
          for (var r = top; r < bottom; r++) {
            if (index[r] === i) {
              return r;
            }
          }
          return top;
        }
        function _remove(k, j, values, index, ptr) {
          values.splice(k, 1);
          index.splice(k, 1);
          for (var x = j + 1; x < ptr.length; x++) {
            ptr[x]--;
          }
        }
        function _insert(k, i, j, v, values, index, ptr) {
          values.splice(k, 0, v);
          index.splice(k, 0, i);
          for (var x = j + 1; x < ptr.length; x++) {
            ptr[x]++;
          }
        }
        SparseMatrix2.prototype.resize = function(size2, defaultValue, copy) {
          if (!(0, _is.isCollection)(size2)) {
            throw new TypeError("Array or Matrix expected");
          }
          var sizeArray = size2.valueOf().map(function(value) {
            return Array.isArray(value) && value.length === 1 ? value[0] : value;
          });
          if (sizeArray.length !== 2) {
            throw new Error("Only two dimensions matrix are supported");
          }
          sizeArray.forEach(function(value) {
            if (!(0, _is.isNumber)(value) || !(0, _number.isInteger)(value) || value < 0) {
              throw new TypeError("Invalid size, must contain positive integers (size: " + (0, _string.format)(sizeArray) + ")");
            }
          });
          var m = copy ? this.clone() : this;
          return _resize2(m, sizeArray[0], sizeArray[1], defaultValue);
        };
        function _resize2(matrix2, rows, columns, defaultValue) {
          var value = defaultValue || 0;
          var eq = equalScalar2;
          var zero = 0;
          if ((0, _is.isString)(matrix2._datatype)) {
            eq = typed2.find(equalScalar2, [matrix2._datatype, matrix2._datatype]) || equalScalar2;
            zero = typed2.convert(0, matrix2._datatype);
            value = typed2.convert(value, matrix2._datatype);
          }
          var ins = !eq(value, zero);
          var r = matrix2._size[0];
          var c = matrix2._size[1];
          var i, j, k;
          if (columns > c) {
            for (j = c; j < columns; j++) {
              matrix2._ptr[j] = matrix2._values.length;
              if (ins) {
                for (i = 0; i < r; i++) {
                  matrix2._values.push(value);
                  matrix2._index.push(i);
                }
              }
            }
            matrix2._ptr[columns] = matrix2._values.length;
          } else if (columns < c) {
            matrix2._ptr.splice(columns + 1, c - columns);
            matrix2._values.splice(matrix2._ptr[columns], matrix2._values.length);
            matrix2._index.splice(matrix2._ptr[columns], matrix2._index.length);
          }
          c = columns;
          if (rows > r) {
            if (ins) {
              var n = 0;
              for (j = 0; j < c; j++) {
                matrix2._ptr[j] = matrix2._ptr[j] + n;
                k = matrix2._ptr[j + 1] + n;
                var p = 0;
                for (i = r; i < rows; i++, p++) {
                  matrix2._values.splice(k + p, 0, value);
                  matrix2._index.splice(k + p, 0, i);
                  n++;
                }
              }
              matrix2._ptr[c] = matrix2._values.length;
            }
          } else if (rows < r) {
            var d = 0;
            for (j = 0; j < c; j++) {
              matrix2._ptr[j] = matrix2._ptr[j] - d;
              var k0 = matrix2._ptr[j];
              var k1 = matrix2._ptr[j + 1] - d;
              for (k = k0; k < k1; k++) {
                i = matrix2._index[k];
                if (i > rows - 1) {
                  matrix2._values.splice(k, 1);
                  matrix2._index.splice(k, 1);
                  d++;
                }
              }
            }
            matrix2._ptr[j] = matrix2._values.length;
          }
          matrix2._size[0] = rows;
          matrix2._size[1] = columns;
          return matrix2;
        }
        SparseMatrix2.prototype.reshape = function(sizes, copy) {
          if (!(0, _is.isArray)(sizes)) {
            throw new TypeError("Array expected");
          }
          if (sizes.length !== 2) {
            throw new Error("Sparse matrices can only be reshaped in two dimensions");
          }
          sizes.forEach(function(value) {
            if (!(0, _is.isNumber)(value) || !(0, _number.isInteger)(value) || value <= -2 || value === 0) {
              throw new TypeError("Invalid size, must contain positive integers or -1 (size: " + (0, _string.format)(sizes) + ")");
            }
          });
          var currentLength = this._size[0] * this._size[1];
          sizes = (0, _array.processSizesWildcard)(sizes, currentLength);
          var newLength = sizes[0] * sizes[1];
          if (currentLength !== newLength) {
            throw new Error("Reshaping sparse matrix will result in the wrong number of elements");
          }
          var m = copy ? this.clone() : this;
          if (this._size[0] === sizes[0] && this._size[1] === sizes[1]) {
            return m;
          }
          var colIndex = [];
          for (var i = 0; i < m._ptr.length; i++) {
            for (var j = 0; j < m._ptr[i + 1] - m._ptr[i]; j++) {
              colIndex.push(i);
            }
          }
          var values = m._values.slice();
          var rowIndex = m._index.slice();
          for (var _i = 0; _i < m._index.length; _i++) {
            var r1 = rowIndex[_i];
            var c1 = colIndex[_i];
            var flat = r1 * m._size[1] + c1;
            colIndex[_i] = flat % sizes[1];
            rowIndex[_i] = Math.floor(flat / sizes[1]);
          }
          m._values.length = 0;
          m._index.length = 0;
          m._ptr.length = sizes[1] + 1;
          m._size = sizes.slice();
          for (var _i2 = 0; _i2 < m._ptr.length; _i2++) {
            m._ptr[_i2] = 0;
          }
          for (var h = 0; h < values.length; h++) {
            var _i3 = rowIndex[h];
            var _j = colIndex[h];
            var v = values[h];
            var k = _getValueIndex(_i3, m._ptr[_j], m._ptr[_j + 1], m._index);
            _insert(k, _i3, _j, v, m._values, m._index, m._ptr);
          }
          return m;
        };
        SparseMatrix2.prototype.clone = function() {
          var m = new SparseMatrix2({
            values: this._values ? (0, _object.clone)(this._values) : void 0,
            index: (0, _object.clone)(this._index),
            ptr: (0, _object.clone)(this._ptr),
            size: (0, _object.clone)(this._size),
            datatype: this._datatype
          });
          return m;
        };
        SparseMatrix2.prototype.size = function() {
          return this._size.slice(0);
        };
        SparseMatrix2.prototype.map = function(callback, skipZeros) {
          if (!this._values) {
            throw new Error("Cannot invoke map on a Pattern only matrix");
          }
          var me = this;
          var rows = this._size[0];
          var columns = this._size[1];
          var args = (0, _function.maxArgumentCount)(callback);
          var invoke = function invoke2(v, i, j) {
            if (args === 1) return callback(v);
            if (args === 2) return callback(v, [i, j]);
            return callback(v, [i, j], me);
          };
          return _map(this, 0, rows - 1, 0, columns - 1, invoke, skipZeros);
        };
        function _map(matrix2, minRow, maxRow, minColumn, maxColumn, callback, skipZeros) {
          var values = [];
          var index = [];
          var ptr = [];
          var eq = equalScalar2;
          var zero = 0;
          if ((0, _is.isString)(matrix2._datatype)) {
            eq = typed2.find(equalScalar2, [matrix2._datatype, matrix2._datatype]) || equalScalar2;
            zero = typed2.convert(0, matrix2._datatype);
          }
          var invoke = function invoke2(v, x, y) {
            v = callback(v, x, y);
            if (!eq(v, zero)) {
              values.push(v);
              index.push(x);
            }
          };
          for (var j = minColumn; j <= maxColumn; j++) {
            ptr.push(values.length);
            var k0 = matrix2._ptr[j];
            var k1 = matrix2._ptr[j + 1];
            if (skipZeros) {
              for (var k = k0; k < k1; k++) {
                var i = matrix2._index[k];
                if (i >= minRow && i <= maxRow) {
                  invoke(matrix2._values[k], i - minRow, j - minColumn);
                }
              }
            } else {
              var _values = {};
              for (var _k = k0; _k < k1; _k++) {
                var _i4 = matrix2._index[_k];
                _values[_i4] = matrix2._values[_k];
              }
              for (var _i5 = minRow; _i5 <= maxRow; _i5++) {
                var value = _i5 in _values ? _values[_i5] : 0;
                invoke(value, _i5 - minRow, j - minColumn);
              }
            }
          }
          ptr.push(values.length);
          return new SparseMatrix2({
            values,
            index,
            ptr,
            size: [maxRow - minRow + 1, maxColumn - minColumn + 1]
          });
        }
        SparseMatrix2.prototype.forEach = function(callback, skipZeros) {
          if (!this._values) {
            throw new Error("Cannot invoke forEach on a Pattern only matrix");
          }
          var me = this;
          var rows = this._size[0];
          var columns = this._size[1];
          for (var j = 0; j < columns; j++) {
            var k0 = this._ptr[j];
            var k1 = this._ptr[j + 1];
            if (skipZeros) {
              for (var k = k0; k < k1; k++) {
                var i = this._index[k];
                callback(this._values[k], [i, j], me);
              }
            } else {
              var values = {};
              for (var _k2 = k0; _k2 < k1; _k2++) {
                var _i6 = this._index[_k2];
                values[_i6] = this._values[_k2];
              }
              for (var _i7 = 0; _i7 < rows; _i7++) {
                var value = _i7 in values ? values[_i7] : 0;
                callback(value, [_i7, j], me);
              }
            }
          }
        };
        SparseMatrix2.prototype[Symbol.iterator] = /* @__PURE__ */ _regenerator["default"].mark(function _callee() {
          var columns, j, k0, k1, k, i;
          return _regenerator["default"].wrap(function _callee$(_context) {
            while (1) switch (_context.prev = _context.next) {
              case 0:
                if (this._values) {
                  _context.next = 2;
                  break;
                }
                throw new Error("Cannot iterate a Pattern only matrix");
              case 2:
                columns = this._size[1];
                j = 0;
              case 4:
                if (!(j < columns)) {
                  _context.next = 18;
                  break;
                }
                k0 = this._ptr[j];
                k1 = this._ptr[j + 1];
                k = k0;
              case 8:
                if (!(k < k1)) {
                  _context.next = 15;
                  break;
                }
                i = this._index[k];
                _context.next = 12;
                return {
                  value: this._values[k],
                  index: [i, j]
                };
              case 12:
                k++;
                _context.next = 8;
                break;
              case 15:
                j++;
                _context.next = 4;
                break;
              case 18:
              case "end":
                return _context.stop();
            }
          }, _callee, this);
        });
        SparseMatrix2.prototype.toArray = function() {
          return _toArray(this._values, this._index, this._ptr, this._size, true);
        };
        SparseMatrix2.prototype.valueOf = function() {
          return _toArray(this._values, this._index, this._ptr, this._size, false);
        };
        function _toArray(values, index, ptr, size2, copy) {
          var rows = size2[0];
          var columns = size2[1];
          var a = [];
          var i, j;
          for (i = 0; i < rows; i++) {
            a[i] = [];
            for (j = 0; j < columns; j++) {
              a[i][j] = 0;
            }
          }
          for (j = 0; j < columns; j++) {
            var k0 = ptr[j];
            var k1 = ptr[j + 1];
            for (var k = k0; k < k1; k++) {
              i = index[k];
              a[i][j] = values ? copy ? (0, _object.clone)(values[k]) : values[k] : 1;
            }
          }
          return a;
        }
        SparseMatrix2.prototype.format = function(options) {
          var rows = this._size[0];
          var columns = this._size[1];
          var density = this.density();
          var str = "Sparse Matrix [" + (0, _string.format)(rows, options) + " x " + (0, _string.format)(columns, options) + "] density: " + (0, _string.format)(density, options) + "\n";
          for (var j = 0; j < columns; j++) {
            var k0 = this._ptr[j];
            var k1 = this._ptr[j + 1];
            for (var k = k0; k < k1; k++) {
              var i = this._index[k];
              str += "\n    (" + (0, _string.format)(i, options) + ", " + (0, _string.format)(j, options) + ") ==> " + (this._values ? (0, _string.format)(this._values[k], options) : "X");
            }
          }
          return str;
        };
        SparseMatrix2.prototype.toString = function() {
          return (0, _string.format)(this.toArray());
        };
        SparseMatrix2.prototype.toJSON = function() {
          return {
            mathjs: "SparseMatrix",
            values: this._values,
            index: this._index,
            ptr: this._ptr,
            size: this._size,
            datatype: this._datatype
          };
        };
        SparseMatrix2.prototype.diagonal = function(k) {
          if (k) {
            if ((0, _is.isBigNumber)(k)) {
              k = k.toNumber();
            }
            if (!(0, _is.isNumber)(k) || !(0, _number.isInteger)(k)) {
              throw new TypeError("The parameter k must be an integer number");
            }
          } else {
            k = 0;
          }
          var kSuper = k > 0 ? k : 0;
          var kSub = k < 0 ? -k : 0;
          var rows = this._size[0];
          var columns = this._size[1];
          var n = Math.min(rows - kSub, columns - kSuper);
          var values = [];
          var index = [];
          var ptr = [];
          ptr[0] = 0;
          for (var j = kSuper; j < columns && values.length < n; j++) {
            var k0 = this._ptr[j];
            var k1 = this._ptr[j + 1];
            for (var x = k0; x < k1; x++) {
              var i = this._index[x];
              if (i === j - kSuper + kSub) {
                values.push(this._values[x]);
                index[values.length - 1] = i - kSub;
                break;
              }
            }
          }
          ptr.push(values.length);
          return new SparseMatrix2({
            values,
            index,
            ptr,
            size: [n, 1]
          });
        };
        SparseMatrix2.fromJSON = function(json) {
          return new SparseMatrix2(json);
        };
        SparseMatrix2.diagonal = function(size2, value, k, defaultValue, datatype) {
          if (!(0, _is.isArray)(size2)) {
            throw new TypeError("Array expected, size parameter");
          }
          if (size2.length !== 2) {
            throw new Error("Only two dimensions matrix are supported");
          }
          size2 = size2.map(function(s) {
            if ((0, _is.isBigNumber)(s)) {
              s = s.toNumber();
            }
            if (!(0, _is.isNumber)(s) || !(0, _number.isInteger)(s) || s < 1) {
              throw new Error("Size values must be positive integers");
            }
            return s;
          });
          if (k) {
            if ((0, _is.isBigNumber)(k)) {
              k = k.toNumber();
            }
            if (!(0, _is.isNumber)(k) || !(0, _number.isInteger)(k)) {
              throw new TypeError("The parameter k must be an integer number");
            }
          } else {
            k = 0;
          }
          var eq = equalScalar2;
          var zero = 0;
          if ((0, _is.isString)(datatype)) {
            eq = typed2.find(equalScalar2, [datatype, datatype]) || equalScalar2;
            zero = typed2.convert(0, datatype);
          }
          var kSuper = k > 0 ? k : 0;
          var kSub = k < 0 ? -k : 0;
          var rows = size2[0];
          var columns = size2[1];
          var n = Math.min(rows - kSub, columns - kSuper);
          var _value;
          if ((0, _is.isArray)(value)) {
            if (value.length !== n) {
              throw new Error("Invalid value array length");
            }
            _value = function _value2(i2) {
              return value[i2];
            };
          } else if ((0, _is.isMatrix)(value)) {
            var ms = value.size();
            if (ms.length !== 1 || ms[0] !== n) {
              throw new Error("Invalid matrix length");
            }
            _value = function _value2(i2) {
              return value.get([i2]);
            };
          } else {
            _value = function _value2() {
              return value;
            };
          }
          var values = [];
          var index = [];
          var ptr = [];
          for (var j = 0; j < columns; j++) {
            ptr.push(values.length);
            var i = j - kSuper;
            if (i >= 0 && i < n) {
              var v = _value(i);
              if (!eq(v, zero)) {
                index.push(i + kSub);
                values.push(v);
              }
            }
          }
          ptr.push(values.length);
          return new SparseMatrix2({
            values,
            index,
            ptr,
            size: [rows, columns]
          });
        };
        SparseMatrix2.prototype.swapRows = function(i, j) {
          if (!(0, _is.isNumber)(i) || !(0, _number.isInteger)(i) || !(0, _is.isNumber)(j) || !(0, _number.isInteger)(j)) {
            throw new Error("Row index must be positive integers");
          }
          if (this._size.length !== 2) {
            throw new Error("Only two dimensional matrix is supported");
          }
          (0, _array.validateIndex)(i, this._size[0]);
          (0, _array.validateIndex)(j, this._size[0]);
          SparseMatrix2._swapRows(i, j, this._size[1], this._values, this._index, this._ptr);
          return this;
        };
        SparseMatrix2._forEachRow = function(j, values, index, ptr, callback) {
          var k0 = ptr[j];
          var k1 = ptr[j + 1];
          for (var k = k0; k < k1; k++) {
            callback(index[k], values[k]);
          }
        };
        SparseMatrix2._swapRows = function(x, y, columns, values, index, ptr) {
          for (var j = 0; j < columns; j++) {
            var k0 = ptr[j];
            var k1 = ptr[j + 1];
            var kx = _getValueIndex(x, k0, k1, index);
            var ky = _getValueIndex(y, k0, k1, index);
            if (kx < k1 && ky < k1 && index[kx] === x && index[ky] === y) {
              if (values) {
                var v = values[kx];
                values[kx] = values[ky];
                values[ky] = v;
              }
              continue;
            }
            if (kx < k1 && index[kx] === x && (ky >= k1 || index[ky] !== y)) {
              var vx = values ? values[kx] : void 0;
              index.splice(ky, 0, y);
              if (values) {
                values.splice(ky, 0, vx);
              }
              index.splice(ky <= kx ? kx + 1 : kx, 1);
              if (values) {
                values.splice(ky <= kx ? kx + 1 : kx, 1);
              }
              continue;
            }
            if (ky < k1 && index[ky] === y && (kx >= k1 || index[kx] !== x)) {
              var vy = values ? values[ky] : void 0;
              index.splice(kx, 0, x);
              if (values) {
                values.splice(kx, 0, vy);
              }
              index.splice(kx <= ky ? ky + 1 : ky, 1);
              if (values) {
                values.splice(kx <= ky ? ky + 1 : ky, 1);
              }
            }
          }
        };
        return SparseMatrix2;
      }, {
        isClass: true
      });
    }
  });

  // node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/type/number.js
  var require_number3 = __commonJS({
    "node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/type/number.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.createNumber = void 0;
      var _factory = require_factory();
      var _collection = require_collection();
      var name18 = "number";
      var dependencies19 = ["typed"];
      function getNonDecimalNumberParts(input) {
        var nonDecimalWithRadixMatch = input.match(/(0[box])([0-9a-fA-F]*)\.([0-9a-fA-F]*)/);
        if (nonDecimalWithRadixMatch) {
          var radix = {
            "0b": 2,
            "0o": 8,
            "0x": 16
          }[nonDecimalWithRadixMatch[1]];
          var integerPart = nonDecimalWithRadixMatch[2];
          var fractionalPart = nonDecimalWithRadixMatch[3];
          return {
            input,
            radix,
            integerPart,
            fractionalPart
          };
        } else {
          return null;
        }
      }
      function makeNumberFromNonDecimalParts(parts) {
        var n = parseInt(parts.integerPart, parts.radix);
        var f = 0;
        for (var i = 0; i < parts.fractionalPart.length; i++) {
          var digitValue = parseInt(parts.fractionalPart[i], parts.radix);
          f += digitValue / Math.pow(parts.radix, i + 1);
        }
        var result = n + f;
        if (isNaN(result)) {
          throw new SyntaxError('String "' + parts.input + '" is not a valid number');
        }
        return result;
      }
      var createNumber2 = exports.createNumber = /* @__PURE__ */ (0, _factory.factory)(name18, dependencies19, function(_ref) {
        var typed2 = _ref.typed;
        var number = typed2("number", {
          "": function _() {
            return 0;
          },
          number: function number2(x) {
            return x;
          },
          string: function string(x) {
            if (x === "NaN") return NaN;
            var nonDecimalNumberParts = getNonDecimalNumberParts(x);
            if (nonDecimalNumberParts) {
              return makeNumberFromNonDecimalParts(nonDecimalNumberParts);
            }
            var size2 = 0;
            var wordSizeSuffixMatch = x.match(/(0[box][0-9a-fA-F]*)i([0-9]*)/);
            if (wordSizeSuffixMatch) {
              size2 = Number(wordSizeSuffixMatch[2]);
              x = wordSizeSuffixMatch[1];
            }
            var num = Number(x);
            if (isNaN(num)) {
              throw new SyntaxError('String "' + x + '" is not a valid number');
            }
            if (wordSizeSuffixMatch) {
              if (num > Math.pow(2, size2) - 1) {
                throw new SyntaxError('String "'.concat(x, '" is out of range'));
              }
              if (num >= Math.pow(2, size2 - 1)) {
                num = num - Math.pow(2, size2);
              }
            }
            return num;
          },
          BigNumber: function BigNumber2(x) {
            return x.toNumber();
          },
          Fraction: function Fraction3(x) {
            return x.valueOf();
          },
          Unit: typed2.referToSelf(function(self2) {
            return function(x) {
              var clone4 = x.clone();
              clone4.value = self2(x.value);
              return clone4;
            };
          }),
          "null": function _null(x) {
            return 0;
          },
          "Unit, string | Unit": function UnitStringUnit(unit, valuelessUnit) {
            return unit.toNumber(valuelessUnit);
          },
          "Array | Matrix": typed2.referToSelf(function(self2) {
            return function(x) {
              return (0, _collection.deepMap)(x, self2);
            };
          })
        });
        number.fromJSON = function(json) {
          return parseFloat(json.value);
        };
        return number;
      });
    }
  });

  // node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/type/string.js
  var require_string2 = __commonJS({
    "node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/type/string.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.createString = void 0;
      var _factory = require_factory();
      var _collection = require_collection();
      var _number = require_number();
      var name18 = "string";
      var dependencies19 = ["typed"];
      var createString2 = exports.createString = /* @__PURE__ */ (0, _factory.factory)(name18, dependencies19, function(_ref) {
        var typed2 = _ref.typed;
        return typed2(name18, {
          "": function _() {
            return "";
          },
          number: _number.format,
          "null": function _null(x) {
            return "null";
          },
          "boolean": function boolean(x) {
            return x + "";
          },
          string: function string(x) {
            return x;
          },
          "Array | Matrix": typed2.referToSelf(function(self2) {
            return function(x) {
              return (0, _collection.deepMap)(x, self2);
            };
          }),
          any: function any(x) {
            return String(x);
          }
        });
      });
    }
  });

  // node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/type/boolean.js
  var require_boolean = __commonJS({
    "node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/type/boolean.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.createBoolean = void 0;
      var _factory = require_factory();
      var _collection = require_collection();
      var name18 = "boolean";
      var dependencies19 = ["typed"];
      var createBoolean2 = exports.createBoolean = /* @__PURE__ */ (0, _factory.factory)(name18, dependencies19, function(_ref) {
        var typed2 = _ref.typed;
        return typed2(name18, {
          "": function _() {
            return false;
          },
          "boolean": function boolean(x) {
            return x;
          },
          number: function number(x) {
            return !!x;
          },
          "null": function _null(x) {
            return false;
          },
          BigNumber: function BigNumber2(x) {
            return !x.isZero();
          },
          string: function string(x) {
            var lcase = x.toLowerCase();
            if (lcase === "true") {
              return true;
            } else if (lcase === "false") {
              return false;
            }
            var num = Number(x);
            if (x !== "" && !isNaN(num)) {
              return !!num;
            }
            throw new Error('Cannot convert "' + x + '" to a boolean');
          },
          "Array | Matrix": typed2.referToSelf(function(self2) {
            return function(x) {
              return (0, _collection.deepMap)(x, self2);
            };
          })
        });
      });
    }
  });

  // node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/type/bignumber/function/bignumber.js
  var require_bignumber = __commonJS({
    "node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/type/bignumber/function/bignumber.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.createBignumber = void 0;
      var _factory = require_factory();
      var _collection = require_collection();
      var name18 = "bignumber";
      var dependencies19 = ["typed", "BigNumber"];
      var createBignumber2 = exports.createBignumber = /* @__PURE__ */ (0, _factory.factory)(name18, dependencies19, function(_ref) {
        var typed2 = _ref.typed, BigNumber2 = _ref.BigNumber;
        return typed2("bignumber", {
          "": function _() {
            return new BigNumber2(0);
          },
          number: function number(x) {
            return new BigNumber2(x + "");
          },
          string: function string(x) {
            var wordSizeSuffixMatch = x.match(/(0[box][0-9a-fA-F]*)i([0-9]*)/);
            if (wordSizeSuffixMatch) {
              var size2 = wordSizeSuffixMatch[2];
              var n = BigNumber2(wordSizeSuffixMatch[1]);
              var twoPowSize = new BigNumber2(2).pow(Number(size2));
              if (n.gt(twoPowSize.sub(1))) {
                throw new SyntaxError('String "'.concat(x, '" is out of range'));
              }
              var twoPowSizeSubOne = new BigNumber2(2).pow(Number(size2) - 1);
              if (n.gte(twoPowSizeSubOne)) {
                return n.sub(twoPowSize);
              } else {
                return n;
              }
            }
            return new BigNumber2(x);
          },
          BigNumber: function BigNumber3(x) {
            return x;
          },
          Unit: typed2.referToSelf(function(self2) {
            return function(x) {
              var clone4 = x.clone();
              clone4.value = self2(x.value);
              return clone4;
            };
          }),
          Fraction: function Fraction3(x) {
            return new BigNumber2(x.n).div(x.d).times(x.s);
          },
          "null": function _null(x) {
            return new BigNumber2(0);
          },
          "Array | Matrix": typed2.referToSelf(function(self2) {
            return function(x) {
              return (0, _collection.deepMap)(x, self2);
            };
          })
        });
      });
    }
  });

  // node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/type/complex/function/complex.js
  var require_complex3 = __commonJS({
    "node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/type/complex/function/complex.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.createComplex = void 0;
      var _factory = require_factory();
      var _collection = require_collection();
      var name18 = "complex";
      var dependencies19 = ["typed", "Complex"];
      var createComplex2 = exports.createComplex = /* @__PURE__ */ (0, _factory.factory)(name18, dependencies19, function(_ref) {
        var typed2 = _ref.typed, Complex3 = _ref.Complex;
        return typed2("complex", {
          "": function _() {
            return Complex3.ZERO;
          },
          number: function number(x) {
            return new Complex3(x, 0);
          },
          "number, number": function numberNumber(re, im) {
            return new Complex3(re, im);
          },
          // TODO: this signature should be redundant
          "BigNumber, BigNumber": function BigNumberBigNumber(re, im) {
            return new Complex3(re.toNumber(), im.toNumber());
          },
          Fraction: function Fraction3(x) {
            return new Complex3(x.valueOf(), 0);
          },
          Complex: function Complex4(x) {
            return x.clone();
          },
          string: function string(x) {
            return Complex3(x);
          },
          "null": function _null(x) {
            return Complex3(0);
          },
          Object: function Object2(x) {
            if ("re" in x && "im" in x) {
              return new Complex3(x.re, x.im);
            }
            if ("r" in x && "phi" in x || "abs" in x && "arg" in x) {
              return new Complex3(x);
            }
            throw new Error("Expected object with properties (re and im) or (r and phi) or (abs and arg)");
          },
          "Array | Matrix": typed2.referToSelf(function(self2) {
            return function(x) {
              return (0, _collection.deepMap)(x, self2);
            };
          })
        });
      });
    }
  });

  // node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/type/fraction/function/fraction.js
  var require_fraction2 = __commonJS({
    "node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/type/fraction/function/fraction.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.createFraction = void 0;
      var _factory = require_factory();
      var _collection = require_collection();
      var name18 = "fraction";
      var dependencies19 = ["typed", "Fraction"];
      var createFraction2 = exports.createFraction = /* @__PURE__ */ (0, _factory.factory)(name18, dependencies19, function(_ref) {
        var typed2 = _ref.typed, Fraction3 = _ref.Fraction;
        return typed2("fraction", {
          number: function number(x) {
            if (!isFinite(x) || isNaN(x)) {
              throw new Error(x + " cannot be represented as a fraction");
            }
            return new Fraction3(x);
          },
          string: function string(x) {
            return new Fraction3(x);
          },
          "number, number": function numberNumber(numerator, denominator) {
            return new Fraction3(numerator, denominator);
          },
          "null": function _null(x) {
            return new Fraction3(0);
          },
          BigNumber: function BigNumber2(x) {
            return new Fraction3(x.toString());
          },
          Fraction: function Fraction4(x) {
            return x;
          },
          Unit: typed2.referToSelf(function(self2) {
            return function(x) {
              var clone4 = x.clone();
              clone4.value = self2(x.value);
              return clone4;
            };
          }),
          Object: function Object2(x) {
            return new Fraction3(x);
          },
          "Array | Matrix": typed2.referToSelf(function(self2) {
            return function(x) {
              return (0, _collection.deepMap)(x, self2);
            };
          })
        });
      });
    }
  });

  // node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/type/matrix/function/matrix.js
  var require_matrix = __commonJS({
    "node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/type/matrix/function/matrix.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.createMatrix = void 0;
      var _factory = require_factory();
      var name18 = "matrix";
      var dependencies19 = ["typed", "Matrix", "DenseMatrix", "SparseMatrix"];
      var createMatrix2 = exports.createMatrix = /* @__PURE__ */ (0, _factory.factory)(name18, dependencies19, function(_ref) {
        var typed2 = _ref.typed, Matrix2 = _ref.Matrix, DenseMatrix2 = _ref.DenseMatrix, SparseMatrix2 = _ref.SparseMatrix;
        return typed2(name18, {
          "": function _() {
            return _create([]);
          },
          string: function string(format4) {
            return _create([], format4);
          },
          "string, string": function stringString(format4, datatype) {
            return _create([], format4, datatype);
          },
          Array: function Array2(data) {
            return _create(data);
          },
          Matrix: function Matrix3(data) {
            return _create(data, data.storage());
          },
          "Array | Matrix, string": _create,
          "Array | Matrix, string, string": _create
        });
        function _create(data, format4, datatype) {
          if (format4 === "dense" || format4 === "default" || format4 === void 0) {
            return new DenseMatrix2(data, datatype);
          }
          if (format4 === "sparse") {
            return new SparseMatrix2(data, datatype);
          }
          throw new TypeError("Unknown matrix type " + JSON.stringify(format4) + ".");
        }
      });
    }
  });

  // node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/function/matrix/matrixFromFunction.js
  var require_matrixFromFunction = __commonJS({
    "node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/function/matrix/matrixFromFunction.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.createMatrixFromFunction = void 0;
      var _factory = require_factory();
      var name18 = "matrixFromFunction";
      var dependencies19 = ["typed", "matrix", "isZero"];
      var createMatrixFromFunction2 = exports.createMatrixFromFunction = /* @__PURE__ */ (0, _factory.factory)(name18, dependencies19, function(_ref) {
        var typed2 = _ref.typed, matrix2 = _ref.matrix, isZero = _ref.isZero;
        return typed2(name18, {
          "Array | Matrix, function, string, string": function ArrayMatrixFunctionStringString(size2, fn, format4, datatype) {
            return _create(size2, fn, format4, datatype);
          },
          "Array | Matrix, function, string": function ArrayMatrixFunctionString(size2, fn, format4) {
            return _create(size2, fn, format4);
          },
          "Matrix, function": function MatrixFunction(size2, fn) {
            return _create(size2, fn, "dense");
          },
          "Array, function": function ArrayFunction(size2, fn) {
            return _create(size2, fn, "dense").toArray();
          },
          "Array | Matrix, string, function": function ArrayMatrixStringFunction(size2, format4, fn) {
            return _create(size2, fn, format4);
          },
          "Array | Matrix, string, string, function": function ArrayMatrixStringStringFunction(size2, format4, datatype, fn) {
            return _create(size2, fn, format4, datatype);
          }
        });
        function _create(size2, fn, format4, datatype) {
          var m;
          if (datatype !== void 0) {
            m = matrix2(format4, datatype);
          } else {
            m = matrix2(format4);
          }
          m.resize(size2);
          m.forEach(function(_, index) {
            var val = fn(index);
            if (isZero(val)) return;
            m.set(index, val);
          });
          return m;
        }
      });
    }
  });

  // node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/function/matrix/matrixFromRows.js
  var require_matrixFromRows = __commonJS({
    "node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/function/matrix/matrixFromRows.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.createMatrixFromRows = void 0;
      var _factory = require_factory();
      function _createForOfIteratorHelper(o, allowArrayLike) {
        var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"];
        if (!it) {
          if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") {
            if (it) o = it;
            var i = 0;
            var F = function F2() {
            };
            return { s: F, n: function n() {
              if (i >= o.length) return { done: true };
              return { done: false, value: o[i++] };
            }, e: function e(_e) {
              throw _e;
            }, f: F };
          }
          throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
        }
        var normalCompletion = true, didErr = false, err;
        return { s: function s() {
          it = it.call(o);
        }, n: function n() {
          var step = it.next();
          normalCompletion = step.done;
          return step;
        }, e: function e(_e2) {
          didErr = true;
          err = _e2;
        }, f: function f() {
          try {
            if (!normalCompletion && it["return"] != null) it["return"]();
          } finally {
            if (didErr) throw err;
          }
        } };
      }
      function _unsupportedIterableToArray(o, minLen) {
        if (!o) return;
        if (typeof o === "string") return _arrayLikeToArray(o, minLen);
        var n = Object.prototype.toString.call(o).slice(8, -1);
        if (n === "Object" && o.constructor) n = o.constructor.name;
        if (n === "Map" || n === "Set") return Array.from(o);
        if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);
      }
      function _arrayLikeToArray(arr, len) {
        if (len == null || len > arr.length) len = arr.length;
        for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];
        return arr2;
      }
      var name18 = "matrixFromRows";
      var dependencies19 = ["typed", "matrix", "flatten", "size"];
      var createMatrixFromRows2 = exports.createMatrixFromRows = /* @__PURE__ */ (0, _factory.factory)(name18, dependencies19, function(_ref) {
        var typed2 = _ref.typed, matrix2 = _ref.matrix, flatten2 = _ref.flatten, size2 = _ref.size;
        return typed2(name18, {
          "...Array": function Array2(arr) {
            return _createArray(arr);
          },
          "...Matrix": function Matrix2(arr) {
            return matrix2(_createArray(arr.map(function(m) {
              return m.toArray();
            })));
          }
          // TODO implement this properly for SparseMatrix
        });
        function _createArray(arr) {
          if (arr.length === 0) throw new TypeError("At least one row is needed to construct a matrix.");
          var N = checkVectorTypeAndReturnLength(arr[0]);
          var result = [];
          var _iterator = _createForOfIteratorHelper(arr), _step;
          try {
            for (_iterator.s(); !(_step = _iterator.n()).done; ) {
              var row = _step.value;
              var rowLength = checkVectorTypeAndReturnLength(row);
              if (rowLength !== N) {
                throw new TypeError("The vectors had different length: " + (N | 0) + " \u2260 " + (rowLength | 0));
              }
              result.push(flatten2(row));
            }
          } catch (err) {
            _iterator.e(err);
          } finally {
            _iterator.f();
          }
          return result;
        }
        function checkVectorTypeAndReturnLength(vec) {
          var s = size2(vec);
          if (s.length === 1) {
            return s[0];
          } else if (s.length === 2) {
            if (s[0] === 1) {
              return s[1];
            } else if (s[1] === 1) {
              return s[0];
            } else {
              throw new TypeError("At least one of the arguments is not a vector.");
            }
          } else {
            throw new TypeError("Only one- or two-dimensional vectors are supported.");
          }
        }
      });
    }
  });

  // node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/function/matrix/matrixFromColumns.js
  var require_matrixFromColumns = __commonJS({
    "node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/function/matrix/matrixFromColumns.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.createMatrixFromColumns = void 0;
      var _factory = require_factory();
      function _createForOfIteratorHelper(o, allowArrayLike) {
        var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"];
        if (!it) {
          if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") {
            if (it) o = it;
            var i = 0;
            var F = function F2() {
            };
            return { s: F, n: function n() {
              if (i >= o.length) return { done: true };
              return { done: false, value: o[i++] };
            }, e: function e(_e) {
              throw _e;
            }, f: F };
          }
          throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
        }
        var normalCompletion = true, didErr = false, err;
        return { s: function s() {
          it = it.call(o);
        }, n: function n() {
          var step = it.next();
          normalCompletion = step.done;
          return step;
        }, e: function e(_e2) {
          didErr = true;
          err = _e2;
        }, f: function f() {
          try {
            if (!normalCompletion && it["return"] != null) it["return"]();
          } finally {
            if (didErr) throw err;
          }
        } };
      }
      function _unsupportedIterableToArray(o, minLen) {
        if (!o) return;
        if (typeof o === "string") return _arrayLikeToArray(o, minLen);
        var n = Object.prototype.toString.call(o).slice(8, -1);
        if (n === "Object" && o.constructor) n = o.constructor.name;
        if (n === "Map" || n === "Set") return Array.from(o);
        if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);
      }
      function _arrayLikeToArray(arr, len) {
        if (len == null || len > arr.length) len = arr.length;
        for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];
        return arr2;
      }
      var name18 = "matrixFromColumns";
      var dependencies19 = ["typed", "matrix", "flatten", "size"];
      var createMatrixFromColumns2 = exports.createMatrixFromColumns = /* @__PURE__ */ (0, _factory.factory)(name18, dependencies19, function(_ref) {
        var typed2 = _ref.typed, matrix2 = _ref.matrix, flatten2 = _ref.flatten, size2 = _ref.size;
        return typed2(name18, {
          "...Array": function Array2(arr) {
            return _createArray(arr);
          },
          "...Matrix": function Matrix2(arr) {
            return matrix2(_createArray(arr.map(function(m) {
              return m.toArray();
            })));
          }
          // TODO implement this properly for SparseMatrix
        });
        function _createArray(arr) {
          if (arr.length === 0) throw new TypeError("At least one column is needed to construct a matrix.");
          var N = checkVectorTypeAndReturnLength(arr[0]);
          var result = [];
          for (var i = 0; i < N; i++) {
            result[i] = [];
          }
          var _iterator = _createForOfIteratorHelper(arr), _step;
          try {
            for (_iterator.s(); !(_step = _iterator.n()).done; ) {
              var col = _step.value;
              var colLength = checkVectorTypeAndReturnLength(col);
              if (colLength !== N) {
                throw new TypeError("The vectors had different length: " + (N | 0) + " \u2260 " + (colLength | 0));
              }
              var f = flatten2(col);
              for (var _i = 0; _i < N; _i++) {
                result[_i].push(f[_i]);
              }
            }
          } catch (err) {
            _iterator.e(err);
          } finally {
            _iterator.f();
          }
          return result;
        }
        function checkVectorTypeAndReturnLength(vec) {
          var s = size2(vec);
          if (s.length === 1) {
            return s[0];
          } else if (s.length === 2) {
            if (s[0] === 1) {
              return s[1];
            } else if (s[1] === 1) {
              return s[0];
            } else {
              throw new TypeError("At least one of the arguments is not a vector.");
            }
          } else {
            throw new TypeError("Only one- or two-dimensional vectors are supported.");
          }
        }
      });
    }
  });

  // node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/type/unit/function/splitUnit.js
  var require_splitUnit = __commonJS({
    "node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/type/unit/function/splitUnit.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.createSplitUnit = void 0;
      var _factory = require_factory();
      var name18 = "splitUnit";
      var dependencies19 = ["typed"];
      var createSplitUnit2 = exports.createSplitUnit = /* @__PURE__ */ (0, _factory.factory)(name18, dependencies19, function(_ref) {
        var typed2 = _ref.typed;
        return typed2(name18, {
          "Unit, Array": function UnitArray(unit, parts) {
            return unit.splitUnit(parts);
          }
        });
      });
    }
  });

  // node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/function/arithmetic/unaryMinus.js
  var require_unaryMinus = __commonJS({
    "node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/function/arithmetic/unaryMinus.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.createUnaryMinus = void 0;
      var _factory = require_factory();
      var _collection = require_collection();
      var _index = require_number2();
      var name18 = "unaryMinus";
      var dependencies19 = ["typed"];
      var createUnaryMinus2 = exports.createUnaryMinus = /* @__PURE__ */ (0, _factory.factory)(name18, dependencies19, function(_ref) {
        var typed2 = _ref.typed;
        return typed2(name18, {
          number: _index.unaryMinusNumber,
          "Complex | BigNumber | Fraction": function ComplexBigNumberFraction(x) {
            return x.neg();
          },
          Unit: typed2.referToSelf(function(self2) {
            return function(x) {
              var res = x.clone();
              res.value = typed2.find(self2, res.valueType())(x.value);
              return res;
            };
          }),
          // deep map collection, skip zeros since unaryMinus(0) = 0
          "Array | Matrix": typed2.referToSelf(function(self2) {
            return function(x) {
              return (0, _collection.deepMap)(x, self2, true);
            };
          })
          // TODO: add support for string
        });
      });
    }
  });

  // node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/function/arithmetic/unaryPlus.js
  var require_unaryPlus = __commonJS({
    "node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/function/arithmetic/unaryPlus.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.createUnaryPlus = void 0;
      var _factory = require_factory();
      var _collection = require_collection();
      var _index = require_number2();
      var name18 = "unaryPlus";
      var dependencies19 = ["typed", "config", "BigNumber"];
      var createUnaryPlus2 = exports.createUnaryPlus = /* @__PURE__ */ (0, _factory.factory)(name18, dependencies19, function(_ref) {
        var typed2 = _ref.typed, config4 = _ref.config, BigNumber2 = _ref.BigNumber;
        return typed2(name18, {
          number: _index.unaryPlusNumber,
          Complex: function Complex3(x) {
            return x;
          },
          BigNumber: function BigNumber3(x) {
            return x;
          },
          Fraction: function Fraction3(x) {
            return x;
          },
          Unit: function Unit(x) {
            return x.clone();
          },
          // deep map collection, skip zeros since unaryPlus(0) = 0
          "Array | Matrix": typed2.referToSelf(function(self2) {
            return function(x) {
              return (0, _collection.deepMap)(x, self2, true);
            };
          }),
          "boolean | string": function booleanString(x) {
            return config4.number === "BigNumber" ? new BigNumber2(+x) : +x;
          }
        });
      });
    }
  });

  // node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/function/arithmetic/abs.js
  var require_abs = __commonJS({
    "node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/function/arithmetic/abs.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.createAbs = void 0;
      var _factory = require_factory();
      var _collection = require_collection();
      var _index = require_number2();
      var name18 = "abs";
      var dependencies19 = ["typed"];
      var createAbs2 = exports.createAbs = /* @__PURE__ */ (0, _factory.factory)(name18, dependencies19, function(_ref) {
        var typed2 = _ref.typed;
        return typed2(name18, {
          number: _index.absNumber,
          "Complex | BigNumber | Fraction | Unit": function ComplexBigNumberFractionUnit(x) {
            return x.abs();
          },
          // deep map collection, skip zeros since abs(0) = 0
          "Array | Matrix": typed2.referToSelf(function(self2) {
            return function(x) {
              return (0, _collection.deepMap)(x, self2, true);
            };
          })
        });
      });
    }
  });

  // node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/function/matrix/apply.js
  var require_apply = __commonJS({
    "node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/function/matrix/apply.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.createApply = void 0;
      var _factory = require_factory();
      var _array = require_array();
      var _is = require_is();
      var _IndexError = require_IndexError();
      var name18 = "apply";
      var dependencies19 = ["typed", "isInteger"];
      var createApply2 = exports.createApply = /* @__PURE__ */ (0, _factory.factory)(name18, dependencies19, function(_ref) {
        var typed2 = _ref.typed, isInteger2 = _ref.isInteger;
        return typed2(name18, {
          "Array | Matrix, number | BigNumber, function": function ArrayMatrixNumberBigNumberFunction(mat, dim, callback) {
            if (!isInteger2(dim)) {
              throw new TypeError("Integer number expected for dimension");
            }
            var size2 = Array.isArray(mat) ? (0, _array.arraySize)(mat) : mat.size();
            if (dim < 0 || dim >= size2.length) {
              throw new _IndexError.IndexError(dim, size2.length);
            }
            if ((0, _is.isMatrix)(mat)) {
              return mat.create(_apply(mat.valueOf(), dim, callback));
            } else {
              return _apply(mat, dim, callback);
            }
          }
        });
      });
      function _apply(mat, dim, callback) {
        var i, ret, tran;
        if (dim <= 0) {
          if (!Array.isArray(mat[0])) {
            return callback(mat);
          } else {
            tran = _switch(mat);
            ret = [];
            for (i = 0; i < tran.length; i++) {
              ret[i] = _apply(tran[i], dim - 1, callback);
            }
            return ret;
          }
        } else {
          ret = [];
          for (i = 0; i < mat.length; i++) {
            ret[i] = _apply(mat[i], dim - 1, callback);
          }
          return ret;
        }
      }
      function _switch(mat) {
        var I = mat.length;
        var J = mat[0].length;
        var i, j;
        var ret = [];
        for (j = 0; j < J; j++) {
          var tmp = [];
          for (i = 0; i < I; i++) {
            tmp.push(mat[i][j]);
          }
          ret.push(tmp);
        }
        return ret;
      }
    }
  });

  // node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/function/arithmetic/addScalar.js
  var require_addScalar = __commonJS({
    "node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/function/arithmetic/addScalar.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.createAddScalar = void 0;
      var _factory = require_factory();
      var _index = require_number2();
      var name18 = "addScalar";
      var dependencies19 = ["typed"];
      var createAddScalar2 = exports.createAddScalar = /* @__PURE__ */ (0, _factory.factory)(name18, dependencies19, function(_ref) {
        var typed2 = _ref.typed;
        return typed2(name18, {
          "number, number": _index.addNumber,
          "Complex, Complex": function ComplexComplex(x, y) {
            return x.add(y);
          },
          "BigNumber, BigNumber": function BigNumberBigNumber(x, y) {
            return x.plus(y);
          },
          "Fraction, Fraction": function FractionFraction(x, y) {
            return x.add(y);
          },
          "Unit, Unit": typed2.referToSelf(function(self2) {
            return function(x, y) {
              if (x.value === null || x.value === void 0) {
                throw new Error("Parameter x contains a unit with undefined value");
              }
              if (y.value === null || y.value === void 0) {
                throw new Error("Parameter y contains a unit with undefined value");
              }
              if (!x.equalBase(y)) throw new Error("Units do not match");
              var res = x.clone();
              res.value = typed2.find(self2, [res.valueType(), y.valueType()])(res.value, y.value);
              res.fixPrefix = false;
              return res;
            };
          })
        });
      });
    }
  });

  // node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/function/arithmetic/subtractScalar.js
  var require_subtractScalar = __commonJS({
    "node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/function/arithmetic/subtractScalar.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.createSubtractScalar = void 0;
      var _factory = require_factory();
      var _index = require_number2();
      var name18 = "subtractScalar";
      var dependencies19 = ["typed"];
      var createSubtractScalar2 = exports.createSubtractScalar = /* @__PURE__ */ (0, _factory.factory)(name18, dependencies19, function(_ref) {
        var typed2 = _ref.typed;
        return typed2(name18, {
          "number, number": _index.subtractNumber,
          "Complex, Complex": function ComplexComplex(x, y) {
            return x.sub(y);
          },
          "BigNumber, BigNumber": function BigNumberBigNumber(x, y) {
            return x.minus(y);
          },
          "Fraction, Fraction": function FractionFraction(x, y) {
            return x.sub(y);
          },
          "Unit, Unit": typed2.referToSelf(function(self2) {
            return function(x, y) {
              if (x.value === null || x.value === void 0) {
                throw new Error("Parameter x contains a unit with undefined value");
              }
              if (y.value === null || y.value === void 0) {
                throw new Error("Parameter y contains a unit with undefined value");
              }
              if (!x.equalBase(y)) throw new Error("Units do not match");
              var res = x.clone();
              res.value = typed2.find(self2, [res.valueType(), y.valueType()])(res.value, y.value);
              res.fixPrefix = false;
              return res;
            };
          })
        });
      });
    }
  });

  // node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/function/arithmetic/cbrt.js
  var require_cbrt = __commonJS({
    "node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/function/arithmetic/cbrt.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.createCbrt = void 0;
      var _factory = require_factory();
      var _is = require_is();
      var _index = require_number2();
      var name18 = "cbrt";
      var dependencies19 = ["config", "typed", "isNegative", "unaryMinus", "matrix", "Complex", "BigNumber", "Fraction"];
      var createCbrt2 = exports.createCbrt = /* @__PURE__ */ (0, _factory.factory)(name18, dependencies19, function(_ref) {
        var config4 = _ref.config, typed2 = _ref.typed, isNegative = _ref.isNegative, unaryMinus = _ref.unaryMinus, matrix2 = _ref.matrix, Complex3 = _ref.Complex, BigNumber2 = _ref.BigNumber, Fraction3 = _ref.Fraction;
        return typed2(name18, {
          number: _index.cbrtNumber,
          // note: signature 'number, boolean' is also supported,
          //       created by typed as it knows how to convert number to Complex
          Complex: _cbrtComplex,
          "Complex, boolean": _cbrtComplex,
          BigNumber: function BigNumber3(x) {
            return x.cbrt();
          },
          Unit: _cbrtUnit
        });
        function _cbrtComplex(x, allRoots) {
          var arg3 = x.arg() / 3;
          var abs2 = x.abs();
          var principal = new Complex3((0, _index.cbrtNumber)(abs2), 0).mul(new Complex3(0, arg3).exp());
          if (allRoots) {
            var all = [principal, new Complex3((0, _index.cbrtNumber)(abs2), 0).mul(new Complex3(0, arg3 + Math.PI * 2 / 3).exp()), new Complex3((0, _index.cbrtNumber)(abs2), 0).mul(new Complex3(0, arg3 - Math.PI * 2 / 3).exp())];
            return config4.matrix === "Array" ? all : matrix2(all);
          } else {
            return principal;
          }
        }
        function _cbrtUnit(x) {
          if (x.value && (0, _is.isComplex)(x.value)) {
            var result = x.clone();
            result.value = 1;
            result = result.pow(1 / 3);
            result.value = _cbrtComplex(x.value);
            return result;
          } else {
            var negate = isNegative(x.value);
            if (negate) {
              x.value = unaryMinus(x.value);
            }
            var third;
            if ((0, _is.isBigNumber)(x.value)) {
              third = new BigNumber2(1).div(3);
            } else if ((0, _is.isFraction)(x.value)) {
              third = new Fraction3(1, 3);
            } else {
              third = 1 / 3;
            }
            var _result = x.pow(third);
            if (negate) {
              _result.value = unaryMinus(_result.value);
            }
            return _result;
          }
        }
      });
    }
  });

  // node_modules/.pnpm/@babel+runtime@7.28.4/node_modules/@babel/runtime/helpers/arrayWithHoles.js
  var require_arrayWithHoles = __commonJS({
    "node_modules/.pnpm/@babel+runtime@7.28.4/node_modules/@babel/runtime/helpers/arrayWithHoles.js"(exports, module) {
      function _arrayWithHoles(r) {
        if (Array.isArray(r)) return r;
      }
      module.exports = _arrayWithHoles, module.exports.__esModule = true, module.exports["default"] = module.exports;
    }
  });

  // node_modules/.pnpm/@babel+runtime@7.28.4/node_modules/@babel/runtime/helpers/iterableToArrayLimit.js
  var require_iterableToArrayLimit = __commonJS({
    "node_modules/.pnpm/@babel+runtime@7.28.4/node_modules/@babel/runtime/helpers/iterableToArrayLimit.js"(exports, module) {
      function _iterableToArrayLimit(r, l) {
        var t = null == r ? null : "undefined" != typeof Symbol && r[Symbol.iterator] || r["@@iterator"];
        if (null != t) {
          var e, n, i, u, a = [], f = true, o = false;
          try {
            if (i = (t = t.call(r)).next, 0 === l) {
              if (Object(t) !== t) return;
              f = false;
            } else for (; !(f = (e = i.call(t)).done) && (a.push(e.value), a.length !== l); f = true) ;
          } catch (r2) {
            o = true, n = r2;
          } finally {
            try {
              if (!f && null != t["return"] && (u = t["return"](), Object(u) !== u)) return;
            } finally {
              if (o) throw n;
            }
          }
          return a;
        }
      }
      module.exports = _iterableToArrayLimit, module.exports.__esModule = true, module.exports["default"] = module.exports;
    }
  });

  // node_modules/.pnpm/@babel+runtime@7.28.4/node_modules/@babel/runtime/helpers/nonIterableRest.js
  var require_nonIterableRest = __commonJS({
    "node_modules/.pnpm/@babel+runtime@7.28.4/node_modules/@babel/runtime/helpers/nonIterableRest.js"(exports, module) {
      function _nonIterableRest() {
        throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
      }
      module.exports = _nonIterableRest, module.exports.__esModule = true, module.exports["default"] = module.exports;
    }
  });

  // node_modules/.pnpm/@babel+runtime@7.28.4/node_modules/@babel/runtime/helpers/slicedToArray.js
  var require_slicedToArray = __commonJS({
    "node_modules/.pnpm/@babel+runtime@7.28.4/node_modules/@babel/runtime/helpers/slicedToArray.js"(exports, module) {
      var arrayWithHoles = require_arrayWithHoles();
      var iterableToArrayLimit = require_iterableToArrayLimit();
      var unsupportedIterableToArray = require_unsupportedIterableToArray();
      var nonIterableRest = require_nonIterableRest();
      function _slicedToArray(r, e) {
        return arrayWithHoles(r) || iterableToArrayLimit(r, e) || unsupportedIterableToArray(r, e) || nonIterableRest();
      }
      module.exports = _slicedToArray, module.exports.__esModule = true, module.exports["default"] = module.exports;
    }
  });

  // node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/type/matrix/utils/matAlgo11xS0s.js
  var require_matAlgo11xS0s = __commonJS({
    "node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/type/matrix/utils/matAlgo11xS0s.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.createMatAlgo11xS0s = void 0;
      var _factory = require_factory();
      var name18 = "matAlgo11xS0s";
      var dependencies19 = ["typed", "equalScalar"];
      var createMatAlgo11xS0s2 = exports.createMatAlgo11xS0s = /* @__PURE__ */ (0, _factory.factory)(name18, dependencies19, function(_ref) {
        var typed2 = _ref.typed, equalScalar2 = _ref.equalScalar;
        return function matAlgo11xS0s(s, b, callback, inverse) {
          var avalues = s._values;
          var aindex = s._index;
          var aptr = s._ptr;
          var asize = s._size;
          var adt = s._datatype;
          if (!avalues) {
            throw new Error("Cannot perform operation on Pattern Sparse Matrix and Scalar value");
          }
          var rows = asize[0];
          var columns = asize[1];
          var dt;
          var eq = equalScalar2;
          var zero = 0;
          var cf = callback;
          if (typeof adt === "string") {
            dt = adt;
            eq = typed2.find(equalScalar2, [dt, dt]);
            zero = typed2.convert(0, dt);
            b = typed2.convert(b, dt);
            cf = typed2.find(callback, [dt, dt]);
          }
          var cvalues = [];
          var cindex = [];
          var cptr = [];
          for (var j = 0; j < columns; j++) {
            cptr[j] = cindex.length;
            for (var k0 = aptr[j], k1 = aptr[j + 1], k = k0; k < k1; k++) {
              var i = aindex[k];
              var v = inverse ? cf(b, avalues[k]) : cf(avalues[k], b);
              if (!eq(v, zero)) {
                cindex.push(i);
                cvalues.push(v);
              }
            }
          }
          cptr[columns] = cindex.length;
          return s.createSparseMatrix({
            values: cvalues,
            index: cindex,
            ptr: cptr,
            size: [rows, columns],
            datatype: dt
          });
        };
      });
    }
  });

  // node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/type/matrix/utils/matAlgo12xSfs.js
  var require_matAlgo12xSfs = __commonJS({
    "node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/type/matrix/utils/matAlgo12xSfs.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.createMatAlgo12xSfs = void 0;
      var _factory = require_factory();
      var name18 = "matAlgo12xSfs";
      var dependencies19 = ["typed", "DenseMatrix"];
      var createMatAlgo12xSfs = exports.createMatAlgo12xSfs = /* @__PURE__ */ (0, _factory.factory)(name18, dependencies19, function(_ref) {
        var typed2 = _ref.typed, DenseMatrix2 = _ref.DenseMatrix;
        return function matAlgo12xSfs(s, b, callback, inverse) {
          var avalues = s._values;
          var aindex = s._index;
          var aptr = s._ptr;
          var asize = s._size;
          var adt = s._datatype;
          if (!avalues) {
            throw new Error("Cannot perform operation on Pattern Sparse Matrix and Scalar value");
          }
          var rows = asize[0];
          var columns = asize[1];
          var dt;
          var cf = callback;
          if (typeof adt === "string") {
            dt = adt;
            b = typed2.convert(b, dt);
            cf = typed2.find(callback, [dt, dt]);
          }
          var cdata = [];
          var x = [];
          var w = [];
          for (var j = 0; j < columns; j++) {
            var mark = j + 1;
            for (var k0 = aptr[j], k1 = aptr[j + 1], k = k0; k < k1; k++) {
              var r = aindex[k];
              x[r] = avalues[k];
              w[r] = mark;
            }
            for (var i = 0; i < rows; i++) {
              if (j === 0) {
                cdata[i] = [];
              }
              if (w[i] === mark) {
                cdata[i][j] = inverse ? cf(b, x[i]) : cf(x[i], b);
              } else {
                cdata[i][j] = inverse ? cf(b, 0) : cf(0, b);
              }
            }
          }
          return new DenseMatrix2({
            data: cdata,
            size: [rows, columns],
            datatype: dt
          });
        };
      });
    }
  });

  // node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/type/matrix/utils/matAlgo14xDs.js
  var require_matAlgo14xDs = __commonJS({
    "node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/type/matrix/utils/matAlgo14xDs.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.createMatAlgo14xDs = void 0;
      var _factory = require_factory();
      var _object = require_object();
      var name18 = "matAlgo14xDs";
      var dependencies19 = ["typed"];
      var createMatAlgo14xDs2 = exports.createMatAlgo14xDs = /* @__PURE__ */ (0, _factory.factory)(name18, dependencies19, function(_ref) {
        var typed2 = _ref.typed;
        return function matAlgo14xDs(a, b, callback, inverse) {
          var adata = a._data;
          var asize = a._size;
          var adt = a._datatype;
          var dt;
          var cf = callback;
          if (typeof adt === "string") {
            dt = adt;
            b = typed2.convert(b, dt);
            cf = typed2.find(callback, [dt, dt]);
          }
          var cdata = asize.length > 0 ? _iterate(cf, 0, asize, asize[0], adata, b, inverse) : [];
          return a.createDenseMatrix({
            data: cdata,
            size: (0, _object.clone)(asize),
            datatype: dt
          });
        };
        function _iterate(f, level, s, n, av, bv, inverse) {
          var cv = [];
          if (level === s.length - 1) {
            for (var i = 0; i < n; i++) {
              cv[i] = inverse ? f(bv, av[i]) : f(av[i], bv);
            }
          } else {
            for (var j = 0; j < n; j++) {
              cv[j] = _iterate(f, level + 1, s, s[level + 1], av[j], bv, inverse);
            }
          }
          return cv;
        }
      });
    }
  });

  // node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/function/arithmetic/ceil.js
  var require_ceil = __commonJS({
    "node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/function/arithmetic/ceil.js"(exports) {
      "use strict";
      var _interopRequireDefault = require_interopRequireDefault();
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.createCeilNumber = exports.createCeil = void 0;
      var _slicedToArray2 = _interopRequireDefault(require_slicedToArray());
      var _decimal = _interopRequireDefault(require_decimal());
      var _factory = require_factory();
      var _collection = require_collection();
      var _number = require_number();
      var _nearlyEqual = require_nearlyEqual();
      var _matAlgo11xS0s = require_matAlgo11xS0s();
      var _matAlgo12xSfs = require_matAlgo12xSfs();
      var _matAlgo14xDs = require_matAlgo14xDs();
      var name18 = "ceil";
      var dependencies19 = ["typed", "config", "round", "matrix", "equalScalar", "zeros", "DenseMatrix"];
      var createCeilNumber = exports.createCeilNumber = /* @__PURE__ */ (0, _factory.factory)(name18, ["typed", "config", "round"], function(_ref) {
        var typed2 = _ref.typed, config4 = _ref.config, round2 = _ref.round;
        return typed2(name18, {
          number: function number(x) {
            if ((0, _number.nearlyEqual)(x, round2(x), config4.epsilon)) {
              return round2(x);
            } else {
              return Math.ceil(x);
            }
          },
          "number, number": function numberNumber(x, n) {
            if ((0, _number.nearlyEqual)(x, round2(x, n), config4.epsilon)) {
              return round2(x, n);
            } else {
              var _split = "".concat(x, "e").split("e"), _split2 = (0, _slicedToArray2["default"])(_split, 2), number = _split2[0], exponent = _split2[1];
              var result = Math.ceil(Number("".concat(number, "e").concat(Number(exponent) + n)));
              var _split3 = "".concat(result, "e").split("e");
              var _split4 = (0, _slicedToArray2["default"])(_split3, 2);
              number = _split4[0];
              exponent = _split4[1];
              return Number("".concat(number, "e").concat(Number(exponent) - n));
            }
          }
        });
      });
      var createCeil2 = exports.createCeil = /* @__PURE__ */ (0, _factory.factory)(name18, dependencies19, function(_ref2) {
        var typed2 = _ref2.typed, config4 = _ref2.config, round2 = _ref2.round, matrix2 = _ref2.matrix, equalScalar2 = _ref2.equalScalar, zeros2 = _ref2.zeros, DenseMatrix2 = _ref2.DenseMatrix;
        var matAlgo11xS0s = (0, _matAlgo11xS0s.createMatAlgo11xS0s)({
          typed: typed2,
          equalScalar: equalScalar2
        });
        var matAlgo12xSfs = (0, _matAlgo12xSfs.createMatAlgo12xSfs)({
          typed: typed2,
          DenseMatrix: DenseMatrix2
        });
        var matAlgo14xDs = (0, _matAlgo14xDs.createMatAlgo14xDs)({
          typed: typed2
        });
        var ceilNumber = createCeilNumber({
          typed: typed2,
          config: config4,
          round: round2
        });
        return typed2("ceil", {
          number: ceilNumber.signatures.number,
          "number,number": ceilNumber.signatures["number,number"],
          Complex: function Complex3(x) {
            return x.ceil();
          },
          "Complex, number": function ComplexNumber(x, n) {
            return x.ceil(n);
          },
          "Complex, BigNumber": function ComplexBigNumber(x, n) {
            return x.ceil(n.toNumber());
          },
          BigNumber: function BigNumber2(x) {
            if ((0, _nearlyEqual.nearlyEqual)(x, round2(x), config4.epsilon)) {
              return round2(x);
            } else {
              return x.ceil();
            }
          },
          "BigNumber, BigNumber": function BigNumberBigNumber(x, n) {
            if ((0, _nearlyEqual.nearlyEqual)(x, round2(x, n), config4.epsilon)) {
              return round2(x, n);
            } else {
              return x.toDecimalPlaces(n.toNumber(), _decimal["default"].ROUND_CEIL);
            }
          },
          Fraction: function Fraction3(x) {
            return x.ceil();
          },
          "Fraction, number": function FractionNumber(x, n) {
            return x.ceil(n);
          },
          "Fraction, BigNumber": function FractionBigNumber(x, n) {
            return x.ceil(n.toNumber());
          },
          "Array | Matrix": typed2.referToSelf(function(self2) {
            return function(x) {
              return (0, _collection.deepMap)(x, self2, true);
            };
          }),
          "Array, number | BigNumber": typed2.referToSelf(function(self2) {
            return function(x, n) {
              return (0, _collection.deepMap)(x, function(i) {
                return self2(i, n);
              }, true);
            };
          }),
          "SparseMatrix, number | BigNumber": typed2.referToSelf(function(self2) {
            return function(x, y) {
              return matAlgo11xS0s(x, y, self2, false);
            };
          }),
          "DenseMatrix, number | BigNumber": typed2.referToSelf(function(self2) {
            return function(x, y) {
              return matAlgo14xDs(x, y, self2, false);
            };
          }),
          "number | Complex | Fraction | BigNumber, Array": typed2.referToSelf(function(self2) {
            return function(x, y) {
              return matAlgo14xDs(matrix2(y), x, self2, true).valueOf();
            };
          }),
          "number | Complex | Fraction | BigNumber, Matrix": typed2.referToSelf(function(self2) {
            return function(x, y) {
              if (equalScalar2(x, 0)) return zeros2(y.size(), y.storage());
              if (y.storage() === "dense") {
                return matAlgo14xDs(y, x, self2, true);
              }
              return matAlgo12xSfs(y, x, self2, true);
            };
          })
        });
      });
    }
  });

  // node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/function/arithmetic/cube.js
  var require_cube = __commonJS({
    "node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/function/arithmetic/cube.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.createCube = void 0;
      var _factory = require_factory();
      var _index = require_number2();
      var name18 = "cube";
      var dependencies19 = ["typed"];
      var createCube2 = exports.createCube = /* @__PURE__ */ (0, _factory.factory)(name18, dependencies19, function(_ref) {
        var typed2 = _ref.typed;
        return typed2(name18, {
          number: _index.cubeNumber,
          Complex: function Complex3(x) {
            return x.mul(x).mul(x);
          },
          BigNumber: function BigNumber2(x) {
            return x.times(x).times(x);
          },
          Fraction: function Fraction3(x) {
            return x.pow(3);
          },
          Unit: function Unit(x) {
            return x.pow(3);
          }
        });
      });
    }
  });

  // node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/function/arithmetic/exp.js
  var require_exp = __commonJS({
    "node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/function/arithmetic/exp.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.createExp = void 0;
      var _factory = require_factory();
      var _index = require_number2();
      var name18 = "exp";
      var dependencies19 = ["typed"];
      var createExp2 = exports.createExp = /* @__PURE__ */ (0, _factory.factory)(name18, dependencies19, function(_ref) {
        var typed2 = _ref.typed;
        return typed2(name18, {
          number: _index.expNumber,
          Complex: function Complex3(x) {
            return x.exp();
          },
          BigNumber: function BigNumber2(x) {
            return x.exp();
          }
        });
      });
    }
  });

  // node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/function/arithmetic/expm1.js
  var require_expm1 = __commonJS({
    "node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/function/arithmetic/expm1.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.createExpm1 = void 0;
      var _factory = require_factory();
      var _index = require_number2();
      var name18 = "expm1";
      var dependencies19 = ["typed", "Complex"];
      var createExpm12 = exports.createExpm1 = /* @__PURE__ */ (0, _factory.factory)(name18, dependencies19, function(_ref) {
        var typed2 = _ref.typed, _Complex = _ref.Complex;
        return typed2(name18, {
          number: _index.expm1Number,
          Complex: function Complex3(x) {
            var r = Math.exp(x.re);
            return new _Complex(r * Math.cos(x.im) - 1, r * Math.sin(x.im));
          },
          BigNumber: function BigNumber2(x) {
            return x.exp().minus(1);
          }
        });
      });
    }
  });

  // node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/function/arithmetic/fix.js
  var require_fix = __commonJS({
    "node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/function/arithmetic/fix.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.createFixNumber = exports.createFix = void 0;
      var _factory = require_factory();
      var _collection = require_collection();
      var _matAlgo12xSfs = require_matAlgo12xSfs();
      var _matAlgo14xDs = require_matAlgo14xDs();
      var name18 = "fix";
      var dependencies19 = ["typed", "Complex", "matrix", "ceil", "floor", "equalScalar", "zeros", "DenseMatrix"];
      var createFixNumber = exports.createFixNumber = /* @__PURE__ */ (0, _factory.factory)(name18, ["typed", "ceil", "floor"], function(_ref) {
        var typed2 = _ref.typed, ceil2 = _ref.ceil, floor2 = _ref.floor;
        return typed2(name18, {
          number: function number(x) {
            return x > 0 ? floor2(x) : ceil2(x);
          },
          "number, number": function numberNumber(x, n) {
            return x > 0 ? floor2(x, n) : ceil2(x, n);
          }
        });
      });
      var createFix2 = exports.createFix = /* @__PURE__ */ (0, _factory.factory)(name18, dependencies19, function(_ref2) {
        var typed2 = _ref2.typed, _Complex = _ref2.Complex, matrix2 = _ref2.matrix, ceil2 = _ref2.ceil, floor2 = _ref2.floor, equalScalar2 = _ref2.equalScalar, zeros2 = _ref2.zeros, DenseMatrix2 = _ref2.DenseMatrix;
        var matAlgo12xSfs = (0, _matAlgo12xSfs.createMatAlgo12xSfs)({
          typed: typed2,
          DenseMatrix: DenseMatrix2
        });
        var matAlgo14xDs = (0, _matAlgo14xDs.createMatAlgo14xDs)({
          typed: typed2
        });
        var fixNumber = createFixNumber({
          typed: typed2,
          ceil: ceil2,
          floor: floor2
        });
        return typed2("fix", {
          number: fixNumber.signatures.number,
          "number, number | BigNumber": fixNumber.signatures["number,number"],
          Complex: function Complex3(x) {
            return new _Complex(x.re > 0 ? Math.floor(x.re) : Math.ceil(x.re), x.im > 0 ? Math.floor(x.im) : Math.ceil(x.im));
          },
          "Complex, number": function ComplexNumber(x, n) {
            return new _Complex(x.re > 0 ? floor2(x.re, n) : ceil2(x.re, n), x.im > 0 ? floor2(x.im, n) : ceil2(x.im, n));
          },
          "Complex, BigNumber": function ComplexBigNumber(x, bn) {
            var n = bn.toNumber();
            return new _Complex(x.re > 0 ? floor2(x.re, n) : ceil2(x.re, n), x.im > 0 ? floor2(x.im, n) : ceil2(x.im, n));
          },
          BigNumber: function BigNumber2(x) {
            return x.isNegative() ? ceil2(x) : floor2(x);
          },
          "BigNumber, number | BigNumber": function BigNumberNumberBigNumber(x, n) {
            return x.isNegative() ? ceil2(x, n) : floor2(x, n);
          },
          Fraction: function Fraction3(x) {
            return x.s < 0 ? x.ceil() : x.floor();
          },
          "Fraction, number | BigNumber": function FractionNumberBigNumber(x, n) {
            return x.s < 0 ? ceil2(x, n) : floor2(x, n);
          },
          "Array | Matrix": typed2.referToSelf(function(self2) {
            return function(x) {
              return (0, _collection.deepMap)(x, self2, true);
            };
          }),
          "Array | Matrix, number | BigNumber": typed2.referToSelf(function(self2) {
            return function(x, n) {
              return (0, _collection.deepMap)(x, function(i) {
                return self2(i, n);
              }, true);
            };
          }),
          "number | Complex | Fraction | BigNumber, Array": typed2.referToSelf(function(self2) {
            return function(x, y) {
              return matAlgo14xDs(matrix2(y), x, self2, true).valueOf();
            };
          }),
          "number | Complex | Fraction | BigNumber, Matrix": typed2.referToSelf(function(self2) {
            return function(x, y) {
              if (equalScalar2(x, 0)) return zeros2(y.size(), y.storage());
              if (y.storage() === "dense") {
                return matAlgo14xDs(y, x, self2, true);
              }
              return matAlgo12xSfs(y, x, self2, true);
            };
          })
        });
      });
    }
  });

  // node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/function/arithmetic/floor.js
  var require_floor = __commonJS({
    "node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/function/arithmetic/floor.js"(exports) {
      "use strict";
      var _interopRequireDefault = require_interopRequireDefault();
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.createFloorNumber = exports.createFloor = void 0;
      var _slicedToArray2 = _interopRequireDefault(require_slicedToArray());
      var _decimal = _interopRequireDefault(require_decimal());
      var _factory = require_factory();
      var _collection = require_collection();
      var _number = require_number();
      var _nearlyEqual = require_nearlyEqual();
      var _matAlgo11xS0s = require_matAlgo11xS0s();
      var _matAlgo12xSfs = require_matAlgo12xSfs();
      var _matAlgo14xDs = require_matAlgo14xDs();
      var name18 = "floor";
      var dependencies19 = ["typed", "config", "round", "matrix", "equalScalar", "zeros", "DenseMatrix"];
      var createFloorNumber = exports.createFloorNumber = /* @__PURE__ */ (0, _factory.factory)(name18, ["typed", "config", "round"], function(_ref) {
        var typed2 = _ref.typed, config4 = _ref.config, round2 = _ref.round;
        return typed2(name18, {
          number: function number(x) {
            if ((0, _number.nearlyEqual)(x, round2(x), config4.epsilon)) {
              return round2(x);
            } else {
              return Math.floor(x);
            }
          },
          "number, number": function numberNumber(x, n) {
            if ((0, _number.nearlyEqual)(x, round2(x, n), config4.epsilon)) {
              return round2(x, n);
            } else {
              var _split = "".concat(x, "e").split("e"), _split2 = (0, _slicedToArray2["default"])(_split, 2), number = _split2[0], exponent = _split2[1];
              var result = Math.floor(Number("".concat(number, "e").concat(Number(exponent) + n)));
              var _split3 = "".concat(result, "e").split("e");
              var _split4 = (0, _slicedToArray2["default"])(_split3, 2);
              number = _split4[0];
              exponent = _split4[1];
              return Number("".concat(number, "e").concat(Number(exponent) - n));
            }
          }
        });
      });
      var createFloor2 = exports.createFloor = /* @__PURE__ */ (0, _factory.factory)(name18, dependencies19, function(_ref2) {
        var typed2 = _ref2.typed, config4 = _ref2.config, round2 = _ref2.round, matrix2 = _ref2.matrix, equalScalar2 = _ref2.equalScalar, zeros2 = _ref2.zeros, DenseMatrix2 = _ref2.DenseMatrix;
        var matAlgo11xS0s = (0, _matAlgo11xS0s.createMatAlgo11xS0s)({
          typed: typed2,
          equalScalar: equalScalar2
        });
        var matAlgo12xSfs = (0, _matAlgo12xSfs.createMatAlgo12xSfs)({
          typed: typed2,
          DenseMatrix: DenseMatrix2
        });
        var matAlgo14xDs = (0, _matAlgo14xDs.createMatAlgo14xDs)({
          typed: typed2
        });
        var floorNumber = createFloorNumber({
          typed: typed2,
          config: config4,
          round: round2
        });
        return typed2("floor", {
          number: floorNumber.signatures.number,
          "number,number": floorNumber.signatures["number,number"],
          Complex: function Complex3(x) {
            return x.floor();
          },
          "Complex, number": function ComplexNumber(x, n) {
            return x.floor(n);
          },
          "Complex, BigNumber": function ComplexBigNumber(x, n) {
            return x.floor(n.toNumber());
          },
          BigNumber: function BigNumber2(x) {
            if ((0, _nearlyEqual.nearlyEqual)(x, round2(x), config4.epsilon)) {
              return round2(x);
            } else {
              return x.floor();
            }
          },
          "BigNumber, BigNumber": function BigNumberBigNumber(x, n) {
            if ((0, _nearlyEqual.nearlyEqual)(x, round2(x, n), config4.epsilon)) {
              return round2(x, n);
            } else {
              return x.toDecimalPlaces(n.toNumber(), _decimal["default"].ROUND_FLOOR);
            }
          },
          Fraction: function Fraction3(x) {
            return x.floor();
          },
          "Fraction, number": function FractionNumber(x, n) {
            return x.floor(n);
          },
          "Fraction, BigNumber": function FractionBigNumber(x, n) {
            return x.floor(n.toNumber());
          },
          "Array | Matrix": typed2.referToSelf(function(self2) {
            return function(x) {
              return (0, _collection.deepMap)(x, self2, true);
            };
          }),
          "Array, number | BigNumber": typed2.referToSelf(function(self2) {
            return function(x, n) {
              return (0, _collection.deepMap)(x, function(i) {
                return self2(i, n);
              }, true);
            };
          }),
          "SparseMatrix, number | BigNumber": typed2.referToSelf(function(self2) {
            return function(x, y) {
              return matAlgo11xS0s(x, y, self2, false);
            };
          }),
          "DenseMatrix, number | BigNumber": typed2.referToSelf(function(self2) {
            return function(x, y) {
              return matAlgo14xDs(x, y, self2, false);
            };
          }),
          "number | Complex | Fraction | BigNumber, Array": typed2.referToSelf(function(self2) {
            return function(x, y) {
              return matAlgo14xDs(matrix2(y), x, self2, true).valueOf();
            };
          }),
          "number | Complex | Fraction | BigNumber, Matrix": typed2.referToSelf(function(self2) {
            return function(x, y) {
              if (equalScalar2(x, 0)) return zeros2(y.size(), y.storage());
              if (y.storage() === "dense") {
                return matAlgo14xDs(y, x, self2, true);
              }
              return matAlgo12xSfs(y, x, self2, true);
            };
          })
        });
      });
    }
  });

  // node_modules/.pnpm/@babel+runtime@7.28.4/node_modules/@babel/runtime/helpers/defineProperty.js
  var require_defineProperty = __commonJS({
    "node_modules/.pnpm/@babel+runtime@7.28.4/node_modules/@babel/runtime/helpers/defineProperty.js"(exports, module) {
      var toPropertyKey = require_toPropertyKey();
      function _defineProperty(e, r, t) {
        return (r = toPropertyKey(r)) in e ? Object.defineProperty(e, r, {
          value: t,
          enumerable: true,
          configurable: true,
          writable: true
        }) : e[r] = t, e;
      }
      module.exports = _defineProperty, module.exports.__esModule = true, module.exports["default"] = module.exports;
    }
  });

  // node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/type/matrix/utils/matAlgo02xDS0.js
  var require_matAlgo02xDS0 = __commonJS({
    "node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/type/matrix/utils/matAlgo02xDS0.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.createMatAlgo02xDS0 = void 0;
      var _factory = require_factory();
      var _DimensionError = require_DimensionError();
      var name18 = "matAlgo02xDS0";
      var dependencies19 = ["typed", "equalScalar"];
      var createMatAlgo02xDS0 = exports.createMatAlgo02xDS0 = /* @__PURE__ */ (0, _factory.factory)(name18, dependencies19, function(_ref) {
        var typed2 = _ref.typed, equalScalar2 = _ref.equalScalar;
        return function matAlgo02xDS0(denseMatrix, sparseMatrix, callback, inverse) {
          var adata = denseMatrix._data;
          var asize = denseMatrix._size;
          var adt = denseMatrix._datatype || denseMatrix.getDataType();
          var bvalues = sparseMatrix._values;
          var bindex = sparseMatrix._index;
          var bptr = sparseMatrix._ptr;
          var bsize = sparseMatrix._size;
          var bdt = sparseMatrix._datatype || sparseMatrix._data === void 0 ? sparseMatrix._datatype : sparseMatrix.getDataType();
          if (asize.length !== bsize.length) {
            throw new _DimensionError.DimensionError(asize.length, bsize.length);
          }
          if (asize[0] !== bsize[0] || asize[1] !== bsize[1]) {
            throw new RangeError("Dimension mismatch. Matrix A (" + asize + ") must match Matrix B (" + bsize + ")");
          }
          if (!bvalues) {
            throw new Error("Cannot perform operation on Dense Matrix and Pattern Sparse Matrix");
          }
          var rows = asize[0];
          var columns = asize[1];
          var dt;
          var eq = equalScalar2;
          var zero = 0;
          var cf = callback;
          if (typeof adt === "string" && adt === bdt && adt !== "mixed") {
            dt = adt;
            eq = typed2.find(equalScalar2, [dt, dt]);
            zero = typed2.convert(0, dt);
            cf = typed2.find(callback, [dt, dt]);
          }
          var cvalues = [];
          var cindex = [];
          var cptr = [];
          for (var j = 0; j < columns; j++) {
            cptr[j] = cindex.length;
            for (var k0 = bptr[j], k1 = bptr[j + 1], k = k0; k < k1; k++) {
              var i = bindex[k];
              var cij = inverse ? cf(bvalues[k], adata[i][j]) : cf(adata[i][j], bvalues[k]);
              if (!eq(cij, zero)) {
                cindex.push(i);
                cvalues.push(cij);
              }
            }
          }
          cptr[columns] = cindex.length;
          return sparseMatrix.createSparseMatrix({
            values: cvalues,
            index: cindex,
            ptr: cptr,
            size: [rows, columns],
            datatype: adt === denseMatrix._datatype && bdt === sparseMatrix._datatype ? dt : void 0
          });
        };
      });
    }
  });

  // node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/type/matrix/utils/matAlgo03xDSf.js
  var require_matAlgo03xDSf = __commonJS({
    "node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/type/matrix/utils/matAlgo03xDSf.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.createMatAlgo03xDSf = void 0;
      var _factory = require_factory();
      var _DimensionError = require_DimensionError();
      var name18 = "matAlgo03xDSf";
      var dependencies19 = ["typed"];
      var createMatAlgo03xDSf = exports.createMatAlgo03xDSf = /* @__PURE__ */ (0, _factory.factory)(name18, dependencies19, function(_ref) {
        var typed2 = _ref.typed;
        return function matAlgo03xDSf(denseMatrix, sparseMatrix, callback, inverse) {
          var adata = denseMatrix._data;
          var asize = denseMatrix._size;
          var adt = denseMatrix._datatype || denseMatrix.getDataType();
          var bvalues = sparseMatrix._values;
          var bindex = sparseMatrix._index;
          var bptr = sparseMatrix._ptr;
          var bsize = sparseMatrix._size;
          var bdt = sparseMatrix._datatype || sparseMatrix._data === void 0 ? sparseMatrix._datatype : sparseMatrix.getDataType();
          if (asize.length !== bsize.length) {
            throw new _DimensionError.DimensionError(asize.length, bsize.length);
          }
          if (asize[0] !== bsize[0] || asize[1] !== bsize[1]) {
            throw new RangeError("Dimension mismatch. Matrix A (" + asize + ") must match Matrix B (" + bsize + ")");
          }
          if (!bvalues) {
            throw new Error("Cannot perform operation on Dense Matrix and Pattern Sparse Matrix");
          }
          var rows = asize[0];
          var columns = asize[1];
          var dt;
          var zero = 0;
          var cf = callback;
          if (typeof adt === "string" && adt === bdt && adt !== "mixed") {
            dt = adt;
            zero = typed2.convert(0, dt);
            cf = typed2.find(callback, [dt, dt]);
          }
          var cdata = [];
          for (var z = 0; z < rows; z++) {
            cdata[z] = [];
          }
          var x = [];
          var w = [];
          for (var j = 0; j < columns; j++) {
            var mark = j + 1;
            for (var k0 = bptr[j], k1 = bptr[j + 1], k = k0; k < k1; k++) {
              var i = bindex[k];
              x[i] = inverse ? cf(bvalues[k], adata[i][j]) : cf(adata[i][j], bvalues[k]);
              w[i] = mark;
            }
            for (var y = 0; y < rows; y++) {
              if (w[y] === mark) {
                cdata[y][j] = x[y];
              } else {
                cdata[y][j] = inverse ? cf(zero, adata[y][j]) : cf(adata[y][j], zero);
              }
            }
          }
          return denseMatrix.createDenseMatrix({
            data: cdata,
            size: [rows, columns],
            datatype: adt === denseMatrix._datatype && bdt === sparseMatrix._datatype ? dt : void 0
          });
        };
      });
    }
  });

  // node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/type/matrix/utils/matAlgo05xSfSf.js
  var require_matAlgo05xSfSf = __commonJS({
    "node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/type/matrix/utils/matAlgo05xSfSf.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.createMatAlgo05xSfSf = void 0;
      var _factory = require_factory();
      var _DimensionError = require_DimensionError();
      var name18 = "matAlgo05xSfSf";
      var dependencies19 = ["typed", "equalScalar"];
      var createMatAlgo05xSfSf = exports.createMatAlgo05xSfSf = /* @__PURE__ */ (0, _factory.factory)(name18, dependencies19, function(_ref) {
        var typed2 = _ref.typed, equalScalar2 = _ref.equalScalar;
        return function matAlgo05xSfSf(a, b, callback) {
          var avalues = a._values;
          var aindex = a._index;
          var aptr = a._ptr;
          var asize = a._size;
          var adt = a._datatype || a._data === void 0 ? a._datatype : a.getDataType();
          var bvalues = b._values;
          var bindex = b._index;
          var bptr = b._ptr;
          var bsize = b._size;
          var bdt = b._datatype || b._data === void 0 ? b._datatype : b.getDataType();
          if (asize.length !== bsize.length) {
            throw new _DimensionError.DimensionError(asize.length, bsize.length);
          }
          if (asize[0] !== bsize[0] || asize[1] !== bsize[1]) {
            throw new RangeError("Dimension mismatch. Matrix A (" + asize + ") must match Matrix B (" + bsize + ")");
          }
          var rows = asize[0];
          var columns = asize[1];
          var dt;
          var eq = equalScalar2;
          var zero = 0;
          var cf = callback;
          if (typeof adt === "string" && adt === bdt && adt !== "mixed") {
            dt = adt;
            eq = typed2.find(equalScalar2, [dt, dt]);
            zero = typed2.convert(0, dt);
            cf = typed2.find(callback, [dt, dt]);
          }
          var cvalues = avalues && bvalues ? [] : void 0;
          var cindex = [];
          var cptr = [];
          var xa = cvalues ? [] : void 0;
          var xb = cvalues ? [] : void 0;
          var wa = [];
          var wb = [];
          var i, j, k, k1;
          for (j = 0; j < columns; j++) {
            cptr[j] = cindex.length;
            var mark = j + 1;
            for (k = aptr[j], k1 = aptr[j + 1]; k < k1; k++) {
              i = aindex[k];
              cindex.push(i);
              wa[i] = mark;
              if (xa) {
                xa[i] = avalues[k];
              }
            }
            for (k = bptr[j], k1 = bptr[j + 1]; k < k1; k++) {
              i = bindex[k];
              if (wa[i] !== mark) {
                cindex.push(i);
              }
              wb[i] = mark;
              if (xb) {
                xb[i] = bvalues[k];
              }
            }
            if (cvalues) {
              k = cptr[j];
              while (k < cindex.length) {
                i = cindex[k];
                var wai = wa[i];
                var wbi = wb[i];
                if (wai === mark || wbi === mark) {
                  var va = wai === mark ? xa[i] : zero;
                  var vb = wbi === mark ? xb[i] : zero;
                  var vc = cf(va, vb);
                  if (!eq(vc, zero)) {
                    cvalues.push(vc);
                    k++;
                  } else {
                    cindex.splice(k, 1);
                  }
                }
              }
            }
          }
          cptr[columns] = cindex.length;
          return a.createSparseMatrix({
            values: cvalues,
            index: cindex,
            ptr: cptr,
            size: [rows, columns],
            datatype: adt === a._datatype && bdt === b._datatype ? dt : void 0
          });
        };
      });
    }
  });

  // node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/type/matrix/utils/matAlgo13xDD.js
  var require_matAlgo13xDD = __commonJS({
    "node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/type/matrix/utils/matAlgo13xDD.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.createMatAlgo13xDD = void 0;
      var _factory = require_factory();
      var _DimensionError = require_DimensionError();
      var name18 = "matAlgo13xDD";
      var dependencies19 = ["typed"];
      var createMatAlgo13xDD = exports.createMatAlgo13xDD = /* @__PURE__ */ (0, _factory.factory)(name18, dependencies19, function(_ref) {
        var typed2 = _ref.typed;
        return function matAlgo13xDD(a, b, callback) {
          var adata = a._data;
          var asize = a._size;
          var adt = a._datatype;
          var bdata = b._data;
          var bsize = b._size;
          var bdt = b._datatype;
          var csize = [];
          if (asize.length !== bsize.length) {
            throw new _DimensionError.DimensionError(asize.length, bsize.length);
          }
          for (var s = 0; s < asize.length; s++) {
            if (asize[s] !== bsize[s]) {
              throw new RangeError("Dimension mismatch. Matrix A (" + asize + ") must match Matrix B (" + bsize + ")");
            }
            csize[s] = asize[s];
          }
          var dt;
          var cf = callback;
          if (typeof adt === "string" && adt === bdt) {
            dt = adt;
            cf = typed2.find(callback, [dt, dt]);
          }
          var cdata = csize.length > 0 ? _iterate(cf, 0, csize, csize[0], adata, bdata) : [];
          return a.createDenseMatrix({
            data: cdata,
            size: csize,
            datatype: dt
          });
        };
        function _iterate(f, level, s, n, av, bv) {
          var cv = [];
          if (level === s.length - 1) {
            for (var i = 0; i < n; i++) {
              cv[i] = f(av[i], bv[i]);
            }
          } else {
            for (var j = 0; j < n; j++) {
              cv[j] = _iterate(f, level + 1, s, s[level + 1], av[j], bv[j]);
            }
          }
          return cv;
        }
      });
    }
  });

  // node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/type/matrix/utils/broadcast.js
  var require_broadcast = __commonJS({
    "node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/type/matrix/utils/broadcast.js"(exports) {
      "use strict";
      var _interopRequireDefault = require_interopRequireDefault();
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.createBroadcast = void 0;
      var _toConsumableArray2 = _interopRequireDefault(require_toConsumableArray());
      var _array = require_array();
      var _factory = require_factory();
      var name18 = "broadcast";
      var dependancies = ["concat"];
      var createBroadcast = exports.createBroadcast = /* @__PURE__ */ (0, _factory.factory)(name18, dependancies, function(_ref) {
        var concat2 = _ref.concat;
        return function(A, B) {
          var N = Math.max(A._size.length, B._size.length);
          if (A._size.length === B._size.length) {
            if (A._size.every(function(dim2, i) {
              return dim2 === B._size[i];
            })) {
              return [A, B];
            }
          }
          var sizeA = _padLeft(A._size, N, 0);
          var sizeB = _padLeft(B._size, N, 0);
          var sizeMax = [];
          for (var dim = 0; dim < N; dim++) {
            sizeMax[dim] = Math.max(sizeA[dim], sizeB[dim]);
          }
          (0, _array.checkBroadcastingRules)(sizeA, sizeMax);
          (0, _array.checkBroadcastingRules)(sizeB, sizeMax);
          var AA = A.clone();
          var BB = B.clone();
          if (AA._size.length < N) {
            AA.reshape(_padLeft(AA._size, N, 1));
          } else if (BB._size.length < N) {
            BB.reshape(_padLeft(BB._size, N, 1));
          }
          for (var _dim = 0; _dim < N; _dim++) {
            if (AA._size[_dim] < sizeMax[_dim]) {
              AA = _stretch(AA, sizeMax[_dim], _dim);
            }
            if (BB._size[_dim] < sizeMax[_dim]) {
              BB = _stretch(BB, sizeMax[_dim], _dim);
            }
          }
          return [AA, BB];
        };
        function _padLeft(shape, N, filler) {
          return [].concat((0, _toConsumableArray2["default"])(Array(N - shape.length).fill(filler)), (0, _toConsumableArray2["default"])(shape));
        }
        function _stretch(arrayToStretch, sizeToStretch, dimToStretch) {
          return concat2.apply(void 0, (0, _toConsumableArray2["default"])(Array(sizeToStretch).fill(arrayToStretch)).concat([dimToStretch]));
        }
      });
    }
  });

  // node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/type/matrix/utils/matrixAlgorithmSuite.js
  var require_matrixAlgorithmSuite = __commonJS({
    "node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/type/matrix/utils/matrixAlgorithmSuite.js"(exports) {
      "use strict";
      var _interopRequireDefault = require_interopRequireDefault();
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.createMatrixAlgorithmSuite = void 0;
      var _toConsumableArray2 = _interopRequireDefault(require_toConsumableArray());
      var _factory = require_factory();
      var _object = require_object();
      var _matAlgo13xDD = require_matAlgo13xDD();
      var _matAlgo14xDs = require_matAlgo14xDs();
      var _broadcast = require_broadcast();
      var name18 = "matrixAlgorithmSuite";
      var dependencies19 = ["typed", "matrix", "concat"];
      var createMatrixAlgorithmSuite = exports.createMatrixAlgorithmSuite = /* @__PURE__ */ (0, _factory.factory)(name18, dependencies19, function(_ref) {
        var typed2 = _ref.typed, matrix2 = _ref.matrix, concat2 = _ref.concat;
        var matAlgo13xDD = (0, _matAlgo13xDD.createMatAlgo13xDD)({
          typed: typed2
        });
        var matAlgo14xDs = (0, _matAlgo14xDs.createMatAlgo14xDs)({
          typed: typed2
        });
        var broadcast = (0, _broadcast.createBroadcast)({
          concat: concat2
        });
        return function matrixAlgorithmSuite(options) {
          var elop = options.elop;
          var SD = options.SD || options.DS;
          var matrixSignatures;
          if (elop) {
            matrixSignatures = {
              "DenseMatrix, DenseMatrix": function DenseMatrixDenseMatrix(x, y) {
                return matAlgo13xDD.apply(void 0, (0, _toConsumableArray2["default"])(broadcast(x, y)).concat([elop]));
              },
              "Array, Array": function ArrayArray(x, y) {
                return matAlgo13xDD.apply(void 0, (0, _toConsumableArray2["default"])(broadcast(matrix2(x), matrix2(y))).concat([elop])).valueOf();
              },
              "Array, DenseMatrix": function ArrayDenseMatrix(x, y) {
                return matAlgo13xDD.apply(void 0, (0, _toConsumableArray2["default"])(broadcast(matrix2(x), y)).concat([elop]));
              },
              "DenseMatrix, Array": function DenseMatrixArray(x, y) {
                return matAlgo13xDD.apply(void 0, (0, _toConsumableArray2["default"])(broadcast(x, matrix2(y))).concat([elop]));
              }
            };
            if (options.SS) {
              matrixSignatures["SparseMatrix, SparseMatrix"] = function(x, y) {
                return options.SS.apply(options, (0, _toConsumableArray2["default"])(broadcast(x, y)).concat([elop, false]));
              };
            }
            if (options.DS) {
              matrixSignatures["DenseMatrix, SparseMatrix"] = function(x, y) {
                return options.DS.apply(options, (0, _toConsumableArray2["default"])(broadcast(x, y)).concat([elop, false]));
              };
              matrixSignatures["Array, SparseMatrix"] = function(x, y) {
                return options.DS.apply(options, (0, _toConsumableArray2["default"])(broadcast(matrix2(x), y)).concat([elop, false]));
              };
            }
            if (SD) {
              matrixSignatures["SparseMatrix, DenseMatrix"] = function(x, y) {
                return SD.apply(void 0, (0, _toConsumableArray2["default"])(broadcast(y, x)).concat([elop, true]));
              };
              matrixSignatures["SparseMatrix, Array"] = function(x, y) {
                return SD.apply(void 0, (0, _toConsumableArray2["default"])(broadcast(matrix2(y), x)).concat([elop, true]));
              };
            }
          } else {
            matrixSignatures = {
              "DenseMatrix, DenseMatrix": typed2.referToSelf(function(self2) {
                return function(x, y) {
                  return matAlgo13xDD.apply(void 0, (0, _toConsumableArray2["default"])(broadcast(x, y)).concat([self2]));
                };
              }),
              "Array, Array": typed2.referToSelf(function(self2) {
                return function(x, y) {
                  return matAlgo13xDD.apply(void 0, (0, _toConsumableArray2["default"])(broadcast(matrix2(x), matrix2(y))).concat([self2])).valueOf();
                };
              }),
              "Array, DenseMatrix": typed2.referToSelf(function(self2) {
                return function(x, y) {
                  return matAlgo13xDD.apply(void 0, (0, _toConsumableArray2["default"])(broadcast(matrix2(x), y)).concat([self2]));
                };
              }),
              "DenseMatrix, Array": typed2.referToSelf(function(self2) {
                return function(x, y) {
                  return matAlgo13xDD.apply(void 0, (0, _toConsumableArray2["default"])(broadcast(x, matrix2(y))).concat([self2]));
                };
              })
            };
            if (options.SS) {
              matrixSignatures["SparseMatrix, SparseMatrix"] = typed2.referToSelf(function(self2) {
                return function(x, y) {
                  return options.SS.apply(options, (0, _toConsumableArray2["default"])(broadcast(x, y)).concat([self2, false]));
                };
              });
            }
            if (options.DS) {
              matrixSignatures["DenseMatrix, SparseMatrix"] = typed2.referToSelf(function(self2) {
                return function(x, y) {
                  return options.DS.apply(options, (0, _toConsumableArray2["default"])(broadcast(x, y)).concat([self2, false]));
                };
              });
              matrixSignatures["Array, SparseMatrix"] = typed2.referToSelf(function(self2) {
                return function(x, y) {
                  return options.DS.apply(options, (0, _toConsumableArray2["default"])(broadcast(matrix2(x), y)).concat([self2, false]));
                };
              });
            }
            if (SD) {
              matrixSignatures["SparseMatrix, DenseMatrix"] = typed2.referToSelf(function(self2) {
                return function(x, y) {
                  return SD.apply(void 0, (0, _toConsumableArray2["default"])(broadcast(y, x)).concat([self2, true]));
                };
              });
              matrixSignatures["SparseMatrix, Array"] = typed2.referToSelf(function(self2) {
                return function(x, y) {
                  return SD.apply(void 0, (0, _toConsumableArray2["default"])(broadcast(matrix2(y), x)).concat([self2, true]));
                };
              });
            }
          }
          var scalar = options.scalar || "any";
          var Ds = options.Ds || options.Ss;
          if (Ds) {
            if (elop) {
              matrixSignatures["DenseMatrix," + scalar] = function(x, y) {
                return matAlgo14xDs(x, y, elop, false);
              };
              matrixSignatures[scalar + ", DenseMatrix"] = function(x, y) {
                return matAlgo14xDs(y, x, elop, true);
              };
              matrixSignatures["Array," + scalar] = function(x, y) {
                return matAlgo14xDs(matrix2(x), y, elop, false).valueOf();
              };
              matrixSignatures[scalar + ", Array"] = function(x, y) {
                return matAlgo14xDs(matrix2(y), x, elop, true).valueOf();
              };
            } else {
              matrixSignatures["DenseMatrix," + scalar] = typed2.referToSelf(function(self2) {
                return function(x, y) {
                  return matAlgo14xDs(x, y, self2, false);
                };
              });
              matrixSignatures[scalar + ", DenseMatrix"] = typed2.referToSelf(function(self2) {
                return function(x, y) {
                  return matAlgo14xDs(y, x, self2, true);
                };
              });
              matrixSignatures["Array," + scalar] = typed2.referToSelf(function(self2) {
                return function(x, y) {
                  return matAlgo14xDs(matrix2(x), y, self2, false).valueOf();
                };
              });
              matrixSignatures[scalar + ", Array"] = typed2.referToSelf(function(self2) {
                return function(x, y) {
                  return matAlgo14xDs(matrix2(y), x, self2, true).valueOf();
                };
              });
            }
          }
          var sS = options.sS !== void 0 ? options.sS : options.Ss;
          if (elop) {
            if (options.Ss) {
              matrixSignatures["SparseMatrix," + scalar] = function(x, y) {
                return options.Ss(x, y, elop, false);
              };
            }
            if (sS) {
              matrixSignatures[scalar + ", SparseMatrix"] = function(x, y) {
                return sS(y, x, elop, true);
              };
            }
          } else {
            if (options.Ss) {
              matrixSignatures["SparseMatrix," + scalar] = typed2.referToSelf(function(self2) {
                return function(x, y) {
                  return options.Ss(x, y, self2, false);
                };
              });
            }
            if (sS) {
              matrixSignatures[scalar + ", SparseMatrix"] = typed2.referToSelf(function(self2) {
                return function(x, y) {
                  return sS(y, x, self2, true);
                };
              });
            }
          }
          if (elop && elop.signatures) {
            (0, _object.extend)(matrixSignatures, elop.signatures);
          }
          return matrixSignatures;
        };
      });
    }
  });

  // node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/function/arithmetic/mod.js
  var require_mod = __commonJS({
    "node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/function/arithmetic/mod.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.createMod = void 0;
      var _factory = require_factory();
      var _floor = require_floor();
      var _matAlgo02xDS = require_matAlgo02xDS0();
      var _matAlgo03xDSf = require_matAlgo03xDSf();
      var _matAlgo05xSfSf = require_matAlgo05xSfSf();
      var _matAlgo11xS0s = require_matAlgo11xS0s();
      var _matAlgo12xSfs = require_matAlgo12xSfs();
      var _matrixAlgorithmSuite = require_matrixAlgorithmSuite();
      var name18 = "mod";
      var dependencies19 = ["typed", "config", "round", "matrix", "equalScalar", "zeros", "DenseMatrix", "concat"];
      var createMod2 = exports.createMod = /* @__PURE__ */ (0, _factory.factory)(name18, dependencies19, function(_ref) {
        var typed2 = _ref.typed, config4 = _ref.config, round2 = _ref.round, matrix2 = _ref.matrix, equalScalar2 = _ref.equalScalar, zeros2 = _ref.zeros, DenseMatrix2 = _ref.DenseMatrix, concat2 = _ref.concat;
        var floor2 = (0, _floor.createFloor)({
          typed: typed2,
          config: config4,
          round: round2,
          matrix: matrix2,
          equalScalar: equalScalar2,
          zeros: zeros2,
          DenseMatrix: DenseMatrix2
        });
        var matAlgo02xDS0 = (0, _matAlgo02xDS.createMatAlgo02xDS0)({
          typed: typed2,
          equalScalar: equalScalar2
        });
        var matAlgo03xDSf = (0, _matAlgo03xDSf.createMatAlgo03xDSf)({
          typed: typed2
        });
        var matAlgo05xSfSf = (0, _matAlgo05xSfSf.createMatAlgo05xSfSf)({
          typed: typed2,
          equalScalar: equalScalar2
        });
        var matAlgo11xS0s = (0, _matAlgo11xS0s.createMatAlgo11xS0s)({
          typed: typed2,
          equalScalar: equalScalar2
        });
        var matAlgo12xSfs = (0, _matAlgo12xSfs.createMatAlgo12xSfs)({
          typed: typed2,
          DenseMatrix: DenseMatrix2
        });
        var matrixAlgorithmSuite = (0, _matrixAlgorithmSuite.createMatrixAlgorithmSuite)({
          typed: typed2,
          matrix: matrix2,
          concat: concat2
        });
        return typed2(name18, {
          "number, number": _modNumber,
          "BigNumber, BigNumber": function BigNumberBigNumber(x, y) {
            return y.isZero() ? x : x.sub(y.mul(floor2(x.div(y))));
          },
          "Fraction, Fraction": function FractionFraction(x, y) {
            return y.equals(0) ? x : x.sub(y.mul(floor2(x.div(y))));
          }
        }, matrixAlgorithmSuite({
          SS: matAlgo05xSfSf,
          DS: matAlgo03xDSf,
          SD: matAlgo02xDS0,
          Ss: matAlgo11xS0s,
          sS: matAlgo12xSfs
        }));
        function _modNumber(x, y) {
          return y === 0 ? x : x - y * floor2(x / y);
        }
      });
    }
  });

  // node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/type/matrix/utils/matAlgo01xDSid.js
  var require_matAlgo01xDSid = __commonJS({
    "node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/type/matrix/utils/matAlgo01xDSid.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.createMatAlgo01xDSid = void 0;
      var _factory = require_factory();
      var _DimensionError = require_DimensionError();
      var name18 = "matAlgo01xDSid";
      var dependencies19 = ["typed"];
      var createMatAlgo01xDSid = exports.createMatAlgo01xDSid = /* @__PURE__ */ (0, _factory.factory)(name18, dependencies19, function(_ref) {
        var typed2 = _ref.typed;
        return function algorithm1(denseMatrix, sparseMatrix, callback, inverse) {
          var adata = denseMatrix._data;
          var asize = denseMatrix._size;
          var adt = denseMatrix._datatype || denseMatrix.getDataType();
          var bvalues = sparseMatrix._values;
          var bindex = sparseMatrix._index;
          var bptr = sparseMatrix._ptr;
          var bsize = sparseMatrix._size;
          var bdt = sparseMatrix._datatype || sparseMatrix._data === void 0 ? sparseMatrix._datatype : sparseMatrix.getDataType();
          if (asize.length !== bsize.length) {
            throw new _DimensionError.DimensionError(asize.length, bsize.length);
          }
          if (asize[0] !== bsize[0] || asize[1] !== bsize[1]) {
            throw new RangeError("Dimension mismatch. Matrix A (" + asize + ") must match Matrix B (" + bsize + ")");
          }
          if (!bvalues) {
            throw new Error("Cannot perform operation on Dense Matrix and Pattern Sparse Matrix");
          }
          var rows = asize[0];
          var columns = asize[1];
          var dt = typeof adt === "string" && adt !== "mixed" && adt === bdt ? adt : void 0;
          var cf = dt ? typed2.find(callback, [dt, dt]) : callback;
          var i, j;
          var cdata = [];
          for (i = 0; i < rows; i++) {
            cdata[i] = [];
          }
          var x = [];
          var w = [];
          for (j = 0; j < columns; j++) {
            var mark = j + 1;
            for (var k0 = bptr[j], k1 = bptr[j + 1], k = k0; k < k1; k++) {
              i = bindex[k];
              x[i] = inverse ? cf(bvalues[k], adata[i][j]) : cf(adata[i][j], bvalues[k]);
              w[i] = mark;
            }
            for (i = 0; i < rows; i++) {
              if (w[i] === mark) {
                cdata[i][j] = x[i];
              } else {
                cdata[i][j] = adata[i][j];
              }
            }
          }
          return denseMatrix.createDenseMatrix({
            data: cdata,
            size: [rows, columns],
            datatype: adt === denseMatrix._datatype && bdt === sparseMatrix._datatype ? dt : void 0
          });
        };
      });
    }
  });

  // node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/type/matrix/utils/matAlgo04xSidSid.js
  var require_matAlgo04xSidSid = __commonJS({
    "node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/type/matrix/utils/matAlgo04xSidSid.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.createMatAlgo04xSidSid = void 0;
      var _factory = require_factory();
      var _DimensionError = require_DimensionError();
      var name18 = "matAlgo04xSidSid";
      var dependencies19 = ["typed", "equalScalar"];
      var createMatAlgo04xSidSid = exports.createMatAlgo04xSidSid = /* @__PURE__ */ (0, _factory.factory)(name18, dependencies19, function(_ref) {
        var typed2 = _ref.typed, equalScalar2 = _ref.equalScalar;
        return function matAlgo04xSidSid(a, b, callback) {
          var avalues = a._values;
          var aindex = a._index;
          var aptr = a._ptr;
          var asize = a._size;
          var adt = a._datatype || a._data === void 0 ? a._datatype : a.getDataType();
          var bvalues = b._values;
          var bindex = b._index;
          var bptr = b._ptr;
          var bsize = b._size;
          var bdt = b._datatype || b._data === void 0 ? b._datatype : b.getDataType();
          if (asize.length !== bsize.length) {
            throw new _DimensionError.DimensionError(asize.length, bsize.length);
          }
          if (asize[0] !== bsize[0] || asize[1] !== bsize[1]) {
            throw new RangeError("Dimension mismatch. Matrix A (" + asize + ") must match Matrix B (" + bsize + ")");
          }
          var rows = asize[0];
          var columns = asize[1];
          var dt;
          var eq = equalScalar2;
          var zero = 0;
          var cf = callback;
          if (typeof adt === "string" && adt === bdt && adt !== "mixed") {
            dt = adt;
            eq = typed2.find(equalScalar2, [dt, dt]);
            zero = typed2.convert(0, dt);
            cf = typed2.find(callback, [dt, dt]);
          }
          var cvalues = avalues && bvalues ? [] : void 0;
          var cindex = [];
          var cptr = [];
          var xa = avalues && bvalues ? [] : void 0;
          var xb = avalues && bvalues ? [] : void 0;
          var wa = [];
          var wb = [];
          var i, j, k, k0, k1;
          for (j = 0; j < columns; j++) {
            cptr[j] = cindex.length;
            var mark = j + 1;
            for (k0 = aptr[j], k1 = aptr[j + 1], k = k0; k < k1; k++) {
              i = aindex[k];
              cindex.push(i);
              wa[i] = mark;
              if (xa) {
                xa[i] = avalues[k];
              }
            }
            for (k0 = bptr[j], k1 = bptr[j + 1], k = k0; k < k1; k++) {
              i = bindex[k];
              if (wa[i] === mark) {
                if (xa) {
                  var v = cf(xa[i], bvalues[k]);
                  if (!eq(v, zero)) {
                    xa[i] = v;
                  } else {
                    wa[i] = null;
                  }
                }
              } else {
                cindex.push(i);
                wb[i] = mark;
                if (xb) {
                  xb[i] = bvalues[k];
                }
              }
            }
            if (xa && xb) {
              k = cptr[j];
              while (k < cindex.length) {
                i = cindex[k];
                if (wa[i] === mark) {
                  cvalues[k] = xa[i];
                  k++;
                } else if (wb[i] === mark) {
                  cvalues[k] = xb[i];
                  k++;
                } else {
                  cindex.splice(k, 1);
                }
              }
            }
          }
          cptr[columns] = cindex.length;
          return a.createSparseMatrix({
            values: cvalues,
            index: cindex,
            ptr: cptr,
            size: [rows, columns],
            datatype: adt === a._datatype && bdt === b._datatype ? dt : void 0
          });
        };
      });
    }
  });

  // node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/type/matrix/utils/matAlgo10xSids.js
  var require_matAlgo10xSids = __commonJS({
    "node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/type/matrix/utils/matAlgo10xSids.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.createMatAlgo10xSids = void 0;
      var _factory = require_factory();
      var name18 = "matAlgo10xSids";
      var dependencies19 = ["typed", "DenseMatrix"];
      var createMatAlgo10xSids = exports.createMatAlgo10xSids = /* @__PURE__ */ (0, _factory.factory)(name18, dependencies19, function(_ref) {
        var typed2 = _ref.typed, DenseMatrix2 = _ref.DenseMatrix;
        return function matAlgo10xSids(s, b, callback, inverse) {
          var avalues = s._values;
          var aindex = s._index;
          var aptr = s._ptr;
          var asize = s._size;
          var adt = s._datatype;
          if (!avalues) {
            throw new Error("Cannot perform operation on Pattern Sparse Matrix and Scalar value");
          }
          var rows = asize[0];
          var columns = asize[1];
          var dt;
          var cf = callback;
          if (typeof adt === "string") {
            dt = adt;
            b = typed2.convert(b, dt);
            cf = typed2.find(callback, [dt, dt]);
          }
          var cdata = [];
          var x = [];
          var w = [];
          for (var j = 0; j < columns; j++) {
            var mark = j + 1;
            for (var k0 = aptr[j], k1 = aptr[j + 1], k = k0; k < k1; k++) {
              var r = aindex[k];
              x[r] = avalues[k];
              w[r] = mark;
            }
            for (var i = 0; i < rows; i++) {
              if (j === 0) {
                cdata[i] = [];
              }
              if (w[i] === mark) {
                cdata[i][j] = inverse ? cf(b, x[i]) : cf(x[i], b);
              } else {
                cdata[i][j] = b;
              }
            }
          }
          return new DenseMatrix2({
            data: cdata,
            size: [rows, columns],
            datatype: dt
          });
        };
      });
    }
  });

  // node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/error/ArgumentsError.js
  var require_ArgumentsError = __commonJS({
    "node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/error/ArgumentsError.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.ArgumentsError = ArgumentsError;
      function ArgumentsError(fn, count, min2, max2) {
        if (!(this instanceof ArgumentsError)) {
          throw new SyntaxError("Constructor must be called with the new operator");
        }
        this.fn = fn;
        this.count = count;
        this.min = min2;
        this.max = max2;
        this.message = "Wrong number of arguments in function " + fn + " (" + count + " provided, " + min2 + (max2 !== void 0 && max2 !== null ? "-" + max2 : "") + " expected)";
        this.stack = new Error().stack;
      }
      ArgumentsError.prototype = new Error();
      ArgumentsError.prototype.constructor = Error;
      ArgumentsError.prototype.name = "ArgumentsError";
      ArgumentsError.prototype.isArgumentsError = true;
    }
  });

  // node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/function/arithmetic/gcd.js
  var require_gcd = __commonJS({
    "node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/function/arithmetic/gcd.js"(exports) {
      "use strict";
      var _interopRequireDefault = require_interopRequireDefault();
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.createGcd = void 0;
      var _defineProperty2 = _interopRequireDefault(require_defineProperty());
      var _toConsumableArray2 = _interopRequireDefault(require_toConsumableArray());
      var _number = require_number();
      var _factory = require_factory();
      var _mod = require_mod();
      var _matAlgo01xDSid = require_matAlgo01xDSid();
      var _matAlgo04xSidSid = require_matAlgo04xSidSid();
      var _matAlgo10xSids = require_matAlgo10xSids();
      var _matrixAlgorithmSuite = require_matrixAlgorithmSuite();
      var _ArgumentsError = require_ArgumentsError();
      var name18 = "gcd";
      var dependencies19 = ["typed", "config", "round", "matrix", "equalScalar", "zeros", "BigNumber", "DenseMatrix", "concat"];
      var gcdTypes = "number | BigNumber | Fraction | Matrix | Array";
      var gcdManyTypesSignature = "".concat(gcdTypes, ", ").concat(gcdTypes, ", ...").concat(gcdTypes);
      function is1d(array) {
        return !array.some(function(element) {
          return Array.isArray(element);
        });
      }
      var createGcd2 = exports.createGcd = /* @__PURE__ */ (0, _factory.factory)(name18, dependencies19, function(_ref) {
        var typed2 = _ref.typed, matrix2 = _ref.matrix, config4 = _ref.config, round2 = _ref.round, equalScalar2 = _ref.equalScalar, zeros2 = _ref.zeros, BigNumber2 = _ref.BigNumber, DenseMatrix2 = _ref.DenseMatrix, concat2 = _ref.concat;
        var mod2 = (0, _mod.createMod)({
          typed: typed2,
          config: config4,
          round: round2,
          matrix: matrix2,
          equalScalar: equalScalar2,
          zeros: zeros2,
          DenseMatrix: DenseMatrix2,
          concat: concat2
        });
        var matAlgo01xDSid = (0, _matAlgo01xDSid.createMatAlgo01xDSid)({
          typed: typed2
        });
        var matAlgo04xSidSid = (0, _matAlgo04xSidSid.createMatAlgo04xSidSid)({
          typed: typed2,
          equalScalar: equalScalar2
        });
        var matAlgo10xSids = (0, _matAlgo10xSids.createMatAlgo10xSids)({
          typed: typed2,
          DenseMatrix: DenseMatrix2
        });
        var matrixAlgorithmSuite = (0, _matrixAlgorithmSuite.createMatrixAlgorithmSuite)({
          typed: typed2,
          matrix: matrix2,
          concat: concat2
        });
        return typed2(name18, {
          "number, number": _gcdNumber,
          "BigNumber, BigNumber": _gcdBigNumber,
          "Fraction, Fraction": function FractionFraction(x, y) {
            return x.gcd(y);
          }
        }, matrixAlgorithmSuite({
          SS: matAlgo04xSidSid,
          DS: matAlgo01xDSid,
          Ss: matAlgo10xSids
        }), (0, _defineProperty2["default"])((0, _defineProperty2["default"])((0, _defineProperty2["default"])({}, gcdManyTypesSignature, typed2.referToSelf(function(self2) {
          return function(a, b, args) {
            var res = self2(a, b);
            for (var i = 0; i < args.length; i++) {
              res = self2(res, args[i]);
            }
            return res;
          };
        })), "Array", typed2.referToSelf(function(self2) {
          return function(array) {
            if (array.length === 1 && Array.isArray(array[0]) && is1d(array[0])) {
              return self2.apply(void 0, (0, _toConsumableArray2["default"])(array[0]));
            }
            if (is1d(array)) {
              return self2.apply(void 0, (0, _toConsumableArray2["default"])(array));
            }
            throw new _ArgumentsError.ArgumentsError("gcd() supports only 1d matrices!");
          };
        })), "Matrix", typed2.referToSelf(function(self2) {
          return function(matrix3) {
            return self2(matrix3.toArray());
          };
        })));
        function _gcdNumber(a, b) {
          if (!(0, _number.isInteger)(a) || !(0, _number.isInteger)(b)) {
            throw new Error("Parameters in function gcd must be integer numbers");
          }
          var r;
          while (b !== 0) {
            r = mod2(a, b);
            a = b;
            b = r;
          }
          return a < 0 ? -a : a;
        }
        function _gcdBigNumber(a, b) {
          if (!a.isInt() || !b.isInt()) {
            throw new Error("Parameters in function gcd must be integer numbers");
          }
          var zero = new BigNumber2(0);
          while (!b.isZero()) {
            var r = mod2(a, b);
            a = b;
            b = r;
          }
          return a.lt(zero) ? a.neg() : a;
        }
      });
    }
  });

  // node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/type/matrix/utils/matAlgo06xS0S0.js
  var require_matAlgo06xS0S0 = __commonJS({
    "node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/type/matrix/utils/matAlgo06xS0S0.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.createMatAlgo06xS0S0 = void 0;
      var _factory = require_factory();
      var _DimensionError = require_DimensionError();
      var _collection = require_collection();
      var name18 = "matAlgo06xS0S0";
      var dependencies19 = ["typed", "equalScalar"];
      var createMatAlgo06xS0S0 = exports.createMatAlgo06xS0S0 = /* @__PURE__ */ (0, _factory.factory)(name18, dependencies19, function(_ref) {
        var typed2 = _ref.typed, equalScalar2 = _ref.equalScalar;
        return function matAlgo06xS0S0(a, b, callback) {
          var avalues = a._values;
          var asize = a._size;
          var adt = a._datatype || a._data === void 0 ? a._datatype : a.getDataType();
          var bvalues = b._values;
          var bsize = b._size;
          var bdt = b._datatype || b._data === void 0 ? b._datatype : b.getDataType();
          if (asize.length !== bsize.length) {
            throw new _DimensionError.DimensionError(asize.length, bsize.length);
          }
          if (asize[0] !== bsize[0] || asize[1] !== bsize[1]) {
            throw new RangeError("Dimension mismatch. Matrix A (" + asize + ") must match Matrix B (" + bsize + ")");
          }
          var rows = asize[0];
          var columns = asize[1];
          var dt;
          var eq = equalScalar2;
          var zero = 0;
          var cf = callback;
          if (typeof adt === "string" && adt === bdt && adt !== "mixed") {
            dt = adt;
            eq = typed2.find(equalScalar2, [dt, dt]);
            zero = typed2.convert(0, dt);
            cf = typed2.find(callback, [dt, dt]);
          }
          var cvalues = avalues && bvalues ? [] : void 0;
          var cindex = [];
          var cptr = [];
          var x = cvalues ? [] : void 0;
          var w = [];
          var u = [];
          for (var j = 0; j < columns; j++) {
            cptr[j] = cindex.length;
            var mark = j + 1;
            (0, _collection.scatter)(a, j, w, x, u, mark, cindex, cf);
            (0, _collection.scatter)(b, j, w, x, u, mark, cindex, cf);
            if (x) {
              var k = cptr[j];
              while (k < cindex.length) {
                var i = cindex[k];
                if (u[i] === mark) {
                  var v = x[i];
                  if (!eq(v, zero)) {
                    cvalues.push(v);
                    k++;
                  } else {
                    cindex.splice(k, 1);
                  }
                } else {
                  cindex.splice(k, 1);
                }
              }
            } else {
              var p = cptr[j];
              while (p < cindex.length) {
                var r = cindex[p];
                if (u[r] !== mark) {
                  cindex.splice(p, 1);
                } else {
                  p++;
                }
              }
            }
          }
          cptr[columns] = cindex.length;
          return a.createSparseMatrix({
            values: cvalues,
            index: cindex,
            ptr: cptr,
            size: [rows, columns],
            datatype: adt === a._datatype && bdt === b._datatype ? dt : void 0
          });
        };
      });
    }
  });

  // node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/function/arithmetic/lcm.js
  var require_lcm = __commonJS({
    "node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/function/arithmetic/lcm.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.createLcm = void 0;
      var _factory = require_factory();
      var _matAlgo02xDS = require_matAlgo02xDS0();
      var _matAlgo06xS0S = require_matAlgo06xS0S0();
      var _matAlgo11xS0s = require_matAlgo11xS0s();
      var _matrixAlgorithmSuite = require_matrixAlgorithmSuite();
      var _index = require_number2();
      var name18 = "lcm";
      var dependencies19 = ["typed", "matrix", "equalScalar", "concat"];
      var createLcm2 = exports.createLcm = /* @__PURE__ */ (0, _factory.factory)(name18, dependencies19, function(_ref) {
        var typed2 = _ref.typed, matrix2 = _ref.matrix, equalScalar2 = _ref.equalScalar, concat2 = _ref.concat;
        var matAlgo02xDS0 = (0, _matAlgo02xDS.createMatAlgo02xDS0)({
          typed: typed2,
          equalScalar: equalScalar2
        });
        var matAlgo06xS0S0 = (0, _matAlgo06xS0S.createMatAlgo06xS0S0)({
          typed: typed2,
          equalScalar: equalScalar2
        });
        var matAlgo11xS0s = (0, _matAlgo11xS0s.createMatAlgo11xS0s)({
          typed: typed2,
          equalScalar: equalScalar2
        });
        var matrixAlgorithmSuite = (0, _matrixAlgorithmSuite.createMatrixAlgorithmSuite)({
          typed: typed2,
          matrix: matrix2,
          concat: concat2
        });
        var lcmTypes = "number | BigNumber | Fraction | Matrix | Array";
        var lcmManySignature = {};
        lcmManySignature["".concat(lcmTypes, ", ").concat(lcmTypes, ", ...").concat(lcmTypes)] = typed2.referToSelf(function(self2) {
          return function(a, b, args) {
            var res = self2(a, b);
            for (var i = 0; i < args.length; i++) {
              res = self2(res, args[i]);
            }
            return res;
          };
        });
        return typed2(name18, {
          "number, number": _index.lcmNumber,
          "BigNumber, BigNumber": _lcmBigNumber,
          "Fraction, Fraction": function FractionFraction(x, y) {
            return x.lcm(y);
          }
        }, matrixAlgorithmSuite({
          SS: matAlgo06xS0S0,
          DS: matAlgo02xDS0,
          Ss: matAlgo11xS0s
        }), lcmManySignature);
        function _lcmBigNumber(a, b) {
          if (!a.isInt() || !b.isInt()) {
            throw new Error("Parameters in function lcm must be integer numbers");
          }
          if (a.isZero()) {
            return a;
          }
          if (b.isZero()) {
            return b;
          }
          var prod = a.times(b);
          while (!b.isZero()) {
            var t = b;
            b = a.mod(t);
            a = t;
          }
          return prod.div(a).abs();
        }
      });
    }
  });

  // node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/function/arithmetic/log10.js
  var require_log10 = __commonJS({
    "node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/function/arithmetic/log10.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.createLog10 = void 0;
      var _factory = require_factory();
      var _collection = require_collection();
      var _index = require_number2();
      var name18 = "log10";
      var dependencies19 = ["typed", "config", "Complex"];
      var createLog102 = exports.createLog10 = /* @__PURE__ */ (0, _factory.factory)(name18, dependencies19, function(_ref) {
        var typed2 = _ref.typed, config4 = _ref.config, _Complex = _ref.Complex;
        return typed2(name18, {
          number: function number(x) {
            if (x >= 0 || config4.predictable) {
              return (0, _index.log10Number)(x);
            } else {
              return new _Complex(x, 0).log().div(Math.LN10);
            }
          },
          Complex: function Complex3(x) {
            return new _Complex(x).log().div(Math.LN10);
          },
          BigNumber: function BigNumber2(x) {
            if (!x.isNegative() || config4.predictable) {
              return x.log();
            } else {
              return new _Complex(x.toNumber(), 0).log().div(Math.LN10);
            }
          },
          "Array | Matrix": typed2.referToSelf(function(self2) {
            return function(x) {
              return (0, _collection.deepMap)(x, self2);
            };
          })
        });
      });
    }
  });

  // node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/function/arithmetic/log2.js
  var require_log2 = __commonJS({
    "node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/function/arithmetic/log2.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.createLog2 = void 0;
      var _factory = require_factory();
      var _collection = require_collection();
      var _index = require_number2();
      var name18 = "log2";
      var dependencies19 = ["typed", "config", "Complex"];
      var createLog22 = exports.createLog2 = /* @__PURE__ */ (0, _factory.factory)(name18, dependencies19, function(_ref) {
        var typed2 = _ref.typed, config4 = _ref.config, Complex3 = _ref.Complex;
        return typed2(name18, {
          number: function number(x) {
            if (x >= 0 || config4.predictable) {
              return (0, _index.log2Number)(x);
            } else {
              return _log2Complex(new Complex3(x, 0));
            }
          },
          Complex: _log2Complex,
          BigNumber: function BigNumber2(x) {
            if (!x.isNegative() || config4.predictable) {
              return x.log(2);
            } else {
              return _log2Complex(new Complex3(x.toNumber(), 0));
            }
          },
          "Array | Matrix": typed2.referToSelf(function(self2) {
            return function(x) {
              return (0, _collection.deepMap)(x, self2);
            };
          })
        });
        function _log2Complex(x) {
          var newX = Math.sqrt(x.re * x.re + x.im * x.im);
          return new Complex3(Math.log2 ? Math.log2(newX) : Math.log(newX) / Math.LN2, Math.atan2(x.im, x.re) / Math.LN2);
        }
      });
    }
  });

  // node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/function/arithmetic/multiplyScalar.js
  var require_multiplyScalar = __commonJS({
    "node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/function/arithmetic/multiplyScalar.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.createMultiplyScalar = void 0;
      var _factory = require_factory();
      var _index = require_number2();
      var name18 = "multiplyScalar";
      var dependencies19 = ["typed"];
      var createMultiplyScalar2 = exports.createMultiplyScalar = /* @__PURE__ */ (0, _factory.factory)(name18, dependencies19, function(_ref) {
        var typed2 = _ref.typed;
        return typed2("multiplyScalar", {
          "number, number": _index.multiplyNumber,
          "Complex, Complex": function ComplexComplex(x, y) {
            return x.mul(y);
          },
          "BigNumber, BigNumber": function BigNumberBigNumber(x, y) {
            return x.times(y);
          },
          "Fraction, Fraction": function FractionFraction(x, y) {
            return x.mul(y);
          },
          "number | Fraction | BigNumber | Complex, Unit": function numberFractionBigNumberComplexUnit(x, y) {
            return y.multiply(x);
          },
          "Unit, number | Fraction | BigNumber | Complex | Unit": function UnitNumberFractionBigNumberComplexUnit(x, y) {
            return x.multiply(y);
          }
        });
      });
    }
  });

  // node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/function/arithmetic/multiply.js
  var require_multiply = __commonJS({
    "node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/function/arithmetic/multiply.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.createMultiply = void 0;
      var _factory = require_factory();
      var _is = require_is();
      var _array = require_array();
      var _matAlgo11xS0s = require_matAlgo11xS0s();
      var _matAlgo14xDs = require_matAlgo14xDs();
      var name18 = "multiply";
      var dependencies19 = ["typed", "matrix", "addScalar", "multiplyScalar", "equalScalar", "dot"];
      var createMultiply2 = exports.createMultiply = /* @__PURE__ */ (0, _factory.factory)(name18, dependencies19, function(_ref) {
        var typed2 = _ref.typed, matrix2 = _ref.matrix, addScalar2 = _ref.addScalar, multiplyScalar2 = _ref.multiplyScalar, equalScalar2 = _ref.equalScalar, dot2 = _ref.dot;
        var matAlgo11xS0s = (0, _matAlgo11xS0s.createMatAlgo11xS0s)({
          typed: typed2,
          equalScalar: equalScalar2
        });
        var matAlgo14xDs = (0, _matAlgo14xDs.createMatAlgo14xDs)({
          typed: typed2
        });
        function _validateMatrixDimensions(size1, size2) {
          switch (size1.length) {
            case 1:
              switch (size2.length) {
                case 1:
                  if (size1[0] !== size2[0]) {
                    throw new RangeError("Dimension mismatch in multiplication. Vectors must have the same length");
                  }
                  break;
                case 2:
                  if (size1[0] !== size2[0]) {
                    throw new RangeError("Dimension mismatch in multiplication. Vector length (" + size1[0] + ") must match Matrix rows (" + size2[0] + ")");
                  }
                  break;
                default:
                  throw new Error("Can only multiply a 1 or 2 dimensional matrix (Matrix B has " + size2.length + " dimensions)");
              }
              break;
            case 2:
              switch (size2.length) {
                case 1:
                  if (size1[1] !== size2[0]) {
                    throw new RangeError("Dimension mismatch in multiplication. Matrix columns (" + size1[1] + ") must match Vector length (" + size2[0] + ")");
                  }
                  break;
                case 2:
                  if (size1[1] !== size2[0]) {
                    throw new RangeError("Dimension mismatch in multiplication. Matrix A columns (" + size1[1] + ") must match Matrix B rows (" + size2[0] + ")");
                  }
                  break;
                default:
                  throw new Error("Can only multiply a 1 or 2 dimensional matrix (Matrix B has " + size2.length + " dimensions)");
              }
              break;
            default:
              throw new Error("Can only multiply a 1 or 2 dimensional matrix (Matrix A has " + size1.length + " dimensions)");
          }
        }
        function _multiplyVectorVector(a, b, n) {
          if (n === 0) {
            throw new Error("Cannot multiply two empty vectors");
          }
          return dot2(a, b);
        }
        function _multiplyVectorMatrix(a, b) {
          if (b.storage() !== "dense") {
            throw new Error("Support for SparseMatrix not implemented");
          }
          return _multiplyVectorDenseMatrix(a, b);
        }
        function _multiplyVectorDenseMatrix(a, b) {
          var adata = a._data;
          var asize = a._size;
          var adt = a._datatype || a.getDataType();
          var bdata = b._data;
          var bsize = b._size;
          var bdt = b._datatype || b.getDataType();
          var alength = asize[0];
          var bcolumns = bsize[1];
          var dt;
          var af = addScalar2;
          var mf = multiplyScalar2;
          if (adt && bdt && adt === bdt && typeof adt === "string" && adt !== "mixed") {
            dt = adt;
            af = typed2.find(addScalar2, [dt, dt]);
            mf = typed2.find(multiplyScalar2, [dt, dt]);
          }
          var c = [];
          for (var j = 0; j < bcolumns; j++) {
            var sum2 = mf(adata[0], bdata[0][j]);
            for (var i = 1; i < alength; i++) {
              sum2 = af(sum2, mf(adata[i], bdata[i][j]));
            }
            c[j] = sum2;
          }
          return a.createDenseMatrix({
            data: c,
            size: [bcolumns],
            datatype: adt === a._datatype && bdt === b._datatype ? dt : void 0
          });
        }
        var _multiplyMatrixVector = typed2("_multiplyMatrixVector", {
          "DenseMatrix, any": _multiplyDenseMatrixVector,
          "SparseMatrix, any": _multiplySparseMatrixVector
        });
        var _multiplyMatrixMatrix = typed2("_multiplyMatrixMatrix", {
          "DenseMatrix, DenseMatrix": _multiplyDenseMatrixDenseMatrix,
          "DenseMatrix, SparseMatrix": _multiplyDenseMatrixSparseMatrix,
          "SparseMatrix, DenseMatrix": _multiplySparseMatrixDenseMatrix,
          "SparseMatrix, SparseMatrix": _multiplySparseMatrixSparseMatrix
        });
        function _multiplyDenseMatrixVector(a, b) {
          var adata = a._data;
          var asize = a._size;
          var adt = a._datatype || a.getDataType();
          var bdata = b._data;
          var bdt = b._datatype || b.getDataType();
          var arows = asize[0];
          var acolumns = asize[1];
          var dt;
          var af = addScalar2;
          var mf = multiplyScalar2;
          if (adt && bdt && adt === bdt && typeof adt === "string" && adt !== "mixed") {
            dt = adt;
            af = typed2.find(addScalar2, [dt, dt]);
            mf = typed2.find(multiplyScalar2, [dt, dt]);
          }
          var c = [];
          for (var i = 0; i < arows; i++) {
            var row = adata[i];
            var sum2 = mf(row[0], bdata[0]);
            for (var j = 1; j < acolumns; j++) {
              sum2 = af(sum2, mf(row[j], bdata[j]));
            }
            c[i] = sum2;
          }
          return a.createDenseMatrix({
            data: c,
            size: [arows],
            datatype: adt === a._datatype && bdt === b._datatype ? dt : void 0
          });
        }
        function _multiplyDenseMatrixDenseMatrix(a, b) {
          var adata = a._data;
          var asize = a._size;
          var adt = a._datatype || a.getDataType();
          var bdata = b._data;
          var bsize = b._size;
          var bdt = b._datatype || b.getDataType();
          var arows = asize[0];
          var acolumns = asize[1];
          var bcolumns = bsize[1];
          var dt;
          var af = addScalar2;
          var mf = multiplyScalar2;
          if (adt && bdt && adt === bdt && typeof adt === "string" && adt !== "mixed" && adt !== "mixed") {
            dt = adt;
            af = typed2.find(addScalar2, [dt, dt]);
            mf = typed2.find(multiplyScalar2, [dt, dt]);
          }
          var c = [];
          for (var i = 0; i < arows; i++) {
            var row = adata[i];
            c[i] = [];
            for (var j = 0; j < bcolumns; j++) {
              var sum2 = mf(row[0], bdata[0][j]);
              for (var x = 1; x < acolumns; x++) {
                sum2 = af(sum2, mf(row[x], bdata[x][j]));
              }
              c[i][j] = sum2;
            }
          }
          return a.createDenseMatrix({
            data: c,
            size: [arows, bcolumns],
            datatype: adt === a._datatype && bdt === b._datatype ? dt : void 0
          });
        }
        function _multiplyDenseMatrixSparseMatrix(a, b) {
          var adata = a._data;
          var asize = a._size;
          var adt = a._datatype || a.getDataType();
          var bvalues = b._values;
          var bindex = b._index;
          var bptr = b._ptr;
          var bsize = b._size;
          var bdt = b._datatype || b._data === void 0 ? b._datatype : b.getDataType();
          if (!bvalues) {
            throw new Error("Cannot multiply Dense Matrix times Pattern only Matrix");
          }
          var arows = asize[0];
          var bcolumns = bsize[1];
          var dt;
          var af = addScalar2;
          var mf = multiplyScalar2;
          var eq = equalScalar2;
          var zero = 0;
          if (adt && bdt && adt === bdt && typeof adt === "string" && adt !== "mixed") {
            dt = adt;
            af = typed2.find(addScalar2, [dt, dt]);
            mf = typed2.find(multiplyScalar2, [dt, dt]);
            eq = typed2.find(equalScalar2, [dt, dt]);
            zero = typed2.convert(0, dt);
          }
          var cvalues = [];
          var cindex = [];
          var cptr = [];
          var c = b.createSparseMatrix({
            values: cvalues,
            index: cindex,
            ptr: cptr,
            size: [arows, bcolumns],
            datatype: adt === a._datatype && bdt === b._datatype ? dt : void 0
          });
          for (var jb = 0; jb < bcolumns; jb++) {
            cptr[jb] = cindex.length;
            var kb0 = bptr[jb];
            var kb1 = bptr[jb + 1];
            if (kb1 > kb0) {
              var last = 0;
              for (var i = 0; i < arows; i++) {
                var mark = i + 1;
                var cij = void 0;
                for (var kb = kb0; kb < kb1; kb++) {
                  var ib = bindex[kb];
                  if (last !== mark) {
                    cij = mf(adata[i][ib], bvalues[kb]);
                    last = mark;
                  } else {
                    cij = af(cij, mf(adata[i][ib], bvalues[kb]));
                  }
                }
                if (last === mark && !eq(cij, zero)) {
                  cindex.push(i);
                  cvalues.push(cij);
                }
              }
            }
          }
          cptr[bcolumns] = cindex.length;
          return c;
        }
        function _multiplySparseMatrixVector(a, b) {
          var avalues = a._values;
          var aindex = a._index;
          var aptr = a._ptr;
          var adt = a._datatype || a._data === void 0 ? a._datatype : a.getDataType();
          if (!avalues) {
            throw new Error("Cannot multiply Pattern only Matrix times Dense Matrix");
          }
          var bdata = b._data;
          var bdt = b._datatype || b.getDataType();
          var arows = a._size[0];
          var brows = b._size[0];
          var cvalues = [];
          var cindex = [];
          var cptr = [];
          var dt;
          var af = addScalar2;
          var mf = multiplyScalar2;
          var eq = equalScalar2;
          var zero = 0;
          if (adt && bdt && adt === bdt && typeof adt === "string" && adt !== "mixed") {
            dt = adt;
            af = typed2.find(addScalar2, [dt, dt]);
            mf = typed2.find(multiplyScalar2, [dt, dt]);
            eq = typed2.find(equalScalar2, [dt, dt]);
            zero = typed2.convert(0, dt);
          }
          var x = [];
          var w = [];
          cptr[0] = 0;
          for (var ib = 0; ib < brows; ib++) {
            var vbi = bdata[ib];
            if (!eq(vbi, zero)) {
              for (var ka0 = aptr[ib], ka1 = aptr[ib + 1], ka = ka0; ka < ka1; ka++) {
                var ia = aindex[ka];
                if (!w[ia]) {
                  w[ia] = true;
                  cindex.push(ia);
                  x[ia] = mf(vbi, avalues[ka]);
                } else {
                  x[ia] = af(x[ia], mf(vbi, avalues[ka]));
                }
              }
            }
          }
          for (var p1 = cindex.length, p = 0; p < p1; p++) {
            var ic = cindex[p];
            cvalues[p] = x[ic];
          }
          cptr[1] = cindex.length;
          return a.createSparseMatrix({
            values: cvalues,
            index: cindex,
            ptr: cptr,
            size: [arows, 1],
            datatype: adt === a._datatype && bdt === b._datatype ? dt : void 0
          });
        }
        function _multiplySparseMatrixDenseMatrix(a, b) {
          var avalues = a._values;
          var aindex = a._index;
          var aptr = a._ptr;
          var adt = a._datatype || a._data === void 0 ? a._datatype : a.getDataType();
          if (!avalues) {
            throw new Error("Cannot multiply Pattern only Matrix times Dense Matrix");
          }
          var bdata = b._data;
          var bdt = b._datatype || b.getDataType();
          var arows = a._size[0];
          var brows = b._size[0];
          var bcolumns = b._size[1];
          var dt;
          var af = addScalar2;
          var mf = multiplyScalar2;
          var eq = equalScalar2;
          var zero = 0;
          if (adt && bdt && adt === bdt && typeof adt === "string" && adt !== "mixed") {
            dt = adt;
            af = typed2.find(addScalar2, [dt, dt]);
            mf = typed2.find(multiplyScalar2, [dt, dt]);
            eq = typed2.find(equalScalar2, [dt, dt]);
            zero = typed2.convert(0, dt);
          }
          var cvalues = [];
          var cindex = [];
          var cptr = [];
          var c = a.createSparseMatrix({
            values: cvalues,
            index: cindex,
            ptr: cptr,
            size: [arows, bcolumns],
            datatype: adt === a._datatype && bdt === b._datatype ? dt : void 0
          });
          var x = [];
          var w = [];
          for (var jb = 0; jb < bcolumns; jb++) {
            cptr[jb] = cindex.length;
            var mark = jb + 1;
            for (var ib = 0; ib < brows; ib++) {
              var vbij = bdata[ib][jb];
              if (!eq(vbij, zero)) {
                for (var ka0 = aptr[ib], ka1 = aptr[ib + 1], ka = ka0; ka < ka1; ka++) {
                  var ia = aindex[ka];
                  if (w[ia] !== mark) {
                    w[ia] = mark;
                    cindex.push(ia);
                    x[ia] = mf(vbij, avalues[ka]);
                  } else {
                    x[ia] = af(x[ia], mf(vbij, avalues[ka]));
                  }
                }
              }
            }
            for (var p0 = cptr[jb], p1 = cindex.length, p = p0; p < p1; p++) {
              var ic = cindex[p];
              cvalues[p] = x[ic];
            }
          }
          cptr[bcolumns] = cindex.length;
          return c;
        }
        function _multiplySparseMatrixSparseMatrix(a, b) {
          var avalues = a._values;
          var aindex = a._index;
          var aptr = a._ptr;
          var adt = a._datatype || a._data === void 0 ? a._datatype : a.getDataType();
          var bvalues = b._values;
          var bindex = b._index;
          var bptr = b._ptr;
          var bdt = b._datatype || b._data === void 0 ? b._datatype : b.getDataType();
          var arows = a._size[0];
          var bcolumns = b._size[1];
          var values = avalues && bvalues;
          var dt;
          var af = addScalar2;
          var mf = multiplyScalar2;
          if (adt && bdt && adt === bdt && typeof adt === "string" && adt !== "mixed") {
            dt = adt;
            af = typed2.find(addScalar2, [dt, dt]);
            mf = typed2.find(multiplyScalar2, [dt, dt]);
          }
          var cvalues = values ? [] : void 0;
          var cindex = [];
          var cptr = [];
          var c = a.createSparseMatrix({
            values: cvalues,
            index: cindex,
            ptr: cptr,
            size: [arows, bcolumns],
            datatype: adt === a._datatype && bdt === b._datatype ? dt : void 0
          });
          var x = values ? [] : void 0;
          var w = [];
          var ka, ka0, ka1, kb, kb0, kb1, ia, ib;
          for (var jb = 0; jb < bcolumns; jb++) {
            cptr[jb] = cindex.length;
            var mark = jb + 1;
            for (kb0 = bptr[jb], kb1 = bptr[jb + 1], kb = kb0; kb < kb1; kb++) {
              ib = bindex[kb];
              if (values) {
                for (ka0 = aptr[ib], ka1 = aptr[ib + 1], ka = ka0; ka < ka1; ka++) {
                  ia = aindex[ka];
                  if (w[ia] !== mark) {
                    w[ia] = mark;
                    cindex.push(ia);
                    x[ia] = mf(bvalues[kb], avalues[ka]);
                  } else {
                    x[ia] = af(x[ia], mf(bvalues[kb], avalues[ka]));
                  }
                }
              } else {
                for (ka0 = aptr[ib], ka1 = aptr[ib + 1], ka = ka0; ka < ka1; ka++) {
                  ia = aindex[ka];
                  if (w[ia] !== mark) {
                    w[ia] = mark;
                    cindex.push(ia);
                  }
                }
              }
            }
            if (values) {
              for (var p0 = cptr[jb], p1 = cindex.length, p = p0; p < p1; p++) {
                var ic = cindex[p];
                cvalues[p] = x[ic];
              }
            }
          }
          cptr[bcolumns] = cindex.length;
          return c;
        }
        return typed2(name18, multiplyScalar2, {
          // we extend the signatures of multiplyScalar with signatures dealing with matrices
          "Array, Array": typed2.referTo("Matrix, Matrix", function(selfMM) {
            return function(x, y) {
              _validateMatrixDimensions((0, _array.arraySize)(x), (0, _array.arraySize)(y));
              var m = selfMM(matrix2(x), matrix2(y));
              return (0, _is.isMatrix)(m) ? m.valueOf() : m;
            };
          }),
          "Matrix, Matrix": function MatrixMatrix(x, y) {
            var xsize = x.size();
            var ysize = y.size();
            _validateMatrixDimensions(xsize, ysize);
            if (xsize.length === 1) {
              if (ysize.length === 1) {
                return _multiplyVectorVector(x, y, xsize[0]);
              }
              return _multiplyVectorMatrix(x, y);
            }
            if (ysize.length === 1) {
              return _multiplyMatrixVector(x, y);
            }
            return _multiplyMatrixMatrix(x, y);
          },
          "Matrix, Array": typed2.referTo("Matrix,Matrix", function(selfMM) {
            return function(x, y) {
              return selfMM(x, matrix2(y));
            };
          }),
          "Array, Matrix": typed2.referToSelf(function(self2) {
            return function(x, y) {
              return self2(matrix2(x, y.storage()), y);
            };
          }),
          "SparseMatrix, any": function SparseMatrixAny(x, y) {
            return matAlgo11xS0s(x, y, multiplyScalar2, false);
          },
          "DenseMatrix, any": function DenseMatrixAny(x, y) {
            return matAlgo14xDs(x, y, multiplyScalar2, false);
          },
          "any, SparseMatrix": function anySparseMatrix(x, y) {
            return matAlgo11xS0s(y, x, multiplyScalar2, true);
          },
          "any, DenseMatrix": function anyDenseMatrix(x, y) {
            return matAlgo14xDs(y, x, multiplyScalar2, true);
          },
          "Array, any": function ArrayAny(x, y) {
            return matAlgo14xDs(matrix2(x), y, multiplyScalar2, false).valueOf();
          },
          "any, Array": function anyArray(x, y) {
            return matAlgo14xDs(matrix2(y), x, multiplyScalar2, true).valueOf();
          },
          "any, any": multiplyScalar2,
          "any, any, ...any": typed2.referToSelf(function(self2) {
            return function(x, y, rest) {
              var result = self2(x, y);
              for (var i = 0; i < rest.length; i++) {
                result = self2(result, rest[i]);
              }
              return result;
            };
          })
        });
      });
    }
  });

  // node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/function/arithmetic/nthRoot.js
  var require_nthRoot = __commonJS({
    "node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/function/arithmetic/nthRoot.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.createNthRootNumber = exports.createNthRoot = void 0;
      var _factory = require_factory();
      var _matAlgo01xDSid = require_matAlgo01xDSid();
      var _matAlgo02xDS = require_matAlgo02xDS0();
      var _matAlgo06xS0S = require_matAlgo06xS0S0();
      var _matAlgo11xS0s = require_matAlgo11xS0s();
      var _matrixAlgorithmSuite = require_matrixAlgorithmSuite();
      var _index = require_number2();
      var name18 = "nthRoot";
      var dependencies19 = ["typed", "matrix", "equalScalar", "BigNumber", "concat"];
      var createNthRoot2 = exports.createNthRoot = /* @__PURE__ */ (0, _factory.factory)(name18, dependencies19, function(_ref) {
        var typed2 = _ref.typed, matrix2 = _ref.matrix, equalScalar2 = _ref.equalScalar, _BigNumber = _ref.BigNumber, concat2 = _ref.concat;
        var matAlgo01xDSid = (0, _matAlgo01xDSid.createMatAlgo01xDSid)({
          typed: typed2
        });
        var matAlgo02xDS0 = (0, _matAlgo02xDS.createMatAlgo02xDS0)({
          typed: typed2,
          equalScalar: equalScalar2
        });
        var matAlgo06xS0S0 = (0, _matAlgo06xS0S.createMatAlgo06xS0S0)({
          typed: typed2,
          equalScalar: equalScalar2
        });
        var matAlgo11xS0s = (0, _matAlgo11xS0s.createMatAlgo11xS0s)({
          typed: typed2,
          equalScalar: equalScalar2
        });
        var matrixAlgorithmSuite = (0, _matrixAlgorithmSuite.createMatrixAlgorithmSuite)({
          typed: typed2,
          matrix: matrix2,
          concat: concat2
        });
        function complexErr() {
          throw new Error("Complex number not supported in function nthRoot. Use nthRoots instead.");
        }
        return typed2(name18, {
          number: _index.nthRootNumber,
          "number, number": _index.nthRootNumber,
          BigNumber: function BigNumber2(x) {
            return _bigNthRoot(x, new _BigNumber(2));
          },
          "BigNumber, BigNumber": _bigNthRoot,
          Complex: complexErr,
          "Complex, number": complexErr,
          Array: typed2.referTo("DenseMatrix,number", function(selfDn) {
            return function(x) {
              return selfDn(matrix2(x), 2).valueOf();
            };
          }),
          DenseMatrix: typed2.referTo("DenseMatrix,number", function(selfDn) {
            return function(x) {
              return selfDn(x, 2);
            };
          }),
          SparseMatrix: typed2.referTo("SparseMatrix,number", function(selfSn) {
            return function(x) {
              return selfSn(x, 2);
            };
          }),
          "SparseMatrix, SparseMatrix": typed2.referToSelf(function(self2) {
            return function(x, y) {
              if (y.density() === 1) {
                return matAlgo06xS0S0(x, y, self2);
              } else {
                throw new Error("Root must be non-zero");
              }
            };
          }),
          "DenseMatrix, SparseMatrix": typed2.referToSelf(function(self2) {
            return function(x, y) {
              if (y.density() === 1) {
                return matAlgo01xDSid(x, y, self2, false);
              } else {
                throw new Error("Root must be non-zero");
              }
            };
          }),
          "Array, SparseMatrix": typed2.referTo("DenseMatrix,SparseMatrix", function(selfDS) {
            return function(x, y) {
              return selfDS(matrix2(x), y);
            };
          }),
          "number | BigNumber, SparseMatrix": typed2.referToSelf(function(self2) {
            return function(x, y) {
              if (y.density() === 1) {
                return matAlgo11xS0s(y, x, self2, true);
              } else {
                throw new Error("Root must be non-zero");
              }
            };
          })
        }, matrixAlgorithmSuite({
          scalar: "number | BigNumber",
          SD: matAlgo02xDS0,
          Ss: matAlgo11xS0s,
          sS: false
        }));
        function _bigNthRoot(a, root) {
          var precision = _BigNumber.precision;
          var Big = _BigNumber.clone({
            precision: precision + 2
          });
          var zero = new _BigNumber(0);
          var one = new Big(1);
          var inv = root.isNegative();
          if (inv) {
            root = root.neg();
          }
          if (root.isZero()) {
            throw new Error("Root must be non-zero");
          }
          if (a.isNegative() && !root.abs().mod(2).equals(1)) {
            throw new Error("Root must be odd when a is negative.");
          }
          if (a.isZero()) {
            return inv ? new Big(Infinity) : 0;
          }
          if (!a.isFinite()) {
            return inv ? zero : a;
          }
          var x = a.abs().pow(one.div(root));
          x = a.isNeg() ? x.neg() : x;
          return new _BigNumber((inv ? one.div(x) : x).toPrecision(precision));
        }
      });
      var createNthRootNumber = exports.createNthRootNumber = /* @__PURE__ */ (0, _factory.factory)(name18, ["typed"], function(_ref2) {
        var typed2 = _ref2.typed;
        return typed2(name18, {
          number: _index.nthRootNumber,
          "number, number": _index.nthRootNumber
        });
      });
    }
  });

  // node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/function/arithmetic/sign.js
  var require_sign = __commonJS({
    "node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/function/arithmetic/sign.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.createSign = void 0;
      var _factory = require_factory();
      var _collection = require_collection();
      var _index = require_number2();
      var name18 = "sign";
      var dependencies19 = ["typed", "BigNumber", "Fraction", "complex"];
      var createSign2 = exports.createSign = /* @__PURE__ */ (0, _factory.factory)(name18, dependencies19, function(_ref) {
        var typed2 = _ref.typed, _BigNumber = _ref.BigNumber, complex2 = _ref.complex, _Fraction = _ref.Fraction;
        return typed2(name18, {
          number: _index.signNumber,
          Complex: function Complex3(x) {
            return x.im === 0 ? complex2((0, _index.signNumber)(x.re)) : x.sign();
          },
          BigNumber: function BigNumber2(x) {
            return new _BigNumber(x.cmp(0));
          },
          Fraction: function Fraction3(x) {
            return new _Fraction(x.s, 1);
          },
          // deep map collection, skip zeros since sign(0) = 0
          "Array | Matrix": typed2.referToSelf(function(self2) {
            return function(x) {
              return (0, _collection.deepMap)(x, self2, true);
            };
          }),
          Unit: typed2.referToSelf(function(self2) {
            return function(x) {
              if (!x._isDerived() && x.units[0].unit.offset !== 0) {
                throw new TypeError("sign is ambiguous for units with offset");
              }
              return typed2.find(self2, x.valueType())(x.value);
            };
          })
        });
      });
    }
  });

  // node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/function/arithmetic/sqrt.js
  var require_sqrt = __commonJS({
    "node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/function/arithmetic/sqrt.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.createSqrt = void 0;
      var _factory = require_factory();
      var name18 = "sqrt";
      var dependencies19 = ["config", "typed", "Complex"];
      var createSqrt2 = exports.createSqrt = /* @__PURE__ */ (0, _factory.factory)(name18, dependencies19, function(_ref) {
        var config4 = _ref.config, typed2 = _ref.typed, Complex3 = _ref.Complex;
        return typed2("sqrt", {
          number: _sqrtNumber,
          Complex: function Complex4(x) {
            return x.sqrt();
          },
          BigNumber: function BigNumber2(x) {
            if (!x.isNegative() || config4.predictable) {
              return x.sqrt();
            } else {
              return _sqrtNumber(x.toNumber());
            }
          },
          Unit: function Unit(x) {
            return x.pow(0.5);
          }
        });
        function _sqrtNumber(x) {
          if (isNaN(x)) {
            return NaN;
          } else if (x >= 0 || config4.predictable) {
            return Math.sqrt(x);
          } else {
            return new Complex3(x, 0).sqrt();
          }
        }
      });
    }
  });

  // node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/function/arithmetic/square.js
  var require_square = __commonJS({
    "node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/function/arithmetic/square.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.createSquare = void 0;
      var _factory = require_factory();
      var _index = require_number2();
      var name18 = "square";
      var dependencies19 = ["typed"];
      var createSquare2 = exports.createSquare = /* @__PURE__ */ (0, _factory.factory)(name18, dependencies19, function(_ref) {
        var typed2 = _ref.typed;
        return typed2(name18, {
          number: _index.squareNumber,
          Complex: function Complex3(x) {
            return x.mul(x);
          },
          BigNumber: function BigNumber2(x) {
            return x.times(x);
          },
          Fraction: function Fraction3(x) {
            return x.mul(x);
          },
          Unit: function Unit(x) {
            return x.pow(2);
          }
        });
      });
    }
  });

  // node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/function/arithmetic/subtract.js
  var require_subtract = __commonJS({
    "node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/function/arithmetic/subtract.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.createSubtract = void 0;
      var _factory = require_factory();
      var _matAlgo01xDSid = require_matAlgo01xDSid();
      var _matAlgo03xDSf = require_matAlgo03xDSf();
      var _matAlgo05xSfSf = require_matAlgo05xSfSf();
      var _matAlgo10xSids = require_matAlgo10xSids();
      var _matAlgo12xSfs = require_matAlgo12xSfs();
      var _matrixAlgorithmSuite = require_matrixAlgorithmSuite();
      var name18 = "subtract";
      var dependencies19 = ["typed", "matrix", "equalScalar", "subtractScalar", "unaryMinus", "DenseMatrix", "concat"];
      var createSubtract2 = exports.createSubtract = /* @__PURE__ */ (0, _factory.factory)(name18, dependencies19, function(_ref) {
        var typed2 = _ref.typed, matrix2 = _ref.matrix, equalScalar2 = _ref.equalScalar, subtractScalar = _ref.subtractScalar, unaryMinus = _ref.unaryMinus, DenseMatrix2 = _ref.DenseMatrix, concat2 = _ref.concat;
        var matAlgo01xDSid = (0, _matAlgo01xDSid.createMatAlgo01xDSid)({
          typed: typed2
        });
        var matAlgo03xDSf = (0, _matAlgo03xDSf.createMatAlgo03xDSf)({
          typed: typed2
        });
        var matAlgo05xSfSf = (0, _matAlgo05xSfSf.createMatAlgo05xSfSf)({
          typed: typed2,
          equalScalar: equalScalar2
        });
        var matAlgo10xSids = (0, _matAlgo10xSids.createMatAlgo10xSids)({
          typed: typed2,
          DenseMatrix: DenseMatrix2
        });
        var matAlgo12xSfs = (0, _matAlgo12xSfs.createMatAlgo12xSfs)({
          typed: typed2,
          DenseMatrix: DenseMatrix2
        });
        var matrixAlgorithmSuite = (0, _matrixAlgorithmSuite.createMatrixAlgorithmSuite)({
          typed: typed2,
          matrix: matrix2,
          concat: concat2
        });
        return typed2(name18, {
          "any, any": subtractScalar
        }, matrixAlgorithmSuite({
          elop: subtractScalar,
          SS: matAlgo05xSfSf,
          DS: matAlgo01xDSid,
          SD: matAlgo03xDSf,
          Ss: matAlgo12xSfs,
          sS: matAlgo10xSids
        }));
      });
    }
  });

  // node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/function/arithmetic/xgcd.js
  var require_xgcd = __commonJS({
    "node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/function/arithmetic/xgcd.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.createXgcd = void 0;
      var _factory = require_factory();
      var _index = require_number2();
      var name18 = "xgcd";
      var dependencies19 = ["typed", "config", "matrix", "BigNumber"];
      var createXgcd2 = exports.createXgcd = /* @__PURE__ */ (0, _factory.factory)(name18, dependencies19, function(_ref) {
        var typed2 = _ref.typed, config4 = _ref.config, matrix2 = _ref.matrix, BigNumber2 = _ref.BigNumber;
        return typed2(name18, {
          "number, number": function numberNumber(a, b) {
            var res = (0, _index.xgcdNumber)(a, b);
            return config4.matrix === "Array" ? res : matrix2(res);
          },
          "BigNumber, BigNumber": _xgcdBigNumber
          // TODO: implement support for Fraction
        });
        function _xgcdBigNumber(a, b) {
          var t;
          var q;
          var r;
          var zero = new BigNumber2(0);
          var one = new BigNumber2(1);
          var x = zero;
          var lastx = one;
          var y = one;
          var lasty = zero;
          if (!a.isInt() || !b.isInt()) {
            throw new Error("Parameters in function xgcd must be integer numbers");
          }
          while (!b.isZero()) {
            q = a.div(b).floor();
            r = a.mod(b);
            t = x;
            x = lastx.minus(q.times(x));
            lastx = t;
            t = y;
            y = lasty.minus(q.times(y));
            lasty = t;
            a = b;
            b = r;
          }
          var res;
          if (a.lt(zero)) {
            res = [a.neg(), lastx.neg(), lasty.neg()];
          } else {
            res = [a, !a.isZero() ? lastx : 0, lasty];
          }
          return config4.matrix === "Array" ? res : matrix2(res);
        }
      });
    }
  });

  // node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/function/arithmetic/invmod.js
  var require_invmod = __commonJS({
    "node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/function/arithmetic/invmod.js"(exports) {
      "use strict";
      var _interopRequireDefault = require_interopRequireDefault();
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.createInvmod = void 0;
      var _slicedToArray2 = _interopRequireDefault(require_slicedToArray());
      var _factory = require_factory();
      var name18 = "invmod";
      var dependencies19 = ["typed", "config", "BigNumber", "xgcd", "equal", "smaller", "mod", "add", "isInteger"];
      var createInvmod2 = exports.createInvmod = /* @__PURE__ */ (0, _factory.factory)(name18, dependencies19, function(_ref) {
        var typed2 = _ref.typed, config4 = _ref.config, BigNumber2 = _ref.BigNumber, xgcd = _ref.xgcd, equal = _ref.equal, smaller = _ref.smaller, mod2 = _ref.mod, add2 = _ref.add, isInteger2 = _ref.isInteger;
        return typed2(name18, {
          "number, number": invmod,
          "BigNumber, BigNumber": invmod
        });
        function invmod(a, b) {
          if (!isInteger2(a) || !isInteger2(b)) throw new Error("Parameters in function invmod must be integer numbers");
          a = mod2(a, b);
          if (equal(b, 0)) throw new Error("Divisor must be non zero");
          var res = xgcd(a, b);
          res = res.valueOf();
          var _res = res, _res2 = (0, _slicedToArray2["default"])(_res, 2), gcd = _res2[0], inv = _res2[1];
          if (!equal(gcd, BigNumber2(1))) return NaN;
          inv = mod2(inv, b);
          if (smaller(inv, BigNumber2(0))) inv = add2(inv, b);
          return inv;
        }
      });
    }
  });

  // node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/type/matrix/utils/matAlgo09xS0Sf.js
  var require_matAlgo09xS0Sf = __commonJS({
    "node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/type/matrix/utils/matAlgo09xS0Sf.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.createMatAlgo09xS0Sf = void 0;
      var _factory = require_factory();
      var _DimensionError = require_DimensionError();
      var name18 = "matAlgo09xS0Sf";
      var dependencies19 = ["typed", "equalScalar"];
      var createMatAlgo09xS0Sf = exports.createMatAlgo09xS0Sf = /* @__PURE__ */ (0, _factory.factory)(name18, dependencies19, function(_ref) {
        var typed2 = _ref.typed, equalScalar2 = _ref.equalScalar;
        return function matAlgo09xS0Sf(a, b, callback) {
          var avalues = a._values;
          var aindex = a._index;
          var aptr = a._ptr;
          var asize = a._size;
          var adt = a._datatype || a._data === void 0 ? a._datatype : a.getDataType();
          var bvalues = b._values;
          var bindex = b._index;
          var bptr = b._ptr;
          var bsize = b._size;
          var bdt = b._datatype || b._data === void 0 ? b._datatype : b.getDataType();
          if (asize.length !== bsize.length) {
            throw new _DimensionError.DimensionError(asize.length, bsize.length);
          }
          if (asize[0] !== bsize[0] || asize[1] !== bsize[1]) {
            throw new RangeError("Dimension mismatch. Matrix A (" + asize + ") must match Matrix B (" + bsize + ")");
          }
          var rows = asize[0];
          var columns = asize[1];
          var dt;
          var eq = equalScalar2;
          var zero = 0;
          var cf = callback;
          if (typeof adt === "string" && adt === bdt && adt !== "mixed") {
            dt = adt;
            eq = typed2.find(equalScalar2, [dt, dt]);
            zero = typed2.convert(0, dt);
            cf = typed2.find(callback, [dt, dt]);
          }
          var cvalues = avalues && bvalues ? [] : void 0;
          var cindex = [];
          var cptr = [];
          var x = cvalues ? [] : void 0;
          var w = [];
          var i, j, k, k0, k1;
          for (j = 0; j < columns; j++) {
            cptr[j] = cindex.length;
            var mark = j + 1;
            if (x) {
              for (k0 = bptr[j], k1 = bptr[j + 1], k = k0; k < k1; k++) {
                i = bindex[k];
                w[i] = mark;
                x[i] = bvalues[k];
              }
            }
            for (k0 = aptr[j], k1 = aptr[j + 1], k = k0; k < k1; k++) {
              i = aindex[k];
              if (x) {
                var vb = w[i] === mark ? x[i] : zero;
                var vc = cf(avalues[k], vb);
                if (!eq(vc, zero)) {
                  cindex.push(i);
                  cvalues.push(vc);
                }
              } else {
                cindex.push(i);
              }
            }
          }
          cptr[columns] = cindex.length;
          return a.createSparseMatrix({
            values: cvalues,
            index: cindex,
            ptr: cptr,
            size: [rows, columns],
            datatype: adt === a._datatype && bdt === b._datatype ? dt : void 0
          });
        };
      });
    }
  });

  // node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/function/arithmetic/dotMultiply.js
  var require_dotMultiply = __commonJS({
    "node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/function/arithmetic/dotMultiply.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.createDotMultiply = void 0;
      var _factory = require_factory();
      var _matAlgo02xDS = require_matAlgo02xDS0();
      var _matAlgo09xS0Sf = require_matAlgo09xS0Sf();
      var _matAlgo11xS0s = require_matAlgo11xS0s();
      var _matrixAlgorithmSuite = require_matrixAlgorithmSuite();
      var name18 = "dotMultiply";
      var dependencies19 = ["typed", "matrix", "equalScalar", "multiplyScalar", "concat"];
      var createDotMultiply2 = exports.createDotMultiply = /* @__PURE__ */ (0, _factory.factory)(name18, dependencies19, function(_ref) {
        var typed2 = _ref.typed, matrix2 = _ref.matrix, equalScalar2 = _ref.equalScalar, multiplyScalar2 = _ref.multiplyScalar, concat2 = _ref.concat;
        var matAlgo02xDS0 = (0, _matAlgo02xDS.createMatAlgo02xDS0)({
          typed: typed2,
          equalScalar: equalScalar2
        });
        var matAlgo09xS0Sf = (0, _matAlgo09xS0Sf.createMatAlgo09xS0Sf)({
          typed: typed2,
          equalScalar: equalScalar2
        });
        var matAlgo11xS0s = (0, _matAlgo11xS0s.createMatAlgo11xS0s)({
          typed: typed2,
          equalScalar: equalScalar2
        });
        var matrixAlgorithmSuite = (0, _matrixAlgorithmSuite.createMatrixAlgorithmSuite)({
          typed: typed2,
          matrix: matrix2,
          concat: concat2
        });
        return typed2(name18, matrixAlgorithmSuite({
          elop: multiplyScalar2,
          SS: matAlgo09xS0Sf,
          DS: matAlgo02xDS0,
          Ss: matAlgo11xS0s
        }));
      });
    }
  });

  // node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/utils/bignumber/bitwise.js
  var require_bitwise2 = __commonJS({
    "node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/utils/bignumber/bitwise.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.bitAndBigNumber = bitAndBigNumber;
      exports.bitNotBigNumber = bitNotBigNumber;
      exports.bitOrBigNumber = bitOrBigNumber;
      exports.bitXor = bitXor;
      exports.bitwise = bitwise;
      exports.leftShiftBigNumber = leftShiftBigNumber;
      exports.rightArithShiftBigNumber = rightArithShiftBigNumber;
      function bitAndBigNumber(x, y) {
        if (x.isFinite() && !x.isInteger() || y.isFinite() && !y.isInteger()) {
          throw new Error("Integers expected in function bitAnd");
        }
        var BigNumber2 = x.constructor;
        if (x.isNaN() || y.isNaN()) {
          return new BigNumber2(NaN);
        }
        if (x.isZero() || y.eq(-1) || x.eq(y)) {
          return x;
        }
        if (y.isZero() || x.eq(-1)) {
          return y;
        }
        if (!x.isFinite() || !y.isFinite()) {
          if (!x.isFinite() && !y.isFinite()) {
            if (x.isNegative() === y.isNegative()) {
              return x;
            }
            return new BigNumber2(0);
          }
          if (!x.isFinite()) {
            if (y.isNegative()) {
              return x;
            }
            if (x.isNegative()) {
              return new BigNumber2(0);
            }
            return y;
          }
          if (!y.isFinite()) {
            if (x.isNegative()) {
              return y;
            }
            if (y.isNegative()) {
              return new BigNumber2(0);
            }
            return x;
          }
        }
        return bitwise(x, y, function(a, b) {
          return a & b;
        });
      }
      function bitNotBigNumber(x) {
        if (x.isFinite() && !x.isInteger()) {
          throw new Error("Integer expected in function bitNot");
        }
        var BigNumber2 = x.constructor;
        var prevPrec = BigNumber2.precision;
        BigNumber2.config({
          precision: 1e9
        });
        var result = x.plus(new BigNumber2(1));
        result.s = -result.s || null;
        BigNumber2.config({
          precision: prevPrec
        });
        return result;
      }
      function bitOrBigNumber(x, y) {
        if (x.isFinite() && !x.isInteger() || y.isFinite() && !y.isInteger()) {
          throw new Error("Integers expected in function bitOr");
        }
        var BigNumber2 = x.constructor;
        if (x.isNaN() || y.isNaN()) {
          return new BigNumber2(NaN);
        }
        var negOne = new BigNumber2(-1);
        if (x.isZero() || y.eq(negOne) || x.eq(y)) {
          return y;
        }
        if (y.isZero() || x.eq(negOne)) {
          return x;
        }
        if (!x.isFinite() || !y.isFinite()) {
          if (!x.isFinite() && !x.isNegative() && y.isNegative() || x.isNegative() && !y.isNegative() && !y.isFinite()) {
            return negOne;
          }
          if (x.isNegative() && y.isNegative()) {
            return x.isFinite() ? x : y;
          }
          return x.isFinite() ? y : x;
        }
        return bitwise(x, y, function(a, b) {
          return a | b;
        });
      }
      function bitwise(x, y, func) {
        var BigNumber2 = x.constructor;
        var xBits, yBits;
        var xSign = +(x.s < 0);
        var ySign = +(y.s < 0);
        if (xSign) {
          xBits = decCoefficientToBinaryString(bitNotBigNumber(x));
          for (var i = 0; i < xBits.length; ++i) {
            xBits[i] ^= 1;
          }
        } else {
          xBits = decCoefficientToBinaryString(x);
        }
        if (ySign) {
          yBits = decCoefficientToBinaryString(bitNotBigNumber(y));
          for (var _i = 0; _i < yBits.length; ++_i) {
            yBits[_i] ^= 1;
          }
        } else {
          yBits = decCoefficientToBinaryString(y);
        }
        var minBits, maxBits, minSign;
        if (xBits.length <= yBits.length) {
          minBits = xBits;
          maxBits = yBits;
          minSign = xSign;
        } else {
          minBits = yBits;
          maxBits = xBits;
          minSign = ySign;
        }
        var shortLen = minBits.length;
        var longLen = maxBits.length;
        var expFuncVal = func(xSign, ySign) ^ 1;
        var outVal = new BigNumber2(expFuncVal ^ 1);
        var twoPower = new BigNumber2(1);
        var two = new BigNumber2(2);
        var prevPrec = BigNumber2.precision;
        BigNumber2.config({
          precision: 1e9
        });
        while (shortLen > 0) {
          if (func(minBits[--shortLen], maxBits[--longLen]) === expFuncVal) {
            outVal = outVal.plus(twoPower);
          }
          twoPower = twoPower.times(two);
        }
        while (longLen > 0) {
          if (func(minSign, maxBits[--longLen]) === expFuncVal) {
            outVal = outVal.plus(twoPower);
          }
          twoPower = twoPower.times(two);
        }
        BigNumber2.config({
          precision: prevPrec
        });
        if (expFuncVal === 0) {
          outVal.s = -outVal.s;
        }
        return outVal;
      }
      function decCoefficientToBinaryString(x) {
        var a = x.d;
        var r = a[0] + "";
        for (var i = 1; i < a.length; ++i) {
          var s = a[i] + "";
          for (var z = 7 - s.length; z--; ) {
            s = "0" + s;
          }
          r += s;
        }
        var j = r.length;
        while (r.charAt(j) === "0") {
          j--;
        }
        var xe = x.e;
        var str = r.slice(0, j + 1 || 1);
        var strL = str.length;
        if (xe > 0) {
          if (++xe > strL) {
            xe -= strL;
            while (xe--) {
              str += "0";
            }
          } else if (xe < strL) {
            str = str.slice(0, xe) + "." + str.slice(xe);
          }
        }
        var arr = [0];
        for (var _i2 = 0; _i2 < str.length; ) {
          var arrL = arr.length;
          while (arrL--) {
            arr[arrL] *= 10;
          }
          arr[0] += parseInt(str.charAt(_i2++));
          for (var _j = 0; _j < arr.length; ++_j) {
            if (arr[_j] > 1) {
              if (arr[_j + 1] === null || arr[_j + 1] === void 0) {
                arr[_j + 1] = 0;
              }
              arr[_j + 1] += arr[_j] >> 1;
              arr[_j] &= 1;
            }
          }
        }
        return arr.reverse();
      }
      function bitXor(x, y) {
        if (x.isFinite() && !x.isInteger() || y.isFinite() && !y.isInteger()) {
          throw new Error("Integers expected in function bitXor");
        }
        var BigNumber2 = x.constructor;
        if (x.isNaN() || y.isNaN()) {
          return new BigNumber2(NaN);
        }
        if (x.isZero()) {
          return y;
        }
        if (y.isZero()) {
          return x;
        }
        if (x.eq(y)) {
          return new BigNumber2(0);
        }
        var negOne = new BigNumber2(-1);
        if (x.eq(negOne)) {
          return bitNotBigNumber(y);
        }
        if (y.eq(negOne)) {
          return bitNotBigNumber(x);
        }
        if (!x.isFinite() || !y.isFinite()) {
          if (!x.isFinite() && !y.isFinite()) {
            return negOne;
          }
          return new BigNumber2(x.isNegative() === y.isNegative() ? Infinity : -Infinity);
        }
        return bitwise(x, y, function(a, b) {
          return a ^ b;
        });
      }
      function leftShiftBigNumber(x, y) {
        if (x.isFinite() && !x.isInteger() || y.isFinite() && !y.isInteger()) {
          throw new Error("Integers expected in function leftShift");
        }
        var BigNumber2 = x.constructor;
        if (x.isNaN() || y.isNaN() || y.isNegative() && !y.isZero()) {
          return new BigNumber2(NaN);
        }
        if (x.isZero() || y.isZero()) {
          return x;
        }
        if (!x.isFinite() && !y.isFinite()) {
          return new BigNumber2(NaN);
        }
        if (y.lt(55)) {
          return x.times(Math.pow(2, y.toNumber()) + "");
        }
        return x.times(new BigNumber2(2).pow(y));
      }
      function rightArithShiftBigNumber(x, y) {
        if (x.isFinite() && !x.isInteger() || y.isFinite() && !y.isInteger()) {
          throw new Error("Integers expected in function rightArithShift");
        }
        var BigNumber2 = x.constructor;
        if (x.isNaN() || y.isNaN() || y.isNegative() && !y.isZero()) {
          return new BigNumber2(NaN);
        }
        if (x.isZero() || y.isZero()) {
          return x;
        }
        if (!y.isFinite()) {
          if (x.isNegative()) {
            return new BigNumber2(-1);
          }
          if (!x.isFinite()) {
            return new BigNumber2(NaN);
          }
          return new BigNumber2(0);
        }
        if (y.lt(55)) {
          return x.div(Math.pow(2, y.toNumber()) + "").floor();
        }
        return x.div(new BigNumber2(2).pow(y)).floor();
      }
    }
  });

  // node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/function/bitwise/bitAnd.js
  var require_bitAnd = __commonJS({
    "node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/function/bitwise/bitAnd.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.createBitAnd = void 0;
      var _bitwise = require_bitwise2();
      var _matAlgo02xDS = require_matAlgo02xDS0();
      var _matAlgo11xS0s = require_matAlgo11xS0s();
      var _matAlgo06xS0S = require_matAlgo06xS0S0();
      var _factory = require_factory();
      var _matrixAlgorithmSuite = require_matrixAlgorithmSuite();
      var _index = require_number2();
      var name18 = "bitAnd";
      var dependencies19 = ["typed", "matrix", "equalScalar", "concat"];
      var createBitAnd2 = exports.createBitAnd = /* @__PURE__ */ (0, _factory.factory)(name18, dependencies19, function(_ref) {
        var typed2 = _ref.typed, matrix2 = _ref.matrix, equalScalar2 = _ref.equalScalar, concat2 = _ref.concat;
        var matAlgo02xDS0 = (0, _matAlgo02xDS.createMatAlgo02xDS0)({
          typed: typed2,
          equalScalar: equalScalar2
        });
        var matAlgo06xS0S0 = (0, _matAlgo06xS0S.createMatAlgo06xS0S0)({
          typed: typed2,
          equalScalar: equalScalar2
        });
        var matAlgo11xS0s = (0, _matAlgo11xS0s.createMatAlgo11xS0s)({
          typed: typed2,
          equalScalar: equalScalar2
        });
        var matrixAlgorithmSuite = (0, _matrixAlgorithmSuite.createMatrixAlgorithmSuite)({
          typed: typed2,
          matrix: matrix2,
          concat: concat2
        });
        return typed2(name18, {
          "number, number": _index.bitAndNumber,
          "BigNumber, BigNumber": _bitwise.bitAndBigNumber
        }, matrixAlgorithmSuite({
          SS: matAlgo06xS0S0,
          DS: matAlgo02xDS0,
          Ss: matAlgo11xS0s
        }));
      });
    }
  });

  // node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/function/bitwise/bitNot.js
  var require_bitNot = __commonJS({
    "node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/function/bitwise/bitNot.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.createBitNot = void 0;
      var _bitwise = require_bitwise2();
      var _collection = require_collection();
      var _factory = require_factory();
      var _index = require_number2();
      var name18 = "bitNot";
      var dependencies19 = ["typed"];
      var createBitNot2 = exports.createBitNot = /* @__PURE__ */ (0, _factory.factory)(name18, dependencies19, function(_ref) {
        var typed2 = _ref.typed;
        return typed2(name18, {
          number: _index.bitNotNumber,
          BigNumber: _bitwise.bitNotBigNumber,
          "Array | Matrix": typed2.referToSelf(function(self2) {
            return function(x) {
              return (0, _collection.deepMap)(x, self2);
            };
          })
        });
      });
    }
  });

  // node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/function/bitwise/bitOr.js
  var require_bitOr = __commonJS({
    "node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/function/bitwise/bitOr.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.createBitOr = void 0;
      var _bitwise = require_bitwise2();
      var _factory = require_factory();
      var _matAlgo10xSids = require_matAlgo10xSids();
      var _matAlgo04xSidSid = require_matAlgo04xSidSid();
      var _matAlgo01xDSid = require_matAlgo01xDSid();
      var _matrixAlgorithmSuite = require_matrixAlgorithmSuite();
      var _index = require_number2();
      var name18 = "bitOr";
      var dependencies19 = ["typed", "matrix", "equalScalar", "DenseMatrix", "concat"];
      var createBitOr2 = exports.createBitOr = /* @__PURE__ */ (0, _factory.factory)(name18, dependencies19, function(_ref) {
        var typed2 = _ref.typed, matrix2 = _ref.matrix, equalScalar2 = _ref.equalScalar, DenseMatrix2 = _ref.DenseMatrix, concat2 = _ref.concat;
        var matAlgo01xDSid = (0, _matAlgo01xDSid.createMatAlgo01xDSid)({
          typed: typed2
        });
        var matAlgo04xSidSid = (0, _matAlgo04xSidSid.createMatAlgo04xSidSid)({
          typed: typed2,
          equalScalar: equalScalar2
        });
        var matAlgo10xSids = (0, _matAlgo10xSids.createMatAlgo10xSids)({
          typed: typed2,
          DenseMatrix: DenseMatrix2
        });
        var matrixAlgorithmSuite = (0, _matrixAlgorithmSuite.createMatrixAlgorithmSuite)({
          typed: typed2,
          matrix: matrix2,
          concat: concat2
        });
        return typed2(name18, {
          "number, number": _index.bitOrNumber,
          "BigNumber, BigNumber": _bitwise.bitOrBigNumber
        }, matrixAlgorithmSuite({
          SS: matAlgo04xSidSid,
          DS: matAlgo01xDSid,
          Ss: matAlgo10xSids
        }));
      });
    }
  });

  // node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/type/matrix/utils/matAlgo07xSSf.js
  var require_matAlgo07xSSf = __commonJS({
    "node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/type/matrix/utils/matAlgo07xSSf.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.createMatAlgo07xSSf = void 0;
      var _factory = require_factory();
      var _DimensionError = require_DimensionError();
      var name18 = "matAlgo07xSSf";
      var dependencies19 = ["typed", "DenseMatrix"];
      var createMatAlgo07xSSf = exports.createMatAlgo07xSSf = /* @__PURE__ */ (0, _factory.factory)(name18, dependencies19, function(_ref) {
        var typed2 = _ref.typed, DenseMatrix2 = _ref.DenseMatrix;
        return function matAlgo07xSSf(a, b, callback) {
          var asize = a._size;
          var adt = a._datatype || a._data === void 0 ? a._datatype : a.getDataType();
          var bsize = b._size;
          var bdt = b._datatype || b._data === void 0 ? b._datatype : b.getDataType();
          if (asize.length !== bsize.length) {
            throw new _DimensionError.DimensionError(asize.length, bsize.length);
          }
          if (asize[0] !== bsize[0] || asize[1] !== bsize[1]) {
            throw new RangeError("Dimension mismatch. Matrix A (" + asize + ") must match Matrix B (" + bsize + ")");
          }
          var rows = asize[0];
          var columns = asize[1];
          var dt;
          var zero = 0;
          var cf = callback;
          if (typeof adt === "string" && adt === bdt && adt !== "mixed") {
            dt = adt;
            zero = typed2.convert(0, dt);
            cf = typed2.find(callback, [dt, dt]);
          }
          var i, j;
          var cdata = [];
          for (i = 0; i < rows; i++) {
            cdata[i] = [];
          }
          var xa = [];
          var xb = [];
          var wa = [];
          var wb = [];
          for (j = 0; j < columns; j++) {
            var mark = j + 1;
            _scatter(a, j, wa, xa, mark);
            _scatter(b, j, wb, xb, mark);
            for (i = 0; i < rows; i++) {
              var va = wa[i] === mark ? xa[i] : zero;
              var vb = wb[i] === mark ? xb[i] : zero;
              cdata[i][j] = cf(va, vb);
            }
          }
          return new DenseMatrix2({
            data: cdata,
            size: [rows, columns],
            datatype: adt === a._datatype && bdt === b._datatype ? dt : void 0
          });
        };
        function _scatter(m, j, w, x, mark) {
          var values = m._values;
          var index = m._index;
          var ptr = m._ptr;
          for (var k = ptr[j], k1 = ptr[j + 1]; k < k1; k++) {
            var i = index[k];
            w[i] = mark;
            x[i] = values[k];
          }
        }
      });
    }
  });

  // node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/function/bitwise/bitXor.js
  var require_bitXor = __commonJS({
    "node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/function/bitwise/bitXor.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.createBitXor = void 0;
      var _bitwise = require_bitwise2();
      var _matAlgo03xDSf = require_matAlgo03xDSf();
      var _matAlgo07xSSf = require_matAlgo07xSSf();
      var _matAlgo12xSfs = require_matAlgo12xSfs();
      var _factory = require_factory();
      var _matrixAlgorithmSuite = require_matrixAlgorithmSuite();
      var _index = require_number2();
      var name18 = "bitXor";
      var dependencies19 = ["typed", "matrix", "DenseMatrix", "concat"];
      var createBitXor2 = exports.createBitXor = /* @__PURE__ */ (0, _factory.factory)(name18, dependencies19, function(_ref) {
        var typed2 = _ref.typed, matrix2 = _ref.matrix, DenseMatrix2 = _ref.DenseMatrix, concat2 = _ref.concat;
        var matAlgo03xDSf = (0, _matAlgo03xDSf.createMatAlgo03xDSf)({
          typed: typed2
        });
        var matAlgo07xSSf = (0, _matAlgo07xSSf.createMatAlgo07xSSf)({
          typed: typed2,
          DenseMatrix: DenseMatrix2
        });
        var matAlgo12xSfs = (0, _matAlgo12xSfs.createMatAlgo12xSfs)({
          typed: typed2,
          DenseMatrix: DenseMatrix2
        });
        var matrixAlgorithmSuite = (0, _matrixAlgorithmSuite.createMatrixAlgorithmSuite)({
          typed: typed2,
          matrix: matrix2,
          concat: concat2
        });
        return typed2(name18, {
          "number, number": _index.bitXorNumber,
          "BigNumber, BigNumber": _bitwise.bitXor
        }, matrixAlgorithmSuite({
          SS: matAlgo07xSSf,
          DS: matAlgo03xDSf,
          Ss: matAlgo12xSfs
        }));
      });
    }
  });

  // node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/function/complex/arg.js
  var require_arg = __commonJS({
    "node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/function/complex/arg.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.createArg = void 0;
      var _factory = require_factory();
      var _collection = require_collection();
      var name18 = "arg";
      var dependencies19 = ["typed"];
      var createArg2 = exports.createArg = /* @__PURE__ */ (0, _factory.factory)(name18, dependencies19, function(_ref) {
        var typed2 = _ref.typed;
        return typed2(name18, {
          number: function number(x) {
            return Math.atan2(0, x);
          },
          BigNumber: function BigNumber2(x) {
            return x.constructor.atan2(0, x);
          },
          Complex: function Complex3(x) {
            return x.arg();
          },
          // TODO: implement BigNumber support for function arg
          "Array | Matrix": typed2.referToSelf(function(self2) {
            return function(x) {
              return (0, _collection.deepMap)(x, self2);
            };
          })
        });
      });
    }
  });

  // node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/function/complex/conj.js
  var require_conj = __commonJS({
    "node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/function/complex/conj.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.createConj = void 0;
      var _factory = require_factory();
      var _collection = require_collection();
      var name18 = "conj";
      var dependencies19 = ["typed"];
      var createConj2 = exports.createConj = /* @__PURE__ */ (0, _factory.factory)(name18, dependencies19, function(_ref) {
        var typed2 = _ref.typed;
        return typed2(name18, {
          "number | BigNumber | Fraction": function numberBigNumberFraction(x) {
            return x;
          },
          Complex: function Complex3(x) {
            return x.conjugate();
          },
          "Array | Matrix": typed2.referToSelf(function(self2) {
            return function(x) {
              return (0, _collection.deepMap)(x, self2);
            };
          })
        });
      });
    }
  });

  // node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/function/complex/im.js
  var require_im = __commonJS({
    "node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/function/complex/im.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.createIm = void 0;
      var _factory = require_factory();
      var _collection = require_collection();
      var name18 = "im";
      var dependencies19 = ["typed"];
      var createIm2 = exports.createIm = /* @__PURE__ */ (0, _factory.factory)(name18, dependencies19, function(_ref) {
        var typed2 = _ref.typed;
        return typed2(name18, {
          number: function number() {
            return 0;
          },
          "BigNumber | Fraction": function BigNumberFraction(x) {
            return x.mul(0);
          },
          Complex: function Complex3(x) {
            return x.im;
          },
          "Array | Matrix": typed2.referToSelf(function(self2) {
            return function(x) {
              return (0, _collection.deepMap)(x, self2);
            };
          })
        });
      });
    }
  });

  // node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/function/complex/re.js
  var require_re = __commonJS({
    "node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/function/complex/re.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.createRe = void 0;
      var _factory = require_factory();
      var _collection = require_collection();
      var name18 = "re";
      var dependencies19 = ["typed"];
      var createRe2 = exports.createRe = /* @__PURE__ */ (0, _factory.factory)(name18, dependencies19, function(_ref) {
        var typed2 = _ref.typed;
        return typed2(name18, {
          "number | BigNumber | Fraction": function numberBigNumberFraction(x) {
            return x;
          },
          Complex: function Complex3(x) {
            return x.re;
          },
          "Array | Matrix": typed2.referToSelf(function(self2) {
            return function(x) {
              return (0, _collection.deepMap)(x, self2);
            };
          })
        });
      });
    }
  });

  // node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/function/logical/not.js
  var require_not = __commonJS({
    "node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/function/logical/not.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.createNot = void 0;
      var _collection = require_collection();
      var _factory = require_factory();
      var _index = require_number2();
      var name18 = "not";
      var dependencies19 = ["typed"];
      var createNot2 = exports.createNot = /* @__PURE__ */ (0, _factory.factory)(name18, dependencies19, function(_ref) {
        var typed2 = _ref.typed;
        return typed2(name18, {
          "null | undefined": function nullUndefined() {
            return true;
          },
          number: _index.notNumber,
          Complex: function Complex3(x) {
            return x.re === 0 && x.im === 0;
          },
          BigNumber: function BigNumber2(x) {
            return x.isZero() || x.isNaN();
          },
          Unit: typed2.referToSelf(function(self2) {
            return function(x) {
              return typed2.find(self2, x.valueType())(x.value);
            };
          }),
          "Array | Matrix": typed2.referToSelf(function(self2) {
            return function(x) {
              return (0, _collection.deepMap)(x, self2);
            };
          })
        });
      });
    }
  });

  // node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/function/logical/or.js
  var require_or = __commonJS({
    "node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/function/logical/or.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.createOr = void 0;
      var _matAlgo03xDSf = require_matAlgo03xDSf();
      var _matAlgo12xSfs = require_matAlgo12xSfs();
      var _matAlgo05xSfSf = require_matAlgo05xSfSf();
      var _factory = require_factory();
      var _matrixAlgorithmSuite = require_matrixAlgorithmSuite();
      var _index = require_number2();
      var name18 = "or";
      var dependencies19 = ["typed", "matrix", "equalScalar", "DenseMatrix", "concat"];
      var createOr2 = exports.createOr = /* @__PURE__ */ (0, _factory.factory)(name18, dependencies19, function(_ref) {
        var typed2 = _ref.typed, matrix2 = _ref.matrix, equalScalar2 = _ref.equalScalar, DenseMatrix2 = _ref.DenseMatrix, concat2 = _ref.concat;
        var matAlgo03xDSf = (0, _matAlgo03xDSf.createMatAlgo03xDSf)({
          typed: typed2
        });
        var matAlgo05xSfSf = (0, _matAlgo05xSfSf.createMatAlgo05xSfSf)({
          typed: typed2,
          equalScalar: equalScalar2
        });
        var matAlgo12xSfs = (0, _matAlgo12xSfs.createMatAlgo12xSfs)({
          typed: typed2,
          DenseMatrix: DenseMatrix2
        });
        var matrixAlgorithmSuite = (0, _matrixAlgorithmSuite.createMatrixAlgorithmSuite)({
          typed: typed2,
          matrix: matrix2,
          concat: concat2
        });
        return typed2(name18, {
          "number, number": _index.orNumber,
          "Complex, Complex": function ComplexComplex(x, y) {
            return x.re !== 0 || x.im !== 0 || y.re !== 0 || y.im !== 0;
          },
          "BigNumber, BigNumber": function BigNumberBigNumber(x, y) {
            return !x.isZero() && !x.isNaN() || !y.isZero() && !y.isNaN();
          },
          "Unit, Unit": typed2.referToSelf(function(self2) {
            return function(x, y) {
              return self2(x.value || 0, y.value || 0);
            };
          })
        }, matrixAlgorithmSuite({
          SS: matAlgo05xSfSf,
          DS: matAlgo03xDSf,
          Ss: matAlgo12xSfs
        }));
      });
    }
  });

  // node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/function/logical/xor.js
  var require_xor = __commonJS({
    "node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/function/logical/xor.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.createXor = void 0;
      var _matAlgo03xDSf = require_matAlgo03xDSf();
      var _matAlgo07xSSf = require_matAlgo07xSSf();
      var _matAlgo12xSfs = require_matAlgo12xSfs();
      var _factory = require_factory();
      var _matrixAlgorithmSuite = require_matrixAlgorithmSuite();
      var _index = require_number2();
      var name18 = "xor";
      var dependencies19 = ["typed", "matrix", "DenseMatrix", "concat"];
      var createXor2 = exports.createXor = /* @__PURE__ */ (0, _factory.factory)(name18, dependencies19, function(_ref) {
        var typed2 = _ref.typed, matrix2 = _ref.matrix, DenseMatrix2 = _ref.DenseMatrix, concat2 = _ref.concat;
        var matAlgo03xDSf = (0, _matAlgo03xDSf.createMatAlgo03xDSf)({
          typed: typed2
        });
        var matAlgo07xSSf = (0, _matAlgo07xSSf.createMatAlgo07xSSf)({
          typed: typed2,
          DenseMatrix: DenseMatrix2
        });
        var matAlgo12xSfs = (0, _matAlgo12xSfs.createMatAlgo12xSfs)({
          typed: typed2,
          DenseMatrix: DenseMatrix2
        });
        var matrixAlgorithmSuite = (0, _matrixAlgorithmSuite.createMatrixAlgorithmSuite)({
          typed: typed2,
          matrix: matrix2,
          concat: concat2
        });
        return typed2(name18, {
          "number, number": _index.xorNumber,
          "Complex, Complex": function ComplexComplex(x, y) {
            return (x.re !== 0 || x.im !== 0) !== (y.re !== 0 || y.im !== 0);
          },
          "BigNumber, BigNumber": function BigNumberBigNumber(x, y) {
            return (!x.isZero() && !x.isNaN()) !== (!y.isZero() && !y.isNaN());
          },
          "Unit, Unit": typed2.referToSelf(function(self2) {
            return function(x, y) {
              return self2(x.value || 0, y.value || 0);
            };
          })
        }, matrixAlgorithmSuite({
          SS: matAlgo07xSSf,
          DS: matAlgo03xDSf,
          Ss: matAlgo12xSfs
        }));
      });
    }
  });

  // node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/function/matrix/concat.js
  var require_concat = __commonJS({
    "node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/function/matrix/concat.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.createConcat = void 0;
      var _is = require_is();
      var _object = require_object();
      var _array = require_array();
      var _IndexError = require_IndexError();
      var _DimensionError = require_DimensionError();
      var _factory = require_factory();
      var name18 = "concat";
      var dependencies19 = ["typed", "matrix", "isInteger"];
      var createConcat2 = exports.createConcat = /* @__PURE__ */ (0, _factory.factory)(name18, dependencies19, function(_ref) {
        var typed2 = _ref.typed, matrix2 = _ref.matrix, isInteger2 = _ref.isInteger;
        return typed2(name18, {
          // TODO: change signature to '...Array | Matrix, dim?' when supported
          "...Array | Matrix | number | BigNumber": function ArrayMatrixNumberBigNumber(args) {
            var i;
            var len = args.length;
            var dim = -1;
            var prevDim;
            var asMatrix = false;
            var matrices = [];
            for (i = 0; i < len; i++) {
              var arg = args[i];
              if ((0, _is.isMatrix)(arg)) {
                asMatrix = true;
              }
              if ((0, _is.isNumber)(arg) || (0, _is.isBigNumber)(arg)) {
                if (i !== len - 1) {
                  throw new Error("Dimension must be specified as last argument");
                }
                prevDim = dim;
                dim = arg.valueOf();
                if (!isInteger2(dim)) {
                  throw new TypeError("Integer number expected for dimension");
                }
                if (dim < 0 || i > 0 && dim > prevDim) {
                  throw new _IndexError.IndexError(dim, prevDim + 1);
                }
              } else {
                var m = (0, _object.clone)(arg).valueOf();
                var size2 = (0, _array.arraySize)(m);
                matrices[i] = m;
                prevDim = dim;
                dim = size2.length - 1;
                if (i > 0 && dim !== prevDim) {
                  throw new _DimensionError.DimensionError(prevDim + 1, dim + 1);
                }
              }
            }
            if (matrices.length === 0) {
              throw new SyntaxError("At least one matrix expected");
            }
            var res = matrices.shift();
            while (matrices.length) {
              res = (0, _array.concat)(res, matrices.shift(), dim);
            }
            return asMatrix ? matrix2(res) : res;
          },
          "...string": function string(args) {
            return args.join("");
          }
        });
      });
    }
  });

  // node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/function/matrix/column.js
  var require_column = __commonJS({
    "node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/function/matrix/column.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.createColumn = void 0;
      var _factory = require_factory();
      var _is = require_is();
      var _object = require_object();
      var _array = require_array();
      var name18 = "column";
      var dependencies19 = ["typed", "Index", "matrix", "range"];
      var createColumn2 = exports.createColumn = /* @__PURE__ */ (0, _factory.factory)(name18, dependencies19, function(_ref) {
        var typed2 = _ref.typed, Index = _ref.Index, matrix2 = _ref.matrix, range = _ref.range;
        return typed2(name18, {
          "Matrix, number": _column,
          "Array, number": function ArrayNumber(value, column) {
            return _column(matrix2((0, _object.clone)(value)), column).valueOf();
          }
        });
        function _column(value, column) {
          if (value.size().length !== 2) {
            throw new Error("Only two dimensional matrix is supported");
          }
          (0, _array.validateIndex)(column, value.size()[1]);
          var rowRange = range(0, value.size()[0]);
          var index = new Index(rowRange, column);
          var result = value.subset(index);
          return (0, _is.isMatrix)(result) ? result : matrix2([[result]]);
        }
      });
    }
  });

  // node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/function/matrix/count.js
  var require_count = __commonJS({
    "node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/function/matrix/count.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.createCount = void 0;
      var _factory = require_factory();
      var name18 = "count";
      var dependencies19 = ["typed", "size", "prod"];
      var createCount2 = exports.createCount = /* @__PURE__ */ (0, _factory.factory)(name18, dependencies19, function(_ref) {
        var typed2 = _ref.typed, size2 = _ref.size, prod = _ref.prod;
        return typed2(name18, {
          string: function string(x) {
            return x.length;
          },
          "Matrix | Array": function MatrixArray(x) {
            return prod(size2(x));
          }
        });
      });
    }
  });

  // node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/function/matrix/cross.js
  var require_cross = __commonJS({
    "node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/function/matrix/cross.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.createCross = void 0;
      var _array = require_array();
      var _factory = require_factory();
      var name18 = "cross";
      var dependencies19 = ["typed", "matrix", "subtract", "multiply"];
      var createCross2 = exports.createCross = /* @__PURE__ */ (0, _factory.factory)(name18, dependencies19, function(_ref) {
        var typed2 = _ref.typed, matrix2 = _ref.matrix, subtract = _ref.subtract, multiply2 = _ref.multiply;
        return typed2(name18, {
          "Matrix, Matrix": function MatrixMatrix(x, y) {
            return matrix2(_cross(x.toArray(), y.toArray()));
          },
          "Matrix, Array": function MatrixArray(x, y) {
            return matrix2(_cross(x.toArray(), y));
          },
          "Array, Matrix": function ArrayMatrix(x, y) {
            return matrix2(_cross(x, y.toArray()));
          },
          "Array, Array": _cross
        });
        function _cross(x, y) {
          var highestDimension = Math.max((0, _array.arraySize)(x).length, (0, _array.arraySize)(y).length);
          x = (0, _array.squeeze)(x);
          y = (0, _array.squeeze)(y);
          var xSize = (0, _array.arraySize)(x);
          var ySize = (0, _array.arraySize)(y);
          if (xSize.length !== 1 || ySize.length !== 1 || xSize[0] !== 3 || ySize[0] !== 3) {
            throw new RangeError("Vectors with length 3 expected (Size A = [" + xSize.join(", ") + "], B = [" + ySize.join(", ") + "])");
          }
          var product2 = [subtract(multiply2(x[1], y[2]), multiply2(x[2], y[1])), subtract(multiply2(x[2], y[0]), multiply2(x[0], y[2])), subtract(multiply2(x[0], y[1]), multiply2(x[1], y[0]))];
          if (highestDimension > 1) {
            return [product2];
          } else {
            return product2;
          }
        }
      });
    }
  });

  // node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/function/matrix/diag.js
  var require_diag = __commonJS({
    "node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/function/matrix/diag.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.createDiag = void 0;
      var _is = require_is();
      var _array = require_array();
      var _number = require_number();
      var _factory = require_factory();
      var name18 = "diag";
      var dependencies19 = ["typed", "matrix", "DenseMatrix", "SparseMatrix"];
      var createDiag2 = exports.createDiag = /* @__PURE__ */ (0, _factory.factory)(name18, dependencies19, function(_ref) {
        var typed2 = _ref.typed, matrix2 = _ref.matrix, DenseMatrix2 = _ref.DenseMatrix, SparseMatrix2 = _ref.SparseMatrix;
        return typed2(name18, {
          // FIXME: simplify this huge amount of signatures as soon as typed-function supports optional arguments
          Array: function Array2(x) {
            return _diag(x, 0, (0, _array.arraySize)(x), null);
          },
          "Array, number": function ArrayNumber(x, k) {
            return _diag(x, k, (0, _array.arraySize)(x), null);
          },
          "Array, BigNumber": function ArrayBigNumber(x, k) {
            return _diag(x, k.toNumber(), (0, _array.arraySize)(x), null);
          },
          "Array, string": function ArrayString(x, format4) {
            return _diag(x, 0, (0, _array.arraySize)(x), format4);
          },
          "Array, number, string": function ArrayNumberString(x, k, format4) {
            return _diag(x, k, (0, _array.arraySize)(x), format4);
          },
          "Array, BigNumber, string": function ArrayBigNumberString(x, k, format4) {
            return _diag(x, k.toNumber(), (0, _array.arraySize)(x), format4);
          },
          Matrix: function Matrix2(x) {
            return _diag(x, 0, x.size(), x.storage());
          },
          "Matrix, number": function MatrixNumber(x, k) {
            return _diag(x, k, x.size(), x.storage());
          },
          "Matrix, BigNumber": function MatrixBigNumber(x, k) {
            return _diag(x, k.toNumber(), x.size(), x.storage());
          },
          "Matrix, string": function MatrixString(x, format4) {
            return _diag(x, 0, x.size(), format4);
          },
          "Matrix, number, string": function MatrixNumberString(x, k, format4) {
            return _diag(x, k, x.size(), format4);
          },
          "Matrix, BigNumber, string": function MatrixBigNumberString(x, k, format4) {
            return _diag(x, k.toNumber(), x.size(), format4);
          }
        });
        function _diag(x, k, size2, format4) {
          if (!(0, _number.isInteger)(k)) {
            throw new TypeError("Second parameter in function diag must be an integer");
          }
          var kSuper = k > 0 ? k : 0;
          var kSub = k < 0 ? -k : 0;
          switch (size2.length) {
            case 1:
              return _createDiagonalMatrix(x, k, format4, size2[0], kSub, kSuper);
            case 2:
              return _getDiagonal(x, k, format4, size2, kSub, kSuper);
          }
          throw new RangeError("Matrix for function diag must be 2 dimensional");
        }
        function _createDiagonalMatrix(x, k, format4, l, kSub, kSuper) {
          var ms = [l + kSub, l + kSuper];
          if (format4 && format4 !== "sparse" && format4 !== "dense") {
            throw new TypeError("Unknown matrix type ".concat(format4, '"'));
          }
          var m = format4 === "sparse" ? SparseMatrix2.diagonal(ms, x, k) : DenseMatrix2.diagonal(ms, x, k);
          return format4 !== null ? m : m.valueOf();
        }
        function _getDiagonal(x, k, format4, s, kSub, kSuper) {
          if ((0, _is.isMatrix)(x)) {
            var dm = x.diagonal(k);
            if (format4 !== null) {
              if (format4 !== dm.storage()) {
                return matrix2(dm, format4);
              }
              return dm;
            }
            return dm.valueOf();
          }
          var n = Math.min(s[0] - kSub, s[1] - kSuper);
          var vector = [];
          for (var i = 0; i < n; i++) {
            vector[i] = x[i + kSub][i + kSuper];
          }
          return format4 !== null ? matrix2(vector) : vector;
        }
      });
    }
  });

  // node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/utils/applyCallback.js
  var require_applyCallback = __commonJS({
    "node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/utils/applyCallback.js"(exports) {
      "use strict";
      var _interopRequireDefault = require_interopRequireDefault();
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.applyCallback = applyCallback;
      var _typedFunction = _interopRequireDefault(require_typed_function());
      var _is = require_is();
      function applyCallback(callback, value, index, array, mappingFnName) {
        if (_typedFunction["default"].isTypedFunction(callback)) {
          var args3 = [value, index, array];
          var signature3 = _typedFunction["default"].resolve(callback, args3);
          if (signature3) {
            return tryWithArgs(signature3.implementation, args3);
          }
          var args2 = [value, index];
          var signature2 = _typedFunction["default"].resolve(callback, args2);
          if (signature2) {
            return tryWithArgs(signature2.implementation, args2);
          }
          var args1 = [value];
          var signature1 = _typedFunction["default"].resolve(callback, args1);
          if (signature1) {
            return tryWithArgs(signature1.implementation, args1);
          }
          return tryWithArgs(callback, args3);
        } else {
          return callback(value, index, array);
        }
        function tryWithArgs(signature, args) {
          try {
            return signature.apply(signature, args);
          } catch (err) {
            var _err$data;
            if (err instanceof TypeError && ((_err$data = err.data) === null || _err$data === void 0 ? void 0 : _err$data.category) === "wrongType") {
              var argsDesc = [];
              argsDesc.push("value: ".concat((0, _is.typeOf)(value)));
              if (args.length >= 2) {
                argsDesc.push("index: ".concat((0, _is.typeOf)(index)));
              }
              if (args.length >= 3) {
                argsDesc.push("array: ".concat((0, _is.typeOf)(array)));
              }
              throw new TypeError("Function ".concat(mappingFnName, " cannot apply callback arguments ") + "".concat(callback.name, "(").concat(argsDesc.join(", "), ") at index ").concat(JSON.stringify(index)));
            } else {
              throw new TypeError("Function ".concat(mappingFnName, " cannot apply callback arguments ") + "to function ".concat(callback.name, ": ").concat(err.message));
            }
          }
        }
      }
    }
  });

  // node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/function/matrix/filter.js
  var require_filter = __commonJS({
    "node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/function/matrix/filter.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.createFilter = void 0;
      var _applyCallback = require_applyCallback();
      var _array = require_array();
      var _factory = require_factory();
      var name18 = "filter";
      var dependencies19 = ["typed"];
      var createFilter2 = exports.createFilter = /* @__PURE__ */ (0, _factory.factory)(name18, dependencies19, function(_ref) {
        var typed2 = _ref.typed;
        return typed2("filter", {
          "Array, function": _filterCallback,
          "Matrix, function": function MatrixFunction(x, test) {
            return x.create(_filterCallback(x.toArray(), test));
          },
          "Array, RegExp": _array.filterRegExp,
          "Matrix, RegExp": function MatrixRegExp(x, test) {
            return x.create((0, _array.filterRegExp)(x.toArray(), test));
          }
        });
      });
      function _filterCallback(x, callback) {
        return (0, _array.filter)(x, function(value, index, array) {
          return (0, _applyCallback.applyCallback)(callback, value, [index], array, "filter");
        });
      }
    }
  });

  // node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/function/matrix/flatten.js
  var require_flatten = __commonJS({
    "node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/function/matrix/flatten.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.createFlatten = void 0;
      var _array = require_array();
      var _factory = require_factory();
      var name18 = "flatten";
      var dependencies19 = ["typed", "matrix"];
      var createFlatten2 = exports.createFlatten = /* @__PURE__ */ (0, _factory.factory)(name18, dependencies19, function(_ref) {
        var typed2 = _ref.typed, matrix2 = _ref.matrix;
        return typed2(name18, {
          Array: function Array2(x) {
            return (0, _array.flatten)(x);
          },
          Matrix: function Matrix2(x) {
            var flat = (0, _array.flatten)(x.toArray());
            return matrix2(flat);
          }
        });
      });
    }
  });

  // node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/function/matrix/forEach.js
  var require_forEach = __commonJS({
    "node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/function/matrix/forEach.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.createForEach = void 0;
      var _applyCallback = require_applyCallback();
      var _array = require_array();
      var _factory = require_factory();
      var name18 = "forEach";
      var dependencies19 = ["typed"];
      var createForEach2 = exports.createForEach = /* @__PURE__ */ (0, _factory.factory)(name18, dependencies19, function(_ref) {
        var typed2 = _ref.typed;
        return typed2(name18, {
          "Array, function": _forEach,
          "Matrix, function": function MatrixFunction(x, callback) {
            x.forEach(callback);
          }
        });
      });
      function _forEach(array, callback) {
        var recurse = function recurse2(value, index) {
          if (Array.isArray(value)) {
            (0, _array.forEach)(value, function(child, i) {
              recurse2(child, index.concat(i));
            });
          } else {
            return (0, _applyCallback.applyCallback)(callback, value, index, array, "forEach");
          }
        };
        recurse(array, []);
      }
    }
  });

  // node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/function/matrix/getMatrixDataType.js
  var require_getMatrixDataType = __commonJS({
    "node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/function/matrix/getMatrixDataType.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.createGetMatrixDataType = void 0;
      var _factory = require_factory();
      var _array = require_array();
      var _is = require_is();
      var name18 = "getMatrixDataType";
      var dependencies19 = ["typed"];
      var createGetMatrixDataType2 = exports.createGetMatrixDataType = /* @__PURE__ */ (0, _factory.factory)(name18, dependencies19, function(_ref) {
        var typed2 = _ref.typed;
        return typed2(name18, {
          Array: function Array2(x) {
            return (0, _array.getArrayDataType)(x, _is.typeOf);
          },
          Matrix: function Matrix2(x) {
            return x.getDataType();
          }
        });
      });
    }
  });

  // node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/function/matrix/identity.js
  var require_identity = __commonJS({
    "node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/function/matrix/identity.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.createIdentity = void 0;
      var _is = require_is();
      var _array = require_array();
      var _number = require_number();
      var _factory = require_factory();
      var name18 = "identity";
      var dependencies19 = ["typed", "config", "matrix", "BigNumber", "DenseMatrix", "SparseMatrix"];
      var createIdentity2 = exports.createIdentity = /* @__PURE__ */ (0, _factory.factory)(name18, dependencies19, function(_ref) {
        var typed2 = _ref.typed, config4 = _ref.config, matrix2 = _ref.matrix, BigNumber2 = _ref.BigNumber, DenseMatrix2 = _ref.DenseMatrix, SparseMatrix2 = _ref.SparseMatrix;
        return typed2(name18, {
          "": function _() {
            return config4.matrix === "Matrix" ? matrix2([]) : [];
          },
          string: function string(format4) {
            return matrix2(format4);
          },
          "number | BigNumber": function numberBigNumber(rows) {
            return _identity(rows, rows, config4.matrix === "Matrix" ? "dense" : void 0);
          },
          "number | BigNumber, string": function numberBigNumberString(rows, format4) {
            return _identity(rows, rows, format4);
          },
          "number | BigNumber, number | BigNumber": function numberBigNumberNumberBigNumber(rows, cols) {
            return _identity(rows, cols, config4.matrix === "Matrix" ? "dense" : void 0);
          },
          "number | BigNumber, number | BigNumber, string": function numberBigNumberNumberBigNumberString(rows, cols, format4) {
            return _identity(rows, cols, format4);
          },
          Array: function Array2(size2) {
            return _identityVector(size2);
          },
          "Array, string": function ArrayString(size2, format4) {
            return _identityVector(size2, format4);
          },
          Matrix: function Matrix2(size2) {
            return _identityVector(size2.valueOf(), size2.storage());
          },
          "Matrix, string": function MatrixString(size2, format4) {
            return _identityVector(size2.valueOf(), format4);
          }
        });
        function _identityVector(size2, format4) {
          switch (size2.length) {
            case 0:
              return format4 ? matrix2(format4) : [];
            case 1:
              return _identity(size2[0], size2[0], format4);
            case 2:
              return _identity(size2[0], size2[1], format4);
            default:
              throw new Error("Vector containing two values expected");
          }
        }
        function _identity(rows, cols, format4) {
          var Big = (0, _is.isBigNumber)(rows) || (0, _is.isBigNumber)(cols) ? BigNumber2 : null;
          if ((0, _is.isBigNumber)(rows)) rows = rows.toNumber();
          if ((0, _is.isBigNumber)(cols)) cols = cols.toNumber();
          if (!(0, _number.isInteger)(rows) || rows < 1) {
            throw new Error("Parameters in function identity must be positive integers");
          }
          if (!(0, _number.isInteger)(cols) || cols < 1) {
            throw new Error("Parameters in function identity must be positive integers");
          }
          var one = Big ? new BigNumber2(1) : 1;
          var defaultValue = Big ? new Big(0) : 0;
          var size2 = [rows, cols];
          if (format4) {
            if (format4 === "sparse") {
              return SparseMatrix2.diagonal(size2, one, 0, defaultValue);
            }
            if (format4 === "dense") {
              return DenseMatrix2.diagonal(size2, one, 0, defaultValue);
            }
            throw new TypeError('Unknown matrix type "'.concat(format4, '"'));
          }
          var res = (0, _array.resize)([], size2, defaultValue);
          var minimum = rows < cols ? rows : cols;
          for (var d = 0; d < minimum; d++) {
            res[d][d] = one;
          }
          return res;
        }
      });
    }
  });

  // node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/function/matrix/kron.js
  var require_kron = __commonJS({
    "node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/function/matrix/kron.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.createKron = void 0;
      var _array = require_array();
      var _factory = require_factory();
      var name18 = "kron";
      var dependencies19 = ["typed", "matrix", "multiplyScalar"];
      var createKron2 = exports.createKron = /* @__PURE__ */ (0, _factory.factory)(name18, dependencies19, function(_ref) {
        var typed2 = _ref.typed, matrix2 = _ref.matrix, multiplyScalar2 = _ref.multiplyScalar;
        return typed2(name18, {
          "Matrix, Matrix": function MatrixMatrix(x, y) {
            return matrix2(_kron(x.toArray(), y.toArray()));
          },
          "Matrix, Array": function MatrixArray(x, y) {
            return matrix2(_kron(x.toArray(), y));
          },
          "Array, Matrix": function ArrayMatrix(x, y) {
            return matrix2(_kron(x, y.toArray()));
          },
          "Array, Array": _kron
        });
        function _kron(a, b) {
          if ((0, _array.arraySize)(a).length === 1) {
            a = [a];
          }
          if ((0, _array.arraySize)(b).length === 1) {
            b = [b];
          }
          if ((0, _array.arraySize)(a).length > 2 || (0, _array.arraySize)(b).length > 2) {
            throw new RangeError("Vectors with dimensions greater then 2 are not supported expected (Size x = " + JSON.stringify(a.length) + ", y = " + JSON.stringify(b.length) + ")");
          }
          var t = [];
          var r = [];
          return a.map(function(a2) {
            return b.map(function(b2) {
              r = [];
              t.push(r);
              return a2.map(function(y) {
                return b2.map(function(x) {
                  return r.push(multiplyScalar2(y, x));
                });
              });
            });
          }) && t;
        }
      });
    }
  });

  // node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/function/matrix/map.js
  var require_map2 = __commonJS({
    "node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/function/matrix/map.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.createMap = void 0;
      var _applyCallback = require_applyCallback();
      var _factory = require_factory();
      var name18 = "map";
      var dependencies19 = ["typed"];
      var createMap2 = exports.createMap = /* @__PURE__ */ (0, _factory.factory)(name18, dependencies19, function(_ref) {
        var typed2 = _ref.typed;
        return typed2(name18, {
          "Array, function": _map,
          "Matrix, function": function MatrixFunction(x, callback) {
            return x.map(callback);
          }
        });
      });
      function _map(array, callback) {
        var recurse = function recurse2(value, index) {
          if (Array.isArray(value)) {
            return value.map(function(child, i) {
              return recurse2(child, index.concat(i));
            });
          } else {
            return (0, _applyCallback.applyCallback)(callback, value, index, array, "map");
          }
        };
        return recurse(array, []);
      }
    }
  });

  // node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/function/matrix/diff.js
  var require_diff = __commonJS({
    "node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/function/matrix/diff.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.createDiff = void 0;
      var _factory = require_factory();
      var _number = require_number();
      var _is = require_is();
      var name18 = "diff";
      var dependencies19 = ["typed", "matrix", "subtract", "number"];
      var createDiff2 = exports.createDiff = /* @__PURE__ */ (0, _factory.factory)(name18, dependencies19, function(_ref) {
        var typed2 = _ref.typed, matrix2 = _ref.matrix, subtract = _ref.subtract, number = _ref.number;
        return typed2(name18, {
          "Array | Matrix": function ArrayMatrix(arr) {
            if ((0, _is.isMatrix)(arr)) {
              return matrix2(_diff(arr.toArray()));
            } else {
              return _diff(arr);
            }
          },
          "Array | Matrix, number": function ArrayMatrixNumber(arr, dim) {
            if (!(0, _number.isInteger)(dim)) throw new RangeError("Dimension must be a whole number");
            if ((0, _is.isMatrix)(arr)) {
              return matrix2(_recursive(arr.toArray(), dim));
            } else {
              return _recursive(arr, dim);
            }
          },
          "Array, BigNumber": typed2.referTo("Array,number", function(selfAn) {
            return function(arr, dim) {
              return selfAn(arr, number(dim));
            };
          }),
          "Matrix, BigNumber": typed2.referTo("Matrix,number", function(selfMn) {
            return function(arr, dim) {
              return selfMn(arr, number(dim));
            };
          })
        });
        function _recursive(arr, dim) {
          if ((0, _is.isMatrix)(arr)) {
            arr = arr.toArray();
          }
          if (!Array.isArray(arr)) {
            throw RangeError("Array/Matrix does not have that many dimensions");
          }
          if (dim > 0) {
            var result = [];
            arr.forEach(function(element) {
              result.push(_recursive(element, dim - 1));
            });
            return result;
          } else if (dim === 0) {
            return _diff(arr);
          } else {
            throw RangeError("Cannot have negative dimension");
          }
        }
        function _diff(arr) {
          var result = [];
          var size2 = arr.length;
          for (var i = 1; i < size2; i++) {
            result.push(_ElementDiff(arr[i - 1], arr[i]));
          }
          return result;
        }
        function _ElementDiff(obj1, obj2) {
          if ((0, _is.isMatrix)(obj1)) obj1 = obj1.toArray();
          if ((0, _is.isMatrix)(obj2)) obj2 = obj2.toArray();
          var obj1IsArray = Array.isArray(obj1);
          var obj2IsArray = Array.isArray(obj2);
          if (obj1IsArray && obj2IsArray) {
            return _ArrayDiff(obj1, obj2);
          }
          if (!obj1IsArray && !obj2IsArray) {
            return subtract(obj2, obj1);
          }
          throw TypeError("Cannot calculate difference between 1 array and 1 non-array");
        }
        function _ArrayDiff(arr1, arr2) {
          if (arr1.length !== arr2.length) {
            throw RangeError("Not all sub-arrays have the same length");
          }
          var result = [];
          var size2 = arr1.length;
          for (var i = 0; i < size2; i++) {
            result.push(_ElementDiff(arr1[i], arr2[i]));
          }
          return result;
        }
      });
    }
  });

  // node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/function/matrix/ones.js
  var require_ones = __commonJS({
    "node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/function/matrix/ones.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.createOnes = void 0;
      var _is = require_is();
      var _number = require_number();
      var _array = require_array();
      var _factory = require_factory();
      var name18 = "ones";
      var dependencies19 = ["typed", "config", "matrix", "BigNumber"];
      var createOnes2 = exports.createOnes = /* @__PURE__ */ (0, _factory.factory)(name18, dependencies19, function(_ref) {
        var typed2 = _ref.typed, config4 = _ref.config, matrix2 = _ref.matrix, BigNumber2 = _ref.BigNumber;
        return typed2("ones", {
          "": function _() {
            return config4.matrix === "Array" ? _ones([]) : _ones([], "default");
          },
          // math.ones(m, n, p, ..., format)
          // TODO: more accurate signature '...number | BigNumber, string' as soon as typed-function supports this
          "...number | BigNumber | string": function numberBigNumberString(size2) {
            var last = size2[size2.length - 1];
            if (typeof last === "string") {
              var format4 = size2.pop();
              return _ones(size2, format4);
            } else if (config4.matrix === "Array") {
              return _ones(size2);
            } else {
              return _ones(size2, "default");
            }
          },
          Array: _ones,
          Matrix: function Matrix2(size2) {
            var format4 = size2.storage();
            return _ones(size2.valueOf(), format4);
          },
          "Array | Matrix, string": function ArrayMatrixString(size2, format4) {
            return _ones(size2.valueOf(), format4);
          }
        });
        function _ones(size2, format4) {
          var hasBigNumbers = _normalize(size2);
          var defaultValue = hasBigNumbers ? new BigNumber2(1) : 1;
          _validate2(size2);
          if (format4) {
            var m = matrix2(format4);
            if (size2.length > 0) {
              return m.resize(size2, defaultValue);
            }
            return m;
          } else {
            var arr = [];
            if (size2.length > 0) {
              return (0, _array.resize)(arr, size2, defaultValue);
            }
            return arr;
          }
        }
        function _normalize(size2) {
          var hasBigNumbers = false;
          size2.forEach(function(value, index, arr) {
            if ((0, _is.isBigNumber)(value)) {
              hasBigNumbers = true;
              arr[index] = value.toNumber();
            }
          });
          return hasBigNumbers;
        }
        function _validate2(size2) {
          size2.forEach(function(value) {
            if (typeof value !== "number" || !(0, _number.isInteger)(value) || value < 0) {
              throw new Error("Parameters in function ones must be positive integers");
            }
          });
        }
      });
    }
  });

  // node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/utils/noop.js
  var require_noop = __commonJS({
    "node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/utils/noop.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.noBignumber = noBignumber;
      exports.noFraction = noFraction;
      exports.noIndex = noIndex;
      exports.noMatrix = noMatrix2;
      exports.noSubset = noSubset;
      function noBignumber() {
        throw new Error('No "bignumber" implementation available');
      }
      function noFraction() {
        throw new Error('No "fraction" implementation available');
      }
      function noMatrix2() {
        throw new Error('No "matrix" implementation available');
      }
      function noIndex() {
        throw new Error('No "index" implementation available');
      }
      function noSubset() {
        throw new Error('No "matrix" implementation available');
      }
    }
  });

  // node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/function/matrix/range.js
  var require_range = __commonJS({
    "node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/function/matrix/range.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.createRange = void 0;
      var _factory = require_factory();
      var _noop = require_noop();
      var name18 = "range";
      var dependencies19 = ["typed", "config", "?matrix", "?bignumber", "smaller", "smallerEq", "larger", "largerEq", "add", "isPositive"];
      var createRange2 = exports.createRange = /* @__PURE__ */ (0, _factory.factory)(name18, dependencies19, function(_ref) {
        var typed2 = _ref.typed, config4 = _ref.config, matrix2 = _ref.matrix, bignumber = _ref.bignumber, smaller = _ref.smaller, smallerEq = _ref.smallerEq, larger = _ref.larger, largerEq = _ref.largerEq, add2 = _ref.add, isPositive = _ref.isPositive;
        return typed2(name18, {
          // TODO: simplify signatures when typed-function supports default values and optional arguments
          // TODO: a number or boolean should not be converted to string here
          string: _strRange,
          "string, boolean": _strRange,
          "number, number": function numberNumber(start, end) {
            return _out(_range(start, end, 1, false));
          },
          "number, number, number": function numberNumberNumber(start, end, step) {
            return _out(_range(start, end, step, false));
          },
          "number, number, boolean": function numberNumberBoolean(start, end, includeEnd) {
            return _out(_range(start, end, 1, includeEnd));
          },
          "number, number, number, boolean": function numberNumberNumberBoolean(start, end, step, includeEnd) {
            return _out(_range(start, end, step, includeEnd));
          },
          "BigNumber, BigNumber": function BigNumberBigNumber(start, end) {
            var BigNumber2 = start.constructor;
            return _out(_range(start, end, new BigNumber2(1), false));
          },
          "BigNumber, BigNumber, BigNumber": function BigNumberBigNumberBigNumber(start, end, step) {
            return _out(_range(start, end, step, false));
          },
          "BigNumber, BigNumber, boolean": function BigNumberBigNumberBoolean(start, end, includeEnd) {
            var BigNumber2 = start.constructor;
            return _out(_range(start, end, new BigNumber2(1), includeEnd));
          },
          "BigNumber, BigNumber, BigNumber, boolean": function BigNumberBigNumberBigNumberBoolean(start, end, step, includeEnd) {
            return _out(_range(start, end, step, includeEnd));
          },
          "Unit, Unit, Unit": function UnitUnitUnit(start, end, step) {
            return _out(_range(start, end, step, false));
          },
          "Unit, Unit, Unit, boolean": function UnitUnitUnitBoolean(start, end, step, includeEnd) {
            return _out(_range(start, end, step, includeEnd));
          }
        });
        function _out(arr) {
          if (config4.matrix === "Matrix") {
            return matrix2 ? matrix2(arr) : (0, _noop.noMatrix)();
          }
          return arr;
        }
        function _strRange(str, includeEnd) {
          var r = _parse(str);
          if (!r) {
            throw new SyntaxError('String "' + str + '" is no valid range');
          }
          if (config4.number === "BigNumber") {
            if (bignumber === void 0) {
              (0, _noop.noBignumber)();
            }
            return _out(_range(bignumber(r.start), bignumber(r.end), bignumber(r.step)), includeEnd);
          } else {
            return _out(_range(r.start, r.end, r.step, includeEnd));
          }
        }
        function _range(start, end, step, includeEnd) {
          var array = [];
          var ongoing = isPositive(step) ? includeEnd ? smallerEq : smaller : includeEnd ? largerEq : larger;
          var x = start;
          while (ongoing(x, end)) {
            array.push(x);
            x = add2(x, step);
          }
          return array;
        }
        function _parse(str) {
          var args = str.split(":");
          var nums = args.map(function(arg) {
            return Number(arg);
          });
          var invalid = nums.some(function(num) {
            return isNaN(num);
          });
          if (invalid) {
            return null;
          }
          switch (nums.length) {
            case 2:
              return {
                start: nums[0],
                end: nums[1],
                step: 1
              };
            case 3:
              return {
                start: nums[0],
                end: nums[2],
                step: nums[1]
              };
            default:
              return null;
          }
        }
      });
    }
  });

  // node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/function/matrix/reshape.js
  var require_reshape = __commonJS({
    "node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/function/matrix/reshape.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.createReshape = void 0;
      var _array = require_array();
      var _factory = require_factory();
      var name18 = "reshape";
      var dependencies19 = ["typed", "isInteger", "matrix"];
      var createReshape2 = exports.createReshape = /* @__PURE__ */ (0, _factory.factory)(name18, dependencies19, function(_ref) {
        var typed2 = _ref.typed, isInteger2 = _ref.isInteger;
        return typed2(name18, {
          "Matrix, Array": function MatrixArray(x, sizes) {
            return x.reshape(sizes, true);
          },
          "Array, Array": function ArrayArray(x, sizes) {
            sizes.forEach(function(size2) {
              if (!isInteger2(size2)) {
                throw new TypeError("Invalid size for dimension: " + size2);
              }
            });
            return (0, _array.reshape)(x, sizes);
          }
        });
      });
    }
  });

  // node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/function/matrix/resize.js
  var require_resize = __commonJS({
    "node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/function/matrix/resize.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.createResize = void 0;
      var _is = require_is();
      var _DimensionError = require_DimensionError();
      var _ArgumentsError = require_ArgumentsError();
      var _number = require_number();
      var _string = require_string();
      var _object = require_object();
      var _array = require_array();
      var _factory = require_factory();
      var name18 = "resize";
      var dependencies19 = ["config", "matrix"];
      var createResize2 = exports.createResize = /* @__PURE__ */ (0, _factory.factory)(name18, dependencies19, function(_ref) {
        var config4 = _ref.config, matrix2 = _ref.matrix;
        return function resize2(x, size2, defaultValue) {
          if (arguments.length !== 2 && arguments.length !== 3) {
            throw new _ArgumentsError.ArgumentsError("resize", arguments.length, 2, 3);
          }
          if ((0, _is.isMatrix)(size2)) {
            size2 = size2.valueOf();
          }
          if ((0, _is.isBigNumber)(size2[0])) {
            size2 = size2.map(function(value) {
              return !(0, _is.isBigNumber)(value) ? value : value.toNumber();
            });
          }
          if ((0, _is.isMatrix)(x)) {
            return x.resize(size2, defaultValue, true);
          }
          if (typeof x === "string") {
            return _resizeString(x, size2, defaultValue);
          }
          var asMatrix = Array.isArray(x) ? false : config4.matrix !== "Array";
          if (size2.length === 0) {
            while (Array.isArray(x)) {
              x = x[0];
            }
            return (0, _object.clone)(x);
          } else {
            if (!Array.isArray(x)) {
              x = [x];
            }
            x = (0, _object.clone)(x);
            var res = (0, _array.resize)(x, size2, defaultValue);
            return asMatrix ? matrix2(res) : res;
          }
        };
        function _resizeString(str, size2, defaultChar) {
          if (defaultChar !== void 0) {
            if (typeof defaultChar !== "string" || defaultChar.length !== 1) {
              throw new TypeError("Single character expected as defaultValue");
            }
          } else {
            defaultChar = " ";
          }
          if (size2.length !== 1) {
            throw new _DimensionError.DimensionError(size2.length, 1);
          }
          var len = size2[0];
          if (typeof len !== "number" || !(0, _number.isInteger)(len)) {
            throw new TypeError("Invalid size, must contain positive integers (size: " + (0, _string.format)(size2) + ")");
          }
          if (str.length > len) {
            return str.substring(0, len);
          } else if (str.length < len) {
            var res = str;
            for (var i = 0, ii = len - str.length; i < ii; i++) {
              res += defaultChar;
            }
            return res;
          } else {
            return str;
          }
        }
      });
    }
  });

  // node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/function/matrix/rotate.js
  var require_rotate = __commonJS({
    "node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/function/matrix/rotate.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.createRotate = void 0;
      var _factory = require_factory();
      var _array = require_array();
      var name18 = "rotate";
      var dependencies19 = ["typed", "multiply", "rotationMatrix"];
      var createRotate2 = exports.createRotate = /* @__PURE__ */ (0, _factory.factory)(name18, dependencies19, function(_ref) {
        var typed2 = _ref.typed, multiply2 = _ref.multiply, rotationMatrix = _ref.rotationMatrix;
        return typed2(name18, {
          "Array , number | BigNumber | Complex | Unit": function ArrayNumberBigNumberComplexUnit(w, theta) {
            _validateSize(w, 2);
            var matrixRes = multiply2(rotationMatrix(theta), w);
            return matrixRes.toArray();
          },
          "Matrix , number | BigNumber | Complex | Unit": function MatrixNumberBigNumberComplexUnit(w, theta) {
            _validateSize(w, 2);
            return multiply2(rotationMatrix(theta), w);
          },
          "Array, number | BigNumber | Complex | Unit, Array | Matrix": function ArrayNumberBigNumberComplexUnitArrayMatrix(w, theta, v) {
            _validateSize(w, 3);
            var matrixRes = multiply2(rotationMatrix(theta, v), w);
            return matrixRes;
          },
          "Matrix, number | BigNumber | Complex | Unit, Array | Matrix": function MatrixNumberBigNumberComplexUnitArrayMatrix(w, theta, v) {
            _validateSize(w, 3);
            return multiply2(rotationMatrix(theta, v), w);
          }
        });
        function _validateSize(v, expectedSize) {
          var actualSize = Array.isArray(v) ? (0, _array.arraySize)(v) : v.size();
          if (actualSize.length > 2) {
            throw new RangeError("Vector must be of dimensions 1x".concat(expectedSize));
          }
          if (actualSize.length === 2 && actualSize[1] !== 1) {
            throw new RangeError("Vector must be of dimensions 1x".concat(expectedSize));
          }
          if (actualSize[0] !== expectedSize) {
            throw new RangeError("Vector must be of dimensions 1x".concat(expectedSize));
          }
        }
      });
    }
  });

  // node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/function/matrix/rotationMatrix.js
  var require_rotationMatrix = __commonJS({
    "node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/function/matrix/rotationMatrix.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.createRotationMatrix = void 0;
      var _is = require_is();
      var _factory = require_factory();
      var name18 = "rotationMatrix";
      var dependencies19 = ["typed", "config", "multiplyScalar", "addScalar", "unaryMinus", "norm", "matrix", "BigNumber", "DenseMatrix", "SparseMatrix", "cos", "sin"];
      var createRotationMatrix2 = exports.createRotationMatrix = /* @__PURE__ */ (0, _factory.factory)(name18, dependencies19, function(_ref) {
        var typed2 = _ref.typed, config4 = _ref.config, multiplyScalar2 = _ref.multiplyScalar, addScalar2 = _ref.addScalar, unaryMinus = _ref.unaryMinus, norm = _ref.norm, BigNumber2 = _ref.BigNumber, matrix2 = _ref.matrix, DenseMatrix2 = _ref.DenseMatrix, SparseMatrix2 = _ref.SparseMatrix, cos2 = _ref.cos, sin2 = _ref.sin;
        return typed2(name18, {
          "": function _() {
            return config4.matrix === "Matrix" ? matrix2([]) : [];
          },
          string: function string(format4) {
            return matrix2(format4);
          },
          "number | BigNumber | Complex | Unit": function numberBigNumberComplexUnit(theta) {
            return _rotationMatrix2x2(theta, config4.matrix === "Matrix" ? "dense" : void 0);
          },
          "number | BigNumber | Complex | Unit, string": function numberBigNumberComplexUnitString(theta, format4) {
            return _rotationMatrix2x2(theta, format4);
          },
          "number | BigNumber | Complex | Unit, Array": function numberBigNumberComplexUnitArray(theta, v) {
            var matrixV = matrix2(v);
            _validateVector(matrixV);
            return _rotationMatrix3x3(theta, matrixV, void 0);
          },
          "number | BigNumber | Complex | Unit, Matrix": function numberBigNumberComplexUnitMatrix(theta, v) {
            _validateVector(v);
            var storageType = v.storage() || (config4.matrix === "Matrix" ? "dense" : void 0);
            return _rotationMatrix3x3(theta, v, storageType);
          },
          "number | BigNumber | Complex | Unit, Array, string": function numberBigNumberComplexUnitArrayString(theta, v, format4) {
            var matrixV = matrix2(v);
            _validateVector(matrixV);
            return _rotationMatrix3x3(theta, matrixV, format4);
          },
          "number | BigNumber | Complex | Unit, Matrix, string": function numberBigNumberComplexUnitMatrixString(theta, v, format4) {
            _validateVector(v);
            return _rotationMatrix3x3(theta, v, format4);
          }
        });
        function _rotationMatrix2x2(theta, format4) {
          var Big = (0, _is.isBigNumber)(theta);
          var minusOne = Big ? new BigNumber2(-1) : -1;
          var cosTheta = cos2(theta);
          var sinTheta = sin2(theta);
          var data = [[cosTheta, multiplyScalar2(minusOne, sinTheta)], [sinTheta, cosTheta]];
          return _convertToFormat(data, format4);
        }
        function _validateVector(v) {
          var size2 = v.size();
          if (size2.length < 1 || size2[0] !== 3) {
            throw new RangeError("Vector must be of dimensions 1x3");
          }
        }
        function _mul(array) {
          return array.reduce(function(p, curr) {
            return multiplyScalar2(p, curr);
          });
        }
        function _convertToFormat(data, format4) {
          if (format4) {
            if (format4 === "sparse") {
              return new SparseMatrix2(data);
            }
            if (format4 === "dense") {
              return new DenseMatrix2(data);
            }
            throw new TypeError('Unknown matrix type "'.concat(format4, '"'));
          }
          return data;
        }
        function _rotationMatrix3x3(theta, v, format4) {
          var normV = norm(v);
          if (normV === 0) {
            throw new RangeError("Rotation around zero vector");
          }
          var Big = (0, _is.isBigNumber)(theta) ? BigNumber2 : null;
          var one = Big ? new Big(1) : 1;
          var minusOne = Big ? new Big(-1) : -1;
          var vx = Big ? new Big(v.get([0]) / normV) : v.get([0]) / normV;
          var vy = Big ? new Big(v.get([1]) / normV) : v.get([1]) / normV;
          var vz = Big ? new Big(v.get([2]) / normV) : v.get([2]) / normV;
          var c = cos2(theta);
          var oneMinusC = addScalar2(one, unaryMinus(c));
          var s = sin2(theta);
          var r11 = addScalar2(c, _mul([vx, vx, oneMinusC]));
          var r12 = addScalar2(_mul([vx, vy, oneMinusC]), _mul([minusOne, vz, s]));
          var r13 = addScalar2(_mul([vx, vz, oneMinusC]), _mul([vy, s]));
          var r21 = addScalar2(_mul([vx, vy, oneMinusC]), _mul([vz, s]));
          var r22 = addScalar2(c, _mul([vy, vy, oneMinusC]));
          var r23 = addScalar2(_mul([vy, vz, oneMinusC]), _mul([minusOne, vx, s]));
          var r31 = addScalar2(_mul([vx, vz, oneMinusC]), _mul([minusOne, vy, s]));
          var r32 = addScalar2(_mul([vy, vz, oneMinusC]), _mul([vx, s]));
          var r33 = addScalar2(c, _mul([vz, vz, oneMinusC]));
          var data = [[r11, r12, r13], [r21, r22, r23], [r31, r32, r33]];
          return _convertToFormat(data, format4);
        }
      });
    }
  });

  // node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/function/matrix/row.js
  var require_row = __commonJS({
    "node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/function/matrix/row.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.createRow = void 0;
      var _factory = require_factory();
      var _is = require_is();
      var _object = require_object();
      var _array = require_array();
      var name18 = "row";
      var dependencies19 = ["typed", "Index", "matrix", "range"];
      var createRow2 = exports.createRow = /* @__PURE__ */ (0, _factory.factory)(name18, dependencies19, function(_ref) {
        var typed2 = _ref.typed, Index = _ref.Index, matrix2 = _ref.matrix, range = _ref.range;
        return typed2(name18, {
          "Matrix, number": _row,
          "Array, number": function ArrayNumber(value, row) {
            return _row(matrix2((0, _object.clone)(value)), row).valueOf();
          }
        });
        function _row(value, row) {
          if (value.size().length !== 2) {
            throw new Error("Only two dimensional matrix is supported");
          }
          (0, _array.validateIndex)(row, value.size()[0]);
          var columnRange = range(0, value.size()[1]);
          var index = new Index(row, columnRange);
          var result = value.subset(index);
          return (0, _is.isMatrix)(result) ? result : matrix2([[result]]);
        }
      });
    }
  });

  // node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/function/matrix/size.js
  var require_size = __commonJS({
    "node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/function/matrix/size.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.createSize = void 0;
      var _array = require_array();
      var _factory = require_factory();
      var _noop = require_noop();
      var name18 = "size";
      var dependencies19 = ["typed", "config", "?matrix"];
      var createSize2 = exports.createSize = /* @__PURE__ */ (0, _factory.factory)(name18, dependencies19, function(_ref) {
        var typed2 = _ref.typed, config4 = _ref.config, matrix2 = _ref.matrix;
        return typed2(name18, {
          Matrix: function Matrix2(x) {
            return x.create(x.size());
          },
          Array: _array.arraySize,
          string: function string(x) {
            return config4.matrix === "Array" ? [x.length] : matrix2([x.length]);
          },
          "number | Complex | BigNumber | Unit | boolean | null": function numberComplexBigNumberUnitBooleanNull(x) {
            return config4.matrix === "Array" ? [] : matrix2 ? matrix2([]) : (0, _noop.noMatrix)();
          }
        });
      });
    }
  });

  // node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/function/matrix/squeeze.js
  var require_squeeze = __commonJS({
    "node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/function/matrix/squeeze.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.createSqueeze = void 0;
      var _object = require_object();
      var _array = require_array();
      var _factory = require_factory();
      var name18 = "squeeze";
      var dependencies19 = ["typed", "matrix"];
      var createSqueeze2 = exports.createSqueeze = /* @__PURE__ */ (0, _factory.factory)(name18, dependencies19, function(_ref) {
        var typed2 = _ref.typed, matrix2 = _ref.matrix;
        return typed2(name18, {
          Array: function Array2(x) {
            return (0, _array.squeeze)((0, _object.clone)(x));
          },
          Matrix: function Matrix2(x) {
            var res = (0, _array.squeeze)(x.toArray());
            return Array.isArray(res) ? matrix2(res) : res;
          },
          any: function any(x) {
            return (0, _object.clone)(x);
          }
        });
      });
    }
  });

  // node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/function/matrix/subset.js
  var require_subset = __commonJS({
    "node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/function/matrix/subset.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.createSubset = void 0;
      var _is = require_is();
      var _object = require_object();
      var _array = require_array();
      var _customs = require_customs();
      var _DimensionError = require_DimensionError();
      var _factory = require_factory();
      var name18 = "subset";
      var dependencies19 = ["typed", "matrix", "zeros", "add"];
      var createSubset2 = exports.createSubset = /* @__PURE__ */ (0, _factory.factory)(name18, dependencies19, function(_ref) {
        var typed2 = _ref.typed, matrix2 = _ref.matrix, zeros2 = _ref.zeros, add2 = _ref.add;
        return typed2(name18, {
          // get subset
          "Matrix, Index": function MatrixIndex(value, index) {
            if ((0, _array.isEmptyIndex)(index)) {
              return matrix2();
            }
            (0, _array.validateIndexSourceSize)(value, index);
            return value.subset(index);
          },
          "Array, Index": typed2.referTo("Matrix, Index", function(subsetRef) {
            return function(value, index) {
              var subsetResult = subsetRef(matrix2(value), index);
              return index.isScalar() ? subsetResult : subsetResult.valueOf();
            };
          }),
          "Object, Index": _getObjectProperty,
          "string, Index": _getSubstring,
          // set subset
          "Matrix, Index, any, any": function MatrixIndexAnyAny(value, index, replacement, defaultValue) {
            if ((0, _array.isEmptyIndex)(index)) {
              return value;
            }
            (0, _array.validateIndexSourceSize)(value, index);
            return value.clone().subset(index, _broadcastReplacement(replacement, index), defaultValue);
          },
          "Array, Index, any, any": typed2.referTo("Matrix, Index, any, any", function(subsetRef) {
            return function(value, index, replacement, defaultValue) {
              var subsetResult = subsetRef(matrix2(value), index, replacement, defaultValue);
              return subsetResult.isMatrix ? subsetResult.valueOf() : subsetResult;
            };
          }),
          "Array, Index, any": typed2.referTo("Matrix, Index, any, any", function(subsetRef) {
            return function(value, index, replacement) {
              return subsetRef(matrix2(value), index, replacement, void 0).valueOf();
            };
          }),
          "Matrix, Index, any": typed2.referTo("Matrix, Index, any, any", function(subsetRef) {
            return function(value, index, replacement) {
              return subsetRef(value, index, replacement, void 0);
            };
          }),
          "string, Index, string": _setSubstring,
          "string, Index, string, string": _setSubstring,
          "Object, Index, any": _setObjectProperty
        });
        function _broadcastReplacement(replacement, index) {
          if (typeof replacement === "string") {
            throw new Error("can't boradcast a string");
          }
          if (index._isScalar) {
            return replacement;
          }
          var indexSize = index.size();
          if (indexSize.every(function(d) {
            return d > 0;
          })) {
            try {
              return add2(replacement, zeros2(indexSize));
            } catch (error) {
              return replacement;
            }
          } else {
            return replacement;
          }
        }
      });
      function _getSubstring(str, index) {
        if (!(0, _is.isIndex)(index)) {
          throw new TypeError("Index expected");
        }
        if ((0, _array.isEmptyIndex)(index)) {
          return "";
        }
        (0, _array.validateIndexSourceSize)(Array.from(str), index);
        if (index.size().length !== 1) {
          throw new _DimensionError.DimensionError(index.size().length, 1);
        }
        var strLen = str.length;
        (0, _array.validateIndex)(index.min()[0], strLen);
        (0, _array.validateIndex)(index.max()[0], strLen);
        var range = index.dimension(0);
        var substr = "";
        range.forEach(function(v) {
          substr += str.charAt(v);
        });
        return substr;
      }
      function _setSubstring(str, index, replacement, defaultValue) {
        if (!index || index.isIndex !== true) {
          throw new TypeError("Index expected");
        }
        if ((0, _array.isEmptyIndex)(index)) {
          return str;
        }
        (0, _array.validateIndexSourceSize)(Array.from(str), index);
        if (index.size().length !== 1) {
          throw new _DimensionError.DimensionError(index.size().length, 1);
        }
        if (defaultValue !== void 0) {
          if (typeof defaultValue !== "string" || defaultValue.length !== 1) {
            throw new TypeError("Single character expected as defaultValue");
          }
        } else {
          defaultValue = " ";
        }
        var range = index.dimension(0);
        var len = range.size()[0];
        if (len !== replacement.length) {
          throw new _DimensionError.DimensionError(range.size()[0], replacement.length);
        }
        var strLen = str.length;
        (0, _array.validateIndex)(index.min()[0]);
        (0, _array.validateIndex)(index.max()[0]);
        var chars = [];
        for (var i = 0; i < strLen; i++) {
          chars[i] = str.charAt(i);
        }
        range.forEach(function(v, i2) {
          chars[v] = replacement.charAt(i2[0]);
        });
        if (chars.length > strLen) {
          for (var _i = strLen - 1, _len = chars.length; _i < _len; _i++) {
            if (!chars[_i]) {
              chars[_i] = defaultValue;
            }
          }
        }
        return chars.join("");
      }
      function _getObjectProperty(object, index) {
        if ((0, _array.isEmptyIndex)(index)) {
          return void 0;
        }
        if (index.size().length !== 1) {
          throw new _DimensionError.DimensionError(index.size(), 1);
        }
        var key = index.dimension(0);
        if (typeof key !== "string") {
          throw new TypeError("String expected as index to retrieve an object property");
        }
        return (0, _customs.getSafeProperty)(object, key);
      }
      function _setObjectProperty(object, index, replacement) {
        if ((0, _array.isEmptyIndex)(index)) {
          return object;
        }
        if (index.size().length !== 1) {
          throw new _DimensionError.DimensionError(index.size(), 1);
        }
        var key = index.dimension(0);
        if (typeof key !== "string") {
          throw new TypeError("String expected as index to retrieve an object property");
        }
        var updated = (0, _object.clone)(object);
        (0, _customs.setSafeProperty)(updated, key, replacement);
        return updated;
      }
    }
  });

  // node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/function/matrix/transpose.js
  var require_transpose = __commonJS({
    "node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/function/matrix/transpose.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.createTranspose = void 0;
      var _object = require_object();
      var _string = require_string();
      var _factory = require_factory();
      var name18 = "transpose";
      var dependencies19 = ["typed", "matrix"];
      var createTranspose2 = exports.createTranspose = /* @__PURE__ */ (0, _factory.factory)(name18, dependencies19, function(_ref) {
        var typed2 = _ref.typed, matrix2 = _ref.matrix;
        return typed2(name18, {
          Array: function Array2(x) {
            return transposeMatrix(matrix2(x)).valueOf();
          },
          Matrix: transposeMatrix,
          any: _object.clone
          // scalars
        });
        function transposeMatrix(x) {
          var size2 = x.size();
          var c;
          switch (size2.length) {
            case 1:
              c = x.clone();
              break;
            case 2:
              {
                var rows = size2[0];
                var columns = size2[1];
                if (columns === 0) {
                  throw new RangeError("Cannot transpose a 2D matrix with no columns (size: " + (0, _string.format)(size2) + ")");
                }
                switch (x.storage()) {
                  case "dense":
                    c = _denseTranspose(x, rows, columns);
                    break;
                  case "sparse":
                    c = _sparseTranspose(x, rows, columns);
                    break;
                }
              }
              break;
            default:
              throw new RangeError("Matrix must be a vector or two dimensional (size: " + (0, _string.format)(size2) + ")");
          }
          return c;
        }
        function _denseTranspose(m, rows, columns) {
          var data = m._data;
          var transposed = [];
          var transposedRow;
          for (var j = 0; j < columns; j++) {
            transposedRow = transposed[j] = [];
            for (var i = 0; i < rows; i++) {
              transposedRow[i] = (0, _object.clone)(data[i][j]);
            }
          }
          return m.createDenseMatrix({
            data: transposed,
            size: [columns, rows],
            datatype: m._datatype
          });
        }
        function _sparseTranspose(m, rows, columns) {
          var values = m._values;
          var index = m._index;
          var ptr = m._ptr;
          var cvalues = values ? [] : void 0;
          var cindex = [];
          var cptr = [];
          var w = [];
          for (var x = 0; x < rows; x++) {
            w[x] = 0;
          }
          var p, l, j;
          for (p = 0, l = index.length; p < l; p++) {
            w[index[p]]++;
          }
          var sum2 = 0;
          for (var i = 0; i < rows; i++) {
            cptr.push(sum2);
            sum2 += w[i];
            w[i] = cptr[i];
          }
          cptr.push(sum2);
          for (j = 0; j < columns; j++) {
            for (var k0 = ptr[j], k1 = ptr[j + 1], k = k0; k < k1; k++) {
              var q = w[index[k]]++;
              cindex[q] = j;
              if (values) {
                cvalues[q] = (0, _object.clone)(values[k]);
              }
            }
          }
          return m.createSparseMatrix({
            values: cvalues,
            index: cindex,
            ptr: cptr,
            size: [columns, rows],
            datatype: m._datatype
          });
        }
      });
    }
  });

  // node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/function/matrix/ctranspose.js
  var require_ctranspose = __commonJS({
    "node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/function/matrix/ctranspose.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.createCtranspose = void 0;
      var _factory = require_factory();
      var name18 = "ctranspose";
      var dependencies19 = ["typed", "transpose", "conj"];
      var createCtranspose2 = exports.createCtranspose = /* @__PURE__ */ (0, _factory.factory)(name18, dependencies19, function(_ref) {
        var typed2 = _ref.typed, transpose = _ref.transpose, conj2 = _ref.conj;
        return typed2(name18, {
          any: function any(x) {
            return conj2(transpose(x));
          }
        });
      });
    }
  });

  // node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/function/matrix/zeros.js
  var require_zeros = __commonJS({
    "node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/function/matrix/zeros.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.createZeros = void 0;
      var _is = require_is();
      var _number = require_number();
      var _array = require_array();
      var _factory = require_factory();
      var name18 = "zeros";
      var dependencies19 = ["typed", "config", "matrix", "BigNumber"];
      var createZeros2 = exports.createZeros = /* @__PURE__ */ (0, _factory.factory)(name18, dependencies19, function(_ref) {
        var typed2 = _ref.typed, config4 = _ref.config, matrix2 = _ref.matrix, BigNumber2 = _ref.BigNumber;
        return typed2(name18, {
          "": function _() {
            return config4.matrix === "Array" ? _zeros([]) : _zeros([], "default");
          },
          // math.zeros(m, n, p, ..., format)
          // TODO: more accurate signature '...number | BigNumber, string' as soon as typed-function supports this
          "...number | BigNumber | string": function numberBigNumberString(size2) {
            var last = size2[size2.length - 1];
            if (typeof last === "string") {
              var format4 = size2.pop();
              return _zeros(size2, format4);
            } else if (config4.matrix === "Array") {
              return _zeros(size2);
            } else {
              return _zeros(size2, "default");
            }
          },
          Array: _zeros,
          Matrix: function Matrix2(size2) {
            var format4 = size2.storage();
            return _zeros(size2.valueOf(), format4);
          },
          "Array | Matrix, string": function ArrayMatrixString(size2, format4) {
            return _zeros(size2.valueOf(), format4);
          }
        });
        function _zeros(size2, format4) {
          var hasBigNumbers = _normalize(size2);
          var defaultValue = hasBigNumbers ? new BigNumber2(0) : 0;
          _validate2(size2);
          if (format4) {
            var m = matrix2(format4);
            if (size2.length > 0) {
              return m.resize(size2, defaultValue);
            }
            return m;
          } else {
            var arr = [];
            if (size2.length > 0) {
              return (0, _array.resize)(arr, size2, defaultValue);
            }
            return arr;
          }
        }
        function _normalize(size2) {
          var hasBigNumbers = false;
          size2.forEach(function(value, index, arr) {
            if ((0, _is.isBigNumber)(value)) {
              hasBigNumbers = true;
              arr[index] = value.toNumber();
            }
          });
          return hasBigNumbers;
        }
        function _validate2(size2) {
          size2.forEach(function(value) {
            if (typeof value !== "number" || !(0, _number.isInteger)(value) || value < 0) {
              throw new Error("Parameters in function zeros must be positive integers");
            }
          });
        }
      });
    }
  });

  // node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/function/matrix/fft.js
  var require_fft = __commonJS({
    "node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/function/matrix/fft.js"(exports) {
      "use strict";
      var _interopRequireDefault = require_interopRequireDefault();
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.createFft = void 0;
      var _toConsumableArray2 = _interopRequireDefault(require_toConsumableArray());
      var _array = require_array();
      var _factory = require_factory();
      var name18 = "fft";
      var dependencies19 = ["typed", "matrix", "addScalar", "multiplyScalar", "divideScalar", "exp", "tau", "i", "dotDivide", "conj", "pow", "ceil", "log2"];
      var createFft2 = exports.createFft = /* @__PURE__ */ (0, _factory.factory)(name18, dependencies19, function(_ref) {
        var typed2 = _ref.typed, matrix2 = _ref.matrix, addScalar2 = _ref.addScalar, multiplyScalar2 = _ref.multiplyScalar, divideScalar = _ref.divideScalar, exp2 = _ref.exp, tau = _ref.tau, I = _ref.i, dotDivide = _ref.dotDivide, conj2 = _ref.conj, pow2 = _ref.pow, ceil2 = _ref.ceil, log24 = _ref.log2;
        return typed2(name18, {
          Array: _ndFft,
          Matrix: function Matrix2(matrix3) {
            return matrix3.create(_ndFft(matrix3.toArray()));
          }
        });
        function _ndFft(arr) {
          var size2 = (0, _array.arraySize)(arr);
          if (size2.length === 1) return _fft(arr, size2[0]);
          return _1dFft(arr.map(function(slice) {
            return _ndFft(slice, size2.slice(1));
          }), 0);
        }
        function _1dFft(arr, dim) {
          var size2 = (0, _array.arraySize)(arr);
          if (dim !== 0) return new Array(size2[0]).fill(0).map(function(_, i) {
            return _1dFft(arr[i], dim - 1);
          });
          if (size2.length === 1) return _fft(arr);
          function _transpose(arr2) {
            var size3 = (0, _array.arraySize)(arr2);
            return new Array(size3[1]).fill(0).map(function(_, j) {
              return new Array(size3[0]).fill(0).map(function(_2, i) {
                return arr2[i][j];
              });
            });
          }
          return _transpose(_1dFft(_transpose(arr), 1));
        }
        function _czt(arr) {
          var n = arr.length;
          var w = exp2(divideScalar(multiplyScalar2(-1, multiplyScalar2(I, tau)), n));
          var chirp = [];
          for (var i = 1 - n; i < n; i++) {
            chirp.push(pow2(w, divideScalar(pow2(i, 2), 2)));
          }
          var N2 = pow2(2, ceil2(log24(n + n - 1)));
          var xp = [].concat((0, _toConsumableArray2["default"])(new Array(n).fill(0).map(function(_, i2) {
            return multiplyScalar2(arr[i2], chirp[n - 1 + i2]);
          })), (0, _toConsumableArray2["default"])(new Array(N2 - n).fill(0)));
          var ichirp = [].concat((0, _toConsumableArray2["default"])(new Array(n + n - 1).fill(0).map(function(_, i2) {
            return divideScalar(1, chirp[i2]);
          })), (0, _toConsumableArray2["default"])(new Array(N2 - (n + n - 1)).fill(0)));
          var fftXp = _fft(xp);
          var fftIchirp = _fft(ichirp);
          var fftProduct = new Array(N2).fill(0).map(function(_, i2) {
            return multiplyScalar2(fftXp[i2], fftIchirp[i2]);
          });
          var ifftProduct = dotDivide(conj2(_ndFft(conj2(fftProduct))), N2);
          var ret = [];
          for (var _i = n - 1; _i < n + n - 1; _i++) {
            ret.push(multiplyScalar2(ifftProduct[_i], chirp[_i]));
          }
          return ret;
        }
        function _fft(arr) {
          var len = arr.length;
          if (len === 1) return [arr[0]];
          if (len % 2 === 0) {
            var ret = [].concat((0, _toConsumableArray2["default"])(_fft(arr.filter(function(_, i) {
              return i % 2 === 0;
            }), len / 2)), (0, _toConsumableArray2["default"])(_fft(arr.filter(function(_, i) {
              return i % 2 === 1;
            }), len / 2)));
            for (var k = 0; k < len / 2; k++) {
              var p = ret[k];
              var q = multiplyScalar2(ret[k + len / 2], exp2(multiplyScalar2(multiplyScalar2(tau, I), divideScalar(-k, len))));
              ret[k] = addScalar2(p, q);
              ret[k + len / 2] = addScalar2(p, multiplyScalar2(-1, q));
            }
            return ret;
          } else {
            return _czt(arr);
          }
        }
      });
    }
  });

  // node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/function/matrix/ifft.js
  var require_ifft = __commonJS({
    "node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/function/matrix/ifft.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.createIfft = void 0;
      var _array = require_array();
      var _factory = require_factory();
      var _is = require_is();
      var name18 = "ifft";
      var dependencies19 = ["typed", "fft", "dotDivide", "conj"];
      var createIfft2 = exports.createIfft = /* @__PURE__ */ (0, _factory.factory)(name18, dependencies19, function(_ref) {
        var typed2 = _ref.typed, fft = _ref.fft, dotDivide = _ref.dotDivide, conj2 = _ref.conj;
        return typed2(name18, {
          "Array | Matrix": function ArrayMatrix(arr) {
            var size2 = (0, _is.isMatrix)(arr) ? arr.size() : (0, _array.arraySize)(arr);
            return dotDivide(conj2(fft(conj2(arr))), size2.reduce(function(acc, curr) {
              return acc * curr;
            }, 1));
          }
        });
      });
    }
  });

  // node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/function/numeric/solveODE.js
  var require_solveODE = __commonJS({
    "node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/function/numeric/solveODE.js"(exports) {
      "use strict";
      var _interopRequireDefault = require_interopRequireDefault();
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.createSolveODE = void 0;
      var _defineProperty2 = _interopRequireDefault(require_defineProperty());
      var _slicedToArray2 = _interopRequireDefault(require_slicedToArray());
      var _toConsumableArray2 = _interopRequireDefault(require_toConsumableArray());
      var _is = require_is();
      var _factory = require_factory();
      function ownKeys(e, r) {
        var t = Object.keys(e);
        if (Object.getOwnPropertySymbols) {
          var o = Object.getOwnPropertySymbols(e);
          r && (o = o.filter(function(r2) {
            return Object.getOwnPropertyDescriptor(e, r2).enumerable;
          })), t.push.apply(t, o);
        }
        return t;
      }
      function _objectSpread(e) {
        for (var r = 1; r < arguments.length; r++) {
          var t = null != arguments[r] ? arguments[r] : {};
          r % 2 ? ownKeys(Object(t), true).forEach(function(r2) {
            (0, _defineProperty2["default"])(e, r2, t[r2]);
          }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function(r2) {
            Object.defineProperty(e, r2, Object.getOwnPropertyDescriptor(t, r2));
          });
        }
        return e;
      }
      var name18 = "solveODE";
      var dependencies19 = ["typed", "add", "subtract", "multiply", "divide", "max", "map", "abs", "isPositive", "isNegative", "larger", "smaller", "matrix", "bignumber", "unaryMinus"];
      var createSolveODE2 = exports.createSolveODE = /* @__PURE__ */ (0, _factory.factory)(name18, dependencies19, function(_ref) {
        var typed2 = _ref.typed, add2 = _ref.add, subtract = _ref.subtract, multiply2 = _ref.multiply, divide2 = _ref.divide, max2 = _ref.max, map = _ref.map, abs2 = _ref.abs, isPositive = _ref.isPositive, isNegative = _ref.isNegative, larger = _ref.larger, smaller = _ref.smaller, matrix2 = _ref.matrix, bignumber = _ref.bignumber, unaryMinus = _ref.unaryMinus;
        function _rk(butcherTableau) {
          return function(f, tspan, y0, options) {
            var wrongTSpan = !(tspan.length === 2 && (tspan.every(isNumOrBig) || tspan.every(_is.isUnit)));
            if (wrongTSpan) {
              throw new Error('"tspan" must be an Array of two numeric values or two units [tStart, tEnd]');
            }
            var t0 = tspan[0];
            var tf = tspan[1];
            var isForwards = larger(tf, t0);
            var firstStep = options.firstStep;
            if (firstStep !== void 0 && !isPositive(firstStep)) {
              throw new Error('"firstStep" must be positive');
            }
            var maxStep = options.maxStep;
            if (maxStep !== void 0 && !isPositive(maxStep)) {
              throw new Error('"maxStep" must be positive');
            }
            var minStep = options.minStep;
            if (minStep && isNegative(minStep)) {
              throw new Error('"minStep" must be positive or zero');
            }
            var timeVars = [t0, tf, firstStep, minStep, maxStep].filter(function(x) {
              return x !== void 0;
            });
            if (!(timeVars.every(isNumOrBig) || timeVars.every(_is.isUnit))) {
              throw new Error('Inconsistent type of "t" dependant variables');
            }
            var steps = 1;
            var tol = options.tol ? options.tol : 1e-4;
            var minDelta = options.minDelta ? options.minDelta : 0.2;
            var maxDelta = options.maxDelta ? options.maxDelta : 5;
            var maxIter = options.maxIter ? options.maxIter : 1e4;
            var hasBigNumbers = [t0, tf].concat((0, _toConsumableArray2["default"])(y0), [maxStep, minStep]).some(_is.isBigNumber);
            var _ref2 = hasBigNumbers ? [bignumber(butcherTableau.a), bignumber(butcherTableau.c), bignumber(butcherTableau.b), bignumber(butcherTableau.bp)] : [butcherTableau.a, butcherTableau.c, butcherTableau.b, butcherTableau.bp], _ref3 = (0, _slicedToArray2["default"])(_ref2, 4), a = _ref3[0], c = _ref3[1], b = _ref3[2], bp = _ref3[3];
            var h = firstStep ? isForwards ? firstStep : unaryMinus(firstStep) : divide2(subtract(tf, t0), steps);
            var t = [t0];
            var y = [y0];
            var deltaB = subtract(b, bp);
            var n = 0;
            var iter = 0;
            var ongoing = _createOngoing(isForwards);
            var trimStep = _createTrimStep(isForwards);
            while (ongoing(t[n], tf)) {
              var k = [];
              h = trimStep(t[n], tf, h);
              k.push(f(t[n], y[n]));
              for (var i = 1; i < c.length; ++i) {
                k.push(f(add2(t[n], multiply2(c[i], h)), add2(y[n], multiply2(h, a[i], k))));
              }
              var TE = max2(abs2(map(multiply2(deltaB, k), function(X) {
                return (0, _is.isUnit)(X) ? X.value : X;
              })));
              if (TE < tol && tol / TE > 1 / 4) {
                t.push(add2(t[n], h));
                y.push(add2(y[n], multiply2(h, b, k)));
                n++;
              }
              var delta = 0.84 * Math.pow(tol / TE, 1 / 5);
              if (smaller(delta, minDelta)) {
                delta = minDelta;
              } else if (larger(delta, maxDelta)) {
                delta = maxDelta;
              }
              delta = hasBigNumbers ? bignumber(delta) : delta;
              h = multiply2(h, delta);
              if (maxStep && larger(abs2(h), maxStep)) {
                h = isForwards ? maxStep : unaryMinus(maxStep);
              } else if (minStep && smaller(abs2(h), minStep)) {
                h = isForwards ? minStep : unaryMinus(minStep);
              }
              iter++;
              if (iter > maxIter) {
                throw new Error("Maximum number of iterations reached, try changing options");
              }
            }
            return {
              t,
              y
            };
          };
        }
        function _rk23(f, tspan, y0, options) {
          var a = [[], [1 / 2], [0, 3 / 4], [2 / 9, 1 / 3, 4 / 9]];
          var c = [null, 1 / 2, 3 / 4, 1];
          var b = [2 / 9, 1 / 3, 4 / 9, 0];
          var bp = [7 / 24, 1 / 4, 1 / 3, 1 / 8];
          var butcherTableau = {
            a,
            c,
            b,
            bp
          };
          return _rk(butcherTableau)(f, tspan, y0, options);
        }
        function _rk45(f, tspan, y0, options) {
          var a = [[], [1 / 5], [3 / 40, 9 / 40], [44 / 45, -56 / 15, 32 / 9], [19372 / 6561, -25360 / 2187, 64448 / 6561, -212 / 729], [9017 / 3168, -355 / 33, 46732 / 5247, 49 / 176, -5103 / 18656], [35 / 384, 0, 500 / 1113, 125 / 192, -2187 / 6784, 11 / 84]];
          var c = [null, 1 / 5, 3 / 10, 4 / 5, 8 / 9, 1, 1];
          var b = [35 / 384, 0, 500 / 1113, 125 / 192, -2187 / 6784, 11 / 84, 0];
          var bp = [5179 / 57600, 0, 7571 / 16695, 393 / 640, -92097 / 339200, 187 / 2100, 1 / 40];
          var butcherTableau = {
            a,
            c,
            b,
            bp
          };
          return _rk(butcherTableau)(f, tspan, y0, options);
        }
        function _solveODE(f, tspan, y0, opt) {
          var method = opt.method ? opt.method : "RK45";
          var methods = {
            RK23: _rk23,
            RK45: _rk45
          };
          if (method.toUpperCase() in methods) {
            var methodOptions = _objectSpread({}, opt);
            delete methodOptions.method;
            return methods[method.toUpperCase()](f, tspan, y0, methodOptions);
          } else {
            var methodsWithQuotes = Object.keys(methods).map(function(x) {
              return '"'.concat(x, '"');
            });
            var availableMethodsString = "".concat(methodsWithQuotes.slice(0, -1).join(", "), " and ").concat(methodsWithQuotes.slice(-1));
            throw new Error('Unavailable method "'.concat(method, '". Available methods are ').concat(availableMethodsString));
          }
        }
        function _createOngoing(isForwards) {
          return isForwards ? smaller : larger;
        }
        function _createTrimStep(isForwards) {
          var outOfBounds = isForwards ? larger : smaller;
          return function(t, tf, h) {
            var next = add2(t, h);
            return outOfBounds(next, tf) ? subtract(tf, t) : h;
          };
        }
        function isNumOrBig(x) {
          return (0, _is.isBigNumber)(x) || (0, _is.isNumber)(x);
        }
        function _matrixSolveODE(f, T, y0, options) {
          var sol = _solveODE(f, T.toArray(), y0.toArray(), options);
          return {
            t: matrix2(sol.t),
            y: matrix2(sol.y)
          };
        }
        return typed2("solveODE", {
          "function, Array, Array, Object": _solveODE,
          "function, Matrix, Matrix, Object": _matrixSolveODE,
          "function, Array, Array": function functionArrayArray(f, T, y0) {
            return _solveODE(f, T, y0, {});
          },
          "function, Matrix, Matrix": function functionMatrixMatrix(f, T, y0) {
            return _matrixSolveODE(f, T, y0, {});
          },
          "function, Array, number | BigNumber | Unit": function functionArrayNumberBigNumberUnit(f, T, y0) {
            var sol = _solveODE(f, T, [y0], {});
            return {
              t: sol.t,
              y: sol.y.map(function(Y) {
                return Y[0];
              })
            };
          },
          "function, Matrix, number | BigNumber | Unit": function functionMatrixNumberBigNumberUnit(f, T, y0) {
            var sol = _solveODE(f, T.toArray(), [y0], {});
            return {
              t: matrix2(sol.t),
              y: matrix2(sol.y.map(function(Y) {
                return Y[0];
              }))
            };
          },
          "function, Array, number | BigNumber | Unit, Object": function functionArrayNumberBigNumberUnitObject(f, T, y0, options) {
            var sol = _solveODE(f, T, [y0], options);
            return {
              t: sol.t,
              y: sol.y.map(function(Y) {
                return Y[0];
              })
            };
          },
          "function, Matrix, number | BigNumber | Unit, Object": function functionMatrixNumberBigNumberUnitObject(f, T, y0, options) {
            var sol = _solveODE(f, T.toArray(), [y0], options);
            return {
              t: matrix2(sol.t),
              y: matrix2(sol.y.map(function(Y) {
                return Y[0];
              }))
            };
          }
        });
      });
    }
  });

  // node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/function/special/erf.js
  var require_erf = __commonJS({
    "node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/function/special/erf.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.createErf = void 0;
      var _collection = require_collection();
      var _number = require_number();
      var _factory = require_factory();
      var name18 = "erf";
      var dependencies19 = ["typed"];
      var createErf2 = exports.createErf = /* @__PURE__ */ (0, _factory.factory)(name18, dependencies19, function(_ref) {
        var typed2 = _ref.typed;
        return typed2("name", {
          number: function number(x) {
            var y = Math.abs(x);
            if (y >= MAX_NUM) {
              return (0, _number.sign)(x);
            }
            if (y <= THRESH) {
              return (0, _number.sign)(x) * erf1(y);
            }
            if (y <= 4) {
              return (0, _number.sign)(x) * (1 - erfc2(y));
            }
            return (0, _number.sign)(x) * (1 - erfc3(y));
          },
          "Array | Matrix": typed2.referToSelf(function(self2) {
            return function(n) {
              return (0, _collection.deepMap)(n, self2);
            };
          })
          // TODO: For complex numbers, use the approximation for the Faddeeva function
          //  from "More Efficient Computation of the Complex Error Function" (AMS)
        });
        function erf1(y) {
          var ysq = y * y;
          var xnum = P3[0][4] * ysq;
          var xden = ysq;
          var i;
          for (i = 0; i < 3; i += 1) {
            xnum = (xnum + P3[0][i]) * ysq;
            xden = (xden + Q[0][i]) * ysq;
          }
          return y * (xnum + P3[0][3]) / (xden + Q[0][3]);
        }
        function erfc2(y) {
          var xnum = P3[1][8] * y;
          var xden = y;
          var i;
          for (i = 0; i < 7; i += 1) {
            xnum = (xnum + P3[1][i]) * y;
            xden = (xden + Q[1][i]) * y;
          }
          var result = (xnum + P3[1][7]) / (xden + Q[1][7]);
          var ysq = parseInt(y * 16) / 16;
          var del = (y - ysq) * (y + ysq);
          return Math.exp(-ysq * ysq) * Math.exp(-del) * result;
        }
        function erfc3(y) {
          var ysq = 1 / (y * y);
          var xnum = P3[2][5] * ysq;
          var xden = ysq;
          var i;
          for (i = 0; i < 4; i += 1) {
            xnum = (xnum + P3[2][i]) * ysq;
            xden = (xden + Q[2][i]) * ysq;
          }
          var result = ysq * (xnum + P3[2][4]) / (xden + Q[2][4]);
          result = (SQRPI - result) / y;
          ysq = parseInt(y * 16) / 16;
          var del = (y - ysq) * (y + ysq);
          return Math.exp(-ysq * ysq) * Math.exp(-del) * result;
        }
      });
      var THRESH = 0.46875;
      var SQRPI = 0.5641895835477563;
      var P3 = [[3.1611237438705655, 113.86415415105016, 377.485237685302, 3209.3775891384694, 0.18577770618460315], [0.5641884969886701, 8.883149794388377, 66.11919063714163, 298.6351381974001, 881.952221241769, 1712.0476126340707, 2051.0783778260716, 1230.3393547979972, 21531153547440383e-24], [0.30532663496123236, 0.36034489994980445, 0.12578172611122926, 0.016083785148742275, 6587491615298378e-19, 0.016315387137302097]];
      var Q = [[23.601290952344122, 244.02463793444417, 1282.6165260773723, 2844.236833439171], [15.744926110709835, 117.6939508913125, 537.1811018620099, 1621.3895745666903, 3290.7992357334597, 4362.619090143247, 3439.3676741437216, 1230.3393548037495], [2.568520192289822, 1.8729528499234604, 0.5279051029514285, 0.06051834131244132, 0.0023352049762686918]];
      var MAX_NUM = Math.pow(2, 53);
    }
  });

  // node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/function/special/zeta.js
  var require_zeta = __commonJS({
    "node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/function/special/zeta.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.createZeta = void 0;
      var _factory = require_factory();
      var name18 = "zeta";
      var dependencies19 = ["typed", "config", "multiply", "pow", "divide", "factorial", "equal", "smallerEq", "isNegative", "gamma", "sin", "subtract", "add", "?Complex", "?BigNumber", "pi"];
      var createZeta2 = exports.createZeta = /* @__PURE__ */ (0, _factory.factory)(name18, dependencies19, function(_ref) {
        var typed2 = _ref.typed, config4 = _ref.config, multiply2 = _ref.multiply, pow2 = _ref.pow, divide2 = _ref.divide, factorial = _ref.factorial, equal = _ref.equal, smallerEq = _ref.smallerEq, isNegative = _ref.isNegative, gamma = _ref.gamma, sin2 = _ref.sin, subtract = _ref.subtract, add2 = _ref.add, Complex3 = _ref.Complex, _BigNumber = _ref.BigNumber, pi = _ref.pi;
        return typed2(name18, {
          number: function number(s) {
            return zetaNumeric(s, function(value) {
              return value;
            }, function() {
              return 20;
            });
          },
          BigNumber: function BigNumber2(s) {
            return zetaNumeric(s, function(value) {
              return new _BigNumber(value);
            }, function() {
              return Math.abs(Math.log10(config4.epsilon));
            });
          },
          Complex: zetaComplex
        });
        function zetaNumeric(s, createValue, determineDigits) {
          if (equal(s, 0)) {
            return createValue(-0.5);
          }
          if (equal(s, 1)) {
            return createValue(NaN);
          }
          if (!isFinite(s)) {
            return isNegative(s) ? createValue(NaN) : createValue(1);
          }
          return zeta(s, createValue, determineDigits, function(s2) {
            return s2;
          });
        }
        function zetaComplex(s) {
          if (s.re === 0 && s.im === 0) {
            return new Complex3(-0.5);
          }
          if (s.re === 1) {
            return new Complex3(NaN, NaN);
          }
          if (s.re === Infinity && s.im === 0) {
            return new Complex3(1);
          }
          if (s.im === Infinity || s.re === -Infinity) {
            return new Complex3(NaN, NaN);
          }
          return zeta(s, function(value) {
            return value;
          }, function(s2) {
            return Math.round(1.3 * 15 + 0.9 * Math.abs(s2.im));
          }, function(s2) {
            return s2.re;
          });
        }
        function zeta(s, createValue, determineDigits, getRe) {
          var n = determineDigits(s);
          if (getRe(s) > -(n - 1) / 2) {
            return f(s, createValue(n), createValue);
          } else {
            var c = multiply2(pow2(2, s), pow2(createValue(pi), subtract(s, 1)));
            c = multiply2(c, sin2(multiply2(divide2(createValue(pi), 2), s)));
            c = multiply2(c, gamma(subtract(1, s)));
            return multiply2(c, zeta(subtract(1, s), createValue, determineDigits, getRe));
          }
        }
        function d(k, n) {
          var S = k;
          for (var j = k; smallerEq(j, n); j = add2(j, 1)) {
            var factor = divide2(multiply2(factorial(add2(n, subtract(j, 1))), pow2(4, j)), multiply2(factorial(subtract(n, j)), factorial(multiply2(2, j))));
            S = add2(S, factor);
          }
          return multiply2(n, S);
        }
        function f(s, n, createValue) {
          var c = divide2(1, multiply2(d(createValue(0), n), subtract(1, pow2(2, subtract(1, s)))));
          var S = createValue(0);
          for (var k = createValue(1); smallerEq(k, n); k = add2(k, 1)) {
            S = add2(S, divide2(multiply2(Math.pow(-1, k - 1), d(k, n)), pow2(k, s)));
          }
          return multiply2(c, S);
        }
      });
    }
  });

  // node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/function/statistics/mode.js
  var require_mode = __commonJS({
    "node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/function/statistics/mode.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.createMode = void 0;
      var _array = require_array();
      var _factory = require_factory();
      var name18 = "mode";
      var dependencies19 = ["typed", "isNaN", "isNumeric"];
      var createMode2 = exports.createMode = /* @__PURE__ */ (0, _factory.factory)(name18, dependencies19, function(_ref) {
        var typed2 = _ref.typed, isNaN2 = _ref.isNaN, isNumeric = _ref.isNumeric;
        return typed2(name18, {
          "Array | Matrix": _mode,
          "...": function _(args) {
            return _mode(args);
          }
        });
        function _mode(values) {
          values = (0, _array.flatten)(values.valueOf());
          var num = values.length;
          if (num === 0) {
            throw new Error("Cannot calculate mode of an empty array");
          }
          var count = {};
          var mode = [];
          var max2 = 0;
          for (var i = 0; i < values.length; i++) {
            var value = values[i];
            if (isNumeric(value) && isNaN2(value)) {
              throw new Error("Cannot calculate mode of an array containing NaN values");
            }
            if (!(value in count)) {
              count[value] = 0;
            }
            count[value]++;
            if (count[value] === max2) {
              mode.push(value);
            } else if (count[value] > max2) {
              max2 = count[value];
              mode = [value];
            }
          }
          return mode;
        }
      });
    }
  });

  // node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/function/statistics/utils/improveErrorMessage.js
  var require_improveErrorMessage = __commonJS({
    "node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/function/statistics/utils/improveErrorMessage.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.improveErrorMessage = improveErrorMessage;
      var _is = require_is();
      function improveErrorMessage(err, fnName, value) {
        var details;
        if (String(err).includes("Unexpected type")) {
          details = arguments.length > 2 ? " (type: " + (0, _is.typeOf)(value) + ", value: " + JSON.stringify(value) + ")" : " (type: " + err.data.actual + ")";
          return new TypeError("Cannot calculate " + fnName + ", unexpected type of argument" + details);
        }
        if (String(err).includes("complex numbers")) {
          details = arguments.length > 2 ? " (type: " + (0, _is.typeOf)(value) + ", value: " + JSON.stringify(value) + ")" : "";
          return new TypeError("Cannot calculate " + fnName + ", no ordering relation is defined for complex numbers" + details);
        }
        return err;
      }
    }
  });

  // node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/function/statistics/prod.js
  var require_prod = __commonJS({
    "node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/function/statistics/prod.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.createProd = void 0;
      var _collection = require_collection();
      var _factory = require_factory();
      var _improveErrorMessage = require_improveErrorMessage();
      var name18 = "prod";
      var dependencies19 = ["typed", "config", "multiplyScalar", "numeric"];
      var createProd2 = exports.createProd = /* @__PURE__ */ (0, _factory.factory)(name18, dependencies19, function(_ref) {
        var typed2 = _ref.typed, config4 = _ref.config, multiplyScalar2 = _ref.multiplyScalar, numeric = _ref.numeric;
        return typed2(name18, {
          // prod([a, b, c, d, ...])
          "Array | Matrix": _prod,
          // prod([a, b, c, d, ...], dim)
          "Array | Matrix, number | BigNumber": function ArrayMatrixNumberBigNumber(array, dim) {
            throw new Error("prod(A, dim) is not yet supported");
          },
          // prod(a, b, c, d, ...)
          "...": function _(args) {
            return _prod(args);
          }
        });
        function _prod(array) {
          var prod;
          (0, _collection.deepForEach)(array, function(value) {
            try {
              prod = prod === void 0 ? value : multiplyScalar2(prod, value);
            } catch (err) {
              throw (0, _improveErrorMessage.improveErrorMessage)(err, "prod", value);
            }
          });
          if (typeof prod === "string") {
            prod = numeric(prod, config4.number);
          }
          if (prod === void 0) {
            throw new Error("Cannot calculate prod of an empty array");
          }
          return prod;
        }
      });
    }
  });

  // node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/function/string/format.js
  var require_format = __commonJS({
    "node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/function/string/format.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.createFormat = void 0;
      var _string = require_string();
      var _factory = require_factory();
      var name18 = "format";
      var dependencies19 = ["typed"];
      var createFormat2 = exports.createFormat = /* @__PURE__ */ (0, _factory.factory)(name18, dependencies19, function(_ref) {
        var typed2 = _ref.typed;
        return typed2(name18, {
          any: _string.format,
          "any, Object | function | number | BigNumber": _string.format
        });
      });
    }
  });

  // node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/function/string/bin.js
  var require_bin = __commonJS({
    "node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/function/string/bin.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.createBin = void 0;
      var _factory = require_factory();
      var name18 = "bin";
      var dependencies19 = ["typed", "format"];
      var createBin2 = exports.createBin = (0, _factory.factory)(name18, dependencies19, function(_ref) {
        var typed2 = _ref.typed, format4 = _ref.format;
        return typed2(name18, {
          "number | BigNumber": function numberBigNumber(n) {
            return format4(n, {
              notation: "bin"
            });
          },
          "number | BigNumber, number | BigNumber": function numberBigNumberNumberBigNumber(n, wordSize) {
            return format4(n, {
              notation: "bin",
              wordSize
            });
          }
        });
      });
    }
  });

  // node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/function/string/oct.js
  var require_oct = __commonJS({
    "node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/function/string/oct.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.createOct = void 0;
      var _factory = require_factory();
      var name18 = "oct";
      var dependencies19 = ["typed", "format"];
      var createOct2 = exports.createOct = (0, _factory.factory)(name18, dependencies19, function(_ref) {
        var typed2 = _ref.typed, format4 = _ref.format;
        return typed2(name18, {
          "number | BigNumber": function numberBigNumber(n) {
            return format4(n, {
              notation: "oct"
            });
          },
          "number | BigNumber, number | BigNumber": function numberBigNumberNumberBigNumber(n, wordSize) {
            return format4(n, {
              notation: "oct",
              wordSize
            });
          }
        });
      });
    }
  });

  // node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/function/string/hex.js
  var require_hex = __commonJS({
    "node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/function/string/hex.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.createHex = void 0;
      var _factory = require_factory();
      var name18 = "hex";
      var dependencies19 = ["typed", "format"];
      var createHex2 = exports.createHex = (0, _factory.factory)(name18, dependencies19, function(_ref) {
        var typed2 = _ref.typed, format4 = _ref.format;
        return typed2(name18, {
          "number | BigNumber": function numberBigNumber(n) {
            return format4(n, {
              notation: "hex"
            });
          },
          "number | BigNumber, number | BigNumber": function numberBigNumberNumberBigNumber(n, wordSize) {
            return format4(n, {
              notation: "hex",
              wordSize
            });
          }
        });
      });
    }
  });

  // node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/utils/print.js
  var require_print = __commonJS({
    "node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/utils/print.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.printTemplate = void 0;
      var printTemplate = exports.printTemplate = /\$([\w.]+)/g;
    }
  });

  // node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/function/string/print.js
  var require_print2 = __commonJS({
    "node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/function/string/print.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.createPrint = void 0;
      var _string = require_string();
      var _is = require_is();
      var _factory = require_factory();
      var _print2 = require_print();
      var name18 = "print";
      var dependencies19 = ["typed"];
      var createPrint2 = exports.createPrint = /* @__PURE__ */ (0, _factory.factory)(name18, dependencies19, function(_ref) {
        var typed2 = _ref.typed;
        return typed2(name18, {
          // note: Matrix will be converted automatically to an Array
          "string, Object | Array": _print,
          "string, Object | Array, number | Object": _print
        });
      });
      function _print(template, values, options) {
        return template.replace(_print2.printTemplate, function(original, key) {
          var keys = key.split(".");
          var value = values[keys.shift()];
          if (value !== void 0 && value.isMatrix) {
            value = value.toArray();
          }
          while (keys.length && value !== void 0) {
            var k = keys.shift();
            value = k ? value[k] : value + ".";
          }
          if (value !== void 0) {
            if (!(0, _is.isString)(value)) {
              return (0, _string.format)(value, options);
            } else {
              return value;
            }
          }
          return original;
        });
      }
    }
  });

  // node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/function/unit/to.js
  var require_to = __commonJS({
    "node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/function/unit/to.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.createTo = void 0;
      var _factory = require_factory();
      var _matrixAlgorithmSuite = require_matrixAlgorithmSuite();
      var name18 = "to";
      var dependencies19 = ["typed", "matrix", "concat"];
      var createTo2 = exports.createTo = /* @__PURE__ */ (0, _factory.factory)(name18, dependencies19, function(_ref) {
        var typed2 = _ref.typed, matrix2 = _ref.matrix, concat2 = _ref.concat;
        var matrixAlgorithmSuite = (0, _matrixAlgorithmSuite.createMatrixAlgorithmSuite)({
          typed: typed2,
          matrix: matrix2,
          concat: concat2
        });
        return typed2(name18, {
          "Unit, Unit | string": function UnitUnitString(x, unit) {
            return x.to(unit);
          }
        }, matrixAlgorithmSuite({
          Ds: true
        }));
      });
    }
  });

  // node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/function/utils/isPrime.js
  var require_isPrime = __commonJS({
    "node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/function/utils/isPrime.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.createIsPrime = void 0;
      var _collection = require_collection();
      var _factory = require_factory();
      var name18 = "isPrime";
      var dependencies19 = ["typed"];
      var createIsPrime2 = exports.createIsPrime = /* @__PURE__ */ (0, _factory.factory)(name18, dependencies19, function(_ref) {
        var typed2 = _ref.typed;
        return typed2(name18, {
          number: function number(x) {
            if (x * 0 !== 0) {
              return false;
            }
            if (x <= 3) {
              return x > 1;
            }
            if (x % 2 === 0 || x % 3 === 0) {
              return false;
            }
            for (var i = 5; i * i <= x; i += 6) {
              if (x % i === 0 || x % (i + 2) === 0) {
                return false;
              }
            }
            return true;
          },
          BigNumber: function BigNumber2(n) {
            if (n.toNumber() * 0 !== 0) {
              return false;
            }
            if (n.lte(3)) return n.gt(1);
            if (n.mod(2).eq(0) || n.mod(3).eq(0)) return false;
            if (n.lt(Math.pow(2, 32))) {
              var x = n.toNumber();
              for (var i = 5; i * i <= x; i += 6) {
                if (x % i === 0 || x % (i + 2) === 0) {
                  return false;
                }
              }
              return true;
            }
            function modPow(base, exponent, modulus) {
              var accumulator = 1;
              while (!exponent.eq(0)) {
                if (exponent.mod(2).eq(0)) {
                  exponent = exponent.div(2);
                  base = base.mul(base).mod(modulus);
                } else {
                  exponent = exponent.sub(1);
                  accumulator = base.mul(accumulator).mod(modulus);
                }
              }
              return accumulator;
            }
            var Decimal2 = n.constructor.clone({
              precision: n.toFixed(0).length * 2
            });
            n = new Decimal2(n);
            var r = 0;
            var d = n.sub(1);
            while (d.mod(2).eq(0)) {
              d = d.div(2);
              r += 1;
            }
            var bases = null;
            if (n.lt("3317044064679887385961981")) {
              bases = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41].filter(function(x2) {
                return x2 < n;
              });
            } else {
              var max2 = Math.min(n.toNumber() - 2, Math.floor(2 * Math.pow(n.toFixed(0).length * Math.log(10), 2)));
              bases = [];
              for (var _i = 2; _i <= max2; _i += 1) {
                bases.push(max2);
              }
            }
            for (var _i2 = 0; _i2 < bases.length; _i2 += 1) {
              var a = bases[_i2];
              var adn = modPow(n.sub(n).add(a), d, n);
              if (!adn.eq(1)) {
                for (var _i3 = 0, _x = adn; !_x.eq(n.sub(1)); _i3 += 1, _x = _x.mul(_x).mod(n)) {
                  if (_i3 === r - 1) {
                    return false;
                  }
                }
              }
            }
            return true;
          },
          "Array | Matrix": typed2.referToSelf(function(self2) {
            return function(x) {
              return (0, _collection.deepMap)(x, self2);
            };
          })
        });
      });
    }
  });

  // node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/function/utils/numeric.js
  var require_numeric = __commonJS({
    "node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/function/utils/numeric.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.createNumeric = void 0;
      var _is = require_is();
      var _factory = require_factory();
      var _noop = require_noop();
      var name18 = "numeric";
      var dependencies19 = ["number", "?bignumber", "?fraction"];
      var createNumeric2 = exports.createNumeric = /* @__PURE__ */ (0, _factory.factory)(name18, dependencies19, function(_ref) {
        var _number = _ref.number, bignumber = _ref.bignumber, fraction = _ref.fraction;
        var validInputTypes = {
          string: true,
          number: true,
          BigNumber: true,
          Fraction: true
        };
        var validOutputTypes = {
          number: function number(x) {
            return _number(x);
          },
          BigNumber: bignumber ? function(x) {
            return bignumber(x);
          } : _noop.noBignumber,
          Fraction: fraction ? function(x) {
            return fraction(x);
          } : _noop.noFraction
        };
        return function numeric(value) {
          var outputType = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "number";
          var check = arguments.length > 2 ? arguments[2] : void 0;
          if (check !== void 0) {
            throw new SyntaxError("numeric() takes one or two arguments");
          }
          var inputType = (0, _is.typeOf)(value);
          if (!(inputType in validInputTypes)) {
            throw new TypeError("Cannot convert " + value + ' of type "' + inputType + '"; valid input types are ' + Object.keys(validInputTypes).join(", "));
          }
          if (!(outputType in validOutputTypes)) {
            throw new TypeError("Cannot convert " + value + ' to type "' + outputType + '"; valid output types are ' + Object.keys(validOutputTypes).join(", "));
          }
          if (outputType === inputType) {
            return value;
          } else {
            return validOutputTypes[outputType](value);
          }
        };
      });
    }
  });

  // node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/function/arithmetic/divideScalar.js
  var require_divideScalar = __commonJS({
    "node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/function/arithmetic/divideScalar.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.createDivideScalar = void 0;
      var _factory = require_factory();
      var name18 = "divideScalar";
      var dependencies19 = ["typed", "numeric"];
      var createDivideScalar2 = exports.createDivideScalar = /* @__PURE__ */ (0, _factory.factory)(name18, dependencies19, function(_ref) {
        var typed2 = _ref.typed, numeric = _ref.numeric;
        return typed2(name18, {
          "number, number": function numberNumber(x, y) {
            return x / y;
          },
          "Complex, Complex": function ComplexComplex(x, y) {
            return x.div(y);
          },
          "BigNumber, BigNumber": function BigNumberBigNumber(x, y) {
            return x.div(y);
          },
          "Fraction, Fraction": function FractionFraction(x, y) {
            return x.div(y);
          },
          "Unit, number | Complex | Fraction | BigNumber | Unit": function UnitNumberComplexFractionBigNumberUnit(x, y) {
            return x.divide(y);
          },
          "number | Fraction | Complex | BigNumber, Unit": function numberFractionComplexBigNumberUnit(x, y) {
            return y.divideInto(x);
          }
        });
      });
    }
  });

  // node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/function/arithmetic/pow.js
  var require_pow = __commonJS({
    "node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/function/arithmetic/pow.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.createPow = void 0;
      var _factory = require_factory();
      var _number = require_number();
      var _array = require_array();
      var _index = require_number2();
      var name18 = "pow";
      var dependencies19 = ["typed", "config", "identity", "multiply", "matrix", "inv", "fraction", "number", "Complex"];
      var createPow2 = exports.createPow = /* @__PURE__ */ (0, _factory.factory)(name18, dependencies19, function(_ref) {
        var typed2 = _ref.typed, config4 = _ref.config, identity = _ref.identity, multiply2 = _ref.multiply, matrix2 = _ref.matrix, inv = _ref.inv, number = _ref.number, fraction = _ref.fraction, Complex3 = _ref.Complex;
        return typed2(name18, {
          "number, number": _pow,
          "Complex, Complex": function ComplexComplex(x, y) {
            return x.pow(y);
          },
          "BigNumber, BigNumber": function BigNumberBigNumber(x, y) {
            if (y.isInteger() || x >= 0 || config4.predictable) {
              return x.pow(y);
            } else {
              return new Complex3(x.toNumber(), 0).pow(y.toNumber(), 0);
            }
          },
          "Fraction, Fraction": function FractionFraction(x, y) {
            var result = x.pow(y);
            if (result != null) {
              return result;
            }
            if (config4.predictable) {
              throw new Error("Result of pow is non-rational and cannot be expressed as a fraction");
            } else {
              return _pow(x.valueOf(), y.valueOf());
            }
          },
          "Array, number": _powArray,
          "Array, BigNumber": function ArrayBigNumber(x, y) {
            return _powArray(x, y.toNumber());
          },
          "Matrix, number": _powMatrix,
          "Matrix, BigNumber": function MatrixBigNumber(x, y) {
            return _powMatrix(x, y.toNumber());
          },
          "Unit, number | BigNumber": function UnitNumberBigNumber(x, y) {
            return x.pow(y);
          }
        });
        function _pow(x, y) {
          if (config4.predictable && !(0, _number.isInteger)(y) && x < 0) {
            try {
              var yFrac = fraction(y);
              var yNum = number(yFrac);
              if (y === yNum || Math.abs((y - yNum) / y) < 1e-14) {
                if (yFrac.d % 2 === 1) {
                  return (yFrac.n % 2 === 0 ? 1 : -1) * Math.pow(-x, y);
                }
              }
            } catch (ex) {
            }
          }
          if (config4.predictable && (x < -1 && y === Infinity || x > -1 && x < 0 && y === -Infinity)) {
            return NaN;
          }
          if ((0, _number.isInteger)(y) || x >= 0 || config4.predictable) {
            return (0, _index.powNumber)(x, y);
          } else {
            if (x * x < 1 && y === Infinity || x * x > 1 && y === -Infinity) {
              return 0;
            }
            return new Complex3(x, 0).pow(y, 0);
          }
        }
        function _powArray(x, y) {
          if (!(0, _number.isInteger)(y)) {
            throw new TypeError("For A^b, b must be an integer (value is " + y + ")");
          }
          var s = (0, _array.arraySize)(x);
          if (s.length !== 2) {
            throw new Error("For A^b, A must be 2 dimensional (A has " + s.length + " dimensions)");
          }
          if (s[0] !== s[1]) {
            throw new Error("For A^b, A must be square (size is " + s[0] + "x" + s[1] + ")");
          }
          if (y < 0) {
            try {
              return _powArray(inv(x), -y);
            } catch (error) {
              if (error.message === "Cannot calculate inverse, determinant is zero") {
                throw new TypeError("For A^b, when A is not invertible, b must be a positive integer (value is " + y + ")");
              }
              throw error;
            }
          }
          var res = identity(s[0]).valueOf();
          var px = x;
          while (y >= 1) {
            if ((y & 1) === 1) {
              res = multiply2(px, res);
            }
            y >>= 1;
            px = multiply2(px, px);
          }
          return res;
        }
        function _powMatrix(x, y) {
          return matrix2(_powArray(x.valueOf(), y));
        }
      });
    }
  });

  // node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/function/arithmetic/round.js
  var require_round = __commonJS({
    "node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/function/arithmetic/round.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.createRound = void 0;
      var _factory = require_factory();
      var _collection = require_collection();
      var _number = require_number();
      var _nearlyEqual = require_nearlyEqual();
      var _matAlgo11xS0s = require_matAlgo11xS0s();
      var _matAlgo12xSfs = require_matAlgo12xSfs();
      var _matAlgo14xDs = require_matAlgo14xDs();
      var _index = require_number2();
      var NO_INT = "Number of decimals in function round must be an integer";
      var name18 = "round";
      var dependencies19 = ["typed", "config", "matrix", "equalScalar", "zeros", "BigNumber", "DenseMatrix"];
      var createRound2 = exports.createRound = /* @__PURE__ */ (0, _factory.factory)(name18, dependencies19, function(_ref) {
        var typed2 = _ref.typed, config4 = _ref.config, matrix2 = _ref.matrix, equalScalar2 = _ref.equalScalar, zeros2 = _ref.zeros, _BigNumber = _ref.BigNumber, DenseMatrix2 = _ref.DenseMatrix;
        var matAlgo11xS0s = (0, _matAlgo11xS0s.createMatAlgo11xS0s)({
          typed: typed2,
          equalScalar: equalScalar2
        });
        var matAlgo12xSfs = (0, _matAlgo12xSfs.createMatAlgo12xSfs)({
          typed: typed2,
          DenseMatrix: DenseMatrix2
        });
        var matAlgo14xDs = (0, _matAlgo14xDs.createMatAlgo14xDs)({
          typed: typed2
        });
        function toExponent(epsilon) {
          return Math.abs((0, _number.splitNumber)(epsilon).exponent);
        }
        return typed2(name18, {
          number: function number(x) {
            var xEpsilon = (0, _index.roundNumber)(x, toExponent(config4.epsilon));
            var xSelected = (0, _number.nearlyEqual)(x, xEpsilon, config4.epsilon) ? xEpsilon : x;
            return (0, _index.roundNumber)(xSelected);
          },
          "number, number": function numberNumber(x, n) {
            var epsilonExponent = toExponent(config4.epsilon);
            if (n >= epsilonExponent) {
              return (0, _index.roundNumber)(x, n);
            }
            var xEpsilon = (0, _index.roundNumber)(x, epsilonExponent);
            var xSelected = (0, _number.nearlyEqual)(x, xEpsilon, config4.epsilon) ? xEpsilon : x;
            return (0, _index.roundNumber)(xSelected, n);
          },
          "number, BigNumber": function numberBigNumber(x, n) {
            if (!n.isInteger()) {
              throw new TypeError(NO_INT);
            }
            return new _BigNumber(x).toDecimalPlaces(n.toNumber());
          },
          Complex: function Complex3(x) {
            return x.round();
          },
          "Complex, number": function ComplexNumber(x, n) {
            if (n % 1) {
              throw new TypeError(NO_INT);
            }
            return x.round(n);
          },
          "Complex, BigNumber": function ComplexBigNumber(x, n) {
            if (!n.isInteger()) {
              throw new TypeError(NO_INT);
            }
            var _n = n.toNumber();
            return x.round(_n);
          },
          BigNumber: function BigNumber2(x) {
            var xEpsilon = new _BigNumber(x).toDecimalPlaces(toExponent(config4.epsilon));
            var xSelected = (0, _nearlyEqual.nearlyEqual)(x, xEpsilon, config4.epsilon) ? xEpsilon : x;
            return xSelected.toDecimalPlaces(0);
          },
          "BigNumber, BigNumber": function BigNumberBigNumber(x, n) {
            if (!n.isInteger()) {
              throw new TypeError(NO_INT);
            }
            var epsilonExponent = toExponent(config4.epsilon);
            if (n >= epsilonExponent) {
              return x.toDecimalPlaces(n.toNumber());
            }
            var xEpsilon = x.toDecimalPlaces(epsilonExponent);
            var xSelected = (0, _nearlyEqual.nearlyEqual)(x, xEpsilon, config4.epsilon) ? xEpsilon : x;
            return xSelected.toDecimalPlaces(n.toNumber());
          },
          Fraction: function Fraction3(x) {
            return x.round();
          },
          "Fraction, number": function FractionNumber(x, n) {
            if (n % 1) {
              throw new TypeError(NO_INT);
            }
            return x.round(n);
          },
          "Fraction, BigNumber": function FractionBigNumber(x, n) {
            if (!n.isInteger()) {
              throw new TypeError(NO_INT);
            }
            return x.round(n.toNumber());
          },
          "Unit, number, Unit": typed2.referToSelf(function(self2) {
            return function(x, n, unit) {
              var valueless = x.toNumeric(unit);
              return unit.multiply(self2(valueless, n));
            };
          }),
          "Unit, BigNumber, Unit": typed2.referToSelf(function(self2) {
            return function(x, n, unit) {
              return self2(x, n.toNumber(), unit);
            };
          }),
          "Unit, Unit": typed2.referToSelf(function(self2) {
            return function(x, unit) {
              return self2(x, 0, unit);
            };
          }),
          "Array | Matrix, number, Unit": typed2.referToSelf(function(self2) {
            return function(x, n, unit) {
              return (0, _collection.deepMap)(x, function(value) {
                return self2(value, n, unit);
              }, true);
            };
          }),
          "Array | Matrix, BigNumber, Unit": typed2.referToSelf(function(self2) {
            return function(x, n, unit) {
              return self2(x, n.toNumber(), unit);
            };
          }),
          "Array | Matrix, Unit": typed2.referToSelf(function(self2) {
            return function(x, unit) {
              return self2(x, 0, unit);
            };
          }),
          "Array | Matrix": typed2.referToSelf(function(self2) {
            return function(x) {
              return (0, _collection.deepMap)(x, self2, true);
            };
          }),
          "SparseMatrix, number | BigNumber": typed2.referToSelf(function(self2) {
            return function(x, n) {
              return matAlgo11xS0s(x, n, self2, false);
            };
          }),
          "DenseMatrix, number | BigNumber": typed2.referToSelf(function(self2) {
            return function(x, n) {
              return matAlgo14xDs(x, n, self2, false);
            };
          }),
          "Array, number | BigNumber": typed2.referToSelf(function(self2) {
            return function(x, n) {
              return matAlgo14xDs(matrix2(x), n, self2, false).valueOf();
            };
          }),
          "number | Complex | BigNumber | Fraction, SparseMatrix": typed2.referToSelf(function(self2) {
            return function(x, n) {
              if (equalScalar2(x, 0)) {
                return zeros2(n.size(), n.storage());
              }
              return matAlgo12xSfs(n, x, self2, true);
            };
          }),
          "number | Complex | BigNumber | Fraction, DenseMatrix": typed2.referToSelf(function(self2) {
            return function(x, n) {
              if (equalScalar2(x, 0)) {
                return zeros2(n.size(), n.storage());
              }
              return matAlgo14xDs(n, x, self2, true);
            };
          }),
          "number | Complex | BigNumber | Fraction, Array": typed2.referToSelf(function(self2) {
            return function(x, n) {
              return matAlgo14xDs(matrix2(n), x, self2, true).valueOf();
            };
          })
        });
      });
    }
  });

  // node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/function/arithmetic/log.js
  var require_log = __commonJS({
    "node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/function/arithmetic/log.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.createLog = void 0;
      var _factory = require_factory();
      var _index = require_number2();
      var name18 = "log";
      var dependencies19 = ["config", "typed", "divideScalar", "Complex"];
      var createLog3 = exports.createLog = /* @__PURE__ */ (0, _factory.factory)(name18, dependencies19, function(_ref) {
        var typed2 = _ref.typed, config4 = _ref.config, divideScalar = _ref.divideScalar, Complex3 = _ref.Complex;
        return typed2(name18, {
          number: function number(x) {
            if (x >= 0 || config4.predictable) {
              return (0, _index.logNumber)(x);
            } else {
              return new Complex3(x, 0).log();
            }
          },
          Complex: function Complex4(x) {
            return x.log();
          },
          BigNumber: function BigNumber2(x) {
            if (!x.isNegative() || config4.predictable) {
              return x.ln();
            } else {
              return new Complex3(x.toNumber(), 0).log();
            }
          },
          "any, any": typed2.referToSelf(function(self2) {
            return function(x, base) {
              return divideScalar(self2(x), self2(base));
            };
          })
        });
      });
    }
  });

  // node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/function/arithmetic/log1p.js
  var require_log1p = __commonJS({
    "node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/function/arithmetic/log1p.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.createLog1p = void 0;
      var _factory = require_factory();
      var _collection = require_collection();
      var _number = require_number();
      var name18 = "log1p";
      var dependencies19 = ["typed", "config", "divideScalar", "log", "Complex"];
      var createLog1p2 = exports.createLog1p = /* @__PURE__ */ (0, _factory.factory)(name18, dependencies19, function(_ref) {
        var typed2 = _ref.typed, config4 = _ref.config, divideScalar = _ref.divideScalar, log3 = _ref.log, Complex3 = _ref.Complex;
        return typed2(name18, {
          number: function number(x) {
            if (x >= -1 || config4.predictable) {
              return (0, _number.log1p)(x);
            } else {
              return _log1pComplex(new Complex3(x, 0));
            }
          },
          Complex: _log1pComplex,
          BigNumber: function BigNumber2(x) {
            var y = x.plus(1);
            if (!y.isNegative() || config4.predictable) {
              return y.ln();
            } else {
              return _log1pComplex(new Complex3(x.toNumber(), 0));
            }
          },
          "Array | Matrix": typed2.referToSelf(function(self2) {
            return function(x) {
              return (0, _collection.deepMap)(x, self2);
            };
          }),
          "any, any": typed2.referToSelf(function(self2) {
            return function(x, base) {
              return divideScalar(self2(x), log3(base));
            };
          })
        });
        function _log1pComplex(x) {
          var xRe1p = x.re + 1;
          return new Complex3(Math.log(Math.sqrt(xRe1p * xRe1p + x.im * x.im)), Math.atan2(x.im, xRe1p));
        }
      });
    }
  });

  // node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/function/arithmetic/nthRoots.js
  var require_nthRoots = __commonJS({
    "node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/function/arithmetic/nthRoots.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.createNthRoots = void 0;
      var _factory = require_factory();
      var name18 = "nthRoots";
      var dependencies19 = ["config", "typed", "divideScalar", "Complex"];
      var createNthRoots2 = exports.createNthRoots = /* @__PURE__ */ (0, _factory.factory)(name18, dependencies19, function(_ref) {
        var typed2 = _ref.typed, config4 = _ref.config, divideScalar = _ref.divideScalar, Complex3 = _ref.Complex;
        var _calculateExactResult = [function realPos(val) {
          return new Complex3(val, 0);
        }, function imagPos(val) {
          return new Complex3(0, val);
        }, function realNeg(val) {
          return new Complex3(-val, 0);
        }, function imagNeg(val) {
          return new Complex3(0, -val);
        }];
        function _nthComplexRoots(a, root) {
          if (root < 0) throw new Error("Root must be greater than zero");
          if (root === 0) throw new Error("Root must be non-zero");
          if (root % 1 !== 0) throw new Error("Root must be an integer");
          if (a === 0 || a.abs() === 0) return [new Complex3(0, 0)];
          var aIsNumeric = typeof a === "number";
          var offset;
          if (aIsNumeric || a.re === 0 || a.im === 0) {
            if (aIsNumeric) {
              offset = 2 * +(a < 0);
            } else if (a.im === 0) {
              offset = 2 * +(a.re < 0);
            } else {
              offset = 2 * +(a.im < 0) + 1;
            }
          }
          var arg = a.arg();
          var abs2 = a.abs();
          var roots = [];
          var r = Math.pow(abs2, 1 / root);
          for (var k = 0; k < root; k++) {
            var halfPiFactor = (offset + 4 * k) / root;
            if (halfPiFactor === Math.round(halfPiFactor)) {
              roots.push(_calculateExactResult[halfPiFactor % 4](r));
              continue;
            }
            roots.push(new Complex3({
              r,
              phi: (arg + 2 * Math.PI * k) / root
            }));
          }
          return roots;
        }
        return typed2(name18, {
          Complex: function Complex4(x) {
            return _nthComplexRoots(x, 2);
          },
          "Complex, number": _nthComplexRoots
        });
      });
    }
  });

  // node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/function/arithmetic/dotPow.js
  var require_dotPow = __commonJS({
    "node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/function/arithmetic/dotPow.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.createDotPow = void 0;
      var _factory = require_factory();
      var _matAlgo03xDSf = require_matAlgo03xDSf();
      var _matAlgo07xSSf = require_matAlgo07xSSf();
      var _matAlgo11xS0s = require_matAlgo11xS0s();
      var _matAlgo12xSfs = require_matAlgo12xSfs();
      var _matrixAlgorithmSuite = require_matrixAlgorithmSuite();
      var name18 = "dotPow";
      var dependencies19 = ["typed", "equalScalar", "matrix", "pow", "DenseMatrix", "concat"];
      var createDotPow2 = exports.createDotPow = /* @__PURE__ */ (0, _factory.factory)(name18, dependencies19, function(_ref) {
        var typed2 = _ref.typed, equalScalar2 = _ref.equalScalar, matrix2 = _ref.matrix, pow2 = _ref.pow, DenseMatrix2 = _ref.DenseMatrix, concat2 = _ref.concat;
        var matAlgo03xDSf = (0, _matAlgo03xDSf.createMatAlgo03xDSf)({
          typed: typed2
        });
        var matAlgo07xSSf = (0, _matAlgo07xSSf.createMatAlgo07xSSf)({
          typed: typed2,
          DenseMatrix: DenseMatrix2
        });
        var matAlgo11xS0s = (0, _matAlgo11xS0s.createMatAlgo11xS0s)({
          typed: typed2,
          equalScalar: equalScalar2
        });
        var matAlgo12xSfs = (0, _matAlgo12xSfs.createMatAlgo12xSfs)({
          typed: typed2,
          DenseMatrix: DenseMatrix2
        });
        var matrixAlgorithmSuite = (0, _matrixAlgorithmSuite.createMatrixAlgorithmSuite)({
          typed: typed2,
          matrix: matrix2,
          concat: concat2
        });
        var powScalarSignatures = {};
        for (var signature in pow2.signatures) {
          if (Object.prototype.hasOwnProperty.call(pow2.signatures, signature)) {
            if (!signature.includes("Matrix") && !signature.includes("Array")) {
              powScalarSignatures[signature] = pow2.signatures[signature];
            }
          }
        }
        var powScalar = typed2(powScalarSignatures);
        return typed2(name18, matrixAlgorithmSuite({
          elop: powScalar,
          SS: matAlgo07xSSf,
          DS: matAlgo03xDSf,
          Ss: matAlgo11xS0s,
          sS: matAlgo12xSfs
        }));
      });
    }
  });

  // node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/function/arithmetic/dotDivide.js
  var require_dotDivide = __commonJS({
    "node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/function/arithmetic/dotDivide.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.createDotDivide = void 0;
      var _factory = require_factory();
      var _matAlgo02xDS = require_matAlgo02xDS0();
      var _matAlgo03xDSf = require_matAlgo03xDSf();
      var _matAlgo07xSSf = require_matAlgo07xSSf();
      var _matAlgo11xS0s = require_matAlgo11xS0s();
      var _matAlgo12xSfs = require_matAlgo12xSfs();
      var _matrixAlgorithmSuite = require_matrixAlgorithmSuite();
      var name18 = "dotDivide";
      var dependencies19 = ["typed", "matrix", "equalScalar", "divideScalar", "DenseMatrix", "concat"];
      var createDotDivide2 = exports.createDotDivide = /* @__PURE__ */ (0, _factory.factory)(name18, dependencies19, function(_ref) {
        var typed2 = _ref.typed, matrix2 = _ref.matrix, equalScalar2 = _ref.equalScalar, divideScalar = _ref.divideScalar, DenseMatrix2 = _ref.DenseMatrix, concat2 = _ref.concat;
        var matAlgo02xDS0 = (0, _matAlgo02xDS.createMatAlgo02xDS0)({
          typed: typed2,
          equalScalar: equalScalar2
        });
        var matAlgo03xDSf = (0, _matAlgo03xDSf.createMatAlgo03xDSf)({
          typed: typed2
        });
        var matAlgo07xSSf = (0, _matAlgo07xSSf.createMatAlgo07xSSf)({
          typed: typed2,
          DenseMatrix: DenseMatrix2
        });
        var matAlgo11xS0s = (0, _matAlgo11xS0s.createMatAlgo11xS0s)({
          typed: typed2,
          equalScalar: equalScalar2
        });
        var matAlgo12xSfs = (0, _matAlgo12xSfs.createMatAlgo12xSfs)({
          typed: typed2,
          DenseMatrix: DenseMatrix2
        });
        var matrixAlgorithmSuite = (0, _matrixAlgorithmSuite.createMatrixAlgorithmSuite)({
          typed: typed2,
          matrix: matrix2,
          concat: concat2
        });
        return typed2(name18, matrixAlgorithmSuite({
          elop: divideScalar,
          SS: matAlgo07xSSf,
          DS: matAlgo03xDSf,
          SD: matAlgo02xDS0,
          Ss: matAlgo11xS0s,
          sS: matAlgo12xSfs
        }));
      });
    }
  });

  // node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/function/algebra/solver/utils/solveValidation.js
  var require_solveValidation = __commonJS({
    "node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/function/algebra/solver/utils/solveValidation.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.createSolveValidation = createSolveValidation;
      var _is = require_is();
      var _array = require_array();
      var _string = require_string();
      function createSolveValidation(_ref) {
        var DenseMatrix2 = _ref.DenseMatrix;
        return function solveValidation(m, b, copy) {
          var mSize = m.size();
          if (mSize.length !== 2) {
            throw new RangeError("Matrix must be two dimensional (size: " + (0, _string.format)(mSize) + ")");
          }
          var rows = mSize[0];
          var columns = mSize[1];
          if (rows !== columns) {
            throw new RangeError("Matrix must be square (size: " + (0, _string.format)(mSize) + ")");
          }
          var data = [];
          if ((0, _is.isMatrix)(b)) {
            var bSize = b.size();
            var bdata = b._data;
            if (bSize.length === 1) {
              if (bSize[0] !== rows) {
                throw new RangeError("Dimension mismatch. Matrix columns must match vector length.");
              }
              for (var i = 0; i < rows; i++) {
                data[i] = [bdata[i]];
              }
              return new DenseMatrix2({
                data,
                size: [rows, 1],
                datatype: b._datatype
              });
            }
            if (bSize.length === 2) {
              if (bSize[0] !== rows || bSize[1] !== 1) {
                throw new RangeError("Dimension mismatch. Matrix columns must match vector length.");
              }
              if ((0, _is.isDenseMatrix)(b)) {
                if (copy) {
                  data = [];
                  for (var _i = 0; _i < rows; _i++) {
                    data[_i] = [bdata[_i][0]];
                  }
                  return new DenseMatrix2({
                    data,
                    size: [rows, 1],
                    datatype: b._datatype
                  });
                }
                return b;
              }
              if ((0, _is.isSparseMatrix)(b)) {
                for (var _i2 = 0; _i2 < rows; _i2++) {
                  data[_i2] = [0];
                }
                var values = b._values;
                var index = b._index;
                var ptr = b._ptr;
                for (var k1 = ptr[1], k = ptr[0]; k < k1; k++) {
                  var _i3 = index[k];
                  data[_i3][0] = values[k];
                }
                return new DenseMatrix2({
                  data,
                  size: [rows, 1],
                  datatype: b._datatype
                });
              }
            }
            throw new RangeError("Dimension mismatch. The right side has to be either 1- or 2-dimensional vector.");
          }
          if ((0, _is.isArray)(b)) {
            var bsize = (0, _array.arraySize)(b);
            if (bsize.length === 1) {
              if (bsize[0] !== rows) {
                throw new RangeError("Dimension mismatch. Matrix columns must match vector length.");
              }
              for (var _i4 = 0; _i4 < rows; _i4++) {
                data[_i4] = [b[_i4]];
              }
              return new DenseMatrix2({
                data,
                size: [rows, 1]
              });
            }
            if (bsize.length === 2) {
              if (bsize[0] !== rows || bsize[1] !== 1) {
                throw new RangeError("Dimension mismatch. Matrix columns must match vector length.");
              }
              for (var _i5 = 0; _i5 < rows; _i5++) {
                data[_i5] = [b[_i5][0]];
              }
              return new DenseMatrix2({
                data,
                size: [rows, 1]
              });
            }
            throw new RangeError("Dimension mismatch. The right side has to be either 1- or 2-dimensional vector.");
          }
        };
      }
    }
  });

  // node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/function/algebra/solver/lsolve.js
  var require_lsolve = __commonJS({
    "node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/function/algebra/solver/lsolve.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.createLsolve = void 0;
      var _factory = require_factory();
      var _solveValidation = require_solveValidation();
      var name18 = "lsolve";
      var dependencies19 = ["typed", "matrix", "divideScalar", "multiplyScalar", "subtractScalar", "equalScalar", "DenseMatrix"];
      var createLsolve2 = exports.createLsolve = /* @__PURE__ */ (0, _factory.factory)(name18, dependencies19, function(_ref) {
        var typed2 = _ref.typed, matrix2 = _ref.matrix, divideScalar = _ref.divideScalar, multiplyScalar2 = _ref.multiplyScalar, subtractScalar = _ref.subtractScalar, equalScalar2 = _ref.equalScalar, DenseMatrix2 = _ref.DenseMatrix;
        var solveValidation = (0, _solveValidation.createSolveValidation)({
          DenseMatrix: DenseMatrix2
        });
        return typed2(name18, {
          "SparseMatrix, Array | Matrix": function SparseMatrixArrayMatrix(m, b) {
            return _sparseForwardSubstitution(m, b);
          },
          "DenseMatrix, Array | Matrix": function DenseMatrixArrayMatrix(m, b) {
            return _denseForwardSubstitution(m, b);
          },
          "Array, Array | Matrix": function ArrayArrayMatrix(a, b) {
            var m = matrix2(a);
            var r = _denseForwardSubstitution(m, b);
            return r.valueOf();
          }
        });
        function _denseForwardSubstitution(m, b) {
          b = solveValidation(m, b, true);
          var bdata = b._data;
          var rows = m._size[0];
          var columns = m._size[1];
          var x = [];
          var mdata = m._data;
          for (var j = 0; j < columns; j++) {
            var bj = bdata[j][0] || 0;
            var xj = void 0;
            if (!equalScalar2(bj, 0)) {
              var vjj = mdata[j][j];
              if (equalScalar2(vjj, 0)) {
                throw new Error("Linear system cannot be solved since matrix is singular");
              }
              xj = divideScalar(bj, vjj);
              for (var i = j + 1; i < rows; i++) {
                bdata[i] = [subtractScalar(bdata[i][0] || 0, multiplyScalar2(xj, mdata[i][j]))];
              }
            } else {
              xj = 0;
            }
            x[j] = [xj];
          }
          return new DenseMatrix2({
            data: x,
            size: [rows, 1]
          });
        }
        function _sparseForwardSubstitution(m, b) {
          b = solveValidation(m, b, true);
          var bdata = b._data;
          var rows = m._size[0];
          var columns = m._size[1];
          var values = m._values;
          var index = m._index;
          var ptr = m._ptr;
          var x = [];
          for (var j = 0; j < columns; j++) {
            var bj = bdata[j][0] || 0;
            if (!equalScalar2(bj, 0)) {
              var vjj = 0;
              var jValues = [];
              var jIndices = [];
              var firstIndex = ptr[j];
              var lastIndex = ptr[j + 1];
              for (var k = firstIndex; k < lastIndex; k++) {
                var i = index[k];
                if (i === j) {
                  vjj = values[k];
                } else if (i > j) {
                  jValues.push(values[k]);
                  jIndices.push(i);
                }
              }
              if (equalScalar2(vjj, 0)) {
                throw new Error("Linear system cannot be solved since matrix is singular");
              }
              var xj = divideScalar(bj, vjj);
              for (var _k = 0, l = jIndices.length; _k < l; _k++) {
                var _i = jIndices[_k];
                bdata[_i] = [subtractScalar(bdata[_i][0] || 0, multiplyScalar2(xj, jValues[_k]))];
              }
              x[j] = [xj];
            } else {
              x[j] = [0];
            }
          }
          return new DenseMatrix2({
            data: x,
            size: [rows, 1]
          });
        }
      });
    }
  });

  // node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/function/algebra/solver/usolve.js
  var require_usolve = __commonJS({
    "node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/function/algebra/solver/usolve.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.createUsolve = void 0;
      var _factory = require_factory();
      var _solveValidation = require_solveValidation();
      var name18 = "usolve";
      var dependencies19 = ["typed", "matrix", "divideScalar", "multiplyScalar", "subtractScalar", "equalScalar", "DenseMatrix"];
      var createUsolve2 = exports.createUsolve = /* @__PURE__ */ (0, _factory.factory)(name18, dependencies19, function(_ref) {
        var typed2 = _ref.typed, matrix2 = _ref.matrix, divideScalar = _ref.divideScalar, multiplyScalar2 = _ref.multiplyScalar, subtractScalar = _ref.subtractScalar, equalScalar2 = _ref.equalScalar, DenseMatrix2 = _ref.DenseMatrix;
        var solveValidation = (0, _solveValidation.createSolveValidation)({
          DenseMatrix: DenseMatrix2
        });
        return typed2(name18, {
          "SparseMatrix, Array | Matrix": function SparseMatrixArrayMatrix(m, b) {
            return _sparseBackwardSubstitution(m, b);
          },
          "DenseMatrix, Array | Matrix": function DenseMatrixArrayMatrix(m, b) {
            return _denseBackwardSubstitution(m, b);
          },
          "Array, Array | Matrix": function ArrayArrayMatrix(a, b) {
            var m = matrix2(a);
            var r = _denseBackwardSubstitution(m, b);
            return r.valueOf();
          }
        });
        function _denseBackwardSubstitution(m, b) {
          b = solveValidation(m, b, true);
          var bdata = b._data;
          var rows = m._size[0];
          var columns = m._size[1];
          var x = [];
          var mdata = m._data;
          for (var j = columns - 1; j >= 0; j--) {
            var bj = bdata[j][0] || 0;
            var xj = void 0;
            if (!equalScalar2(bj, 0)) {
              var vjj = mdata[j][j];
              if (equalScalar2(vjj, 0)) {
                throw new Error("Linear system cannot be solved since matrix is singular");
              }
              xj = divideScalar(bj, vjj);
              for (var i = j - 1; i >= 0; i--) {
                bdata[i] = [subtractScalar(bdata[i][0] || 0, multiplyScalar2(xj, mdata[i][j]))];
              }
            } else {
              xj = 0;
            }
            x[j] = [xj];
          }
          return new DenseMatrix2({
            data: x,
            size: [rows, 1]
          });
        }
        function _sparseBackwardSubstitution(m, b) {
          b = solveValidation(m, b, true);
          var bdata = b._data;
          var rows = m._size[0];
          var columns = m._size[1];
          var values = m._values;
          var index = m._index;
          var ptr = m._ptr;
          var x = [];
          for (var j = columns - 1; j >= 0; j--) {
            var bj = bdata[j][0] || 0;
            if (!equalScalar2(bj, 0)) {
              var vjj = 0;
              var jValues = [];
              var jIndices = [];
              var firstIndex = ptr[j];
              var lastIndex = ptr[j + 1];
              for (var k = lastIndex - 1; k >= firstIndex; k--) {
                var i = index[k];
                if (i === j) {
                  vjj = values[k];
                } else if (i < j) {
                  jValues.push(values[k]);
                  jIndices.push(i);
                }
              }
              if (equalScalar2(vjj, 0)) {
                throw new Error("Linear system cannot be solved since matrix is singular");
              }
              var xj = divideScalar(bj, vjj);
              for (var _k = 0, _lastIndex = jIndices.length; _k < _lastIndex; _k++) {
                var _i = jIndices[_k];
                bdata[_i] = [subtractScalar(bdata[_i][0], multiplyScalar2(xj, jValues[_k]))];
              }
              x[j] = [xj];
            } else {
              x[j] = [0];
            }
          }
          return new DenseMatrix2({
            data: x,
            size: [rows, 1]
          });
        }
      });
    }
  });

  // node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/function/algebra/solver/lsolveAll.js
  var require_lsolveAll = __commonJS({
    "node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/function/algebra/solver/lsolveAll.js"(exports) {
      "use strict";
      var _interopRequireDefault = require_interopRequireDefault();
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.createLsolveAll = void 0;
      var _toConsumableArray2 = _interopRequireDefault(require_toConsumableArray());
      var _factory = require_factory();
      var _solveValidation = require_solveValidation();
      var name18 = "lsolveAll";
      var dependencies19 = ["typed", "matrix", "divideScalar", "multiplyScalar", "subtractScalar", "equalScalar", "DenseMatrix"];
      var createLsolveAll2 = exports.createLsolveAll = /* @__PURE__ */ (0, _factory.factory)(name18, dependencies19, function(_ref) {
        var typed2 = _ref.typed, matrix2 = _ref.matrix, divideScalar = _ref.divideScalar, multiplyScalar2 = _ref.multiplyScalar, subtractScalar = _ref.subtractScalar, equalScalar2 = _ref.equalScalar, DenseMatrix2 = _ref.DenseMatrix;
        var solveValidation = (0, _solveValidation.createSolveValidation)({
          DenseMatrix: DenseMatrix2
        });
        return typed2(name18, {
          "SparseMatrix, Array | Matrix": function SparseMatrixArrayMatrix(m, b) {
            return _sparseForwardSubstitution(m, b);
          },
          "DenseMatrix, Array | Matrix": function DenseMatrixArrayMatrix(m, b) {
            return _denseForwardSubstitution(m, b);
          },
          "Array, Array | Matrix": function ArrayArrayMatrix(a, b) {
            var m = matrix2(a);
            var R = _denseForwardSubstitution(m, b);
            return R.map(function(r) {
              return r.valueOf();
            });
          }
        });
        function _denseForwardSubstitution(m, b_) {
          var B = [solveValidation(m, b_, true)._data.map(function(e) {
            return e[0];
          })];
          var M = m._data;
          var rows = m._size[0];
          var columns = m._size[1];
          for (var i = 0; i < columns; i++) {
            var L = B.length;
            for (var k = 0; k < L; k++) {
              var b = B[k];
              if (!equalScalar2(M[i][i], 0)) {
                b[i] = divideScalar(b[i], M[i][i]);
                for (var j = i + 1; j < columns; j++) {
                  b[j] = subtractScalar(b[j], multiplyScalar2(b[i], M[j][i]));
                }
              } else if (!equalScalar2(b[i], 0)) {
                if (k === 0) {
                  return [];
                } else {
                  B.splice(k, 1);
                  k -= 1;
                  L -= 1;
                }
              } else if (k === 0) {
                var bNew = (0, _toConsumableArray2["default"])(b);
                bNew[i] = 1;
                for (var _j = i + 1; _j < columns; _j++) {
                  bNew[_j] = subtractScalar(bNew[_j], M[_j][i]);
                }
                B.push(bNew);
              }
            }
          }
          return B.map(function(x) {
            return new DenseMatrix2({
              data: x.map(function(e) {
                return [e];
              }),
              size: [rows, 1]
            });
          });
        }
        function _sparseForwardSubstitution(m, b_) {
          var B = [solveValidation(m, b_, true)._data.map(function(e) {
            return e[0];
          })];
          var rows = m._size[0];
          var columns = m._size[1];
          var values = m._values;
          var index = m._index;
          var ptr = m._ptr;
          for (var i = 0; i < columns; i++) {
            var L = B.length;
            for (var k = 0; k < L; k++) {
              var b = B[k];
              var iValues = [];
              var iIndices = [];
              var firstIndex = ptr[i];
              var lastIndex = ptr[i + 1];
              var Mii = 0;
              for (var j = firstIndex; j < lastIndex; j++) {
                var J = index[j];
                if (J === i) {
                  Mii = values[j];
                } else if (J > i) {
                  iValues.push(values[j]);
                  iIndices.push(J);
                }
              }
              if (!equalScalar2(Mii, 0)) {
                b[i] = divideScalar(b[i], Mii);
                for (var _j2 = 0, _lastIndex = iIndices.length; _j2 < _lastIndex; _j2++) {
                  var _J = iIndices[_j2];
                  b[_J] = subtractScalar(b[_J], multiplyScalar2(b[i], iValues[_j2]));
                }
              } else if (!equalScalar2(b[i], 0)) {
                if (k === 0) {
                  return [];
                } else {
                  B.splice(k, 1);
                  k -= 1;
                  L -= 1;
                }
              } else if (k === 0) {
                var bNew = (0, _toConsumableArray2["default"])(b);
                bNew[i] = 1;
                for (var _j3 = 0, _lastIndex2 = iIndices.length; _j3 < _lastIndex2; _j3++) {
                  var _J2 = iIndices[_j3];
                  bNew[_J2] = subtractScalar(bNew[_J2], iValues[_j3]);
                }
                B.push(bNew);
              }
            }
          }
          return B.map(function(x) {
            return new DenseMatrix2({
              data: x.map(function(e) {
                return [e];
              }),
              size: [rows, 1]
            });
          });
        }
      });
    }
  });

  // node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/function/algebra/solver/usolveAll.js
  var require_usolveAll = __commonJS({
    "node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/function/algebra/solver/usolveAll.js"(exports) {
      "use strict";
      var _interopRequireDefault = require_interopRequireDefault();
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.createUsolveAll = void 0;
      var _toConsumableArray2 = _interopRequireDefault(require_toConsumableArray());
      var _factory = require_factory();
      var _solveValidation = require_solveValidation();
      var name18 = "usolveAll";
      var dependencies19 = ["typed", "matrix", "divideScalar", "multiplyScalar", "subtractScalar", "equalScalar", "DenseMatrix"];
      var createUsolveAll2 = exports.createUsolveAll = /* @__PURE__ */ (0, _factory.factory)(name18, dependencies19, function(_ref) {
        var typed2 = _ref.typed, matrix2 = _ref.matrix, divideScalar = _ref.divideScalar, multiplyScalar2 = _ref.multiplyScalar, subtractScalar = _ref.subtractScalar, equalScalar2 = _ref.equalScalar, DenseMatrix2 = _ref.DenseMatrix;
        var solveValidation = (0, _solveValidation.createSolveValidation)({
          DenseMatrix: DenseMatrix2
        });
        return typed2(name18, {
          "SparseMatrix, Array | Matrix": function SparseMatrixArrayMatrix(m, b) {
            return _sparseBackwardSubstitution(m, b);
          },
          "DenseMatrix, Array | Matrix": function DenseMatrixArrayMatrix(m, b) {
            return _denseBackwardSubstitution(m, b);
          },
          "Array, Array | Matrix": function ArrayArrayMatrix(a, b) {
            var m = matrix2(a);
            var R = _denseBackwardSubstitution(m, b);
            return R.map(function(r) {
              return r.valueOf();
            });
          }
        });
        function _denseBackwardSubstitution(m, b_) {
          var B = [solveValidation(m, b_, true)._data.map(function(e) {
            return e[0];
          })];
          var M = m._data;
          var rows = m._size[0];
          var columns = m._size[1];
          for (var i = columns - 1; i >= 0; i--) {
            var L = B.length;
            for (var k = 0; k < L; k++) {
              var b = B[k];
              if (!equalScalar2(M[i][i], 0)) {
                b[i] = divideScalar(b[i], M[i][i]);
                for (var j = i - 1; j >= 0; j--) {
                  b[j] = subtractScalar(b[j], multiplyScalar2(b[i], M[j][i]));
                }
              } else if (!equalScalar2(b[i], 0)) {
                if (k === 0) {
                  return [];
                } else {
                  B.splice(k, 1);
                  k -= 1;
                  L -= 1;
                }
              } else if (k === 0) {
                var bNew = (0, _toConsumableArray2["default"])(b);
                bNew[i] = 1;
                for (var _j = i - 1; _j >= 0; _j--) {
                  bNew[_j] = subtractScalar(bNew[_j], M[_j][i]);
                }
                B.push(bNew);
              }
            }
          }
          return B.map(function(x) {
            return new DenseMatrix2({
              data: x.map(function(e) {
                return [e];
              }),
              size: [rows, 1]
            });
          });
        }
        function _sparseBackwardSubstitution(m, b_) {
          var B = [solveValidation(m, b_, true)._data.map(function(e) {
            return e[0];
          })];
          var rows = m._size[0];
          var columns = m._size[1];
          var values = m._values;
          var index = m._index;
          var ptr = m._ptr;
          for (var i = columns - 1; i >= 0; i--) {
            var L = B.length;
            for (var k = 0; k < L; k++) {
              var b = B[k];
              var iValues = [];
              var iIndices = [];
              var firstIndex = ptr[i];
              var lastIndex = ptr[i + 1];
              var Mii = 0;
              for (var j = lastIndex - 1; j >= firstIndex; j--) {
                var J = index[j];
                if (J === i) {
                  Mii = values[j];
                } else if (J < i) {
                  iValues.push(values[j]);
                  iIndices.push(J);
                }
              }
              if (!equalScalar2(Mii, 0)) {
                b[i] = divideScalar(b[i], Mii);
                for (var _j2 = 0, _lastIndex = iIndices.length; _j2 < _lastIndex; _j2++) {
                  var _J = iIndices[_j2];
                  b[_J] = subtractScalar(b[_J], multiplyScalar2(b[i], iValues[_j2]));
                }
              } else if (!equalScalar2(b[i], 0)) {
                if (k === 0) {
                  return [];
                } else {
                  B.splice(k, 1);
                  k -= 1;
                  L -= 1;
                }
              } else if (k === 0) {
                var bNew = (0, _toConsumableArray2["default"])(b);
                bNew[i] = 1;
                for (var _j3 = 0, _lastIndex2 = iIndices.length; _j3 < _lastIndex2; _j3++) {
                  var _J2 = iIndices[_j3];
                  bNew[_J2] = subtractScalar(bNew[_J2], iValues[_j3]);
                }
                B.push(bNew);
              }
            }
          }
          return B.map(function(x) {
            return new DenseMatrix2({
              data: x.map(function(e) {
                return [e];
              }),
              size: [rows, 1]
            });
          });
        }
      });
    }
  });

  // node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/type/matrix/utils/matAlgo08xS0Sid.js
  var require_matAlgo08xS0Sid = __commonJS({
    "node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/type/matrix/utils/matAlgo08xS0Sid.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.createMatAlgo08xS0Sid = void 0;
      var _factory = require_factory();
      var _DimensionError = require_DimensionError();
      var name18 = "matAlgo08xS0Sid";
      var dependencies19 = ["typed", "equalScalar"];
      var createMatAlgo08xS0Sid = exports.createMatAlgo08xS0Sid = /* @__PURE__ */ (0, _factory.factory)(name18, dependencies19, function(_ref) {
        var typed2 = _ref.typed, equalScalar2 = _ref.equalScalar;
        return function matAlgo08xS0Sid(a, b, callback) {
          var avalues = a._values;
          var aindex = a._index;
          var aptr = a._ptr;
          var asize = a._size;
          var adt = a._datatype || a._data === void 0 ? a._datatype : a.getDataType();
          var bvalues = b._values;
          var bindex = b._index;
          var bptr = b._ptr;
          var bsize = b._size;
          var bdt = b._datatype || b._data === void 0 ? b._datatype : b.getDataType();
          if (asize.length !== bsize.length) {
            throw new _DimensionError.DimensionError(asize.length, bsize.length);
          }
          if (asize[0] !== bsize[0] || asize[1] !== bsize[1]) {
            throw new RangeError("Dimension mismatch. Matrix A (" + asize + ") must match Matrix B (" + bsize + ")");
          }
          if (!avalues || !bvalues) {
            throw new Error("Cannot perform operation on Pattern Sparse Matrices");
          }
          var rows = asize[0];
          var columns = asize[1];
          var dt;
          var eq = equalScalar2;
          var zero = 0;
          var cf = callback;
          if (typeof adt === "string" && adt === bdt && adt !== "mixed") {
            dt = adt;
            eq = typed2.find(equalScalar2, [dt, dt]);
            zero = typed2.convert(0, dt);
            cf = typed2.find(callback, [dt, dt]);
          }
          var cvalues = [];
          var cindex = [];
          var cptr = [];
          var x = [];
          var w = [];
          var k, k0, k1, i;
          for (var j = 0; j < columns; j++) {
            cptr[j] = cindex.length;
            var mark = j + 1;
            for (k0 = aptr[j], k1 = aptr[j + 1], k = k0; k < k1; k++) {
              i = aindex[k];
              w[i] = mark;
              x[i] = avalues[k];
              cindex.push(i);
            }
            for (k0 = bptr[j], k1 = bptr[j + 1], k = k0; k < k1; k++) {
              i = bindex[k];
              if (w[i] === mark) {
                x[i] = cf(x[i], bvalues[k]);
              }
            }
            k = cptr[j];
            while (k < cindex.length) {
              i = cindex[k];
              var v = x[i];
              if (!eq(v, zero)) {
                cvalues.push(v);
                k++;
              } else {
                cindex.splice(k, 1);
              }
            }
          }
          cptr[columns] = cindex.length;
          return a.createSparseMatrix({
            values: cvalues,
            index: cindex,
            ptr: cptr,
            size: [rows, columns],
            datatype: adt === a._datatype && bdt === b._datatype ? dt : void 0
          });
        };
      });
    }
  });

  // node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/function/bitwise/useMatrixForArrayScalar.js
  var require_useMatrixForArrayScalar = __commonJS({
    "node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/function/bitwise/useMatrixForArrayScalar.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.createUseMatrixForArrayScalar = void 0;
      var _factory = require_factory();
      var createUseMatrixForArrayScalar = exports.createUseMatrixForArrayScalar = /* @__PURE__ */ (0, _factory.factory)("useMatrixForArrayScalar", ["typed", "matrix"], function(_ref) {
        var typed2 = _ref.typed, matrix2 = _ref.matrix;
        return {
          "Array, number": typed2.referTo("DenseMatrix, number", function(selfDn) {
            return function(x, y) {
              return selfDn(matrix2(x), y).valueOf();
            };
          }),
          "Array, BigNumber": typed2.referTo("DenseMatrix, BigNumber", function(selfDB) {
            return function(x, y) {
              return selfDB(matrix2(x), y).valueOf();
            };
          }),
          "number, Array": typed2.referTo("number, DenseMatrix", function(selfnD) {
            return function(x, y) {
              return selfnD(x, matrix2(y)).valueOf();
            };
          }),
          "BigNumber, Array": typed2.referTo("BigNumber, DenseMatrix", function(selfBD) {
            return function(x, y) {
              return selfBD(x, matrix2(y)).valueOf();
            };
          })
        };
      });
    }
  });

  // node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/function/bitwise/leftShift.js
  var require_leftShift = __commonJS({
    "node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/function/bitwise/leftShift.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.createLeftShift = void 0;
      var _matAlgo02xDS = require_matAlgo02xDS0();
      var _matAlgo11xS0s = require_matAlgo11xS0s();
      var _matAlgo14xDs = require_matAlgo14xDs();
      var _matAlgo01xDSid = require_matAlgo01xDSid();
      var _matAlgo10xSids = require_matAlgo10xSids();
      var _matAlgo08xS0Sid = require_matAlgo08xS0Sid();
      var _factory = require_factory();
      var _matrixAlgorithmSuite = require_matrixAlgorithmSuite();
      var _useMatrixForArrayScalar = require_useMatrixForArrayScalar();
      var _index = require_number2();
      var _bitwise = require_bitwise2();
      var name18 = "leftShift";
      var dependencies19 = ["typed", "matrix", "equalScalar", "zeros", "DenseMatrix", "concat"];
      var createLeftShift2 = exports.createLeftShift = /* @__PURE__ */ (0, _factory.factory)(name18, dependencies19, function(_ref) {
        var typed2 = _ref.typed, matrix2 = _ref.matrix, equalScalar2 = _ref.equalScalar, zeros2 = _ref.zeros, DenseMatrix2 = _ref.DenseMatrix, concat2 = _ref.concat;
        var matAlgo01xDSid = (0, _matAlgo01xDSid.createMatAlgo01xDSid)({
          typed: typed2
        });
        var matAlgo02xDS0 = (0, _matAlgo02xDS.createMatAlgo02xDS0)({
          typed: typed2,
          equalScalar: equalScalar2
        });
        var matAlgo08xS0Sid = (0, _matAlgo08xS0Sid.createMatAlgo08xS0Sid)({
          typed: typed2,
          equalScalar: equalScalar2
        });
        var matAlgo10xSids = (0, _matAlgo10xSids.createMatAlgo10xSids)({
          typed: typed2,
          DenseMatrix: DenseMatrix2
        });
        var matAlgo11xS0s = (0, _matAlgo11xS0s.createMatAlgo11xS0s)({
          typed: typed2,
          equalScalar: equalScalar2
        });
        var matAlgo14xDs = (0, _matAlgo14xDs.createMatAlgo14xDs)({
          typed: typed2
        });
        var matrixAlgorithmSuite = (0, _matrixAlgorithmSuite.createMatrixAlgorithmSuite)({
          typed: typed2,
          matrix: matrix2,
          concat: concat2
        });
        var useMatrixForArrayScalar = (0, _useMatrixForArrayScalar.createUseMatrixForArrayScalar)({
          typed: typed2,
          matrix: matrix2
        });
        return typed2(name18, {
          "number, number": _index.leftShiftNumber,
          "BigNumber, BigNumber": _bitwise.leftShiftBigNumber,
          "SparseMatrix, number | BigNumber": typed2.referToSelf(function(self2) {
            return function(x, y) {
              if (equalScalar2(y, 0)) {
                return x.clone();
              }
              return matAlgo11xS0s(x, y, self2, false);
            };
          }),
          "DenseMatrix, number | BigNumber": typed2.referToSelf(function(self2) {
            return function(x, y) {
              if (equalScalar2(y, 0)) {
                return x.clone();
              }
              return matAlgo14xDs(x, y, self2, false);
            };
          }),
          "number | BigNumber, SparseMatrix": typed2.referToSelf(function(self2) {
            return function(x, y) {
              if (equalScalar2(x, 0)) {
                return zeros2(y.size(), y.storage());
              }
              return matAlgo10xSids(y, x, self2, true);
            };
          }),
          "number | BigNumber, DenseMatrix": typed2.referToSelf(function(self2) {
            return function(x, y) {
              if (equalScalar2(x, 0)) {
                return zeros2(y.size(), y.storage());
              }
              return matAlgo14xDs(y, x, self2, true);
            };
          })
        }, useMatrixForArrayScalar, matrixAlgorithmSuite({
          SS: matAlgo08xS0Sid,
          DS: matAlgo01xDSid,
          SD: matAlgo02xDS0
        }));
      });
    }
  });

  // node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/function/bitwise/rightArithShift.js
  var require_rightArithShift = __commonJS({
    "node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/function/bitwise/rightArithShift.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.createRightArithShift = void 0;
      var _bitwise = require_bitwise2();
      var _matAlgo02xDS = require_matAlgo02xDS0();
      var _matAlgo11xS0s = require_matAlgo11xS0s();
      var _matAlgo14xDs = require_matAlgo14xDs();
      var _matAlgo01xDSid = require_matAlgo01xDSid();
      var _matAlgo10xSids = require_matAlgo10xSids();
      var _matAlgo08xS0Sid = require_matAlgo08xS0Sid();
      var _factory = require_factory();
      var _matrixAlgorithmSuite = require_matrixAlgorithmSuite();
      var _useMatrixForArrayScalar = require_useMatrixForArrayScalar();
      var _index = require_number2();
      var name18 = "rightArithShift";
      var dependencies19 = ["typed", "matrix", "equalScalar", "zeros", "DenseMatrix", "concat"];
      var createRightArithShift2 = exports.createRightArithShift = /* @__PURE__ */ (0, _factory.factory)(name18, dependencies19, function(_ref) {
        var typed2 = _ref.typed, matrix2 = _ref.matrix, equalScalar2 = _ref.equalScalar, zeros2 = _ref.zeros, DenseMatrix2 = _ref.DenseMatrix, concat2 = _ref.concat;
        var matAlgo01xDSid = (0, _matAlgo01xDSid.createMatAlgo01xDSid)({
          typed: typed2
        });
        var matAlgo02xDS0 = (0, _matAlgo02xDS.createMatAlgo02xDS0)({
          typed: typed2,
          equalScalar: equalScalar2
        });
        var matAlgo08xS0Sid = (0, _matAlgo08xS0Sid.createMatAlgo08xS0Sid)({
          typed: typed2,
          equalScalar: equalScalar2
        });
        var matAlgo10xSids = (0, _matAlgo10xSids.createMatAlgo10xSids)({
          typed: typed2,
          DenseMatrix: DenseMatrix2
        });
        var matAlgo11xS0s = (0, _matAlgo11xS0s.createMatAlgo11xS0s)({
          typed: typed2,
          equalScalar: equalScalar2
        });
        var matAlgo14xDs = (0, _matAlgo14xDs.createMatAlgo14xDs)({
          typed: typed2
        });
        var matrixAlgorithmSuite = (0, _matrixAlgorithmSuite.createMatrixAlgorithmSuite)({
          typed: typed2,
          matrix: matrix2,
          concat: concat2
        });
        var useMatrixForArrayScalar = (0, _useMatrixForArrayScalar.createUseMatrixForArrayScalar)({
          typed: typed2,
          matrix: matrix2
        });
        return typed2(name18, {
          "number, number": _index.rightArithShiftNumber,
          "BigNumber, BigNumber": _bitwise.rightArithShiftBigNumber,
          "SparseMatrix, number | BigNumber": typed2.referToSelf(function(self2) {
            return function(x, y) {
              if (equalScalar2(y, 0)) {
                return x.clone();
              }
              return matAlgo11xS0s(x, y, self2, false);
            };
          }),
          "DenseMatrix, number | BigNumber": typed2.referToSelf(function(self2) {
            return function(x, y) {
              if (equalScalar2(y, 0)) {
                return x.clone();
              }
              return matAlgo14xDs(x, y, self2, false);
            };
          }),
          "number | BigNumber, SparseMatrix": typed2.referToSelf(function(self2) {
            return function(x, y) {
              if (equalScalar2(x, 0)) {
                return zeros2(y.size(), y.storage());
              }
              return matAlgo10xSids(y, x, self2, true);
            };
          }),
          "number | BigNumber, DenseMatrix": typed2.referToSelf(function(self2) {
            return function(x, y) {
              if (equalScalar2(x, 0)) {
                return zeros2(y.size(), y.storage());
              }
              return matAlgo14xDs(y, x, self2, true);
            };
          })
        }, useMatrixForArrayScalar, matrixAlgorithmSuite({
          SS: matAlgo08xS0Sid,
          DS: matAlgo01xDSid,
          SD: matAlgo02xDS0
        }));
      });
    }
  });

  // node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/function/bitwise/rightLogShift.js
  var require_rightLogShift = __commonJS({
    "node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/function/bitwise/rightLogShift.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.createRightLogShift = void 0;
      var _matAlgo02xDS = require_matAlgo02xDS0();
      var _matAlgo11xS0s = require_matAlgo11xS0s();
      var _matAlgo14xDs = require_matAlgo14xDs();
      var _matAlgo01xDSid = require_matAlgo01xDSid();
      var _matAlgo10xSids = require_matAlgo10xSids();
      var _matAlgo08xS0Sid = require_matAlgo08xS0Sid();
      var _factory = require_factory();
      var _matrixAlgorithmSuite = require_matrixAlgorithmSuite();
      var _index = require_number2();
      var _useMatrixForArrayScalar = require_useMatrixForArrayScalar();
      var name18 = "rightLogShift";
      var dependencies19 = ["typed", "matrix", "equalScalar", "zeros", "DenseMatrix", "concat"];
      var createRightLogShift2 = exports.createRightLogShift = /* @__PURE__ */ (0, _factory.factory)(name18, dependencies19, function(_ref) {
        var typed2 = _ref.typed, matrix2 = _ref.matrix, equalScalar2 = _ref.equalScalar, zeros2 = _ref.zeros, DenseMatrix2 = _ref.DenseMatrix, concat2 = _ref.concat;
        var matAlgo01xDSid = (0, _matAlgo01xDSid.createMatAlgo01xDSid)({
          typed: typed2
        });
        var matAlgo02xDS0 = (0, _matAlgo02xDS.createMatAlgo02xDS0)({
          typed: typed2,
          equalScalar: equalScalar2
        });
        var matAlgo08xS0Sid = (0, _matAlgo08xS0Sid.createMatAlgo08xS0Sid)({
          typed: typed2,
          equalScalar: equalScalar2
        });
        var matAlgo10xSids = (0, _matAlgo10xSids.createMatAlgo10xSids)({
          typed: typed2,
          DenseMatrix: DenseMatrix2
        });
        var matAlgo11xS0s = (0, _matAlgo11xS0s.createMatAlgo11xS0s)({
          typed: typed2,
          equalScalar: equalScalar2
        });
        var matAlgo14xDs = (0, _matAlgo14xDs.createMatAlgo14xDs)({
          typed: typed2
        });
        var matrixAlgorithmSuite = (0, _matrixAlgorithmSuite.createMatrixAlgorithmSuite)({
          typed: typed2,
          matrix: matrix2,
          concat: concat2
        });
        var useMatrixForArrayScalar = (0, _useMatrixForArrayScalar.createUseMatrixForArrayScalar)({
          typed: typed2,
          matrix: matrix2
        });
        return typed2(name18, {
          "number, number": _index.rightLogShiftNumber,
          // 'BigNumber, BigNumber': ..., // TODO: implement BigNumber support for rightLogShift
          "SparseMatrix, number | BigNumber": typed2.referToSelf(function(self2) {
            return function(x, y) {
              if (equalScalar2(y, 0)) {
                return x.clone();
              }
              return matAlgo11xS0s(x, y, self2, false);
            };
          }),
          "DenseMatrix, number | BigNumber": typed2.referToSelf(function(self2) {
            return function(x, y) {
              if (equalScalar2(y, 0)) {
                return x.clone();
              }
              return matAlgo14xDs(x, y, self2, false);
            };
          }),
          "number | BigNumber, SparseMatrix": typed2.referToSelf(function(self2) {
            return function(x, y) {
              if (equalScalar2(x, 0)) {
                return zeros2(y.size(), y.storage());
              }
              return matAlgo10xSids(y, x, self2, true);
            };
          }),
          "number | BigNumber, DenseMatrix": typed2.referToSelf(function(self2) {
            return function(x, y) {
              if (equalScalar2(x, 0)) {
                return zeros2(y.size(), y.storage());
              }
              return matAlgo14xDs(y, x, self2, true);
            };
          })
        }, useMatrixForArrayScalar, matrixAlgorithmSuite({
          SS: matAlgo08xS0Sid,
          DS: matAlgo01xDSid,
          SD: matAlgo02xDS0
        }));
      });
    }
  });

  // node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/function/logical/and.js
  var require_and = __commonJS({
    "node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/function/logical/and.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.createAnd = void 0;
      var _matAlgo02xDS = require_matAlgo02xDS0();
      var _matAlgo11xS0s = require_matAlgo11xS0s();
      var _matAlgo14xDs = require_matAlgo14xDs();
      var _matAlgo06xS0S = require_matAlgo06xS0S0();
      var _factory = require_factory();
      var _matrixAlgorithmSuite = require_matrixAlgorithmSuite();
      var _index = require_number2();
      var name18 = "and";
      var dependencies19 = ["typed", "matrix", "equalScalar", "zeros", "not", "concat"];
      var createAnd2 = exports.createAnd = /* @__PURE__ */ (0, _factory.factory)(name18, dependencies19, function(_ref) {
        var typed2 = _ref.typed, matrix2 = _ref.matrix, equalScalar2 = _ref.equalScalar, zeros2 = _ref.zeros, not = _ref.not, concat2 = _ref.concat;
        var matAlgo02xDS0 = (0, _matAlgo02xDS.createMatAlgo02xDS0)({
          typed: typed2,
          equalScalar: equalScalar2
        });
        var matAlgo06xS0S0 = (0, _matAlgo06xS0S.createMatAlgo06xS0S0)({
          typed: typed2,
          equalScalar: equalScalar2
        });
        var matAlgo11xS0s = (0, _matAlgo11xS0s.createMatAlgo11xS0s)({
          typed: typed2,
          equalScalar: equalScalar2
        });
        var matAlgo14xDs = (0, _matAlgo14xDs.createMatAlgo14xDs)({
          typed: typed2
        });
        var matrixAlgorithmSuite = (0, _matrixAlgorithmSuite.createMatrixAlgorithmSuite)({
          typed: typed2,
          matrix: matrix2,
          concat: concat2
        });
        return typed2(name18, {
          "number, number": _index.andNumber,
          "Complex, Complex": function ComplexComplex(x, y) {
            return (x.re !== 0 || x.im !== 0) && (y.re !== 0 || y.im !== 0);
          },
          "BigNumber, BigNumber": function BigNumberBigNumber(x, y) {
            return !x.isZero() && !y.isZero() && !x.isNaN() && !y.isNaN();
          },
          "Unit, Unit": typed2.referToSelf(function(self2) {
            return function(x, y) {
              return self2(x.value || 0, y.value || 0);
            };
          }),
          "SparseMatrix, any": typed2.referToSelf(function(self2) {
            return function(x, y) {
              if (not(y)) {
                return zeros2(x.size(), x.storage());
              }
              return matAlgo11xS0s(x, y, self2, false);
            };
          }),
          "DenseMatrix, any": typed2.referToSelf(function(self2) {
            return function(x, y) {
              if (not(y)) {
                return zeros2(x.size(), x.storage());
              }
              return matAlgo14xDs(x, y, self2, false);
            };
          }),
          "any, SparseMatrix": typed2.referToSelf(function(self2) {
            return function(x, y) {
              if (not(x)) {
                return zeros2(x.size(), x.storage());
              }
              return matAlgo11xS0s(y, x, self2, true);
            };
          }),
          "any, DenseMatrix": typed2.referToSelf(function(self2) {
            return function(x, y) {
              if (not(x)) {
                return zeros2(x.size(), x.storage());
              }
              return matAlgo14xDs(y, x, self2, true);
            };
          }),
          "Array, any": typed2.referToSelf(function(self2) {
            return function(x, y) {
              return self2(matrix2(x), y).valueOf();
            };
          }),
          "any, Array": typed2.referToSelf(function(self2) {
            return function(x, y) {
              return self2(x, matrix2(y)).valueOf();
            };
          })
        }, matrixAlgorithmSuite({
          SS: matAlgo06xS0S0,
          DS: matAlgo02xDS0
        }));
      });
    }
  });

  // node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/function/relational/compare.js
  var require_compare = __commonJS({
    "node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/function/relational/compare.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.createCompareNumber = exports.createCompare = void 0;
      var _nearlyEqual = require_nearlyEqual();
      var _number = require_number();
      var _factory = require_factory();
      var _matAlgo03xDSf = require_matAlgo03xDSf();
      var _matAlgo12xSfs = require_matAlgo12xSfs();
      var _matAlgo05xSfSf = require_matAlgo05xSfSf();
      var _matrixAlgorithmSuite = require_matrixAlgorithmSuite();
      var _compareUnits = require_compareUnits();
      var name18 = "compare";
      var dependencies19 = ["typed", "config", "matrix", "equalScalar", "BigNumber", "Fraction", "DenseMatrix", "concat"];
      var createCompare2 = exports.createCompare = /* @__PURE__ */ (0, _factory.factory)(name18, dependencies19, function(_ref) {
        var typed2 = _ref.typed, config4 = _ref.config, equalScalar2 = _ref.equalScalar, matrix2 = _ref.matrix, BigNumber2 = _ref.BigNumber, Fraction3 = _ref.Fraction, DenseMatrix2 = _ref.DenseMatrix, concat2 = _ref.concat;
        var matAlgo03xDSf = (0, _matAlgo03xDSf.createMatAlgo03xDSf)({
          typed: typed2
        });
        var matAlgo05xSfSf = (0, _matAlgo05xSfSf.createMatAlgo05xSfSf)({
          typed: typed2,
          equalScalar: equalScalar2
        });
        var matAlgo12xSfs = (0, _matAlgo12xSfs.createMatAlgo12xSfs)({
          typed: typed2,
          DenseMatrix: DenseMatrix2
        });
        var matrixAlgorithmSuite = (0, _matrixAlgorithmSuite.createMatrixAlgorithmSuite)({
          typed: typed2,
          matrix: matrix2,
          concat: concat2
        });
        var compareUnits = (0, _compareUnits.createCompareUnits)({
          typed: typed2
        });
        return typed2(name18, createCompareNumber({
          typed: typed2,
          config: config4
        }), {
          "boolean, boolean": function booleanBoolean(x, y) {
            return x === y ? 0 : x > y ? 1 : -1;
          },
          "BigNumber, BigNumber": function BigNumberBigNumber(x, y) {
            return (0, _nearlyEqual.nearlyEqual)(x, y, config4.epsilon) ? new BigNumber2(0) : new BigNumber2(x.cmp(y));
          },
          "Fraction, Fraction": function FractionFraction(x, y) {
            return new Fraction3(x.compare(y));
          },
          "Complex, Complex": function ComplexComplex() {
            throw new TypeError("No ordering relation is defined for complex numbers");
          }
        }, compareUnits, matrixAlgorithmSuite({
          SS: matAlgo05xSfSf,
          DS: matAlgo03xDSf,
          Ss: matAlgo12xSfs
        }));
      });
      var createCompareNumber = exports.createCompareNumber = /* @__PURE__ */ (0, _factory.factory)(name18, ["typed", "config"], function(_ref2) {
        var typed2 = _ref2.typed, config4 = _ref2.config;
        return typed2(name18, {
          "number, number": function numberNumber(x, y) {
            return (0, _number.nearlyEqual)(x, y, config4.epsilon) ? 0 : x > y ? 1 : -1;
          }
        });
      });
    }
  });

  // node_modules/.pnpm/javascript-natural-sort@0.7.1/node_modules/javascript-natural-sort/naturalSort.js
  var require_naturalSort = __commonJS({
    "node_modules/.pnpm/javascript-natural-sort@0.7.1/node_modules/javascript-natural-sort/naturalSort.js"(exports, module) {
      module.exports = function naturalSort(a, b) {
        "use strict";
        var re = /(^([+\-]?(?:0|[1-9]\d*)(?:\.\d*)?(?:[eE][+\-]?\d+)?)?$|^0x[0-9a-f]+$|\d+)/gi, sre = /(^[ ]*|[ ]*$)/g, dre = /(^([\w ]+,?[\w ]+)?[\w ]+,?[\w ]+\d+:\d+(:\d+)?[\w ]?|^\d{1,4}[\/\-]\d{1,4}[\/\-]\d{1,4}|^\w+, \w+ \d+, \d{4})/, hre = /^0x[0-9a-f]+$/i, ore = /^0/, i = function(s) {
          return naturalSort.insensitive && ("" + s).toLowerCase() || "" + s;
        }, x = i(a).replace(sre, "") || "", y = i(b).replace(sre, "") || "", xN = x.replace(re, "\0$1\0").replace(/\0$/, "").replace(/^\0/, "").split("\0"), yN = y.replace(re, "\0$1\0").replace(/\0$/, "").replace(/^\0/, "").split("\0"), xD = parseInt(x.match(hre), 16) || xN.length !== 1 && x.match(dre) && Date.parse(x), yD = parseInt(y.match(hre), 16) || xD && y.match(dre) && Date.parse(y) || null, oFxNcL, oFyNcL;
        if (yD) {
          if (xD < yD) {
            return -1;
          } else if (xD > yD) {
            return 1;
          }
        }
        for (var cLoc = 0, numS = Math.max(xN.length, yN.length); cLoc < numS; cLoc++) {
          oFxNcL = !(xN[cLoc] || "").match(ore) && parseFloat(xN[cLoc]) || xN[cLoc] || 0;
          oFyNcL = !(yN[cLoc] || "").match(ore) && parseFloat(yN[cLoc]) || yN[cLoc] || 0;
          if (isNaN(oFxNcL) !== isNaN(oFyNcL)) {
            return isNaN(oFxNcL) ? 1 : -1;
          } else if (typeof oFxNcL !== typeof oFyNcL) {
            oFxNcL += "";
            oFyNcL += "";
          }
          if (oFxNcL < oFyNcL) {
            return -1;
          }
          if (oFxNcL > oFyNcL) {
            return 1;
          }
        }
        return 0;
      };
    }
  });

  // node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/function/relational/compareNatural.js
  var require_compareNatural = __commonJS({
    "node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/function/relational/compareNatural.js"(exports) {
      "use strict";
      var _interopRequireDefault = require_interopRequireDefault();
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.createCompareNatural = void 0;
      var _javascriptNaturalSort = _interopRequireDefault(require_naturalSort());
      var _is = require_is();
      var _factory = require_factory();
      var name18 = "compareNatural";
      var dependencies19 = ["typed", "compare"];
      var createCompareNatural2 = exports.createCompareNatural = /* @__PURE__ */ (0, _factory.factory)(name18, dependencies19, function(_ref) {
        var typed2 = _ref.typed, compare = _ref.compare;
        var compareBooleans = compare.signatures["boolean,boolean"];
        return typed2(name18, {
          "any, any": _compareNatural
        });
        function _compareNatural(x, y) {
          var typeX = (0, _is.typeOf)(x);
          var typeY = (0, _is.typeOf)(y);
          var c;
          if ((typeX === "number" || typeX === "BigNumber" || typeX === "Fraction") && (typeY === "number" || typeY === "BigNumber" || typeY === "Fraction")) {
            c = compare(x, y);
            if (c.toString() !== "0") {
              return c > 0 ? 1 : -1;
            } else {
              return (0, _javascriptNaturalSort["default"])(typeX, typeY);
            }
          }
          var matTypes = ["Array", "DenseMatrix", "SparseMatrix"];
          if (matTypes.includes(typeX) || matTypes.includes(typeY)) {
            c = compareMatricesAndArrays(_compareNatural, x, y);
            if (c !== 0) {
              return c;
            } else {
              return (0, _javascriptNaturalSort["default"])(typeX, typeY);
            }
          }
          if (typeX !== typeY) {
            return (0, _javascriptNaturalSort["default"])(typeX, typeY);
          }
          if (typeX === "Complex") {
            return compareComplexNumbers(x, y);
          }
          if (typeX === "Unit") {
            if (x.equalBase(y)) {
              return _compareNatural(x.value, y.value);
            }
            return compareArrays(_compareNatural, x.formatUnits(), y.formatUnits());
          }
          if (typeX === "boolean") {
            return compareBooleans(x, y);
          }
          if (typeX === "string") {
            return (0, _javascriptNaturalSort["default"])(x, y);
          }
          if (typeX === "Object") {
            return compareObjects(_compareNatural, x, y);
          }
          if (typeX === "null") {
            return 0;
          }
          if (typeX === "undefined") {
            return 0;
          }
          throw new TypeError('Unsupported type of value "' + typeX + '"');
        }
        function compareMatricesAndArrays(compareNatural, x, y) {
          if ((0, _is.isSparseMatrix)(x) && (0, _is.isSparseMatrix)(y)) {
            return compareArrays(compareNatural, x.toJSON().values, y.toJSON().values);
          }
          if ((0, _is.isSparseMatrix)(x)) {
            return compareMatricesAndArrays(compareNatural, x.toArray(), y);
          }
          if ((0, _is.isSparseMatrix)(y)) {
            return compareMatricesAndArrays(compareNatural, x, y.toArray());
          }
          if ((0, _is.isDenseMatrix)(x)) {
            return compareMatricesAndArrays(compareNatural, x.toJSON().data, y);
          }
          if ((0, _is.isDenseMatrix)(y)) {
            return compareMatricesAndArrays(compareNatural, x, y.toJSON().data);
          }
          if (!Array.isArray(x)) {
            return compareMatricesAndArrays(compareNatural, [x], y);
          }
          if (!Array.isArray(y)) {
            return compareMatricesAndArrays(compareNatural, x, [y]);
          }
          return compareArrays(compareNatural, x, y);
        }
        function compareArrays(compareNatural, x, y) {
          for (var i = 0, ii = Math.min(x.length, y.length); i < ii; i++) {
            var v = compareNatural(x[i], y[i]);
            if (v !== 0) {
              return v;
            }
          }
          if (x.length > y.length) {
            return 1;
          }
          if (x.length < y.length) {
            return -1;
          }
          return 0;
        }
        function compareObjects(compareNatural, x, y) {
          var keysX = Object.keys(x);
          var keysY = Object.keys(y);
          keysX.sort(_javascriptNaturalSort["default"]);
          keysY.sort(_javascriptNaturalSort["default"]);
          var c = compareArrays(compareNatural, keysX, keysY);
          if (c !== 0) {
            return c;
          }
          for (var i = 0; i < keysX.length; i++) {
            var v = compareNatural(x[keysX[i]], y[keysY[i]]);
            if (v !== 0) {
              return v;
            }
          }
          return 0;
        }
      });
      function compareComplexNumbers(x, y) {
        if (x.re > y.re) {
          return 1;
        }
        if (x.re < y.re) {
          return -1;
        }
        if (x.im > y.im) {
          return 1;
        }
        if (x.im < y.im) {
          return -1;
        }
        return 0;
      }
    }
  });

  // node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/function/relational/compareText.js
  var require_compareText = __commonJS({
    "node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/function/relational/compareText.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.createCompareTextNumber = exports.createCompareText = void 0;
      var _string = require_string();
      var _factory = require_factory();
      var _matrixAlgorithmSuite = require_matrixAlgorithmSuite();
      var name18 = "compareText";
      var dependencies19 = ["typed", "matrix", "concat"];
      _string.compareText.signature = "any, any";
      var createCompareText2 = exports.createCompareText = /* @__PURE__ */ (0, _factory.factory)(name18, dependencies19, function(_ref) {
        var typed2 = _ref.typed, matrix2 = _ref.matrix, concat2 = _ref.concat;
        var matrixAlgorithmSuite = (0, _matrixAlgorithmSuite.createMatrixAlgorithmSuite)({
          typed: typed2,
          matrix: matrix2,
          concat: concat2
        });
        return typed2(name18, _string.compareText, matrixAlgorithmSuite({
          elop: _string.compareText,
          Ds: true
        }));
      });
      var createCompareTextNumber = exports.createCompareTextNumber = /* @__PURE__ */ (0, _factory.factory)(name18, ["typed"], function(_ref2) {
        var typed2 = _ref2.typed;
        return typed2(name18, _string.compareText);
      });
    }
  });

  // node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/function/relational/equal.js
  var require_equal = __commonJS({
    "node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/function/relational/equal.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.createEqualNumber = exports.createEqual = void 0;
      var _factory = require_factory();
      var _matAlgo03xDSf = require_matAlgo03xDSf();
      var _matAlgo07xSSf = require_matAlgo07xSSf();
      var _matAlgo12xSfs = require_matAlgo12xSfs();
      var _matrixAlgorithmSuite = require_matrixAlgorithmSuite();
      var name18 = "equal";
      var dependencies19 = ["typed", "matrix", "equalScalar", "DenseMatrix", "concat"];
      var createEqual2 = exports.createEqual = /* @__PURE__ */ (0, _factory.factory)(name18, dependencies19, function(_ref) {
        var typed2 = _ref.typed, matrix2 = _ref.matrix, equalScalar2 = _ref.equalScalar, DenseMatrix2 = _ref.DenseMatrix, concat2 = _ref.concat;
        var matAlgo03xDSf = (0, _matAlgo03xDSf.createMatAlgo03xDSf)({
          typed: typed2
        });
        var matAlgo07xSSf = (0, _matAlgo07xSSf.createMatAlgo07xSSf)({
          typed: typed2,
          DenseMatrix: DenseMatrix2
        });
        var matAlgo12xSfs = (0, _matAlgo12xSfs.createMatAlgo12xSfs)({
          typed: typed2,
          DenseMatrix: DenseMatrix2
        });
        var matrixAlgorithmSuite = (0, _matrixAlgorithmSuite.createMatrixAlgorithmSuite)({
          typed: typed2,
          matrix: matrix2,
          concat: concat2
        });
        return typed2(name18, createEqualNumber({
          typed: typed2,
          equalScalar: equalScalar2
        }), matrixAlgorithmSuite({
          elop: equalScalar2,
          SS: matAlgo07xSSf,
          DS: matAlgo03xDSf,
          Ss: matAlgo12xSfs
        }));
      });
      var createEqualNumber = exports.createEqualNumber = (0, _factory.factory)(name18, ["typed", "equalScalar"], function(_ref2) {
        var typed2 = _ref2.typed, equalScalar2 = _ref2.equalScalar;
        return typed2(name18, {
          "any, any": function anyAny(x, y) {
            if (x === null) {
              return y === null;
            }
            if (y === null) {
              return x === null;
            }
            if (x === void 0) {
              return y === void 0;
            }
            if (y === void 0) {
              return x === void 0;
            }
            return equalScalar2(x, y);
          }
        });
      });
    }
  });

  // node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/function/relational/equalText.js
  var require_equalText = __commonJS({
    "node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/function/relational/equalText.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.createEqualText = void 0;
      var _factory = require_factory();
      var name18 = "equalText";
      var dependencies19 = ["typed", "compareText", "isZero"];
      var createEqualText2 = exports.createEqualText = /* @__PURE__ */ (0, _factory.factory)(name18, dependencies19, function(_ref) {
        var typed2 = _ref.typed, compareText = _ref.compareText, isZero = _ref.isZero;
        return typed2(name18, {
          "any, any": function anyAny(x, y) {
            return isZero(compareText(x, y));
          }
        });
      });
    }
  });

  // node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/function/relational/smaller.js
  var require_smaller = __commonJS({
    "node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/function/relational/smaller.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.createSmallerNumber = exports.createSmaller = void 0;
      var _nearlyEqual = require_nearlyEqual();
      var _number = require_number();
      var _factory = require_factory();
      var _matAlgo03xDSf = require_matAlgo03xDSf();
      var _matAlgo07xSSf = require_matAlgo07xSSf();
      var _matAlgo12xSfs = require_matAlgo12xSfs();
      var _matrixAlgorithmSuite = require_matrixAlgorithmSuite();
      var _compareUnits = require_compareUnits();
      var name18 = "smaller";
      var dependencies19 = ["typed", "config", "matrix", "DenseMatrix", "concat"];
      var createSmaller2 = exports.createSmaller = /* @__PURE__ */ (0, _factory.factory)(name18, dependencies19, function(_ref) {
        var typed2 = _ref.typed, config4 = _ref.config, matrix2 = _ref.matrix, DenseMatrix2 = _ref.DenseMatrix, concat2 = _ref.concat;
        var matAlgo03xDSf = (0, _matAlgo03xDSf.createMatAlgo03xDSf)({
          typed: typed2
        });
        var matAlgo07xSSf = (0, _matAlgo07xSSf.createMatAlgo07xSSf)({
          typed: typed2,
          DenseMatrix: DenseMatrix2
        });
        var matAlgo12xSfs = (0, _matAlgo12xSfs.createMatAlgo12xSfs)({
          typed: typed2,
          DenseMatrix: DenseMatrix2
        });
        var matrixAlgorithmSuite = (0, _matrixAlgorithmSuite.createMatrixAlgorithmSuite)({
          typed: typed2,
          matrix: matrix2,
          concat: concat2
        });
        var compareUnits = (0, _compareUnits.createCompareUnits)({
          typed: typed2
        });
        return typed2(name18, createSmallerNumber({
          typed: typed2,
          config: config4
        }), {
          "boolean, boolean": function booleanBoolean(x, y) {
            return x < y;
          },
          "BigNumber, BigNumber": function BigNumberBigNumber(x, y) {
            return x.lt(y) && !(0, _nearlyEqual.nearlyEqual)(x, y, config4.epsilon);
          },
          "Fraction, Fraction": function FractionFraction(x, y) {
            return x.compare(y) === -1;
          },
          "Complex, Complex": function ComplexComplex(x, y) {
            throw new TypeError("No ordering relation is defined for complex numbers");
          }
        }, compareUnits, matrixAlgorithmSuite({
          SS: matAlgo07xSSf,
          DS: matAlgo03xDSf,
          Ss: matAlgo12xSfs
        }));
      });
      var createSmallerNumber = exports.createSmallerNumber = /* @__PURE__ */ (0, _factory.factory)(name18, ["typed", "config"], function(_ref2) {
        var typed2 = _ref2.typed, config4 = _ref2.config;
        return typed2(name18, {
          "number, number": function numberNumber(x, y) {
            return x < y && !(0, _number.nearlyEqual)(x, y, config4.epsilon);
          }
        });
      });
    }
  });

  // node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/function/relational/smallerEq.js
  var require_smallerEq = __commonJS({
    "node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/function/relational/smallerEq.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.createSmallerEqNumber = exports.createSmallerEq = void 0;
      var _nearlyEqual = require_nearlyEqual();
      var _number = require_number();
      var _factory = require_factory();
      var _matAlgo03xDSf = require_matAlgo03xDSf();
      var _matAlgo07xSSf = require_matAlgo07xSSf();
      var _matAlgo12xSfs = require_matAlgo12xSfs();
      var _matrixAlgorithmSuite = require_matrixAlgorithmSuite();
      var _compareUnits = require_compareUnits();
      var name18 = "smallerEq";
      var dependencies19 = ["typed", "config", "matrix", "DenseMatrix", "concat"];
      var createSmallerEq2 = exports.createSmallerEq = /* @__PURE__ */ (0, _factory.factory)(name18, dependencies19, function(_ref) {
        var typed2 = _ref.typed, config4 = _ref.config, matrix2 = _ref.matrix, DenseMatrix2 = _ref.DenseMatrix, concat2 = _ref.concat;
        var matAlgo03xDSf = (0, _matAlgo03xDSf.createMatAlgo03xDSf)({
          typed: typed2
        });
        var matAlgo07xSSf = (0, _matAlgo07xSSf.createMatAlgo07xSSf)({
          typed: typed2,
          DenseMatrix: DenseMatrix2
        });
        var matAlgo12xSfs = (0, _matAlgo12xSfs.createMatAlgo12xSfs)({
          typed: typed2,
          DenseMatrix: DenseMatrix2
        });
        var matrixAlgorithmSuite = (0, _matrixAlgorithmSuite.createMatrixAlgorithmSuite)({
          typed: typed2,
          matrix: matrix2,
          concat: concat2
        });
        var compareUnits = (0, _compareUnits.createCompareUnits)({
          typed: typed2
        });
        return typed2(name18, createSmallerEqNumber({
          typed: typed2,
          config: config4
        }), {
          "boolean, boolean": function booleanBoolean(x, y) {
            return x <= y;
          },
          "BigNumber, BigNumber": function BigNumberBigNumber(x, y) {
            return x.lte(y) || (0, _nearlyEqual.nearlyEqual)(x, y, config4.epsilon);
          },
          "Fraction, Fraction": function FractionFraction(x, y) {
            return x.compare(y) !== 1;
          },
          "Complex, Complex": function ComplexComplex() {
            throw new TypeError("No ordering relation is defined for complex numbers");
          }
        }, compareUnits, matrixAlgorithmSuite({
          SS: matAlgo07xSSf,
          DS: matAlgo03xDSf,
          Ss: matAlgo12xSfs
        }));
      });
      var createSmallerEqNumber = exports.createSmallerEqNumber = /* @__PURE__ */ (0, _factory.factory)(name18, ["typed", "config"], function(_ref2) {
        var typed2 = _ref2.typed, config4 = _ref2.config;
        return typed2(name18, {
          "number, number": function numberNumber(x, y) {
            return x <= y || (0, _number.nearlyEqual)(x, y, config4.epsilon);
          }
        });
      });
    }
  });

  // node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/function/relational/larger.js
  var require_larger = __commonJS({
    "node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/function/relational/larger.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.createLargerNumber = exports.createLarger = void 0;
      var _nearlyEqual = require_nearlyEqual();
      var _number = require_number();
      var _factory = require_factory();
      var _matAlgo03xDSf = require_matAlgo03xDSf();
      var _matAlgo07xSSf = require_matAlgo07xSSf();
      var _matAlgo12xSfs = require_matAlgo12xSfs();
      var _matrixAlgorithmSuite = require_matrixAlgorithmSuite();
      var _compareUnits = require_compareUnits();
      var name18 = "larger";
      var dependencies19 = ["typed", "config", "matrix", "DenseMatrix", "concat"];
      var createLarger2 = exports.createLarger = /* @__PURE__ */ (0, _factory.factory)(name18, dependencies19, function(_ref) {
        var typed2 = _ref.typed, config4 = _ref.config, matrix2 = _ref.matrix, DenseMatrix2 = _ref.DenseMatrix, concat2 = _ref.concat;
        var matAlgo03xDSf = (0, _matAlgo03xDSf.createMatAlgo03xDSf)({
          typed: typed2
        });
        var matAlgo07xSSf = (0, _matAlgo07xSSf.createMatAlgo07xSSf)({
          typed: typed2,
          DenseMatrix: DenseMatrix2
        });
        var matAlgo12xSfs = (0, _matAlgo12xSfs.createMatAlgo12xSfs)({
          typed: typed2,
          DenseMatrix: DenseMatrix2
        });
        var matrixAlgorithmSuite = (0, _matrixAlgorithmSuite.createMatrixAlgorithmSuite)({
          typed: typed2,
          matrix: matrix2,
          concat: concat2
        });
        var compareUnits = (0, _compareUnits.createCompareUnits)({
          typed: typed2
        });
        return typed2(name18, createLargerNumber({
          typed: typed2,
          config: config4
        }), {
          "boolean, boolean": function booleanBoolean(x, y) {
            return x > y;
          },
          "BigNumber, BigNumber": function BigNumberBigNumber(x, y) {
            return x.gt(y) && !(0, _nearlyEqual.nearlyEqual)(x, y, config4.epsilon);
          },
          "Fraction, Fraction": function FractionFraction(x, y) {
            return x.compare(y) === 1;
          },
          "Complex, Complex": function ComplexComplex() {
            throw new TypeError("No ordering relation is defined for complex numbers");
          }
        }, compareUnits, matrixAlgorithmSuite({
          SS: matAlgo07xSSf,
          DS: matAlgo03xDSf,
          Ss: matAlgo12xSfs
        }));
      });
      var createLargerNumber = exports.createLargerNumber = /* @__PURE__ */ (0, _factory.factory)(name18, ["typed", "config"], function(_ref2) {
        var typed2 = _ref2.typed, config4 = _ref2.config;
        return typed2(name18, {
          "number, number": function numberNumber(x, y) {
            return x > y && !(0, _number.nearlyEqual)(x, y, config4.epsilon);
          }
        });
      });
    }
  });

  // node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/function/relational/largerEq.js
  var require_largerEq = __commonJS({
    "node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/function/relational/largerEq.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.createLargerEqNumber = exports.createLargerEq = void 0;
      var _nearlyEqual = require_nearlyEqual();
      var _number = require_number();
      var _factory = require_factory();
      var _matAlgo03xDSf = require_matAlgo03xDSf();
      var _matAlgo07xSSf = require_matAlgo07xSSf();
      var _matAlgo12xSfs = require_matAlgo12xSfs();
      var _matrixAlgorithmSuite = require_matrixAlgorithmSuite();
      var _compareUnits = require_compareUnits();
      var name18 = "largerEq";
      var dependencies19 = ["typed", "config", "matrix", "DenseMatrix", "concat"];
      var createLargerEq2 = exports.createLargerEq = /* @__PURE__ */ (0, _factory.factory)(name18, dependencies19, function(_ref) {
        var typed2 = _ref.typed, config4 = _ref.config, matrix2 = _ref.matrix, DenseMatrix2 = _ref.DenseMatrix, concat2 = _ref.concat;
        var matAlgo03xDSf = (0, _matAlgo03xDSf.createMatAlgo03xDSf)({
          typed: typed2
        });
        var matAlgo07xSSf = (0, _matAlgo07xSSf.createMatAlgo07xSSf)({
          typed: typed2,
          DenseMatrix: DenseMatrix2
        });
        var matAlgo12xSfs = (0, _matAlgo12xSfs.createMatAlgo12xSfs)({
          typed: typed2,
          DenseMatrix: DenseMatrix2
        });
        var matrixAlgorithmSuite = (0, _matrixAlgorithmSuite.createMatrixAlgorithmSuite)({
          typed: typed2,
          matrix: matrix2,
          concat: concat2
        });
        var compareUnits = (0, _compareUnits.createCompareUnits)({
          typed: typed2
        });
        return typed2(name18, createLargerEqNumber({
          typed: typed2,
          config: config4
        }), {
          "boolean, boolean": function booleanBoolean(x, y) {
            return x >= y;
          },
          "BigNumber, BigNumber": function BigNumberBigNumber(x, y) {
            return x.gte(y) || (0, _nearlyEqual.nearlyEqual)(x, y, config4.epsilon);
          },
          "Fraction, Fraction": function FractionFraction(x, y) {
            return x.compare(y) !== -1;
          },
          "Complex, Complex": function ComplexComplex() {
            throw new TypeError("No ordering relation is defined for complex numbers");
          }
        }, compareUnits, matrixAlgorithmSuite({
          SS: matAlgo07xSSf,
          DS: matAlgo03xDSf,
          Ss: matAlgo12xSfs
        }));
      });
      var createLargerEqNumber = exports.createLargerEqNumber = /* @__PURE__ */ (0, _factory.factory)(name18, ["typed", "config"], function(_ref2) {
        var typed2 = _ref2.typed, config4 = _ref2.config;
        return typed2(name18, {
          "number, number": function numberNumber(x, y) {
            return x >= y || (0, _number.nearlyEqual)(x, y, config4.epsilon);
          }
        });
      });
    }
  });

  // node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/function/relational/deepEqual.js
  var require_deepEqual = __commonJS({
    "node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/function/relational/deepEqual.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.createDeepEqual = void 0;
      var _factory = require_factory();
      var name18 = "deepEqual";
      var dependencies19 = ["typed", "equal"];
      var createDeepEqual2 = exports.createDeepEqual = /* @__PURE__ */ (0, _factory.factory)(name18, dependencies19, function(_ref) {
        var typed2 = _ref.typed, equal = _ref.equal;
        return typed2(name18, {
          "any, any": function anyAny(x, y) {
            return _deepEqual(x.valueOf(), y.valueOf());
          }
        });
        function _deepEqual(x, y) {
          if (Array.isArray(x)) {
            if (Array.isArray(y)) {
              var len = x.length;
              if (len !== y.length) {
                return false;
              }
              for (var i = 0; i < len; i++) {
                if (!_deepEqual(x[i], y[i])) {
                  return false;
                }
              }
              return true;
            } else {
              return false;
            }
          } else {
            if (Array.isArray(y)) {
              return false;
            } else {
              return equal(x, y);
            }
          }
        }
      });
    }
  });

  // node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/function/relational/unequal.js
  var require_unequal = __commonJS({
    "node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/function/relational/unequal.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.createUnequalNumber = exports.createUnequal = void 0;
      var _factory = require_factory();
      var _matAlgo03xDSf = require_matAlgo03xDSf();
      var _matAlgo07xSSf = require_matAlgo07xSSf();
      var _matAlgo12xSfs = require_matAlgo12xSfs();
      var _matrixAlgorithmSuite = require_matrixAlgorithmSuite();
      var name18 = "unequal";
      var dependencies19 = ["typed", "config", "equalScalar", "matrix", "DenseMatrix", "concat"];
      var createUnequal2 = exports.createUnequal = /* @__PURE__ */ (0, _factory.factory)(name18, dependencies19, function(_ref) {
        var typed2 = _ref.typed, config4 = _ref.config, equalScalar2 = _ref.equalScalar, matrix2 = _ref.matrix, DenseMatrix2 = _ref.DenseMatrix, concat2 = _ref.concat;
        var matAlgo03xDSf = (0, _matAlgo03xDSf.createMatAlgo03xDSf)({
          typed: typed2
        });
        var matAlgo07xSSf = (0, _matAlgo07xSSf.createMatAlgo07xSSf)({
          typed: typed2,
          DenseMatrix: DenseMatrix2
        });
        var matAlgo12xSfs = (0, _matAlgo12xSfs.createMatAlgo12xSfs)({
          typed: typed2,
          DenseMatrix: DenseMatrix2
        });
        var matrixAlgorithmSuite = (0, _matrixAlgorithmSuite.createMatrixAlgorithmSuite)({
          typed: typed2,
          matrix: matrix2,
          concat: concat2
        });
        return typed2(name18, createUnequalNumber({
          typed: typed2,
          equalScalar: equalScalar2
        }), matrixAlgorithmSuite({
          elop: _unequal,
          SS: matAlgo07xSSf,
          DS: matAlgo03xDSf,
          Ss: matAlgo12xSfs
        }));
        function _unequal(x, y) {
          return !equalScalar2(x, y);
        }
      });
      var createUnequalNumber = exports.createUnequalNumber = (0, _factory.factory)(name18, ["typed", "equalScalar"], function(_ref2) {
        var typed2 = _ref2.typed, equalScalar2 = _ref2.equalScalar;
        return typed2(name18, {
          "any, any": function anyAny(x, y) {
            if (x === null) {
              return y !== null;
            }
            if (y === null) {
              return x !== null;
            }
            if (x === void 0) {
              return y !== void 0;
            }
            if (y === void 0) {
              return x !== void 0;
            }
            return !equalScalar2(x, y);
          }
        });
      });
    }
  });

  // node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/function/matrix/partitionSelect.js
  var require_partitionSelect = __commonJS({
    "node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/function/matrix/partitionSelect.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.createPartitionSelect = void 0;
      var _is = require_is();
      var _number = require_number();
      var _factory = require_factory();
      var name18 = "partitionSelect";
      var dependencies19 = ["typed", "isNumeric", "isNaN", "compare"];
      var createPartitionSelect2 = exports.createPartitionSelect = /* @__PURE__ */ (0, _factory.factory)(name18, dependencies19, function(_ref) {
        var typed2 = _ref.typed, isNumeric = _ref.isNumeric, isNaN2 = _ref.isNaN, compare = _ref.compare;
        var asc = compare;
        var desc = function desc2(a, b) {
          return -compare(a, b);
        };
        return typed2(name18, {
          "Array | Matrix, number": function ArrayMatrixNumber(x, k) {
            return _partitionSelect(x, k, asc);
          },
          "Array | Matrix, number, string": function ArrayMatrixNumberString(x, k, compare2) {
            if (compare2 === "asc") {
              return _partitionSelect(x, k, asc);
            } else if (compare2 === "desc") {
              return _partitionSelect(x, k, desc);
            } else {
              throw new Error('Compare string must be "asc" or "desc"');
            }
          },
          "Array | Matrix, number, function": _partitionSelect
        });
        function _partitionSelect(x, k, compare2) {
          if (!(0, _number.isInteger)(k) || k < 0) {
            throw new Error("k must be a non-negative integer");
          }
          if ((0, _is.isMatrix)(x)) {
            var size2 = x.size();
            if (size2.length > 1) {
              throw new Error("Only one dimensional matrices supported");
            }
            return quickSelect(x.valueOf(), k, compare2);
          }
          if (Array.isArray(x)) {
            return quickSelect(x, k, compare2);
          }
        }
        function quickSelect(arr, k, compare2) {
          if (k >= arr.length) {
            throw new Error("k out of bounds");
          }
          for (var i = 0; i < arr.length; i++) {
            if (isNumeric(arr[i]) && isNaN2(arr[i])) {
              return arr[i];
            }
          }
          var from = 0;
          var to = arr.length - 1;
          while (from < to) {
            var r = from;
            var w = to;
            var pivot = arr[Math.floor(Math.random() * (to - from + 1)) + from];
            while (r < w) {
              if (compare2(arr[r], pivot) >= 0) {
                var tmp = arr[w];
                arr[w] = arr[r];
                arr[r] = tmp;
                --w;
              } else {
                ++r;
              }
            }
            if (compare2(arr[r], pivot) > 0) {
              --r;
            }
            if (k <= r) {
              to = r;
            } else {
              from = r + 1;
            }
          }
          return arr[k];
        }
      });
    }
  });

  // node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/function/matrix/sort.js
  var require_sort = __commonJS({
    "node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/function/matrix/sort.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.createSort = void 0;
      var _array = require_array();
      var _factory = require_factory();
      var name18 = "sort";
      var dependencies19 = ["typed", "matrix", "compare", "compareNatural"];
      var createSort2 = exports.createSort = /* @__PURE__ */ (0, _factory.factory)(name18, dependencies19, function(_ref) {
        var typed2 = _ref.typed, matrix2 = _ref.matrix, compare = _ref.compare, compareNatural = _ref.compareNatural;
        var compareAsc = compare;
        var compareDesc = function compareDesc2(a, b) {
          return -compare(a, b);
        };
        return typed2(name18, {
          Array: function Array2(x) {
            _arrayIsVector(x);
            return x.sort(compareAsc);
          },
          Matrix: function Matrix2(x) {
            _matrixIsVector(x);
            return matrix2(x.toArray().sort(compareAsc), x.storage());
          },
          "Array, function": function ArrayFunction(x, _comparator2) {
            _arrayIsVector(x);
            return x.sort(_comparator2);
          },
          "Matrix, function": function MatrixFunction(x, _comparator2) {
            _matrixIsVector(x);
            return matrix2(x.toArray().sort(_comparator2), x.storage());
          },
          "Array, string": function ArrayString(x, order) {
            _arrayIsVector(x);
            return x.sort(_comparator(order));
          },
          "Matrix, string": function MatrixString(x, order) {
            _matrixIsVector(x);
            return matrix2(x.toArray().sort(_comparator(order)), x.storage());
          }
        });
        function _comparator(order) {
          if (order === "asc") {
            return compareAsc;
          } else if (order === "desc") {
            return compareDesc;
          } else if (order === "natural") {
            return compareNatural;
          } else {
            throw new Error('String "asc", "desc", or "natural" expected');
          }
        }
        function _arrayIsVector(array) {
          if ((0, _array.arraySize)(array).length !== 1) {
            throw new Error("One dimensional array expected");
          }
        }
        function _matrixIsVector(matrix3) {
          if (matrix3.size().length !== 1) {
            throw new Error("One dimensional matrix expected");
          }
        }
      });
    }
  });

  // node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/function/statistics/max.js
  var require_max = __commonJS({
    "node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/function/statistics/max.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.createMax = void 0;
      var _collection = require_collection();
      var _factory = require_factory();
      var _improveErrorMessage = require_improveErrorMessage();
      var name18 = "max";
      var dependencies19 = ["typed", "config", "numeric", "larger"];
      var createMax2 = exports.createMax = /* @__PURE__ */ (0, _factory.factory)(name18, dependencies19, function(_ref) {
        var typed2 = _ref.typed, config4 = _ref.config, numeric = _ref.numeric, larger = _ref.larger;
        return typed2(name18, {
          // max([a, b, c, d, ...])
          "Array | Matrix": _max,
          // max([a, b, c, d, ...], dim)
          "Array | Matrix, number | BigNumber": function ArrayMatrixNumberBigNumber(array, dim) {
            return (0, _collection.reduce)(array, dim.valueOf(), _largest);
          },
          // max(a, b, c, d, ...)
          "...": function _(args) {
            if ((0, _collection.containsCollections)(args)) {
              throw new TypeError("Scalar values expected in function max");
            }
            return _max(args);
          }
        });
        function _largest(x, y) {
          try {
            return larger(x, y) ? x : y;
          } catch (err) {
            throw (0, _improveErrorMessage.improveErrorMessage)(err, "max", y);
          }
        }
        function _max(array) {
          var res;
          (0, _collection.deepForEach)(array, function(value) {
            try {
              if (isNaN(value) && typeof value === "number") {
                res = NaN;
              } else if (res === void 0 || larger(value, res)) {
                res = value;
              }
            } catch (err) {
              throw (0, _improveErrorMessage.improveErrorMessage)(err, "max", value);
            }
          });
          if (res === void 0) {
            throw new Error("Cannot calculate max of an empty array");
          }
          if (typeof res === "string") {
            res = numeric(res, config4.number);
          }
          return res;
        }
      });
    }
  });

  // node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/function/statistics/min.js
  var require_min = __commonJS({
    "node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/function/statistics/min.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.createMin = void 0;
      var _collection = require_collection();
      var _factory = require_factory();
      var _improveErrorMessage = require_improveErrorMessage();
      var name18 = "min";
      var dependencies19 = ["typed", "config", "numeric", "smaller"];
      var createMin2 = exports.createMin = /* @__PURE__ */ (0, _factory.factory)(name18, dependencies19, function(_ref) {
        var typed2 = _ref.typed, config4 = _ref.config, numeric = _ref.numeric, smaller = _ref.smaller;
        return typed2(name18, {
          // min([a, b, c, d, ...])
          "Array | Matrix": _min,
          // min([a, b, c, d, ...], dim)
          "Array | Matrix, number | BigNumber": function ArrayMatrixNumberBigNumber(array, dim) {
            return (0, _collection.reduce)(array, dim.valueOf(), _smallest);
          },
          // min(a, b, c, d, ...)
          "...": function _(args) {
            if ((0, _collection.containsCollections)(args)) {
              throw new TypeError("Scalar values expected in function min");
            }
            return _min(args);
          }
        });
        function _smallest(x, y) {
          try {
            return smaller(x, y) ? x : y;
          } catch (err) {
            throw (0, _improveErrorMessage.improveErrorMessage)(err, "min", y);
          }
        }
        function _min(array) {
          var min2;
          (0, _collection.deepForEach)(array, function(value) {
            try {
              if (isNaN(value) && typeof value === "number") {
                min2 = NaN;
              } else if (min2 === void 0 || smaller(value, min2)) {
                min2 = value;
              }
            } catch (err) {
              throw (0, _improveErrorMessage.improveErrorMessage)(err, "min", value);
            }
          });
          if (min2 === void 0) {
            throw new Error("Cannot calculate min of an empty array");
          }
          if (typeof min2 === "string") {
            min2 = numeric(min2, config4.number);
          }
          return min2;
        }
      });
    }
  });

  // node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/type/matrix/ImmutableDenseMatrix.js
  var require_ImmutableDenseMatrix = __commonJS({
    "node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/type/matrix/ImmutableDenseMatrix.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.createImmutableDenseMatrixClass = void 0;
      var _is = require_is();
      var _object = require_object();
      var _factory = require_factory();
      var name18 = "ImmutableDenseMatrix";
      var dependencies19 = ["smaller", "DenseMatrix"];
      var createImmutableDenseMatrixClass2 = exports.createImmutableDenseMatrixClass = /* @__PURE__ */ (0, _factory.factory)(name18, dependencies19, function(_ref) {
        var smaller = _ref.smaller, DenseMatrix2 = _ref.DenseMatrix;
        function ImmutableDenseMatrix(data, datatype) {
          if (!(this instanceof ImmutableDenseMatrix)) {
            throw new SyntaxError("Constructor must be called with the new operator");
          }
          if (datatype && !(0, _is.isString)(datatype)) {
            throw new Error("Invalid datatype: " + datatype);
          }
          if ((0, _is.isMatrix)(data) || (0, _is.isArray)(data)) {
            var matrix2 = new DenseMatrix2(data, datatype);
            this._data = matrix2._data;
            this._size = matrix2._size;
            this._datatype = matrix2._datatype;
            this._min = null;
            this._max = null;
          } else if (data && (0, _is.isArray)(data.data) && (0, _is.isArray)(data.size)) {
            this._data = data.data;
            this._size = data.size;
            this._datatype = data.datatype;
            this._min = typeof data.min !== "undefined" ? data.min : null;
            this._max = typeof data.max !== "undefined" ? data.max : null;
          } else if (data) {
            throw new TypeError("Unsupported type of data (" + (0, _is.typeOf)(data) + ")");
          } else {
            this._data = [];
            this._size = [0];
            this._datatype = datatype;
            this._min = null;
            this._max = null;
          }
        }
        ImmutableDenseMatrix.prototype = new DenseMatrix2();
        ImmutableDenseMatrix.prototype.type = "ImmutableDenseMatrix";
        ImmutableDenseMatrix.prototype.isImmutableDenseMatrix = true;
        ImmutableDenseMatrix.prototype.subset = function(index) {
          switch (arguments.length) {
            case 1: {
              var m = DenseMatrix2.prototype.subset.call(this, index);
              if ((0, _is.isMatrix)(m)) {
                return new ImmutableDenseMatrix({
                  data: m._data,
                  size: m._size,
                  datatype: m._datatype
                });
              }
              return m;
            }
            // intentional fall through
            case 2:
            case 3:
              throw new Error("Cannot invoke set subset on an Immutable Matrix instance");
            default:
              throw new SyntaxError("Wrong number of arguments");
          }
        };
        ImmutableDenseMatrix.prototype.set = function() {
          throw new Error("Cannot invoke set on an Immutable Matrix instance");
        };
        ImmutableDenseMatrix.prototype.resize = function() {
          throw new Error("Cannot invoke resize on an Immutable Matrix instance");
        };
        ImmutableDenseMatrix.prototype.reshape = function() {
          throw new Error("Cannot invoke reshape on an Immutable Matrix instance");
        };
        ImmutableDenseMatrix.prototype.clone = function() {
          return new ImmutableDenseMatrix({
            data: (0, _object.clone)(this._data),
            size: (0, _object.clone)(this._size),
            datatype: this._datatype
          });
        };
        ImmutableDenseMatrix.prototype.toJSON = function() {
          return {
            mathjs: "ImmutableDenseMatrix",
            data: this._data,
            size: this._size,
            datatype: this._datatype
          };
        };
        ImmutableDenseMatrix.fromJSON = function(json) {
          return new ImmutableDenseMatrix(json);
        };
        ImmutableDenseMatrix.prototype.swapRows = function() {
          throw new Error("Cannot invoke swapRows on an Immutable Matrix instance");
        };
        ImmutableDenseMatrix.prototype.min = function() {
          if (this._min === null) {
            var m = null;
            this.forEach(function(v) {
              if (m === null || smaller(v, m)) {
                m = v;
              }
            });
            this._min = m !== null ? m : void 0;
          }
          return this._min;
        };
        ImmutableDenseMatrix.prototype.max = function() {
          if (this._max === null) {
            var m = null;
            this.forEach(function(v) {
              if (m === null || smaller(m, v)) {
                m = v;
              }
            });
            this._max = m !== null ? m : void 0;
          }
          return this._max;
        };
        return ImmutableDenseMatrix;
      }, {
        isClass: true
      });
    }
  });

  // node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/type/matrix/MatrixIndex.js
  var require_MatrixIndex = __commonJS({
    "node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/type/matrix/MatrixIndex.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.createIndexClass = void 0;
      var _is = require_is();
      var _object = require_object();
      var _number = require_number();
      var _factory = require_factory();
      var name18 = "Index";
      var dependencies19 = ["ImmutableDenseMatrix", "getMatrixDataType"];
      var createIndexClass2 = exports.createIndexClass = /* @__PURE__ */ (0, _factory.factory)(name18, dependencies19, function(_ref) {
        var ImmutableDenseMatrix = _ref.ImmutableDenseMatrix, getMatrixDataType = _ref.getMatrixDataType;
        function Index(ranges) {
          if (!(this instanceof Index)) {
            throw new SyntaxError("Constructor must be called with the new operator");
          }
          this._dimensions = [];
          this._sourceSize = [];
          this._isScalar = true;
          for (var i = 0, ii = arguments.length; i < ii; i++) {
            var arg = arguments[i];
            var argIsArray = (0, _is.isArray)(arg);
            var argIsMatrix = (0, _is.isMatrix)(arg);
            var sourceSize = null;
            if ((0, _is.isRange)(arg)) {
              this._dimensions.push(arg);
              this._isScalar = false;
            } else if (argIsArray || argIsMatrix) {
              var m = void 0;
              if (getMatrixDataType(arg) === "boolean") {
                if (argIsArray) m = _createImmutableMatrix(_booleansArrayToNumbersForIndex(arg).valueOf());
                if (argIsMatrix) m = _createImmutableMatrix(_booleansArrayToNumbersForIndex(arg._data).valueOf());
                sourceSize = arg.valueOf().length;
              } else {
                m = _createImmutableMatrix(arg.valueOf());
              }
              this._dimensions.push(m);
              var size2 = m.size();
              if (size2.length !== 1 || size2[0] !== 1 || sourceSize !== null) {
                this._isScalar = false;
              }
            } else if (typeof arg === "number") {
              this._dimensions.push(_createImmutableMatrix([arg]));
            } else if (typeof arg === "string") {
              this._dimensions.push(arg);
            } else {
              throw new TypeError("Dimension must be an Array, Matrix, number, string, or Range");
            }
            this._sourceSize.push(sourceSize);
          }
        }
        Index.prototype.type = "Index";
        Index.prototype.isIndex = true;
        function _createImmutableMatrix(arg) {
          for (var i = 0, l = arg.length; i < l; i++) {
            if (typeof arg[i] !== "number" || !(0, _number.isInteger)(arg[i])) {
              throw new TypeError("Index parameters must be positive integer numbers");
            }
          }
          return new ImmutableDenseMatrix(arg);
        }
        Index.prototype.clone = function() {
          var index = new Index();
          index._dimensions = (0, _object.clone)(this._dimensions);
          index._isScalar = this._isScalar;
          index._sourceSize = this._sourceSize;
          return index;
        };
        Index.create = function(ranges) {
          var index = new Index();
          Index.apply(index, ranges);
          return index;
        };
        Index.prototype.size = function() {
          var size2 = [];
          for (var i = 0, ii = this._dimensions.length; i < ii; i++) {
            var d = this._dimensions[i];
            size2[i] = typeof d === "string" ? 1 : d.size()[0];
          }
          return size2;
        };
        Index.prototype.max = function() {
          var values = [];
          for (var i = 0, ii = this._dimensions.length; i < ii; i++) {
            var range = this._dimensions[i];
            values[i] = typeof range === "string" ? range : range.max();
          }
          return values;
        };
        Index.prototype.min = function() {
          var values = [];
          for (var i = 0, ii = this._dimensions.length; i < ii; i++) {
            var range = this._dimensions[i];
            values[i] = typeof range === "string" ? range : range.min();
          }
          return values;
        };
        Index.prototype.forEach = function(callback) {
          for (var i = 0, ii = this._dimensions.length; i < ii; i++) {
            callback(this._dimensions[i], i, this);
          }
        };
        Index.prototype.dimension = function(dim) {
          return this._dimensions[dim] || null;
        };
        Index.prototype.isObjectProperty = function() {
          return this._dimensions.length === 1 && typeof this._dimensions[0] === "string";
        };
        Index.prototype.getObjectProperty = function() {
          return this.isObjectProperty() ? this._dimensions[0] : null;
        };
        Index.prototype.isScalar = function() {
          return this._isScalar;
        };
        Index.prototype.toArray = function() {
          var array = [];
          for (var i = 0, ii = this._dimensions.length; i < ii; i++) {
            var dimension = this._dimensions[i];
            array.push(typeof dimension === "string" ? dimension : dimension.toArray());
          }
          return array;
        };
        Index.prototype.valueOf = Index.prototype.toArray;
        Index.prototype.toString = function() {
          var strings = [];
          for (var i = 0, ii = this._dimensions.length; i < ii; i++) {
            var dimension = this._dimensions[i];
            if (typeof dimension === "string") {
              strings.push(JSON.stringify(dimension));
            } else {
              strings.push(dimension.toString());
            }
          }
          return "[" + strings.join(", ") + "]";
        };
        Index.prototype.toJSON = function() {
          return {
            mathjs: "Index",
            dimensions: this._dimensions
          };
        };
        Index.fromJSON = function(json) {
          return Index.create(json.dimensions);
        };
        return Index;
      }, {
        isClass: true
      });
      function _booleansArrayToNumbersForIndex(booleanArrayIndex) {
        var indexOfNumbers = [];
        booleanArrayIndex.forEach(function(bool, idx) {
          if (bool) {
            indexOfNumbers.push(idx);
          }
        });
        return indexOfNumbers;
      }
    }
  });

  // node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/type/matrix/FibonacciHeap.js
  var require_FibonacciHeap = __commonJS({
    "node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/type/matrix/FibonacciHeap.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.createFibonacciHeapClass = void 0;
      var _factory = require_factory();
      var name18 = "FibonacciHeap";
      var dependencies19 = ["smaller", "larger"];
      var createFibonacciHeapClass2 = exports.createFibonacciHeapClass = /* @__PURE__ */ (0, _factory.factory)(name18, dependencies19, function(_ref) {
        var smaller = _ref.smaller, larger = _ref.larger;
        var oneOverLogPhi = 1 / Math.log((1 + Math.sqrt(5)) / 2);
        function FibonacciHeap() {
          if (!(this instanceof FibonacciHeap)) {
            throw new SyntaxError("Constructor must be called with the new operator");
          }
          this._minimum = null;
          this._size = 0;
        }
        FibonacciHeap.prototype.type = "FibonacciHeap";
        FibonacciHeap.prototype.isFibonacciHeap = true;
        FibonacciHeap.prototype.insert = function(key, value) {
          var node = {
            key,
            value,
            degree: 0
          };
          if (this._minimum) {
            var minimum = this._minimum;
            node.left = minimum;
            node.right = minimum.right;
            minimum.right = node;
            node.right.left = node;
            if (smaller(key, minimum.key)) {
              this._minimum = node;
            }
          } else {
            node.left = node;
            node.right = node;
            this._minimum = node;
          }
          this._size++;
          return node;
        };
        FibonacciHeap.prototype.size = function() {
          return this._size;
        };
        FibonacciHeap.prototype.clear = function() {
          this._minimum = null;
          this._size = 0;
        };
        FibonacciHeap.prototype.isEmpty = function() {
          return this._size === 0;
        };
        FibonacciHeap.prototype.extractMinimum = function() {
          var node = this._minimum;
          if (node === null) {
            return node;
          }
          var minimum = this._minimum;
          var numberOfChildren = node.degree;
          var x = node.child;
          while (numberOfChildren > 0) {
            var tempRight = x.right;
            x.left.right = x.right;
            x.right.left = x.left;
            x.left = minimum;
            x.right = minimum.right;
            minimum.right = x;
            x.right.left = x;
            x.parent = null;
            x = tempRight;
            numberOfChildren--;
          }
          node.left.right = node.right;
          node.right.left = node.left;
          if (node === node.right) {
            minimum = null;
          } else {
            minimum = node.right;
            minimum = _findMinimumNode(minimum, this._size);
          }
          this._size--;
          this._minimum = minimum;
          return node;
        };
        FibonacciHeap.prototype.remove = function(node) {
          this._minimum = _decreaseKey(this._minimum, node, -1);
          this.extractMinimum();
        };
        function _decreaseKey(minimum, node, key) {
          node.key = key;
          var parent = node.parent;
          if (parent && smaller(node.key, parent.key)) {
            _cut(minimum, node, parent);
            _cascadingCut(minimum, parent);
          }
          if (smaller(node.key, minimum.key)) {
            minimum = node;
          }
          return minimum;
        }
        function _cut(minimum, node, parent) {
          node.left.right = node.right;
          node.right.left = node.left;
          parent.degree--;
          if (parent.child === node) {
            parent.child = node.right;
          }
          if (parent.degree === 0) {
            parent.child = null;
          }
          node.left = minimum;
          node.right = minimum.right;
          minimum.right = node;
          node.right.left = node;
          node.parent = null;
          node.mark = false;
        }
        function _cascadingCut(minimum, node) {
          var parent = node.parent;
          if (!parent) {
            return;
          }
          if (!node.mark) {
            node.mark = true;
          } else {
            _cut(minimum, node, parent);
            _cascadingCut(parent);
          }
        }
        var _linkNodes = function _linkNodes2(node, parent) {
          node.left.right = node.right;
          node.right.left = node.left;
          node.parent = parent;
          if (!parent.child) {
            parent.child = node;
            node.right = node;
            node.left = node;
          } else {
            node.left = parent.child;
            node.right = parent.child.right;
            parent.child.right = node;
            node.right.left = node;
          }
          parent.degree++;
          node.mark = false;
        };
        function _findMinimumNode(minimum, size2) {
          var arraySize2 = Math.floor(Math.log(size2) * oneOverLogPhi) + 1;
          var array = new Array(arraySize2);
          var numRoots = 0;
          var x = minimum;
          if (x) {
            numRoots++;
            x = x.right;
            while (x !== minimum) {
              numRoots++;
              x = x.right;
            }
          }
          var y;
          while (numRoots > 0) {
            var d = x.degree;
            var next = x.right;
            while (true) {
              y = array[d];
              if (!y) {
                break;
              }
              if (larger(x.key, y.key)) {
                var temp = y;
                y = x;
                x = temp;
              }
              _linkNodes(y, x);
              array[d] = null;
              d++;
            }
            array[d] = x;
            x = next;
            numRoots--;
          }
          minimum = null;
          for (var i = 0; i < arraySize2; i++) {
            y = array[i];
            if (!y) {
              continue;
            }
            if (minimum) {
              y.left.right = y.right;
              y.right.left = y.left;
              y.left = minimum;
              y.right = minimum.right;
              minimum.right = y;
              y.right.left = y;
              if (smaller(y.key, minimum.key)) {
                minimum = y;
              }
            } else {
              minimum = y;
            }
          }
          return minimum;
        }
        return FibonacciHeap;
      }, {
        isClass: true
      });
    }
  });

  // node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/type/matrix/Spa.js
  var require_Spa = __commonJS({
    "node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/type/matrix/Spa.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.createSpaClass = void 0;
      var _factory = require_factory();
      var name18 = "Spa";
      var dependencies19 = ["addScalar", "equalScalar", "FibonacciHeap"];
      var createSpaClass2 = exports.createSpaClass = /* @__PURE__ */ (0, _factory.factory)(name18, dependencies19, function(_ref) {
        var addScalar2 = _ref.addScalar, equalScalar2 = _ref.equalScalar, FibonacciHeap = _ref.FibonacciHeap;
        function Spa() {
          if (!(this instanceof Spa)) {
            throw new SyntaxError("Constructor must be called with the new operator");
          }
          this._values = [];
          this._heap = new FibonacciHeap();
        }
        Spa.prototype.type = "Spa";
        Spa.prototype.isSpa = true;
        Spa.prototype.set = function(i, v) {
          if (!this._values[i]) {
            var node = this._heap.insert(i, v);
            this._values[i] = node;
          } else {
            this._values[i].value = v;
          }
        };
        Spa.prototype.get = function(i) {
          var node = this._values[i];
          if (node) {
            return node.value;
          }
          return 0;
        };
        Spa.prototype.accumulate = function(i, v) {
          var node = this._values[i];
          if (!node) {
            node = this._heap.insert(i, v);
            this._values[i] = node;
          } else {
            node.value = addScalar2(node.value, v);
          }
        };
        Spa.prototype.forEach = function(from, to, callback) {
          var heap = this._heap;
          var values = this._values;
          var nodes = [];
          var node = heap.extractMinimum();
          if (node) {
            nodes.push(node);
          }
          while (node && node.key <= to) {
            if (node.key >= from) {
              if (!equalScalar2(node.value, 0)) {
                callback(node.key, node.value, this);
              }
            }
            node = heap.extractMinimum();
            if (node) {
              nodes.push(node);
            }
          }
          for (var i = 0; i < nodes.length; i++) {
            var n = nodes[i];
            node = heap.insert(n.key, n.value);
            values[node.key] = node;
          }
        };
        Spa.prototype.swap = function(i, j) {
          var nodei = this._values[i];
          var nodej = this._values[j];
          if (!nodei && nodej) {
            nodei = this._heap.insert(i, nodej.value);
            this._heap.remove(nodej);
            this._values[i] = nodei;
            this._values[j] = void 0;
          } else if (nodei && !nodej) {
            nodej = this._heap.insert(j, nodei.value);
            this._heap.remove(nodei);
            this._values[j] = nodej;
            this._values[i] = void 0;
          } else if (nodei && nodej) {
            var v = nodei.value;
            nodei.value = nodej.value;
            nodej.value = v;
          }
        };
        return Spa;
      }, {
        isClass: true
      });
    }
  });

  // node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/utils/bignumber/constants.js
  var require_constants2 = __commonJS({
    "node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/utils/bignumber/constants.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.createBigNumberTau = exports.createBigNumberPi = exports.createBigNumberPhi = exports.createBigNumberE = void 0;
      var _function = require_function();
      var createBigNumberE = exports.createBigNumberE = (0, _function.memoize)(function(BigNumber2) {
        return new BigNumber2(1).exp();
      }, {
        hasher
      });
      var createBigNumberPhi = exports.createBigNumberPhi = (0, _function.memoize)(function(BigNumber2) {
        return new BigNumber2(1).plus(new BigNumber2(5).sqrt()).div(2);
      }, {
        hasher
      });
      var createBigNumberPi = exports.createBigNumberPi = (0, _function.memoize)(function(BigNumber2) {
        return BigNumber2.acos(-1);
      }, {
        hasher
      });
      var createBigNumberTau = exports.createBigNumberTau = (0, _function.memoize)(function(BigNumber2) {
        return createBigNumberPi(BigNumber2).times(2);
      }, {
        hasher
      });
      function hasher(args) {
        return args[0].precision;
      }
    }
  });

  // node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/type/unit/Unit.js
  var require_Unit = __commonJS({
    "node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/type/unit/Unit.js"(exports) {
      "use strict";
      var _interopRequireDefault = require_interopRequireDefault();
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.createUnitClass = void 0;
      var _typeof2 = _interopRequireDefault(require_typeof());
      var _defineProperty2 = _interopRequireDefault(require_defineProperty());
      var _extends2 = _interopRequireDefault(require_extends());
      var _is = require_is();
      var _factory = require_factory();
      var _function = require_function();
      var _string = require_string();
      var _object = require_object();
      var _constants = require_constants2();
      function ownKeys(e, r) {
        var t = Object.keys(e);
        if (Object.getOwnPropertySymbols) {
          var o = Object.getOwnPropertySymbols(e);
          r && (o = o.filter(function(r2) {
            return Object.getOwnPropertyDescriptor(e, r2).enumerable;
          })), t.push.apply(t, o);
        }
        return t;
      }
      function _objectSpread(e) {
        for (var r = 1; r < arguments.length; r++) {
          var t = null != arguments[r] ? arguments[r] : {};
          r % 2 ? ownKeys(Object(t), true).forEach(function(r2) {
            (0, _defineProperty2["default"])(e, r2, t[r2]);
          }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function(r2) {
            Object.defineProperty(e, r2, Object.getOwnPropertyDescriptor(t, r2));
          });
        }
        return e;
      }
      var name18 = "Unit";
      var dependencies19 = ["?on", "config", "addScalar", "subtractScalar", "multiplyScalar", "divideScalar", "pow", "abs", "fix", "round", "equal", "isNumeric", "format", "number", "Complex", "BigNumber", "Fraction"];
      var createUnitClass2 = exports.createUnitClass = /* @__PURE__ */ (0, _factory.factory)(name18, dependencies19, function(_ref) {
        var on = _ref.on, config4 = _ref.config, addScalar2 = _ref.addScalar, subtractScalar = _ref.subtractScalar, multiplyScalar2 = _ref.multiplyScalar, divideScalar = _ref.divideScalar, pow2 = _ref.pow, abs2 = _ref.abs, fix = _ref.fix, round2 = _ref.round, equal = _ref.equal, isNumeric = _ref.isNumeric, format4 = _ref.format, _number = _ref.number, Complex3 = _ref.Complex, _BigNumber = _ref.BigNumber, _Fraction = _ref.Fraction;
        var toNumber = _number;
        function Unit(value, valuelessUnit) {
          if (!(this instanceof Unit)) {
            throw new Error("Constructor must be called with the new operator");
          }
          if (!(value === null || value === void 0 || isNumeric(value) || (0, _is.isComplex)(value))) {
            throw new TypeError("First parameter in Unit constructor must be number, BigNumber, Fraction, Complex, or undefined");
          }
          this.fixPrefix = false;
          this.skipAutomaticSimplification = true;
          if (valuelessUnit === void 0) {
            this.units = [];
            this.dimensions = BASE_DIMENSIONS.map(function(x) {
              return 0;
            });
          } else if (typeof valuelessUnit === "string") {
            var u = Unit.parse(valuelessUnit);
            this.units = u.units;
            this.dimensions = u.dimensions;
          } else if ((0, _is.isUnit)(valuelessUnit) && valuelessUnit.value === null) {
            this.fixPrefix = valuelessUnit.fixPrefix;
            this.skipAutomaticSimplification = valuelessUnit.skipAutomaticSimplification;
            this.dimensions = valuelessUnit.dimensions.slice(0);
            this.units = valuelessUnit.units.map(function(u2) {
              return (0, _extends2["default"])({}, u2);
            });
          } else {
            throw new TypeError("Second parameter in Unit constructor must be a string or valueless Unit");
          }
          this.value = this._normalize(value);
        }
        Object.defineProperty(Unit, "name", {
          value: "Unit"
        });
        Unit.prototype.constructor = Unit;
        Unit.prototype.type = "Unit";
        Unit.prototype.isUnit = true;
        var text, index, c;
        function skipWhitespace() {
          while (c === " " || c === "	") {
            next();
          }
        }
        function isDigitDot(c2) {
          return c2 >= "0" && c2 <= "9" || c2 === ".";
        }
        function isDigit(c2) {
          return c2 >= "0" && c2 <= "9";
        }
        function next() {
          index++;
          c = text.charAt(index);
        }
        function revert(oldIndex) {
          index = oldIndex;
          c = text.charAt(index);
        }
        function parseNumber() {
          var number = "";
          var oldIndex = index;
          if (c === "+") {
            next();
          } else if (c === "-") {
            number += c;
            next();
          }
          if (!isDigitDot(c)) {
            revert(oldIndex);
            return null;
          }
          if (c === ".") {
            number += c;
            next();
            if (!isDigit(c)) {
              revert(oldIndex);
              return null;
            }
          } else {
            while (isDigit(c)) {
              number += c;
              next();
            }
            if (c === ".") {
              number += c;
              next();
            }
          }
          while (isDigit(c)) {
            number += c;
            next();
          }
          if (c === "E" || c === "e") {
            var tentativeNumber = "";
            var tentativeIndex = index;
            tentativeNumber += c;
            next();
            if (c === "+" || c === "-") {
              tentativeNumber += c;
              next();
            }
            if (!isDigit(c)) {
              revert(tentativeIndex);
              return number;
            }
            number = number + tentativeNumber;
            while (isDigit(c)) {
              number += c;
              next();
            }
          }
          return number;
        }
        function parseUnit() {
          var unitName = "";
          while (isDigit(c) || Unit.isValidAlpha(c)) {
            unitName += c;
            next();
          }
          var firstC = unitName.charAt(0);
          if (Unit.isValidAlpha(firstC)) {
            return unitName;
          } else {
            return null;
          }
        }
        function parseCharacter(toFind) {
          if (c === toFind) {
            next();
            return toFind;
          } else {
            return null;
          }
        }
        Unit.parse = function(str, options) {
          options = options || {};
          text = str;
          index = -1;
          c = "";
          if (typeof text !== "string") {
            throw new TypeError("Invalid argument in Unit.parse, string expected");
          }
          var unit2 = new Unit();
          unit2.units = [];
          var powerMultiplierCurrent = 1;
          var expectingUnit = false;
          next();
          skipWhitespace();
          var valueStr = parseNumber();
          var value = null;
          if (valueStr) {
            if (config4.number === "BigNumber") {
              value = new _BigNumber(valueStr);
            } else if (config4.number === "Fraction") {
              try {
                value = new _Fraction(valueStr);
              } catch (err) {
                value = parseFloat(valueStr);
              }
            } else {
              value = parseFloat(valueStr);
            }
            skipWhitespace();
            if (parseCharacter("*")) {
              powerMultiplierCurrent = 1;
              expectingUnit = true;
            } else if (parseCharacter("/")) {
              powerMultiplierCurrent = -1;
              expectingUnit = true;
            }
          }
          var powerMultiplierStack = [];
          var powerMultiplierStackProduct = 1;
          while (true) {
            skipWhitespace();
            while (c === "(") {
              powerMultiplierStack.push(powerMultiplierCurrent);
              powerMultiplierStackProduct *= powerMultiplierCurrent;
              powerMultiplierCurrent = 1;
              next();
              skipWhitespace();
            }
            var uStr = void 0;
            if (c) {
              var oldC = c;
              uStr = parseUnit();
              if (uStr === null) {
                throw new SyntaxError('Unexpected "' + oldC + '" in "' + text + '" at index ' + index.toString());
              }
            } else {
              break;
            }
            var res = _findUnit(uStr);
            if (res === null) {
              throw new SyntaxError('Unit "' + uStr + '" not found.');
            }
            var power = powerMultiplierCurrent * powerMultiplierStackProduct;
            skipWhitespace();
            if (parseCharacter("^")) {
              skipWhitespace();
              var p = parseNumber();
              if (p === null) {
                throw new SyntaxError('In "' + str + '", "^" must be followed by a floating-point number');
              }
              power *= p;
            }
            unit2.units.push({
              unit: res.unit,
              prefix: res.prefix,
              power
            });
            for (var i = 0; i < BASE_DIMENSIONS.length; i++) {
              unit2.dimensions[i] += (res.unit.dimensions[i] || 0) * power;
            }
            skipWhitespace();
            while (c === ")") {
              if (powerMultiplierStack.length === 0) {
                throw new SyntaxError('Unmatched ")" in "' + text + '" at index ' + index.toString());
              }
              powerMultiplierStackProduct /= powerMultiplierStack.pop();
              next();
              skipWhitespace();
            }
            expectingUnit = false;
            if (parseCharacter("*")) {
              powerMultiplierCurrent = 1;
              expectingUnit = true;
            } else if (parseCharacter("/")) {
              powerMultiplierCurrent = -1;
              expectingUnit = true;
            } else {
              powerMultiplierCurrent = 1;
            }
            if (res.unit.base) {
              var baseDim = res.unit.base.key;
              UNIT_SYSTEMS.auto[baseDim] = {
                unit: res.unit,
                prefix: res.prefix
              };
            }
          }
          skipWhitespace();
          if (c) {
            throw new SyntaxError('Could not parse: "' + str + '"');
          }
          if (expectingUnit) {
            throw new SyntaxError('Trailing characters: "' + str + '"');
          }
          if (powerMultiplierStack.length !== 0) {
            throw new SyntaxError('Unmatched "(" in "' + text + '"');
          }
          if (unit2.units.length === 0 && !options.allowNoUnits) {
            throw new SyntaxError('"' + str + '" contains no units');
          }
          unit2.value = value !== void 0 ? unit2._normalize(value) : null;
          return unit2;
        };
        Unit.prototype.clone = function() {
          var unit2 = new Unit();
          unit2.fixPrefix = this.fixPrefix;
          unit2.skipAutomaticSimplification = this.skipAutomaticSimplification;
          unit2.value = (0, _object.clone)(this.value);
          unit2.dimensions = this.dimensions.slice(0);
          unit2.units = [];
          for (var i = 0; i < this.units.length; i++) {
            unit2.units[i] = {};
            for (var p in this.units[i]) {
              if ((0, _object.hasOwnProperty)(this.units[i], p)) {
                unit2.units[i][p] = this.units[i][p];
              }
            }
          }
          return unit2;
        };
        Unit.prototype.valueType = function() {
          return (0, _is.typeOf)(this.value);
        };
        Unit.prototype._isDerived = function() {
          if (this.units.length === 0) {
            return false;
          }
          return this.units.length > 1 || Math.abs(this.units[0].power - 1) > 1e-15;
        };
        Unit.prototype._normalize = function(value) {
          if (value === null || value === void 0 || this.units.length === 0) {
            return value;
          }
          var res = value;
          var convert = Unit._getNumberConverter((0, _is.typeOf)(value));
          for (var i = 0; i < this.units.length; i++) {
            var unitValue = convert(this.units[i].unit.value);
            var unitPrefixValue = convert(this.units[i].prefix.value);
            var unitPower = convert(this.units[i].power);
            res = multiplyScalar2(res, pow2(multiplyScalar2(unitValue, unitPrefixValue), unitPower));
          }
          return res;
        };
        Unit.prototype._denormalize = function(value, prefixValue) {
          if (value === null || value === void 0 || this.units.length === 0) {
            return value;
          }
          var res = value;
          var convert = Unit._getNumberConverter((0, _is.typeOf)(value));
          for (var i = 0; i < this.units.length; i++) {
            var unitValue = convert(this.units[i].unit.value);
            var unitPrefixValue = convert(this.units[i].prefix.value);
            var unitPower = convert(this.units[i].power);
            res = divideScalar(res, pow2(multiplyScalar2(unitValue, unitPrefixValue), unitPower));
          }
          return res;
        };
        var _findUnit = (0, _function.memoize)(function(str) {
          if ((0, _object.hasOwnProperty)(UNITS, str)) {
            var unit2 = UNITS[str];
            var prefix = unit2.prefixes[""];
            return {
              unit: unit2,
              prefix
            };
          }
          for (var _name in UNITS) {
            if ((0, _object.hasOwnProperty)(UNITS, _name)) {
              if ((0, _string.endsWith)(str, _name)) {
                var _unit = UNITS[_name];
                var prefixLen = str.length - _name.length;
                var prefixName = str.substring(0, prefixLen);
                var _prefix = (0, _object.hasOwnProperty)(_unit.prefixes, prefixName) ? _unit.prefixes[prefixName] : void 0;
                if (_prefix !== void 0) {
                  return {
                    unit: _unit,
                    prefix: _prefix
                  };
                }
              }
            }
          }
          return null;
        }, {
          hasher: function hasher(args) {
            return args[0];
          },
          limit: 100
        });
        Unit.isValuelessUnit = function(name19) {
          return _findUnit(name19) !== null;
        };
        Unit.prototype.hasBase = function(base) {
          if (typeof base === "string") {
            base = BASE_UNITS[base];
          }
          if (!base) {
            return false;
          }
          for (var i = 0; i < BASE_DIMENSIONS.length; i++) {
            if (Math.abs((this.dimensions[i] || 0) - (base.dimensions[i] || 0)) > 1e-12) {
              return false;
            }
          }
          return true;
        };
        Unit.prototype.equalBase = function(other) {
          for (var i = 0; i < BASE_DIMENSIONS.length; i++) {
            if (Math.abs((this.dimensions[i] || 0) - (other.dimensions[i] || 0)) > 1e-12) {
              return false;
            }
          }
          return true;
        };
        Unit.prototype.equals = function(other) {
          return this.equalBase(other) && equal(this.value, other.value);
        };
        Unit.prototype.multiply = function(_other) {
          var res = this.clone();
          var other = (0, _is.isUnit)(_other) ? _other : new Unit(_other);
          for (var i = 0; i < BASE_DIMENSIONS.length; i++) {
            res.dimensions[i] = (this.dimensions[i] || 0) + (other.dimensions[i] || 0);
          }
          for (var _i = 0; _i < other.units.length; _i++) {
            var inverted = _objectSpread({}, other.units[_i]);
            res.units.push(inverted);
          }
          if (this.value !== null || other.value !== null) {
            var valThis = this.value === null ? this._normalize(1) : this.value;
            var valOther = other.value === null ? other._normalize(1) : other.value;
            res.value = multiplyScalar2(valThis, valOther);
          } else {
            res.value = null;
          }
          if ((0, _is.isUnit)(_other)) {
            res.skipAutomaticSimplification = false;
          }
          return getNumericIfUnitless(res);
        };
        Unit.prototype.divideInto = function(numerator) {
          return new Unit(numerator).divide(this);
        };
        Unit.prototype.divide = function(_other) {
          var res = this.clone();
          var other = (0, _is.isUnit)(_other) ? _other : new Unit(_other);
          for (var i = 0; i < BASE_DIMENSIONS.length; i++) {
            res.dimensions[i] = (this.dimensions[i] || 0) - (other.dimensions[i] || 0);
          }
          for (var _i2 = 0; _i2 < other.units.length; _i2++) {
            var inverted = _objectSpread(_objectSpread({}, other.units[_i2]), {}, {
              power: -other.units[_i2].power
            });
            res.units.push(inverted);
          }
          if (this.value !== null || other.value !== null) {
            var valThis = this.value === null ? this._normalize(1) : this.value;
            var valOther = other.value === null ? other._normalize(1) : other.value;
            res.value = divideScalar(valThis, valOther);
          } else {
            res.value = null;
          }
          if ((0, _is.isUnit)(_other)) {
            res.skipAutomaticSimplification = false;
          }
          return getNumericIfUnitless(res);
        };
        Unit.prototype.pow = function(p) {
          var res = this.clone();
          for (var i = 0; i < BASE_DIMENSIONS.length; i++) {
            res.dimensions[i] = (this.dimensions[i] || 0) * p;
          }
          for (var _i3 = 0; _i3 < res.units.length; _i3++) {
            res.units[_i3].power *= p;
          }
          if (res.value !== null) {
            res.value = pow2(res.value, p);
          } else {
            res.value = null;
          }
          res.skipAutomaticSimplification = false;
          return getNumericIfUnitless(res);
        };
        function getNumericIfUnitless(unit2) {
          if (unit2.equalBase(BASE_UNITS.NONE) && unit2.value !== null && !config4.predictable) {
            return unit2.value;
          } else {
            return unit2;
          }
        }
        Unit.prototype.abs = function() {
          var ret = this.clone();
          if (ret.value !== null) {
            if (ret._isDerived() || ret.units.length === 0 || ret.units[0].unit.offset === 0) {
              ret.value = abs2(ret.value);
            } else {
              var convert = ret._numberConverter();
              var unitValue = convert(ret.units[0].unit.value);
              var nominalOffset = convert(ret.units[0].unit.offset);
              var unitOffset = multiplyScalar2(unitValue, nominalOffset);
              ret.value = subtractScalar(abs2(addScalar2(ret.value, unitOffset)), unitOffset);
            }
          }
          for (var i in ret.units) {
            if (ret.units[i].unit.name === "VA" || ret.units[i].unit.name === "VAR") {
              ret.units[i].unit = UNITS.W;
            }
          }
          return ret;
        };
        Unit.prototype.to = function(valuelessUnit) {
          var value = this.value === null ? this._normalize(1) : this.value;
          var other;
          if (typeof valuelessUnit === "string") {
            other = Unit.parse(valuelessUnit);
          } else if ((0, _is.isUnit)(valuelessUnit)) {
            other = valuelessUnit.clone();
          } else {
            throw new Error("String or Unit expected as parameter");
          }
          if (!this.equalBase(other)) {
            throw new Error("Units do not match ('".concat(other.toString(), "' != '").concat(this.toString(), "')"));
          }
          if (other.value !== null) {
            throw new Error("Cannot convert to a unit with a value");
          }
          if (this.value === null || this._isDerived() || this.units.length === 0 || other.units.length === 0 || this.units[0].unit.offset === other.units[0].unit.offset) {
            other.value = (0, _object.clone)(value);
          } else {
            var convert = Unit._getNumberConverter((0, _is.typeOf)(value));
            var thisUnitValue = this.units[0].unit.value;
            var thisNominalOffset = this.units[0].unit.offset;
            var thisUnitOffset = multiplyScalar2(thisUnitValue, thisNominalOffset);
            var otherUnitValue = other.units[0].unit.value;
            var otherNominalOffset = other.units[0].unit.offset;
            var otherUnitOffset = multiplyScalar2(otherUnitValue, otherNominalOffset);
            other.value = addScalar2(value, convert(subtractScalar(thisUnitOffset, otherUnitOffset)));
          }
          other.fixPrefix = true;
          other.skipAutomaticSimplification = true;
          return other;
        };
        Unit.prototype.toNumber = function(valuelessUnit) {
          return toNumber(this.toNumeric(valuelessUnit));
        };
        Unit.prototype.toNumeric = function(valuelessUnit) {
          var other;
          if (valuelessUnit) {
            other = this.to(valuelessUnit);
          } else {
            other = this.clone();
          }
          if (other._isDerived() || other.units.length === 0) {
            return other._denormalize(other.value);
          } else {
            return other._denormalize(other.value, other.units[0].prefix.value);
          }
        };
        Unit.prototype.toString = function() {
          return this.format();
        };
        Unit.prototype.toJSON = function() {
          return {
            mathjs: "Unit",
            value: this._denormalize(this.value),
            unit: this.units.length > 0 ? this.formatUnits() : null,
            fixPrefix: this.fixPrefix
          };
        };
        Unit.fromJSON = function(json) {
          var _json$unit;
          var unit2 = new Unit(json.value, (_json$unit = json.unit) !== null && _json$unit !== void 0 ? _json$unit : void 0);
          unit2.fixPrefix = json.fixPrefix || false;
          return unit2;
        };
        Unit.prototype.valueOf = Unit.prototype.toString;
        Unit.prototype.simplify = function() {
          var ret = this.clone();
          var proposedUnitList = [];
          var matchingBase;
          for (var key2 in currentUnitSystem) {
            if ((0, _object.hasOwnProperty)(currentUnitSystem, key2)) {
              if (ret.hasBase(BASE_UNITS[key2])) {
                matchingBase = key2;
                break;
              }
            }
          }
          if (matchingBase === "NONE") {
            ret.units = [];
          } else {
            var matchingUnit;
            if (matchingBase) {
              if ((0, _object.hasOwnProperty)(currentUnitSystem, matchingBase)) {
                matchingUnit = currentUnitSystem[matchingBase];
              }
            }
            if (matchingUnit) {
              ret.units = [{
                unit: matchingUnit.unit,
                prefix: matchingUnit.prefix,
                power: 1
              }];
            } else {
              var missingBaseDim = false;
              for (var i = 0; i < BASE_DIMENSIONS.length; i++) {
                var baseDim = BASE_DIMENSIONS[i];
                if (Math.abs(ret.dimensions[i] || 0) > 1e-12) {
                  if ((0, _object.hasOwnProperty)(currentUnitSystem, baseDim)) {
                    proposedUnitList.push({
                      unit: currentUnitSystem[baseDim].unit,
                      prefix: currentUnitSystem[baseDim].prefix,
                      power: ret.dimensions[i] || 0
                    });
                  } else {
                    missingBaseDim = true;
                  }
                }
              }
              if (proposedUnitList.length < ret.units.length && !missingBaseDim) {
                ret.units = proposedUnitList;
              }
            }
          }
          return ret;
        };
        Unit.prototype.toSI = function() {
          var ret = this.clone();
          var proposedUnitList = [];
          for (var i = 0; i < BASE_DIMENSIONS.length; i++) {
            var baseDim = BASE_DIMENSIONS[i];
            if (Math.abs(ret.dimensions[i] || 0) > 1e-12) {
              if ((0, _object.hasOwnProperty)(UNIT_SYSTEMS.si, baseDim)) {
                proposedUnitList.push({
                  unit: UNIT_SYSTEMS.si[baseDim].unit,
                  prefix: UNIT_SYSTEMS.si[baseDim].prefix,
                  power: ret.dimensions[i] || 0
                });
              } else {
                throw new Error("Cannot express custom unit " + baseDim + " in SI units");
              }
            }
          }
          ret.units = proposedUnitList;
          ret.fixPrefix = true;
          ret.skipAutomaticSimplification = true;
          if (this.value !== null) {
            ret.value = null;
            return this.to(ret);
          }
          return ret;
        };
        Unit.prototype.formatUnits = function() {
          var strNum = "";
          var strDen = "";
          var nNum = 0;
          var nDen = 0;
          for (var i = 0; i < this.units.length; i++) {
            if (this.units[i].power > 0) {
              nNum++;
              strNum += " " + this.units[i].prefix.name + this.units[i].unit.name;
              if (Math.abs(this.units[i].power - 1) > 1e-15) {
                strNum += "^" + this.units[i].power;
              }
            } else if (this.units[i].power < 0) {
              nDen++;
            }
          }
          if (nDen > 0) {
            for (var _i4 = 0; _i4 < this.units.length; _i4++) {
              if (this.units[_i4].power < 0) {
                if (nNum > 0) {
                  strDen += " " + this.units[_i4].prefix.name + this.units[_i4].unit.name;
                  if (Math.abs(this.units[_i4].power + 1) > 1e-15) {
                    strDen += "^" + -this.units[_i4].power;
                  }
                } else {
                  strDen += " " + this.units[_i4].prefix.name + this.units[_i4].unit.name;
                  strDen += "^" + this.units[_i4].power;
                }
              }
            }
          }
          strNum = strNum.substr(1);
          strDen = strDen.substr(1);
          if (nNum > 1 && nDen > 0) {
            strNum = "(" + strNum + ")";
          }
          if (nDen > 1 && nNum > 0) {
            strDen = "(" + strDen + ")";
          }
          var str = strNum;
          if (nNum > 0 && nDen > 0) {
            str += " / ";
          }
          str += strDen;
          return str;
        };
        Unit.prototype.format = function(options) {
          var simp = this.skipAutomaticSimplification || this.value === null ? this.clone() : this.simplify();
          var isImaginary = false;
          if (typeof simp.value !== "undefined" && simp.value !== null && (0, _is.isComplex)(simp.value)) {
            isImaginary = Math.abs(simp.value.re) < 1e-14;
          }
          for (var i in simp.units) {
            if ((0, _object.hasOwnProperty)(simp.units, i)) {
              if (simp.units[i].unit) {
                if (simp.units[i].unit.name === "VA" && isImaginary) {
                  simp.units[i].unit = UNITS.VAR;
                } else if (simp.units[i].unit.name === "VAR" && !isImaginary) {
                  simp.units[i].unit = UNITS.VA;
                }
              }
            }
          }
          if (simp.units.length === 1 && !simp.fixPrefix) {
            if (Math.abs(simp.units[0].power - Math.round(simp.units[0].power)) < 1e-14) {
              simp.units[0].prefix = simp._bestPrefix();
            }
          }
          var value = simp._denormalize(simp.value);
          var str = simp.value !== null ? format4(value, options || {}) : "";
          var unitStr = simp.formatUnits();
          if (simp.value && (0, _is.isComplex)(simp.value)) {
            str = "(" + str + ")";
          }
          if (unitStr.length > 0 && str.length > 0) {
            str += " ";
          }
          str += unitStr;
          return str;
        };
        Unit.prototype._bestPrefix = function() {
          if (this.units.length !== 1) {
            throw new Error("Can only compute the best prefix for single units with integer powers, like kg, s^2, N^-1, and so forth!");
          }
          if (Math.abs(this.units[0].power - Math.round(this.units[0].power)) >= 1e-14) {
            throw new Error("Can only compute the best prefix for single units with integer powers, like kg, s^2, N^-1, and so forth!");
          }
          var absValue = this.value !== null ? abs2(this.value) : 0;
          var absUnitValue = abs2(this.units[0].unit.value);
          var bestPrefix = this.units[0].prefix;
          if (absValue === 0) {
            return bestPrefix;
          }
          var power = this.units[0].power;
          var bestDiff = Math.log(absValue / Math.pow(bestPrefix.value * absUnitValue, power)) / Math.LN10 - 1.2;
          if (bestDiff > -2.200001 && bestDiff < 1.800001) return bestPrefix;
          bestDiff = Math.abs(bestDiff);
          var prefixes = this.units[0].unit.prefixes;
          for (var p in prefixes) {
            if ((0, _object.hasOwnProperty)(prefixes, p)) {
              var prefix = prefixes[p];
              if (prefix.scientific) {
                var diff = Math.abs(Math.log(absValue / Math.pow(prefix.value * absUnitValue, power)) / Math.LN10 - 1.2);
                if (diff < bestDiff || diff === bestDiff && prefix.name.length < bestPrefix.name.length) {
                  bestPrefix = prefix;
                  bestDiff = diff;
                }
              }
            }
          }
          return bestPrefix;
        };
        Unit.prototype.splitUnit = function(parts) {
          var x = this.clone();
          var ret = [];
          for (var i = 0; i < parts.length; i++) {
            x = x.to(parts[i]);
            if (i === parts.length - 1) break;
            var xNumeric = x.toNumeric();
            var xRounded = round2(xNumeric);
            var xFixed = void 0;
            var isNearlyEqual = equal(xRounded, xNumeric);
            if (isNearlyEqual) {
              xFixed = xRounded;
            } else {
              xFixed = fix(x.toNumeric());
            }
            var y = new Unit(xFixed, parts[i].toString());
            ret.push(y);
            x = subtractScalar(x, y);
          }
          var testSum = 0;
          for (var _i5 = 0; _i5 < ret.length; _i5++) {
            testSum = addScalar2(testSum, ret[_i5].value);
          }
          if (equal(testSum, this.value)) {
            x.value = 0;
          }
          ret.push(x);
          return ret;
        };
        var PREFIXES = {
          NONE: {
            "": {
              name: "",
              value: 1,
              scientific: true
            }
          },
          SHORT: {
            "": {
              name: "",
              value: 1,
              scientific: true
            },
            da: {
              name: "da",
              value: 10,
              scientific: false
            },
            h: {
              name: "h",
              value: 100,
              scientific: false
            },
            k: {
              name: "k",
              value: 1e3,
              scientific: true
            },
            M: {
              name: "M",
              value: 1e6,
              scientific: true
            },
            G: {
              name: "G",
              value: 1e9,
              scientific: true
            },
            T: {
              name: "T",
              value: 1e12,
              scientific: true
            },
            P: {
              name: "P",
              value: 1e15,
              scientific: true
            },
            E: {
              name: "E",
              value: 1e18,
              scientific: true
            },
            Z: {
              name: "Z",
              value: 1e21,
              scientific: true
            },
            Y: {
              name: "Y",
              value: 1e24,
              scientific: true
            },
            R: {
              name: "R",
              value: 1e27,
              scientific: true
            },
            Q: {
              name: "Q",
              value: 1e30,
              scientific: true
            },
            d: {
              name: "d",
              value: 0.1,
              scientific: false
            },
            c: {
              name: "c",
              value: 0.01,
              scientific: false
            },
            m: {
              name: "m",
              value: 1e-3,
              scientific: true
            },
            u: {
              name: "u",
              value: 1e-6,
              scientific: true
            },
            n: {
              name: "n",
              value: 1e-9,
              scientific: true
            },
            p: {
              name: "p",
              value: 1e-12,
              scientific: true
            },
            f: {
              name: "f",
              value: 1e-15,
              scientific: true
            },
            a: {
              name: "a",
              value: 1e-18,
              scientific: true
            },
            z: {
              name: "z",
              value: 1e-21,
              scientific: true
            },
            y: {
              name: "y",
              value: 1e-24,
              scientific: true
            },
            r: {
              name: "r",
              value: 1e-27,
              scientific: true
            },
            q: {
              name: "q",
              value: 1e-30,
              scientific: true
            }
          },
          LONG: {
            "": {
              name: "",
              value: 1,
              scientific: true
            },
            deca: {
              name: "deca",
              value: 10,
              scientific: false
            },
            hecto: {
              name: "hecto",
              value: 100,
              scientific: false
            },
            kilo: {
              name: "kilo",
              value: 1e3,
              scientific: true
            },
            mega: {
              name: "mega",
              value: 1e6,
              scientific: true
            },
            giga: {
              name: "giga",
              value: 1e9,
              scientific: true
            },
            tera: {
              name: "tera",
              value: 1e12,
              scientific: true
            },
            peta: {
              name: "peta",
              value: 1e15,
              scientific: true
            },
            exa: {
              name: "exa",
              value: 1e18,
              scientific: true
            },
            zetta: {
              name: "zetta",
              value: 1e21,
              scientific: true
            },
            yotta: {
              name: "yotta",
              value: 1e24,
              scientific: true
            },
            ronna: {
              name: "ronna",
              value: 1e27,
              scientific: true
            },
            quetta: {
              name: "quetta",
              value: 1e30,
              scientific: true
            },
            deci: {
              name: "deci",
              value: 0.1,
              scientific: false
            },
            centi: {
              name: "centi",
              value: 0.01,
              scientific: false
            },
            milli: {
              name: "milli",
              value: 1e-3,
              scientific: true
            },
            micro: {
              name: "micro",
              value: 1e-6,
              scientific: true
            },
            nano: {
              name: "nano",
              value: 1e-9,
              scientific: true
            },
            pico: {
              name: "pico",
              value: 1e-12,
              scientific: true
            },
            femto: {
              name: "femto",
              value: 1e-15,
              scientific: true
            },
            atto: {
              name: "atto",
              value: 1e-18,
              scientific: true
            },
            zepto: {
              name: "zepto",
              value: 1e-21,
              scientific: true
            },
            yocto: {
              name: "yocto",
              value: 1e-24,
              scientific: true
            },
            ronto: {
              name: "ronto",
              value: 1e-27,
              scientific: true
            },
            quecto: {
              name: "quecto",
              value: 1e-30,
              scientific: true
            }
          },
          SQUARED: {
            "": {
              name: "",
              value: 1,
              scientific: true
            },
            da: {
              name: "da",
              value: 100,
              scientific: false
            },
            h: {
              name: "h",
              value: 1e4,
              scientific: false
            },
            k: {
              name: "k",
              value: 1e6,
              scientific: true
            },
            M: {
              name: "M",
              value: 1e12,
              scientific: true
            },
            G: {
              name: "G",
              value: 1e18,
              scientific: true
            },
            T: {
              name: "T",
              value: 1e24,
              scientific: true
            },
            P: {
              name: "P",
              value: 1e30,
              scientific: true
            },
            E: {
              name: "E",
              value: 1e36,
              scientific: true
            },
            Z: {
              name: "Z",
              value: 1e42,
              scientific: true
            },
            Y: {
              name: "Y",
              value: 1e48,
              scientific: true
            },
            R: {
              name: "R",
              value: 1e54,
              scientific: true
            },
            Q: {
              name: "Q",
              value: 1e60,
              scientific: true
            },
            d: {
              name: "d",
              value: 0.01,
              scientific: false
            },
            c: {
              name: "c",
              value: 1e-4,
              scientific: false
            },
            m: {
              name: "m",
              value: 1e-6,
              scientific: true
            },
            u: {
              name: "u",
              value: 1e-12,
              scientific: true
            },
            n: {
              name: "n",
              value: 1e-18,
              scientific: true
            },
            p: {
              name: "p",
              value: 1e-24,
              scientific: true
            },
            f: {
              name: "f",
              value: 1e-30,
              scientific: true
            },
            a: {
              name: "a",
              value: 1e-36,
              scientific: true
            },
            z: {
              name: "z",
              value: 1e-42,
              scientific: true
            },
            y: {
              name: "y",
              value: 1e-48,
              scientific: true
            },
            r: {
              name: "r",
              value: 1e-54,
              scientific: true
            },
            q: {
              name: "q",
              value: 1e-60,
              scientific: true
            }
          },
          CUBIC: {
            "": {
              name: "",
              value: 1,
              scientific: true
            },
            da: {
              name: "da",
              value: 1e3,
              scientific: false
            },
            h: {
              name: "h",
              value: 1e6,
              scientific: false
            },
            k: {
              name: "k",
              value: 1e9,
              scientific: true
            },
            M: {
              name: "M",
              value: 1e18,
              scientific: true
            },
            G: {
              name: "G",
              value: 1e27,
              scientific: true
            },
            T: {
              name: "T",
              value: 1e36,
              scientific: true
            },
            P: {
              name: "P",
              value: 1e45,
              scientific: true
            },
            E: {
              name: "E",
              value: 1e54,
              scientific: true
            },
            Z: {
              name: "Z",
              value: 1e63,
              scientific: true
            },
            Y: {
              name: "Y",
              value: 1e72,
              scientific: true
            },
            R: {
              name: "R",
              value: 1e81,
              scientific: true
            },
            Q: {
              name: "Q",
              value: 1e90,
              scientific: true
            },
            d: {
              name: "d",
              value: 1e-3,
              scientific: false
            },
            c: {
              name: "c",
              value: 1e-6,
              scientific: false
            },
            m: {
              name: "m",
              value: 1e-9,
              scientific: true
            },
            u: {
              name: "u",
              value: 1e-18,
              scientific: true
            },
            n: {
              name: "n",
              value: 1e-27,
              scientific: true
            },
            p: {
              name: "p",
              value: 1e-36,
              scientific: true
            },
            f: {
              name: "f",
              value: 1e-45,
              scientific: true
            },
            a: {
              name: "a",
              value: 1e-54,
              scientific: true
            },
            z: {
              name: "z",
              value: 1e-63,
              scientific: true
            },
            y: {
              name: "y",
              value: 1e-72,
              scientific: true
            },
            r: {
              name: "r",
              value: 1e-81,
              scientific: true
            },
            q: {
              name: "q",
              value: 1e-90,
              scientific: true
            }
          },
          BINARY_SHORT_SI: {
            "": {
              name: "",
              value: 1,
              scientific: true
            },
            k: {
              name: "k",
              value: 1e3,
              scientific: true
            },
            M: {
              name: "M",
              value: 1e6,
              scientific: true
            },
            G: {
              name: "G",
              value: 1e9,
              scientific: true
            },
            T: {
              name: "T",
              value: 1e12,
              scientific: true
            },
            P: {
              name: "P",
              value: 1e15,
              scientific: true
            },
            E: {
              name: "E",
              value: 1e18,
              scientific: true
            },
            Z: {
              name: "Z",
              value: 1e21,
              scientific: true
            },
            Y: {
              name: "Y",
              value: 1e24,
              scientific: true
            }
          },
          BINARY_SHORT_IEC: {
            "": {
              name: "",
              value: 1,
              scientific: true
            },
            Ki: {
              name: "Ki",
              value: 1024,
              scientific: true
            },
            Mi: {
              name: "Mi",
              value: Math.pow(1024, 2),
              scientific: true
            },
            Gi: {
              name: "Gi",
              value: Math.pow(1024, 3),
              scientific: true
            },
            Ti: {
              name: "Ti",
              value: Math.pow(1024, 4),
              scientific: true
            },
            Pi: {
              name: "Pi",
              value: Math.pow(1024, 5),
              scientific: true
            },
            Ei: {
              name: "Ei",
              value: Math.pow(1024, 6),
              scientific: true
            },
            Zi: {
              name: "Zi",
              value: Math.pow(1024, 7),
              scientific: true
            },
            Yi: {
              name: "Yi",
              value: Math.pow(1024, 8),
              scientific: true
            }
          },
          BINARY_LONG_SI: {
            "": {
              name: "",
              value: 1,
              scientific: true
            },
            kilo: {
              name: "kilo",
              value: 1e3,
              scientific: true
            },
            mega: {
              name: "mega",
              value: 1e6,
              scientific: true
            },
            giga: {
              name: "giga",
              value: 1e9,
              scientific: true
            },
            tera: {
              name: "tera",
              value: 1e12,
              scientific: true
            },
            peta: {
              name: "peta",
              value: 1e15,
              scientific: true
            },
            exa: {
              name: "exa",
              value: 1e18,
              scientific: true
            },
            zetta: {
              name: "zetta",
              value: 1e21,
              scientific: true
            },
            yotta: {
              name: "yotta",
              value: 1e24,
              scientific: true
            }
          },
          BINARY_LONG_IEC: {
            "": {
              name: "",
              value: 1,
              scientific: true
            },
            kibi: {
              name: "kibi",
              value: 1024,
              scientific: true
            },
            mebi: {
              name: "mebi",
              value: Math.pow(1024, 2),
              scientific: true
            },
            gibi: {
              name: "gibi",
              value: Math.pow(1024, 3),
              scientific: true
            },
            tebi: {
              name: "tebi",
              value: Math.pow(1024, 4),
              scientific: true
            },
            pebi: {
              name: "pebi",
              value: Math.pow(1024, 5),
              scientific: true
            },
            exi: {
              name: "exi",
              value: Math.pow(1024, 6),
              scientific: true
            },
            zebi: {
              name: "zebi",
              value: Math.pow(1024, 7),
              scientific: true
            },
            yobi: {
              name: "yobi",
              value: Math.pow(1024, 8),
              scientific: true
            }
          },
          BTU: {
            "": {
              name: "",
              value: 1,
              scientific: true
            },
            MM: {
              name: "MM",
              value: 1e6,
              scientific: true
            }
          }
        };
        PREFIXES.SHORTLONG = (0, _extends2["default"])({}, PREFIXES.SHORT, PREFIXES.LONG);
        PREFIXES.BINARY_SHORT = (0, _extends2["default"])({}, PREFIXES.BINARY_SHORT_SI, PREFIXES.BINARY_SHORT_IEC);
        PREFIXES.BINARY_LONG = (0, _extends2["default"])({}, PREFIXES.BINARY_LONG_SI, PREFIXES.BINARY_LONG_IEC);
        var BASE_DIMENSIONS = ["MASS", "LENGTH", "TIME", "CURRENT", "TEMPERATURE", "LUMINOUS_INTENSITY", "AMOUNT_OF_SUBSTANCE", "ANGLE", "BIT"];
        var BASE_UNITS = {
          NONE: {
            dimensions: [0, 0, 0, 0, 0, 0, 0, 0, 0]
          },
          MASS: {
            dimensions: [1, 0, 0, 0, 0, 0, 0, 0, 0]
          },
          LENGTH: {
            dimensions: [0, 1, 0, 0, 0, 0, 0, 0, 0]
          },
          TIME: {
            dimensions: [0, 0, 1, 0, 0, 0, 0, 0, 0]
          },
          CURRENT: {
            dimensions: [0, 0, 0, 1, 0, 0, 0, 0, 0]
          },
          TEMPERATURE: {
            dimensions: [0, 0, 0, 0, 1, 0, 0, 0, 0]
          },
          LUMINOUS_INTENSITY: {
            dimensions: [0, 0, 0, 0, 0, 1, 0, 0, 0]
          },
          AMOUNT_OF_SUBSTANCE: {
            dimensions: [0, 0, 0, 0, 0, 0, 1, 0, 0]
          },
          FORCE: {
            dimensions: [1, 1, -2, 0, 0, 0, 0, 0, 0]
          },
          SURFACE: {
            dimensions: [0, 2, 0, 0, 0, 0, 0, 0, 0]
          },
          VOLUME: {
            dimensions: [0, 3, 0, 0, 0, 0, 0, 0, 0]
          },
          ENERGY: {
            dimensions: [1, 2, -2, 0, 0, 0, 0, 0, 0]
          },
          POWER: {
            dimensions: [1, 2, -3, 0, 0, 0, 0, 0, 0]
          },
          PRESSURE: {
            dimensions: [1, -1, -2, 0, 0, 0, 0, 0, 0]
          },
          ELECTRIC_CHARGE: {
            dimensions: [0, 0, 1, 1, 0, 0, 0, 0, 0]
          },
          ELECTRIC_CAPACITANCE: {
            dimensions: [-1, -2, 4, 2, 0, 0, 0, 0, 0]
          },
          ELECTRIC_POTENTIAL: {
            dimensions: [1, 2, -3, -1, 0, 0, 0, 0, 0]
          },
          ELECTRIC_RESISTANCE: {
            dimensions: [1, 2, -3, -2, 0, 0, 0, 0, 0]
          },
          ELECTRIC_INDUCTANCE: {
            dimensions: [1, 2, -2, -2, 0, 0, 0, 0, 0]
          },
          ELECTRIC_CONDUCTANCE: {
            dimensions: [-1, -2, 3, 2, 0, 0, 0, 0, 0]
          },
          MAGNETIC_FLUX: {
            dimensions: [1, 2, -2, -1, 0, 0, 0, 0, 0]
          },
          MAGNETIC_FLUX_DENSITY: {
            dimensions: [1, 0, -2, -1, 0, 0, 0, 0, 0]
          },
          FREQUENCY: {
            dimensions: [0, 0, -1, 0, 0, 0, 0, 0, 0]
          },
          ANGLE: {
            dimensions: [0, 0, 0, 0, 0, 0, 0, 1, 0]
          },
          BIT: {
            dimensions: [0, 0, 0, 0, 0, 0, 0, 0, 1]
          }
        };
        for (var key in BASE_UNITS) {
          if ((0, _object.hasOwnProperty)(BASE_UNITS, key)) {
            BASE_UNITS[key].key = key;
          }
        }
        var BASE_UNIT_NONE = {};
        var UNIT_NONE = {
          name: "",
          base: BASE_UNIT_NONE,
          value: 1,
          offset: 0,
          dimensions: BASE_DIMENSIONS.map(function(x) {
            return 0;
          })
        };
        var UNITS = {
          // length
          meter: {
            name: "meter",
            base: BASE_UNITS.LENGTH,
            prefixes: PREFIXES.LONG,
            value: 1,
            offset: 0
          },
          inch: {
            name: "inch",
            base: BASE_UNITS.LENGTH,
            prefixes: PREFIXES.NONE,
            value: 0.0254,
            offset: 0
          },
          foot: {
            name: "foot",
            base: BASE_UNITS.LENGTH,
            prefixes: PREFIXES.NONE,
            value: 0.3048,
            offset: 0
          },
          yard: {
            name: "yard",
            base: BASE_UNITS.LENGTH,
            prefixes: PREFIXES.NONE,
            value: 0.9144,
            offset: 0
          },
          mile: {
            name: "mile",
            base: BASE_UNITS.LENGTH,
            prefixes: PREFIXES.NONE,
            value: 1609.344,
            offset: 0
          },
          link: {
            name: "link",
            base: BASE_UNITS.LENGTH,
            prefixes: PREFIXES.NONE,
            value: 0.201168,
            offset: 0
          },
          rod: {
            name: "rod",
            base: BASE_UNITS.LENGTH,
            prefixes: PREFIXES.NONE,
            value: 5.0292,
            offset: 0
          },
          chain: {
            name: "chain",
            base: BASE_UNITS.LENGTH,
            prefixes: PREFIXES.NONE,
            value: 20.1168,
            offset: 0
          },
          angstrom: {
            name: "angstrom",
            base: BASE_UNITS.LENGTH,
            prefixes: PREFIXES.NONE,
            value: 1e-10,
            offset: 0
          },
          m: {
            name: "m",
            base: BASE_UNITS.LENGTH,
            prefixes: PREFIXES.SHORT,
            value: 1,
            offset: 0
          },
          "in": {
            name: "in",
            base: BASE_UNITS.LENGTH,
            prefixes: PREFIXES.NONE,
            value: 0.0254,
            offset: 0
          },
          ft: {
            name: "ft",
            base: BASE_UNITS.LENGTH,
            prefixes: PREFIXES.NONE,
            value: 0.3048,
            offset: 0
          },
          yd: {
            name: "yd",
            base: BASE_UNITS.LENGTH,
            prefixes: PREFIXES.NONE,
            value: 0.9144,
            offset: 0
          },
          mi: {
            name: "mi",
            base: BASE_UNITS.LENGTH,
            prefixes: PREFIXES.NONE,
            value: 1609.344,
            offset: 0
          },
          li: {
            name: "li",
            base: BASE_UNITS.LENGTH,
            prefixes: PREFIXES.NONE,
            value: 0.201168,
            offset: 0
          },
          rd: {
            name: "rd",
            base: BASE_UNITS.LENGTH,
            prefixes: PREFIXES.NONE,
            value: 5.02921,
            offset: 0
          },
          ch: {
            name: "ch",
            base: BASE_UNITS.LENGTH,
            prefixes: PREFIXES.NONE,
            value: 20.1168,
            offset: 0
          },
          mil: {
            name: "mil",
            base: BASE_UNITS.LENGTH,
            prefixes: PREFIXES.NONE,
            value: 254e-7,
            offset: 0
          },
          // 1/1000 inch
          // Surface
          m2: {
            name: "m2",
            base: BASE_UNITS.SURFACE,
            prefixes: PREFIXES.SQUARED,
            value: 1,
            offset: 0
          },
          sqin: {
            name: "sqin",
            base: BASE_UNITS.SURFACE,
            prefixes: PREFIXES.NONE,
            value: 64516e-8,
            offset: 0
          },
          // 645.16 mm2
          sqft: {
            name: "sqft",
            base: BASE_UNITS.SURFACE,
            prefixes: PREFIXES.NONE,
            value: 0.09290304,
            offset: 0
          },
          // 0.09290304 m2
          sqyd: {
            name: "sqyd",
            base: BASE_UNITS.SURFACE,
            prefixes: PREFIXES.NONE,
            value: 0.83612736,
            offset: 0
          },
          // 0.83612736 m2
          sqmi: {
            name: "sqmi",
            base: BASE_UNITS.SURFACE,
            prefixes: PREFIXES.NONE,
            value: 2589988110336e-6,
            offset: 0
          },
          // 2.589988110336 km2
          sqrd: {
            name: "sqrd",
            base: BASE_UNITS.SURFACE,
            prefixes: PREFIXES.NONE,
            value: 25.29295,
            offset: 0
          },
          // 25.29295 m2
          sqch: {
            name: "sqch",
            base: BASE_UNITS.SURFACE,
            prefixes: PREFIXES.NONE,
            value: 404.6873,
            offset: 0
          },
          // 404.6873 m2
          sqmil: {
            name: "sqmil",
            base: BASE_UNITS.SURFACE,
            prefixes: PREFIXES.NONE,
            value: 64516e-14,
            offset: 0
          },
          // 6.4516 * 10^-10 m2
          acre: {
            name: "acre",
            base: BASE_UNITS.SURFACE,
            prefixes: PREFIXES.NONE,
            value: 4046.86,
            offset: 0
          },
          // 4046.86 m2
          hectare: {
            name: "hectare",
            base: BASE_UNITS.SURFACE,
            prefixes: PREFIXES.NONE,
            value: 1e4,
            offset: 0
          },
          // 10000 m2
          // Volume
          m3: {
            name: "m3",
            base: BASE_UNITS.VOLUME,
            prefixes: PREFIXES.CUBIC,
            value: 1,
            offset: 0
          },
          L: {
            name: "L",
            base: BASE_UNITS.VOLUME,
            prefixes: PREFIXES.SHORT,
            value: 1e-3,
            offset: 0
          },
          // litre
          l: {
            name: "l",
            base: BASE_UNITS.VOLUME,
            prefixes: PREFIXES.SHORT,
            value: 1e-3,
            offset: 0
          },
          // litre
          litre: {
            name: "litre",
            base: BASE_UNITS.VOLUME,
            prefixes: PREFIXES.LONG,
            value: 1e-3,
            offset: 0
          },
          cuin: {
            name: "cuin",
            base: BASE_UNITS.VOLUME,
            prefixes: PREFIXES.NONE,
            value: 16387064e-12,
            offset: 0
          },
          // 1.6387064e-5 m3
          cuft: {
            name: "cuft",
            base: BASE_UNITS.VOLUME,
            prefixes: PREFIXES.NONE,
            value: 0.028316846592,
            offset: 0
          },
          // 28.316 846 592 L
          cuyd: {
            name: "cuyd",
            base: BASE_UNITS.VOLUME,
            prefixes: PREFIXES.NONE,
            value: 0.764554857984,
            offset: 0
          },
          // 764.554 857 984 L
          teaspoon: {
            name: "teaspoon",
            base: BASE_UNITS.VOLUME,
            prefixes: PREFIXES.NONE,
            value: 5e-6,
            offset: 0
          },
          // 5 mL
          tablespoon: {
            name: "tablespoon",
            base: BASE_UNITS.VOLUME,
            prefixes: PREFIXES.NONE,
            value: 15e-6,
            offset: 0
          },
          // 15 mL
          // {name: 'cup', base: BASE_UNITS.VOLUME, prefixes: PREFIXES.NONE, value: 0.000240, offset: 0}, // 240 mL  // not possible, we have already another cup
          drop: {
            name: "drop",
            base: BASE_UNITS.VOLUME,
            prefixes: PREFIXES.NONE,
            value: 5e-8,
            offset: 0
          },
          // 0.05 mL = 5e-8 m3
          gtt: {
            name: "gtt",
            base: BASE_UNITS.VOLUME,
            prefixes: PREFIXES.NONE,
            value: 5e-8,
            offset: 0
          },
          // 0.05 mL = 5e-8 m3
          // Liquid volume
          minim: {
            name: "minim",
            base: BASE_UNITS.VOLUME,
            prefixes: PREFIXES.NONE,
            value: 6161152e-14,
            offset: 0
          },
          // 0.06161152 mL
          fluiddram: {
            name: "fluiddram",
            base: BASE_UNITS.VOLUME,
            prefixes: PREFIXES.NONE,
            value: 36966911e-13,
            offset: 0
          },
          // 3.696691 mL
          fluidounce: {
            name: "fluidounce",
            base: BASE_UNITS.VOLUME,
            prefixes: PREFIXES.NONE,
            value: 2957353e-11,
            offset: 0
          },
          // 29.57353 mL
          gill: {
            name: "gill",
            base: BASE_UNITS.VOLUME,
            prefixes: PREFIXES.NONE,
            value: 1182941e-10,
            offset: 0
          },
          // 118.2941 mL
          cc: {
            name: "cc",
            base: BASE_UNITS.VOLUME,
            prefixes: PREFIXES.NONE,
            value: 1e-6,
            offset: 0
          },
          // 1e-6 L
          cup: {
            name: "cup",
            base: BASE_UNITS.VOLUME,
            prefixes: PREFIXES.NONE,
            value: 2365882e-10,
            offset: 0
          },
          // 236.5882 mL
          pint: {
            name: "pint",
            base: BASE_UNITS.VOLUME,
            prefixes: PREFIXES.NONE,
            value: 4731765e-10,
            offset: 0
          },
          // 473.1765 mL
          quart: {
            name: "quart",
            base: BASE_UNITS.VOLUME,
            prefixes: PREFIXES.NONE,
            value: 9463529e-10,
            offset: 0
          },
          // 946.3529 mL
          gallon: {
            name: "gallon",
            base: BASE_UNITS.VOLUME,
            prefixes: PREFIXES.NONE,
            value: 3785412e-9,
            offset: 0
          },
          // 3.785412 L
          beerbarrel: {
            name: "beerbarrel",
            base: BASE_UNITS.VOLUME,
            prefixes: PREFIXES.NONE,
            value: 0.1173478,
            offset: 0
          },
          // 117.3478 L
          oilbarrel: {
            name: "oilbarrel",
            base: BASE_UNITS.VOLUME,
            prefixes: PREFIXES.NONE,
            value: 0.1589873,
            offset: 0
          },
          // 158.9873 L
          hogshead: {
            name: "hogshead",
            base: BASE_UNITS.VOLUME,
            prefixes: PREFIXES.NONE,
            value: 0.238481,
            offset: 0
          },
          // 238.4810 L
          // {name: 'min', base: BASE_UNITS.VOLUME, prefixes: PREFIXES.NONE, value: 0.00000006161152, offset: 0}, // 0.06161152 mL // min is already in use as minute
          fldr: {
            name: "fldr",
            base: BASE_UNITS.VOLUME,
            prefixes: PREFIXES.NONE,
            value: 36966911e-13,
            offset: 0
          },
          // 3.696691 mL
          floz: {
            name: "floz",
            base: BASE_UNITS.VOLUME,
            prefixes: PREFIXES.NONE,
            value: 2957353e-11,
            offset: 0
          },
          // 29.57353 mL
          gi: {
            name: "gi",
            base: BASE_UNITS.VOLUME,
            prefixes: PREFIXES.NONE,
            value: 1182941e-10,
            offset: 0
          },
          // 118.2941 mL
          cp: {
            name: "cp",
            base: BASE_UNITS.VOLUME,
            prefixes: PREFIXES.NONE,
            value: 2365882e-10,
            offset: 0
          },
          // 236.5882 mL
          pt: {
            name: "pt",
            base: BASE_UNITS.VOLUME,
            prefixes: PREFIXES.NONE,
            value: 4731765e-10,
            offset: 0
          },
          // 473.1765 mL
          qt: {
            name: "qt",
            base: BASE_UNITS.VOLUME,
            prefixes: PREFIXES.NONE,
            value: 9463529e-10,
            offset: 0
          },
          // 946.3529 mL
          gal: {
            name: "gal",
            base: BASE_UNITS.VOLUME,
            prefixes: PREFIXES.NONE,
            value: 3785412e-9,
            offset: 0
          },
          // 3.785412 L
          bbl: {
            name: "bbl",
            base: BASE_UNITS.VOLUME,
            prefixes: PREFIXES.NONE,
            value: 0.1173478,
            offset: 0
          },
          // 117.3478 L
          obl: {
            name: "obl",
            base: BASE_UNITS.VOLUME,
            prefixes: PREFIXES.NONE,
            value: 0.1589873,
            offset: 0
          },
          // 158.9873 L
          // {name: 'hogshead', base: BASE_UNITS.VOLUME, prefixes: PREFIXES.NONE, value: 0.2384810, offset: 0}, // 238.4810 L // TODO: hh?
          // Mass
          g: {
            name: "g",
            base: BASE_UNITS.MASS,
            prefixes: PREFIXES.SHORT,
            value: 1e-3,
            offset: 0
          },
          gram: {
            name: "gram",
            base: BASE_UNITS.MASS,
            prefixes: PREFIXES.LONG,
            value: 1e-3,
            offset: 0
          },
          ton: {
            name: "ton",
            base: BASE_UNITS.MASS,
            prefixes: PREFIXES.SHORT,
            value: 907.18474,
            offset: 0
          },
          t: {
            name: "t",
            base: BASE_UNITS.MASS,
            prefixes: PREFIXES.SHORT,
            value: 1e3,
            offset: 0
          },
          tonne: {
            name: "tonne",
            base: BASE_UNITS.MASS,
            prefixes: PREFIXES.LONG,
            value: 1e3,
            offset: 0
          },
          grain: {
            name: "grain",
            base: BASE_UNITS.MASS,
            prefixes: PREFIXES.NONE,
            value: 6479891e-11,
            offset: 0
          },
          dram: {
            name: "dram",
            base: BASE_UNITS.MASS,
            prefixes: PREFIXES.NONE,
            value: 0.0017718451953125,
            offset: 0
          },
          ounce: {
            name: "ounce",
            base: BASE_UNITS.MASS,
            prefixes: PREFIXES.NONE,
            value: 0.028349523125,
            offset: 0
          },
          poundmass: {
            name: "poundmass",
            base: BASE_UNITS.MASS,
            prefixes: PREFIXES.NONE,
            value: 0.45359237,
            offset: 0
          },
          hundredweight: {
            name: "hundredweight",
            base: BASE_UNITS.MASS,
            prefixes: PREFIXES.NONE,
            value: 45.359237,
            offset: 0
          },
          stick: {
            name: "stick",
            base: BASE_UNITS.MASS,
            prefixes: PREFIXES.NONE,
            value: 0.115,
            offset: 0
          },
          stone: {
            name: "stone",
            base: BASE_UNITS.MASS,
            prefixes: PREFIXES.NONE,
            value: 6.35029318,
            offset: 0
          },
          gr: {
            name: "gr",
            base: BASE_UNITS.MASS,
            prefixes: PREFIXES.NONE,
            value: 6479891e-11,
            offset: 0
          },
          dr: {
            name: "dr",
            base: BASE_UNITS.MASS,
            prefixes: PREFIXES.NONE,
            value: 0.0017718451953125,
            offset: 0
          },
          oz: {
            name: "oz",
            base: BASE_UNITS.MASS,
            prefixes: PREFIXES.NONE,
            value: 0.028349523125,
            offset: 0
          },
          lbm: {
            name: "lbm",
            base: BASE_UNITS.MASS,
            prefixes: PREFIXES.NONE,
            value: 0.45359237,
            offset: 0
          },
          cwt: {
            name: "cwt",
            base: BASE_UNITS.MASS,
            prefixes: PREFIXES.NONE,
            value: 45.359237,
            offset: 0
          },
          // Time
          s: {
            name: "s",
            base: BASE_UNITS.TIME,
            prefixes: PREFIXES.SHORT,
            value: 1,
            offset: 0
          },
          min: {
            name: "min",
            base: BASE_UNITS.TIME,
            prefixes: PREFIXES.NONE,
            value: 60,
            offset: 0
          },
          h: {
            name: "h",
            base: BASE_UNITS.TIME,
            prefixes: PREFIXES.NONE,
            value: 3600,
            offset: 0
          },
          second: {
            name: "second",
            base: BASE_UNITS.TIME,
            prefixes: PREFIXES.LONG,
            value: 1,
            offset: 0
          },
          sec: {
            name: "sec",
            base: BASE_UNITS.TIME,
            prefixes: PREFIXES.LONG,
            value: 1,
            offset: 0
          },
          minute: {
            name: "minute",
            base: BASE_UNITS.TIME,
            prefixes: PREFIXES.NONE,
            value: 60,
            offset: 0
          },
          hour: {
            name: "hour",
            base: BASE_UNITS.TIME,
            prefixes: PREFIXES.NONE,
            value: 3600,
            offset: 0
          },
          day: {
            name: "day",
            base: BASE_UNITS.TIME,
            prefixes: PREFIXES.NONE,
            value: 86400,
            offset: 0
          },
          week: {
            name: "week",
            base: BASE_UNITS.TIME,
            prefixes: PREFIXES.NONE,
            value: 7 * 86400,
            offset: 0
          },
          month: {
            name: "month",
            base: BASE_UNITS.TIME,
            prefixes: PREFIXES.NONE,
            value: 2629800,
            // 1/12th of Julian year
            offset: 0
          },
          year: {
            name: "year",
            base: BASE_UNITS.TIME,
            prefixes: PREFIXES.NONE,
            value: 31557600,
            // Julian year
            offset: 0
          },
          decade: {
            name: "decade",
            base: BASE_UNITS.TIME,
            prefixes: PREFIXES.NONE,
            value: 315576e3,
            // Julian decade
            offset: 0
          },
          century: {
            name: "century",
            base: BASE_UNITS.TIME,
            prefixes: PREFIXES.NONE,
            value: 315576e4,
            // Julian century
            offset: 0
          },
          millennium: {
            name: "millennium",
            base: BASE_UNITS.TIME,
            prefixes: PREFIXES.NONE,
            value: 315576e5,
            // Julian millennium
            offset: 0
          },
          // Frequency
          hertz: {
            name: "Hertz",
            base: BASE_UNITS.FREQUENCY,
            prefixes: PREFIXES.LONG,
            value: 1,
            offset: 0,
            reciprocal: true
          },
          Hz: {
            name: "Hz",
            base: BASE_UNITS.FREQUENCY,
            prefixes: PREFIXES.SHORT,
            value: 1,
            offset: 0,
            reciprocal: true
          },
          // Angle
          rad: {
            name: "rad",
            base: BASE_UNITS.ANGLE,
            prefixes: PREFIXES.SHORT,
            value: 1,
            offset: 0
          },
          radian: {
            name: "radian",
            base: BASE_UNITS.ANGLE,
            prefixes: PREFIXES.LONG,
            value: 1,
            offset: 0
          },
          // deg = rad / (2*pi) * 360 = rad / 0.017453292519943295769236907684888
          deg: {
            name: "deg",
            base: BASE_UNITS.ANGLE,
            prefixes: PREFIXES.SHORT,
            value: null,
            // will be filled in by calculateAngleValues()
            offset: 0
          },
          degree: {
            name: "degree",
            base: BASE_UNITS.ANGLE,
            prefixes: PREFIXES.LONG,
            value: null,
            // will be filled in by calculateAngleValues()
            offset: 0
          },
          // grad = rad / (2*pi) * 400  = rad / 0.015707963267948966192313216916399
          grad: {
            name: "grad",
            base: BASE_UNITS.ANGLE,
            prefixes: PREFIXES.SHORT,
            value: null,
            // will be filled in by calculateAngleValues()
            offset: 0
          },
          gradian: {
            name: "gradian",
            base: BASE_UNITS.ANGLE,
            prefixes: PREFIXES.LONG,
            value: null,
            // will be filled in by calculateAngleValues()
            offset: 0
          },
          // cycle = rad / (2*pi) = rad / 6.2831853071795864769252867665793
          cycle: {
            name: "cycle",
            base: BASE_UNITS.ANGLE,
            prefixes: PREFIXES.NONE,
            value: null,
            // will be filled in by calculateAngleValues()
            offset: 0
          },
          // arcsec = rad / (3600 * (360 / 2 * pi)) = rad / 0.0000048481368110953599358991410235795
          arcsec: {
            name: "arcsec",
            base: BASE_UNITS.ANGLE,
            prefixes: PREFIXES.NONE,
            value: null,
            // will be filled in by calculateAngleValues()
            offset: 0
          },
          // arcmin = rad / (60 * (360 / 2 * pi)) = rad / 0.00029088820866572159615394846141477
          arcmin: {
            name: "arcmin",
            base: BASE_UNITS.ANGLE,
            prefixes: PREFIXES.NONE,
            value: null,
            // will be filled in by calculateAngleValues()
            offset: 0
          },
          // Electric current
          A: {
            name: "A",
            base: BASE_UNITS.CURRENT,
            prefixes: PREFIXES.SHORT,
            value: 1,
            offset: 0
          },
          ampere: {
            name: "ampere",
            base: BASE_UNITS.CURRENT,
            prefixes: PREFIXES.LONG,
            value: 1,
            offset: 0
          },
          // Temperature
          // K(C) = C + 273.15
          // K(F) = (F + 459.67) * (5 / 9)
          // K(R) = R * (5 / 9)
          K: {
            name: "K",
            base: BASE_UNITS.TEMPERATURE,
            prefixes: PREFIXES.SHORT,
            value: 1,
            offset: 0
          },
          degC: {
            name: "degC",
            base: BASE_UNITS.TEMPERATURE,
            prefixes: PREFIXES.SHORT,
            value: 1,
            offset: 273.15
          },
          degF: {
            name: "degF",
            base: BASE_UNITS.TEMPERATURE,
            prefixes: PREFIXES.SHORT,
            value: new _Fraction(5, 9),
            offset: 459.67
          },
          degR: {
            name: "degR",
            base: BASE_UNITS.TEMPERATURE,
            prefixes: PREFIXES.SHORT,
            value: new _Fraction(5, 9),
            offset: 0
          },
          kelvin: {
            name: "kelvin",
            base: BASE_UNITS.TEMPERATURE,
            prefixes: PREFIXES.LONG,
            value: 1,
            offset: 0
          },
          celsius: {
            name: "celsius",
            base: BASE_UNITS.TEMPERATURE,
            prefixes: PREFIXES.LONG,
            value: 1,
            offset: 273.15
          },
          fahrenheit: {
            name: "fahrenheit",
            base: BASE_UNITS.TEMPERATURE,
            prefixes: PREFIXES.LONG,
            value: new _Fraction(5, 9),
            offset: 459.67
          },
          rankine: {
            name: "rankine",
            base: BASE_UNITS.TEMPERATURE,
            prefixes: PREFIXES.LONG,
            value: new _Fraction(5, 9),
            offset: 0
          },
          // amount of substance
          mol: {
            name: "mol",
            base: BASE_UNITS.AMOUNT_OF_SUBSTANCE,
            prefixes: PREFIXES.SHORT,
            value: 1,
            offset: 0
          },
          mole: {
            name: "mole",
            base: BASE_UNITS.AMOUNT_OF_SUBSTANCE,
            prefixes: PREFIXES.LONG,
            value: 1,
            offset: 0
          },
          // luminous intensity
          cd: {
            name: "cd",
            base: BASE_UNITS.LUMINOUS_INTENSITY,
            prefixes: PREFIXES.SHORT,
            value: 1,
            offset: 0
          },
          candela: {
            name: "candela",
            base: BASE_UNITS.LUMINOUS_INTENSITY,
            prefixes: PREFIXES.LONG,
            value: 1,
            offset: 0
          },
          // TODO: units STERADIAN
          // {name: 'sr', base: BASE_UNITS.STERADIAN, prefixes: PREFIXES.NONE, value: 1, offset: 0},
          // {name: 'steradian', base: BASE_UNITS.STERADIAN, prefixes: PREFIXES.NONE, value: 1, offset: 0},
          // Force
          N: {
            name: "N",
            base: BASE_UNITS.FORCE,
            prefixes: PREFIXES.SHORT,
            value: 1,
            offset: 0
          },
          newton: {
            name: "newton",
            base: BASE_UNITS.FORCE,
            prefixes: PREFIXES.LONG,
            value: 1,
            offset: 0
          },
          dyn: {
            name: "dyn",
            base: BASE_UNITS.FORCE,
            prefixes: PREFIXES.SHORT,
            value: 1e-5,
            offset: 0
          },
          dyne: {
            name: "dyne",
            base: BASE_UNITS.FORCE,
            prefixes: PREFIXES.LONG,
            value: 1e-5,
            offset: 0
          },
          lbf: {
            name: "lbf",
            base: BASE_UNITS.FORCE,
            prefixes: PREFIXES.NONE,
            value: 4.4482216152605,
            offset: 0
          },
          poundforce: {
            name: "poundforce",
            base: BASE_UNITS.FORCE,
            prefixes: PREFIXES.NONE,
            value: 4.4482216152605,
            offset: 0
          },
          kip: {
            name: "kip",
            base: BASE_UNITS.FORCE,
            prefixes: PREFIXES.LONG,
            value: 4448.2216,
            offset: 0
          },
          kilogramforce: {
            name: "kilogramforce",
            base: BASE_UNITS.FORCE,
            prefixes: PREFIXES.NONE,
            value: 9.80665,
            offset: 0
          },
          // Energy
          J: {
            name: "J",
            base: BASE_UNITS.ENERGY,
            prefixes: PREFIXES.SHORT,
            value: 1,
            offset: 0
          },
          joule: {
            name: "joule",
            base: BASE_UNITS.ENERGY,
            prefixes: PREFIXES.LONG,
            value: 1,
            offset: 0
          },
          erg: {
            name: "erg",
            base: BASE_UNITS.ENERGY,
            prefixes: PREFIXES.SHORTLONG,
            // Both kiloerg and kerg are acceptable
            value: 1e-7,
            offset: 0
          },
          Wh: {
            name: "Wh",
            base: BASE_UNITS.ENERGY,
            prefixes: PREFIXES.SHORT,
            value: 3600,
            offset: 0
          },
          BTU: {
            name: "BTU",
            base: BASE_UNITS.ENERGY,
            prefixes: PREFIXES.BTU,
            value: 1055.05585262,
            offset: 0
          },
          eV: {
            name: "eV",
            base: BASE_UNITS.ENERGY,
            prefixes: PREFIXES.SHORT,
            value: 1602176565e-28,
            offset: 0
          },
          electronvolt: {
            name: "electronvolt",
            base: BASE_UNITS.ENERGY,
            prefixes: PREFIXES.LONG,
            value: 1602176565e-28,
            offset: 0
          },
          // Power
          W: {
            name: "W",
            base: BASE_UNITS.POWER,
            prefixes: PREFIXES.SHORT,
            value: 1,
            offset: 0
          },
          watt: {
            name: "watt",
            base: BASE_UNITS.POWER,
            prefixes: PREFIXES.LONG,
            value: 1,
            offset: 0
          },
          hp: {
            name: "hp",
            base: BASE_UNITS.POWER,
            prefixes: PREFIXES.NONE,
            value: 745.6998715386,
            offset: 0
          },
          // Electrical power units
          VAR: {
            name: "VAR",
            base: BASE_UNITS.POWER,
            prefixes: PREFIXES.SHORT,
            value: Complex3.I,
            offset: 0
          },
          VA: {
            name: "VA",
            base: BASE_UNITS.POWER,
            prefixes: PREFIXES.SHORT,
            value: 1,
            offset: 0
          },
          // Pressure
          Pa: {
            name: "Pa",
            base: BASE_UNITS.PRESSURE,
            prefixes: PREFIXES.SHORT,
            value: 1,
            offset: 0
          },
          psi: {
            name: "psi",
            base: BASE_UNITS.PRESSURE,
            prefixes: PREFIXES.NONE,
            value: 6894.75729276459,
            offset: 0
          },
          atm: {
            name: "atm",
            base: BASE_UNITS.PRESSURE,
            prefixes: PREFIXES.NONE,
            value: 101325,
            offset: 0
          },
          bar: {
            name: "bar",
            base: BASE_UNITS.PRESSURE,
            prefixes: PREFIXES.SHORTLONG,
            value: 1e5,
            offset: 0
          },
          torr: {
            name: "torr",
            base: BASE_UNITS.PRESSURE,
            prefixes: PREFIXES.NONE,
            value: 133.322,
            offset: 0
          },
          mmHg: {
            name: "mmHg",
            base: BASE_UNITS.PRESSURE,
            prefixes: PREFIXES.NONE,
            value: 133.322,
            offset: 0
          },
          mmH2O: {
            name: "mmH2O",
            base: BASE_UNITS.PRESSURE,
            prefixes: PREFIXES.NONE,
            value: 9.80665,
            offset: 0
          },
          cmH2O: {
            name: "cmH2O",
            base: BASE_UNITS.PRESSURE,
            prefixes: PREFIXES.NONE,
            value: 98.0665,
            offset: 0
          },
          // Electric charge
          coulomb: {
            name: "coulomb",
            base: BASE_UNITS.ELECTRIC_CHARGE,
            prefixes: PREFIXES.LONG,
            value: 1,
            offset: 0
          },
          C: {
            name: "C",
            base: BASE_UNITS.ELECTRIC_CHARGE,
            prefixes: PREFIXES.SHORT,
            value: 1,
            offset: 0
          },
          // Electric capacitance
          farad: {
            name: "farad",
            base: BASE_UNITS.ELECTRIC_CAPACITANCE,
            prefixes: PREFIXES.LONG,
            value: 1,
            offset: 0
          },
          F: {
            name: "F",
            base: BASE_UNITS.ELECTRIC_CAPACITANCE,
            prefixes: PREFIXES.SHORT,
            value: 1,
            offset: 0
          },
          // Electric potential
          volt: {
            name: "volt",
            base: BASE_UNITS.ELECTRIC_POTENTIAL,
            prefixes: PREFIXES.LONG,
            value: 1,
            offset: 0
          },
          V: {
            name: "V",
            base: BASE_UNITS.ELECTRIC_POTENTIAL,
            prefixes: PREFIXES.SHORT,
            value: 1,
            offset: 0
          },
          // Electric resistance
          ohm: {
            name: "ohm",
            base: BASE_UNITS.ELECTRIC_RESISTANCE,
            prefixes: PREFIXES.SHORTLONG,
            // Both Mohm and megaohm are acceptable
            value: 1,
            offset: 0
          },
          /*
           * Unicode breaks in browsers if charset is not specified
          : {
            name: '',
            base: BASE_UNITS.ELECTRIC_RESISTANCE,
            prefixes: PREFIXES.SHORT,
            value: 1,
            offset: 0
          },
          */
          // Electric inductance
          henry: {
            name: "henry",
            base: BASE_UNITS.ELECTRIC_INDUCTANCE,
            prefixes: PREFIXES.LONG,
            value: 1,
            offset: 0
          },
          H: {
            name: "H",
            base: BASE_UNITS.ELECTRIC_INDUCTANCE,
            prefixes: PREFIXES.SHORT,
            value: 1,
            offset: 0
          },
          // Electric conductance
          siemens: {
            name: "siemens",
            base: BASE_UNITS.ELECTRIC_CONDUCTANCE,
            prefixes: PREFIXES.LONG,
            value: 1,
            offset: 0
          },
          S: {
            name: "S",
            base: BASE_UNITS.ELECTRIC_CONDUCTANCE,
            prefixes: PREFIXES.SHORT,
            value: 1,
            offset: 0
          },
          // Magnetic flux
          weber: {
            name: "weber",
            base: BASE_UNITS.MAGNETIC_FLUX,
            prefixes: PREFIXES.LONG,
            value: 1,
            offset: 0
          },
          Wb: {
            name: "Wb",
            base: BASE_UNITS.MAGNETIC_FLUX,
            prefixes: PREFIXES.SHORT,
            value: 1,
            offset: 0
          },
          // Magnetic flux density
          tesla: {
            name: "tesla",
            base: BASE_UNITS.MAGNETIC_FLUX_DENSITY,
            prefixes: PREFIXES.LONG,
            value: 1,
            offset: 0
          },
          T: {
            name: "T",
            base: BASE_UNITS.MAGNETIC_FLUX_DENSITY,
            prefixes: PREFIXES.SHORT,
            value: 1,
            offset: 0
          },
          // Binary
          b: {
            name: "b",
            base: BASE_UNITS.BIT,
            prefixes: PREFIXES.BINARY_SHORT,
            value: 1,
            offset: 0
          },
          bits: {
            name: "bits",
            base: BASE_UNITS.BIT,
            prefixes: PREFIXES.BINARY_LONG,
            value: 1,
            offset: 0
          },
          B: {
            name: "B",
            base: BASE_UNITS.BIT,
            prefixes: PREFIXES.BINARY_SHORT,
            value: 8,
            offset: 0
          },
          bytes: {
            name: "bytes",
            base: BASE_UNITS.BIT,
            prefixes: PREFIXES.BINARY_LONG,
            value: 8,
            offset: 0
          }
        };
        var ALIASES = {
          meters: "meter",
          inches: "inch",
          feet: "foot",
          yards: "yard",
          miles: "mile",
          links: "link",
          rods: "rod",
          chains: "chain",
          angstroms: "angstrom",
          lt: "l",
          litres: "litre",
          liter: "litre",
          liters: "litre",
          teaspoons: "teaspoon",
          tablespoons: "tablespoon",
          minims: "minim",
          fluiddrams: "fluiddram",
          fluidounces: "fluidounce",
          gills: "gill",
          cups: "cup",
          pints: "pint",
          quarts: "quart",
          gallons: "gallon",
          beerbarrels: "beerbarrel",
          oilbarrels: "oilbarrel",
          hogsheads: "hogshead",
          gtts: "gtt",
          grams: "gram",
          tons: "ton",
          tonnes: "tonne",
          grains: "grain",
          drams: "dram",
          ounces: "ounce",
          poundmasses: "poundmass",
          hundredweights: "hundredweight",
          sticks: "stick",
          lb: "lbm",
          lbs: "lbm",
          kips: "kip",
          kgf: "kilogramforce",
          acres: "acre",
          hectares: "hectare",
          sqfeet: "sqft",
          sqyard: "sqyd",
          sqmile: "sqmi",
          sqmiles: "sqmi",
          mmhg: "mmHg",
          mmh2o: "mmH2O",
          cmh2o: "cmH2O",
          seconds: "second",
          secs: "second",
          minutes: "minute",
          mins: "minute",
          hours: "hour",
          hr: "hour",
          hrs: "hour",
          days: "day",
          weeks: "week",
          months: "month",
          years: "year",
          decades: "decade",
          centuries: "century",
          millennia: "millennium",
          hertz: "hertz",
          radians: "radian",
          degrees: "degree",
          gradians: "gradian",
          cycles: "cycle",
          arcsecond: "arcsec",
          arcseconds: "arcsec",
          arcminute: "arcmin",
          arcminutes: "arcmin",
          BTUs: "BTU",
          watts: "watt",
          joules: "joule",
          amperes: "ampere",
          amps: "ampere",
          amp: "ampere",
          coulombs: "coulomb",
          volts: "volt",
          ohms: "ohm",
          farads: "farad",
          webers: "weber",
          teslas: "tesla",
          electronvolts: "electronvolt",
          moles: "mole",
          bit: "bits",
          "byte": "bytes"
        };
        function calculateAngleValues(config5) {
          if (config5.number === "BigNumber") {
            var pi = (0, _constants.createBigNumberPi)(_BigNumber);
            UNITS.rad.value = new _BigNumber(1);
            UNITS.deg.value = pi.div(180);
            UNITS.grad.value = pi.div(200);
            UNITS.cycle.value = pi.times(2);
            UNITS.arcsec.value = pi.div(648e3);
            UNITS.arcmin.value = pi.div(10800);
          } else {
            UNITS.rad.value = 1;
            UNITS.deg.value = Math.PI / 180;
            UNITS.grad.value = Math.PI / 200;
            UNITS.cycle.value = Math.PI * 2;
            UNITS.arcsec.value = Math.PI / 648e3;
            UNITS.arcmin.value = Math.PI / 10800;
          }
          UNITS.radian.value = UNITS.rad.value;
          UNITS.degree.value = UNITS.deg.value;
          UNITS.gradian.value = UNITS.grad.value;
        }
        calculateAngleValues(config4);
        if (on) {
          on("config", function(curr, prev) {
            if (curr.number !== prev.number) {
              calculateAngleValues(curr);
            }
          });
        }
        var UNIT_SYSTEMS = {
          si: {
            // Base units
            NONE: {
              unit: UNIT_NONE,
              prefix: PREFIXES.NONE[""]
            },
            LENGTH: {
              unit: UNITS.m,
              prefix: PREFIXES.SHORT[""]
            },
            MASS: {
              unit: UNITS.g,
              prefix: PREFIXES.SHORT.k
            },
            TIME: {
              unit: UNITS.s,
              prefix: PREFIXES.SHORT[""]
            },
            CURRENT: {
              unit: UNITS.A,
              prefix: PREFIXES.SHORT[""]
            },
            TEMPERATURE: {
              unit: UNITS.K,
              prefix: PREFIXES.SHORT[""]
            },
            LUMINOUS_INTENSITY: {
              unit: UNITS.cd,
              prefix: PREFIXES.SHORT[""]
            },
            AMOUNT_OF_SUBSTANCE: {
              unit: UNITS.mol,
              prefix: PREFIXES.SHORT[""]
            },
            ANGLE: {
              unit: UNITS.rad,
              prefix: PREFIXES.SHORT[""]
            },
            BIT: {
              unit: UNITS.bits,
              prefix: PREFIXES.SHORT[""]
            },
            // Derived units
            FORCE: {
              unit: UNITS.N,
              prefix: PREFIXES.SHORT[""]
            },
            ENERGY: {
              unit: UNITS.J,
              prefix: PREFIXES.SHORT[""]
            },
            POWER: {
              unit: UNITS.W,
              prefix: PREFIXES.SHORT[""]
            },
            PRESSURE: {
              unit: UNITS.Pa,
              prefix: PREFIXES.SHORT[""]
            },
            ELECTRIC_CHARGE: {
              unit: UNITS.C,
              prefix: PREFIXES.SHORT[""]
            },
            ELECTRIC_CAPACITANCE: {
              unit: UNITS.F,
              prefix: PREFIXES.SHORT[""]
            },
            ELECTRIC_POTENTIAL: {
              unit: UNITS.V,
              prefix: PREFIXES.SHORT[""]
            },
            ELECTRIC_RESISTANCE: {
              unit: UNITS.ohm,
              prefix: PREFIXES.SHORT[""]
            },
            ELECTRIC_INDUCTANCE: {
              unit: UNITS.H,
              prefix: PREFIXES.SHORT[""]
            },
            ELECTRIC_CONDUCTANCE: {
              unit: UNITS.S,
              prefix: PREFIXES.SHORT[""]
            },
            MAGNETIC_FLUX: {
              unit: UNITS.Wb,
              prefix: PREFIXES.SHORT[""]
            },
            MAGNETIC_FLUX_DENSITY: {
              unit: UNITS.T,
              prefix: PREFIXES.SHORT[""]
            },
            FREQUENCY: {
              unit: UNITS.Hz,
              prefix: PREFIXES.SHORT[""]
            }
          }
        };
        UNIT_SYSTEMS.cgs = JSON.parse(JSON.stringify(UNIT_SYSTEMS.si));
        UNIT_SYSTEMS.cgs.LENGTH = {
          unit: UNITS.m,
          prefix: PREFIXES.SHORT.c
        };
        UNIT_SYSTEMS.cgs.MASS = {
          unit: UNITS.g,
          prefix: PREFIXES.SHORT[""]
        };
        UNIT_SYSTEMS.cgs.FORCE = {
          unit: UNITS.dyn,
          prefix: PREFIXES.SHORT[""]
        };
        UNIT_SYSTEMS.cgs.ENERGY = {
          unit: UNITS.erg,
          prefix: PREFIXES.NONE[""]
        };
        UNIT_SYSTEMS.us = JSON.parse(JSON.stringify(UNIT_SYSTEMS.si));
        UNIT_SYSTEMS.us.LENGTH = {
          unit: UNITS.ft,
          prefix: PREFIXES.NONE[""]
        };
        UNIT_SYSTEMS.us.MASS = {
          unit: UNITS.lbm,
          prefix: PREFIXES.NONE[""]
        };
        UNIT_SYSTEMS.us.TEMPERATURE = {
          unit: UNITS.degF,
          prefix: PREFIXES.NONE[""]
        };
        UNIT_SYSTEMS.us.FORCE = {
          unit: UNITS.lbf,
          prefix: PREFIXES.NONE[""]
        };
        UNIT_SYSTEMS.us.ENERGY = {
          unit: UNITS.BTU,
          prefix: PREFIXES.BTU[""]
        };
        UNIT_SYSTEMS.us.POWER = {
          unit: UNITS.hp,
          prefix: PREFIXES.NONE[""]
        };
        UNIT_SYSTEMS.us.PRESSURE = {
          unit: UNITS.psi,
          prefix: PREFIXES.NONE[""]
        };
        UNIT_SYSTEMS.auto = JSON.parse(JSON.stringify(UNIT_SYSTEMS.si));
        var currentUnitSystem = UNIT_SYSTEMS.auto;
        Unit.setUnitSystem = function(name19) {
          if ((0, _object.hasOwnProperty)(UNIT_SYSTEMS, name19)) {
            currentUnitSystem = UNIT_SYSTEMS[name19];
          } else {
            throw new Error("Unit system " + name19 + " does not exist. Choices are: " + Object.keys(UNIT_SYSTEMS).join(", "));
          }
        };
        Unit.getUnitSystem = function() {
          for (var _key in UNIT_SYSTEMS) {
            if ((0, _object.hasOwnProperty)(UNIT_SYSTEMS, _key)) {
              if (UNIT_SYSTEMS[_key] === currentUnitSystem) {
                return _key;
              }
            }
          }
        };
        Unit.typeConverters = {
          BigNumber: function BigNumber2(x) {
            if (x !== null && x !== void 0 && x.isFraction) return new _BigNumber(x.n).div(x.d).times(x.s);
            return new _BigNumber(x + "");
          },
          Fraction: function Fraction3(x) {
            return new _Fraction(x);
          },
          Complex: function Complex4(x) {
            return x;
          },
          number: function number(x) {
            if (x !== null && x !== void 0 && x.isFraction) return _number(x);
            return x;
          }
        };
        Unit.prototype._numberConverter = function() {
          var convert = Unit.typeConverters[this.valueType()];
          if (convert) {
            return convert;
          }
          throw new TypeError('Unsupported Unit value type "' + this.valueType() + '"');
        };
        Unit._getNumberConverter = function(type) {
          if (!Unit.typeConverters[type]) {
            throw new TypeError('Unsupported type "' + type + '"');
          }
          return Unit.typeConverters[type];
        };
        for (var _key2 in UNITS) {
          if ((0, _object.hasOwnProperty)(UNITS, _key2)) {
            var unit = UNITS[_key2];
            unit.dimensions = unit.base.dimensions;
          }
        }
        for (var _name2 in ALIASES) {
          if ((0, _object.hasOwnProperty)(ALIASES, _name2)) {
            var _unit2 = UNITS[ALIASES[_name2]];
            var alias = {};
            for (var _key3 in _unit2) {
              if ((0, _object.hasOwnProperty)(_unit2, _key3)) {
                alias[_key3] = _unit2[_key3];
              }
            }
            alias.name = _name2;
            UNITS[_name2] = alias;
          }
        }
        Unit.isValidAlpha = function isValidAlpha(c2) {
          return /^[a-zA-Z]$/.test(c2);
        };
        function assertUnitNameIsValid(name19) {
          for (var i = 0; i < name19.length; i++) {
            c = name19.charAt(i);
            if (i === 0 && !Unit.isValidAlpha(c)) {
              throw new Error('Invalid unit name (must begin with alpha character): "' + name19 + '"');
            }
            if (i > 0 && !(Unit.isValidAlpha(c) || isDigit(c))) {
              throw new Error('Invalid unit name (only alphanumeric characters are allowed): "' + name19 + '"');
            }
          }
        }
        Unit.createUnit = function(obj, options) {
          if ((0, _typeof2["default"])(obj) !== "object") {
            throw new TypeError("createUnit expects first parameter to be of type 'Object'");
          }
          if (options && options.override) {
            for (var _key4 in obj) {
              if ((0, _object.hasOwnProperty)(obj, _key4)) {
                Unit.deleteUnit(_key4);
              }
              if (obj[_key4].aliases) {
                for (var i = 0; i < obj[_key4].aliases.length; i++) {
                  Unit.deleteUnit(obj[_key4].aliases[i]);
                }
              }
            }
          }
          var lastUnit;
          for (var _key5 in obj) {
            if ((0, _object.hasOwnProperty)(obj, _key5)) {
              lastUnit = Unit.createUnitSingle(_key5, obj[_key5]);
            }
          }
          return lastUnit;
        };
        Unit.createUnitSingle = function(name19, obj) {
          if (typeof obj === "undefined" || obj === null) {
            obj = {};
          }
          if (typeof name19 !== "string") {
            throw new TypeError("createUnitSingle expects first parameter to be of type 'string'");
          }
          if ((0, _object.hasOwnProperty)(UNITS, name19)) {
            throw new Error('Cannot create unit "' + name19 + '": a unit with that name already exists');
          }
          assertUnitNameIsValid(name19);
          var defUnit = null;
          var aliases = [];
          var offset = 0;
          var definition;
          var prefixes;
          var baseName;
          if (obj && obj.type === "Unit") {
            defUnit = obj.clone();
          } else if (typeof obj === "string") {
            if (obj !== "") {
              definition = obj;
            }
          } else if ((0, _typeof2["default"])(obj) === "object") {
            definition = obj.definition;
            prefixes = obj.prefixes;
            offset = obj.offset;
            baseName = obj.baseName;
            if (obj.aliases) {
              aliases = obj.aliases.valueOf();
            }
          } else {
            throw new TypeError('Cannot create unit "' + name19 + '" from "' + obj.toString() + '": expecting "string" or "Unit" or "Object"');
          }
          if (aliases) {
            for (var i = 0; i < aliases.length; i++) {
              if ((0, _object.hasOwnProperty)(UNITS, aliases[i])) {
                throw new Error('Cannot create alias "' + aliases[i] + '": a unit with that name already exists');
              }
            }
          }
          if (definition && typeof definition === "string" && !defUnit) {
            try {
              defUnit = Unit.parse(definition, {
                allowNoUnits: true
              });
            } catch (ex) {
              ex.message = 'Could not create unit "' + name19 + '" from "' + definition + '": ' + ex.message;
              throw ex;
            }
          } else if (definition && definition.type === "Unit") {
            defUnit = definition.clone();
          }
          aliases = aliases || [];
          offset = offset || 0;
          if (prefixes && prefixes.toUpperCase) {
            prefixes = PREFIXES[prefixes.toUpperCase()] || PREFIXES.NONE;
          } else {
            prefixes = PREFIXES.NONE;
          }
          var newUnit = {};
          if (!defUnit) {
            baseName = baseName || name19 + "_STUFF";
            if (BASE_DIMENSIONS.indexOf(baseName) >= 0) {
              throw new Error('Cannot create new base unit "' + name19 + '": a base unit with that name already exists (and cannot be overridden)');
            }
            BASE_DIMENSIONS.push(baseName);
            for (var b in BASE_UNITS) {
              if ((0, _object.hasOwnProperty)(BASE_UNITS, b)) {
                BASE_UNITS[b].dimensions[BASE_DIMENSIONS.length - 1] = 0;
              }
            }
            var newBaseUnit = {
              dimensions: []
            };
            for (var _i6 = 0; _i6 < BASE_DIMENSIONS.length; _i6++) {
              newBaseUnit.dimensions[_i6] = 0;
            }
            newBaseUnit.dimensions[BASE_DIMENSIONS.length - 1] = 1;
            newBaseUnit.key = baseName;
            BASE_UNITS[baseName] = newBaseUnit;
            newUnit = {
              name: name19,
              value: 1,
              dimensions: BASE_UNITS[baseName].dimensions.slice(0),
              prefixes,
              offset,
              base: BASE_UNITS[baseName]
            };
            currentUnitSystem[baseName] = {
              unit: newUnit,
              prefix: PREFIXES.NONE[""]
            };
          } else {
            newUnit = {
              name: name19,
              value: defUnit.value,
              dimensions: defUnit.dimensions.slice(0),
              prefixes,
              offset
            };
            var anyMatch = false;
            for (var _i7 in BASE_UNITS) {
              if ((0, _object.hasOwnProperty)(BASE_UNITS, _i7)) {
                var match = true;
                for (var j = 0; j < BASE_DIMENSIONS.length; j++) {
                  if (Math.abs((newUnit.dimensions[j] || 0) - (BASE_UNITS[_i7].dimensions[j] || 0)) > 1e-12) {
                    match = false;
                    break;
                  }
                }
                if (match) {
                  anyMatch = true;
                  newUnit.base = BASE_UNITS[_i7];
                  break;
                }
              }
            }
            if (!anyMatch) {
              baseName = baseName || name19 + "_STUFF";
              var _newBaseUnit = {
                dimensions: defUnit.dimensions.slice(0)
              };
              _newBaseUnit.key = baseName;
              BASE_UNITS[baseName] = _newBaseUnit;
              currentUnitSystem[baseName] = {
                unit: newUnit,
                prefix: PREFIXES.NONE[""]
              };
              newUnit.base = BASE_UNITS[baseName];
            }
          }
          Unit.UNITS[name19] = newUnit;
          for (var _i8 = 0; _i8 < aliases.length; _i8++) {
            var aliasName = aliases[_i8];
            var _alias = {};
            for (var _key6 in newUnit) {
              if ((0, _object.hasOwnProperty)(newUnit, _key6)) {
                _alias[_key6] = newUnit[_key6];
              }
            }
            _alias.name = aliasName;
            Unit.UNITS[aliasName] = _alias;
          }
          delete _findUnit.cache;
          return new Unit(null, name19);
        };
        Unit.deleteUnit = function(name19) {
          delete Unit.UNITS[name19];
          delete _findUnit.cache;
        };
        Unit.PREFIXES = PREFIXES;
        Unit.BASE_DIMENSIONS = BASE_DIMENSIONS;
        Unit.BASE_UNITS = BASE_UNITS;
        Unit.UNIT_SYSTEMS = UNIT_SYSTEMS;
        Unit.UNITS = UNITS;
        return Unit;
      }, {
        isClass: true
      });
    }
  });

  // node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/type/unit/function/unit.js
  var require_unit = __commonJS({
    "node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/type/unit/function/unit.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.createUnitFunction = void 0;
      var _factory = require_factory();
      var _collection = require_collection();
      var name18 = "unit";
      var dependencies19 = ["typed", "Unit"];
      var createUnitFunction2 = exports.createUnitFunction = /* @__PURE__ */ (0, _factory.factory)(name18, dependencies19, function(_ref) {
        var typed2 = _ref.typed, Unit = _ref.Unit;
        return typed2(name18, {
          Unit: function Unit2(x) {
            return x.clone();
          },
          string: function string(x) {
            if (Unit.isValuelessUnit(x)) {
              return new Unit(null, x);
            }
            return Unit.parse(x, {
              allowNoUnits: true
            });
          },
          "number | BigNumber | Fraction | Complex, string | Unit": function numberBigNumberFractionComplexStringUnit(value, unit) {
            return new Unit(value, unit);
          },
          "number | BigNumber | Fraction": function numberBigNumberFraction(value) {
            return new Unit(value);
          },
          "Array | Matrix": typed2.referToSelf(function(self2) {
            return function(x) {
              return (0, _collection.deepMap)(x, self2);
            };
          })
        });
      });
    }
  });

  // node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/type/matrix/function/sparse.js
  var require_sparse = __commonJS({
    "node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/type/matrix/function/sparse.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.createSparse = void 0;
      var _factory = require_factory();
      var name18 = "sparse";
      var dependencies19 = ["typed", "SparseMatrix"];
      var createSparse2 = exports.createSparse = /* @__PURE__ */ (0, _factory.factory)(name18, dependencies19, function(_ref) {
        var typed2 = _ref.typed, SparseMatrix2 = _ref.SparseMatrix;
        return typed2(name18, {
          "": function _() {
            return new SparseMatrix2([]);
          },
          string: function string(datatype) {
            return new SparseMatrix2([], datatype);
          },
          "Array | Matrix": function ArrayMatrix(data) {
            return new SparseMatrix2(data);
          },
          "Array | Matrix, string": function ArrayMatrixString(data, datatype) {
            return new SparseMatrix2(data, datatype);
          }
        });
      });
    }
  });

  // node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/type/unit/function/createUnit.js
  var require_createUnit = __commonJS({
    "node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/type/unit/function/createUnit.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.createCreateUnit = void 0;
      var _factory = require_factory();
      var name18 = "createUnit";
      var dependencies19 = ["typed", "Unit"];
      var createCreateUnit2 = exports.createCreateUnit = /* @__PURE__ */ (0, _factory.factory)(name18, dependencies19, function(_ref) {
        var typed2 = _ref.typed, Unit = _ref.Unit;
        return typed2(name18, {
          // General function signature. First parameter is an object where each property is the definition of a new unit. The object keys are the unit names and the values are the definitions. The values can be objects, strings, or Units. If a property is an empty object or an empty string, a new base unit is created. The second parameter is the options.
          "Object, Object": function ObjectObject(obj, options) {
            return Unit.createUnit(obj, options);
          },
          // Same as above but without the options.
          Object: function Object2(obj) {
            return Unit.createUnit(obj, {});
          },
          // Shortcut method for creating one unit.
          "string, Unit | string | Object, Object": function stringUnitStringObjectObject(name19, def, options) {
            var obj = {};
            obj[name19] = def;
            return Unit.createUnit(obj, options);
          },
          // Same as above but without the options.
          "string, Unit | string | Object": function stringUnitStringObject(name19, def) {
            var obj = {};
            obj[name19] = def;
            return Unit.createUnit(obj, {});
          },
          // Without a definition, creates a base unit.
          string: function string(name19) {
            var obj = {};
            obj[name19] = {};
            return Unit.createUnit(obj, {});
          }
        });
      });
    }
  });

  // node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/function/trigonometry/acos.js
  var require_acos = __commonJS({
    "node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/function/trigonometry/acos.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.createAcos = void 0;
      var _factory = require_factory();
      var name18 = "acos";
      var dependencies19 = ["typed", "config", "Complex"];
      var createAcos2 = exports.createAcos = /* @__PURE__ */ (0, _factory.factory)(name18, dependencies19, function(_ref) {
        var typed2 = _ref.typed, config4 = _ref.config, Complex3 = _ref.Complex;
        return typed2(name18, {
          number: function number(x) {
            if (x >= -1 && x <= 1 || config4.predictable) {
              return Math.acos(x);
            } else {
              return new Complex3(x, 0).acos();
            }
          },
          Complex: function Complex4(x) {
            return x.acos();
          },
          BigNumber: function BigNumber2(x) {
            return x.acos();
          }
        });
      });
    }
  });

  // node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/function/trigonometry/acosh.js
  var require_acosh = __commonJS({
    "node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/function/trigonometry/acosh.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.createAcosh = void 0;
      var _factory = require_factory();
      var _index = require_number2();
      var name18 = "acosh";
      var dependencies19 = ["typed", "config", "Complex"];
      var createAcosh2 = exports.createAcosh = /* @__PURE__ */ (0, _factory.factory)(name18, dependencies19, function(_ref) {
        var typed2 = _ref.typed, config4 = _ref.config, Complex3 = _ref.Complex;
        return typed2(name18, {
          number: function number(x) {
            if (x >= 1 || config4.predictable) {
              return (0, _index.acoshNumber)(x);
            }
            if (x <= -1) {
              return new Complex3(Math.log(Math.sqrt(x * x - 1) - x), Math.PI);
            }
            return new Complex3(x, 0).acosh();
          },
          Complex: function Complex4(x) {
            return x.acosh();
          },
          BigNumber: function BigNumber2(x) {
            return x.acosh();
          }
        });
      });
    }
  });

  // node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/function/trigonometry/acot.js
  var require_acot = __commonJS({
    "node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/function/trigonometry/acot.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.createAcot = void 0;
      var _factory = require_factory();
      var _index = require_number2();
      var name18 = "acot";
      var dependencies19 = ["typed", "BigNumber"];
      var createAcot2 = exports.createAcot = /* @__PURE__ */ (0, _factory.factory)(name18, dependencies19, function(_ref) {
        var typed2 = _ref.typed, _BigNumber = _ref.BigNumber;
        return typed2(name18, {
          number: _index.acotNumber,
          Complex: function Complex3(x) {
            return x.acot();
          },
          BigNumber: function BigNumber2(x) {
            return new _BigNumber(1).div(x).atan();
          }
        });
      });
    }
  });

  // node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/function/trigonometry/acoth.js
  var require_acoth = __commonJS({
    "node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/function/trigonometry/acoth.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.createAcoth = void 0;
      var _factory = require_factory();
      var _index = require_number2();
      var name18 = "acoth";
      var dependencies19 = ["typed", "config", "Complex", "BigNumber"];
      var createAcoth2 = exports.createAcoth = /* @__PURE__ */ (0, _factory.factory)(name18, dependencies19, function(_ref) {
        var typed2 = _ref.typed, config4 = _ref.config, Complex3 = _ref.Complex, _BigNumber = _ref.BigNumber;
        return typed2(name18, {
          number: function number(x) {
            if (x >= 1 || x <= -1 || config4.predictable) {
              return (0, _index.acothNumber)(x);
            }
            return new Complex3(x, 0).acoth();
          },
          Complex: function Complex4(x) {
            return x.acoth();
          },
          BigNumber: function BigNumber2(x) {
            return new _BigNumber(1).div(x).atanh();
          }
        });
      });
    }
  });

  // node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/function/trigonometry/acsc.js
  var require_acsc = __commonJS({
    "node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/function/trigonometry/acsc.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.createAcsc = void 0;
      var _factory = require_factory();
      var _index = require_number2();
      var name18 = "acsc";
      var dependencies19 = ["typed", "config", "Complex", "BigNumber"];
      var createAcsc2 = exports.createAcsc = /* @__PURE__ */ (0, _factory.factory)(name18, dependencies19, function(_ref) {
        var typed2 = _ref.typed, config4 = _ref.config, Complex3 = _ref.Complex, _BigNumber = _ref.BigNumber;
        return typed2(name18, {
          number: function number(x) {
            if (x <= -1 || x >= 1 || config4.predictable) {
              return (0, _index.acscNumber)(x);
            }
            return new Complex3(x, 0).acsc();
          },
          Complex: function Complex4(x) {
            return x.acsc();
          },
          BigNumber: function BigNumber2(x) {
            return new _BigNumber(1).div(x).asin();
          }
        });
      });
    }
  });

  // node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/function/trigonometry/acsch.js
  var require_acsch = __commonJS({
    "node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/function/trigonometry/acsch.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.createAcsch = void 0;
      var _factory = require_factory();
      var _index = require_number2();
      var name18 = "acsch";
      var dependencies19 = ["typed", "BigNumber"];
      var createAcsch2 = exports.createAcsch = /* @__PURE__ */ (0, _factory.factory)(name18, dependencies19, function(_ref) {
        var typed2 = _ref.typed, _BigNumber = _ref.BigNumber;
        return typed2(name18, {
          number: _index.acschNumber,
          Complex: function Complex3(x) {
            return x.acsch();
          },
          BigNumber: function BigNumber2(x) {
            return new _BigNumber(1).div(x).asinh();
          }
        });
      });
    }
  });

  // node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/function/trigonometry/asec.js
  var require_asec = __commonJS({
    "node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/function/trigonometry/asec.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.createAsec = void 0;
      var _factory = require_factory();
      var _index = require_number2();
      var name18 = "asec";
      var dependencies19 = ["typed", "config", "Complex", "BigNumber"];
      var createAsec2 = exports.createAsec = /* @__PURE__ */ (0, _factory.factory)(name18, dependencies19, function(_ref) {
        var typed2 = _ref.typed, config4 = _ref.config, Complex3 = _ref.Complex, _BigNumber = _ref.BigNumber;
        return typed2(name18, {
          number: function number(x) {
            if (x <= -1 || x >= 1 || config4.predictable) {
              return (0, _index.asecNumber)(x);
            }
            return new Complex3(x, 0).asec();
          },
          Complex: function Complex4(x) {
            return x.asec();
          },
          BigNumber: function BigNumber2(x) {
            return new _BigNumber(1).div(x).acos();
          }
        });
      });
    }
  });

  // node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/function/trigonometry/asech.js
  var require_asech = __commonJS({
    "node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/function/trigonometry/asech.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.createAsech = void 0;
      var _factory = require_factory();
      var _index = require_number2();
      var name18 = "asech";
      var dependencies19 = ["typed", "config", "Complex", "BigNumber"];
      var createAsech2 = exports.createAsech = /* @__PURE__ */ (0, _factory.factory)(name18, dependencies19, function(_ref) {
        var typed2 = _ref.typed, config4 = _ref.config, Complex3 = _ref.Complex, _BigNumber = _ref.BigNumber;
        return typed2(name18, {
          number: function number(x) {
            if (x <= 1 && x >= -1 || config4.predictable) {
              var xInv = 1 / x;
              if (xInv > 0 || config4.predictable) {
                return (0, _index.asechNumber)(x);
              }
              var ret = Math.sqrt(xInv * xInv - 1);
              return new Complex3(Math.log(ret - xInv), Math.PI);
            }
            return new Complex3(x, 0).asech();
          },
          Complex: function Complex4(x) {
            return x.asech();
          },
          BigNumber: function BigNumber2(x) {
            return new _BigNumber(1).div(x).acosh();
          }
        });
      });
    }
  });

  // node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/function/trigonometry/asin.js
  var require_asin = __commonJS({
    "node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/function/trigonometry/asin.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.createAsin = void 0;
      var _factory = require_factory();
      var name18 = "asin";
      var dependencies19 = ["typed", "config", "Complex"];
      var createAsin2 = exports.createAsin = /* @__PURE__ */ (0, _factory.factory)(name18, dependencies19, function(_ref) {
        var typed2 = _ref.typed, config4 = _ref.config, Complex3 = _ref.Complex;
        return typed2(name18, {
          number: function number(x) {
            if (x >= -1 && x <= 1 || config4.predictable) {
              return Math.asin(x);
            } else {
              return new Complex3(x, 0).asin();
            }
          },
          Complex: function Complex4(x) {
            return x.asin();
          },
          BigNumber: function BigNumber2(x) {
            return x.asin();
          }
        });
      });
    }
  });

  // node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/function/trigonometry/asinh.js
  var require_asinh = __commonJS({
    "node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/function/trigonometry/asinh.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.createAsinh = void 0;
      var _factory = require_factory();
      var _index = require_number2();
      var name18 = "asinh";
      var dependencies19 = ["typed"];
      var createAsinh2 = exports.createAsinh = /* @__PURE__ */ (0, _factory.factory)(name18, dependencies19, function(_ref) {
        var typed2 = _ref.typed;
        return typed2("asinh", {
          number: _index.asinhNumber,
          Complex: function Complex3(x) {
            return x.asinh();
          },
          BigNumber: function BigNumber2(x) {
            return x.asinh();
          }
        });
      });
    }
  });

  // node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/function/trigonometry/atan.js
  var require_atan = __commonJS({
    "node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/function/trigonometry/atan.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.createAtan = void 0;
      var _factory = require_factory();
      var name18 = "atan";
      var dependencies19 = ["typed"];
      var createAtan3 = exports.createAtan = /* @__PURE__ */ (0, _factory.factory)(name18, dependencies19, function(_ref) {
        var typed2 = _ref.typed;
        return typed2("atan", {
          number: function number(x) {
            return Math.atan(x);
          },
          Complex: function Complex3(x) {
            return x.atan();
          },
          BigNumber: function BigNumber2(x) {
            return x.atan();
          }
        });
      });
    }
  });

  // node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/function/trigonometry/atan2.js
  var require_atan2 = __commonJS({
    "node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/function/trigonometry/atan2.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.createAtan2 = void 0;
      var _factory = require_factory();
      var _matAlgo02xDS = require_matAlgo02xDS0();
      var _matAlgo03xDSf = require_matAlgo03xDSf();
      var _matAlgo09xS0Sf = require_matAlgo09xS0Sf();
      var _matAlgo11xS0s = require_matAlgo11xS0s();
      var _matAlgo12xSfs = require_matAlgo12xSfs();
      var _matrixAlgorithmSuite = require_matrixAlgorithmSuite();
      var name18 = "atan2";
      var dependencies19 = ["typed", "matrix", "equalScalar", "BigNumber", "DenseMatrix", "concat"];
      var createAtan22 = exports.createAtan2 = /* @__PURE__ */ (0, _factory.factory)(name18, dependencies19, function(_ref) {
        var typed2 = _ref.typed, matrix2 = _ref.matrix, equalScalar2 = _ref.equalScalar, BigNumber2 = _ref.BigNumber, DenseMatrix2 = _ref.DenseMatrix, concat2 = _ref.concat;
        var matAlgo02xDS0 = (0, _matAlgo02xDS.createMatAlgo02xDS0)({
          typed: typed2,
          equalScalar: equalScalar2
        });
        var matAlgo03xDSf = (0, _matAlgo03xDSf.createMatAlgo03xDSf)({
          typed: typed2
        });
        var matAlgo09xS0Sf = (0, _matAlgo09xS0Sf.createMatAlgo09xS0Sf)({
          typed: typed2,
          equalScalar: equalScalar2
        });
        var matAlgo11xS0s = (0, _matAlgo11xS0s.createMatAlgo11xS0s)({
          typed: typed2,
          equalScalar: equalScalar2
        });
        var matAlgo12xSfs = (0, _matAlgo12xSfs.createMatAlgo12xSfs)({
          typed: typed2,
          DenseMatrix: DenseMatrix2
        });
        var matrixAlgorithmSuite = (0, _matrixAlgorithmSuite.createMatrixAlgorithmSuite)({
          typed: typed2,
          matrix: matrix2,
          concat: concat2
        });
        return typed2(name18, {
          "number, number": Math.atan2,
          // Complex numbers doesn't seem to have a reasonable implementation of
          // atan2(). Even Matlab removed the support, after they only calculated
          // the atan only on base of the real part of the numbers and ignored
          // the imaginary.
          "BigNumber, BigNumber": function BigNumberBigNumber(y, x) {
            return BigNumber2.atan2(y, x);
          }
        }, matrixAlgorithmSuite({
          scalar: "number | BigNumber",
          SS: matAlgo09xS0Sf,
          DS: matAlgo03xDSf,
          SD: matAlgo02xDS0,
          Ss: matAlgo11xS0s,
          sS: matAlgo12xSfs
        }));
      });
    }
  });

  // node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/function/trigonometry/atanh.js
  var require_atanh = __commonJS({
    "node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/function/trigonometry/atanh.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.createAtanh = void 0;
      var _factory = require_factory();
      var _index = require_number2();
      var name18 = "atanh";
      var dependencies19 = ["typed", "config", "Complex"];
      var createAtanh2 = exports.createAtanh = /* @__PURE__ */ (0, _factory.factory)(name18, dependencies19, function(_ref) {
        var typed2 = _ref.typed, config4 = _ref.config, Complex3 = _ref.Complex;
        return typed2(name18, {
          number: function number(x) {
            if (x <= 1 && x >= -1 || config4.predictable) {
              return (0, _index.atanhNumber)(x);
            }
            return new Complex3(x, 0).atanh();
          },
          Complex: function Complex4(x) {
            return x.atanh();
          },
          BigNumber: function BigNumber2(x) {
            return x.atanh();
          }
        });
      });
    }
  });

  // node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/function/trigonometry/trigUnit.js
  var require_trigUnit = __commonJS({
    "node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/function/trigonometry/trigUnit.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.createTrigUnit = void 0;
      var _factory = require_factory();
      var createTrigUnit = exports.createTrigUnit = /* @__PURE__ */ (0, _factory.factory)("trigUnit", ["typed"], function(_ref) {
        var typed2 = _ref.typed;
        return {
          Unit: typed2.referToSelf(function(self2) {
            return function(x) {
              if (!x.hasBase(x.constructor.BASE_UNITS.ANGLE)) {
                throw new TypeError("Unit in function cot is no angle");
              }
              return typed2.find(self2, x.valueType())(x.value);
            };
          })
        };
      });
    }
  });

  // node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/function/trigonometry/cos.js
  var require_cos = __commonJS({
    "node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/function/trigonometry/cos.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.createCos = void 0;
      var _factory = require_factory();
      var _trigUnit = require_trigUnit();
      var name18 = "cos";
      var dependencies19 = ["typed"];
      var createCos2 = exports.createCos = /* @__PURE__ */ (0, _factory.factory)(name18, dependencies19, function(_ref) {
        var typed2 = _ref.typed;
        var trigUnit = (0, _trigUnit.createTrigUnit)({
          typed: typed2
        });
        return typed2(name18, {
          number: Math.cos,
          "Complex | BigNumber": function ComplexBigNumber(x) {
            return x.cos();
          }
        }, trigUnit);
      });
    }
  });

  // node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/function/trigonometry/cosh.js
  var require_cosh = __commonJS({
    "node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/function/trigonometry/cosh.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.createCosh = void 0;
      var _factory = require_factory();
      var _number = require_number();
      var name18 = "cosh";
      var dependencies19 = ["typed"];
      var createCosh2 = exports.createCosh = /* @__PURE__ */ (0, _factory.factory)(name18, dependencies19, function(_ref) {
        var typed2 = _ref.typed;
        return typed2(name18, {
          number: _number.cosh,
          "Complex | BigNumber": function ComplexBigNumber(x) {
            return x.cosh();
          }
        });
      });
    }
  });

  // node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/function/trigonometry/cot.js
  var require_cot = __commonJS({
    "node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/function/trigonometry/cot.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.createCot = void 0;
      var _factory = require_factory();
      var _index = require_number2();
      var _trigUnit = require_trigUnit();
      var name18 = "cot";
      var dependencies19 = ["typed", "BigNumber"];
      var createCot2 = exports.createCot = /* @__PURE__ */ (0, _factory.factory)(name18, dependencies19, function(_ref) {
        var typed2 = _ref.typed, _BigNumber = _ref.BigNumber;
        var trigUnit = (0, _trigUnit.createTrigUnit)({
          typed: typed2
        });
        return typed2(name18, {
          number: _index.cotNumber,
          Complex: function Complex3(x) {
            return x.cot();
          },
          BigNumber: function BigNumber2(x) {
            return new _BigNumber(1).div(x.tan());
          }
        }, trigUnit);
      });
    }
  });

  // node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/function/trigonometry/coth.js
  var require_coth = __commonJS({
    "node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/function/trigonometry/coth.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.createCoth = void 0;
      var _factory = require_factory();
      var _index = require_number2();
      var name18 = "coth";
      var dependencies19 = ["typed", "BigNumber"];
      var createCoth2 = exports.createCoth = /* @__PURE__ */ (0, _factory.factory)(name18, dependencies19, function(_ref) {
        var typed2 = _ref.typed, _BigNumber = _ref.BigNumber;
        return typed2(name18, {
          number: _index.cothNumber,
          Complex: function Complex3(x) {
            return x.coth();
          },
          BigNumber: function BigNumber2(x) {
            return new _BigNumber(1).div(x.tanh());
          }
        });
      });
    }
  });

  // node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/function/trigonometry/csc.js
  var require_csc = __commonJS({
    "node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/function/trigonometry/csc.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.createCsc = void 0;
      var _factory = require_factory();
      var _index = require_number2();
      var _trigUnit = require_trigUnit();
      var name18 = "csc";
      var dependencies19 = ["typed", "BigNumber"];
      var createCsc2 = exports.createCsc = /* @__PURE__ */ (0, _factory.factory)(name18, dependencies19, function(_ref) {
        var typed2 = _ref.typed, _BigNumber = _ref.BigNumber;
        var trigUnit = (0, _trigUnit.createTrigUnit)({
          typed: typed2
        });
        return typed2(name18, {
          number: _index.cscNumber,
          Complex: function Complex3(x) {
            return x.csc();
          },
          BigNumber: function BigNumber2(x) {
            return new _BigNumber(1).div(x.sin());
          }
        }, trigUnit);
      });
    }
  });

  // node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/function/trigonometry/csch.js
  var require_csch = __commonJS({
    "node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/function/trigonometry/csch.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.createCsch = void 0;
      var _factory = require_factory();
      var _index = require_number2();
      var name18 = "csch";
      var dependencies19 = ["typed", "BigNumber"];
      var createCsch2 = exports.createCsch = /* @__PURE__ */ (0, _factory.factory)(name18, dependencies19, function(_ref) {
        var typed2 = _ref.typed, _BigNumber = _ref.BigNumber;
        return typed2(name18, {
          number: _index.cschNumber,
          Complex: function Complex3(x) {
            return x.csch();
          },
          BigNumber: function BigNumber2(x) {
            return new _BigNumber(1).div(x.sinh());
          }
        });
      });
    }
  });

  // node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/function/trigonometry/sec.js
  var require_sec = __commonJS({
    "node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/function/trigonometry/sec.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.createSec = void 0;
      var _factory = require_factory();
      var _index = require_number2();
      var _trigUnit = require_trigUnit();
      var name18 = "sec";
      var dependencies19 = ["typed", "BigNumber"];
      var createSec2 = exports.createSec = /* @__PURE__ */ (0, _factory.factory)(name18, dependencies19, function(_ref) {
        var typed2 = _ref.typed, _BigNumber = _ref.BigNumber;
        var trigUnit = (0, _trigUnit.createTrigUnit)({
          typed: typed2
        });
        return typed2(name18, {
          number: _index.secNumber,
          Complex: function Complex3(x) {
            return x.sec();
          },
          BigNumber: function BigNumber2(x) {
            return new _BigNumber(1).div(x.cos());
          }
        }, trigUnit);
      });
    }
  });

  // node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/function/trigonometry/sech.js
  var require_sech = __commonJS({
    "node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/function/trigonometry/sech.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.createSech = void 0;
      var _factory = require_factory();
      var _index = require_number2();
      var name18 = "sech";
      var dependencies19 = ["typed", "BigNumber"];
      var createSech2 = exports.createSech = /* @__PURE__ */ (0, _factory.factory)(name18, dependencies19, function(_ref) {
        var typed2 = _ref.typed, _BigNumber = _ref.BigNumber;
        return typed2(name18, {
          number: _index.sechNumber,
          Complex: function Complex3(x) {
            return x.sech();
          },
          BigNumber: function BigNumber2(x) {
            return new _BigNumber(1).div(x.cosh());
          }
        });
      });
    }
  });

  // node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/function/trigonometry/sin.js
  var require_sin = __commonJS({
    "node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/function/trigonometry/sin.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.createSin = void 0;
      var _factory = require_factory();
      var _trigUnit = require_trigUnit();
      var name18 = "sin";
      var dependencies19 = ["typed"];
      var createSin2 = exports.createSin = /* @__PURE__ */ (0, _factory.factory)(name18, dependencies19, function(_ref) {
        var typed2 = _ref.typed;
        var trigUnit = (0, _trigUnit.createTrigUnit)({
          typed: typed2
        });
        return typed2(name18, {
          number: Math.sin,
          "Complex | BigNumber": function ComplexBigNumber(x) {
            return x.sin();
          }
        }, trigUnit);
      });
    }
  });

  // node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/function/trigonometry/sinh.js
  var require_sinh = __commonJS({
    "node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/function/trigonometry/sinh.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.createSinh = void 0;
      var _factory = require_factory();
      var _index = require_number2();
      var name18 = "sinh";
      var dependencies19 = ["typed"];
      var createSinh2 = exports.createSinh = /* @__PURE__ */ (0, _factory.factory)(name18, dependencies19, function(_ref) {
        var typed2 = _ref.typed;
        return typed2(name18, {
          number: _index.sinhNumber,
          "Complex | BigNumber": function ComplexBigNumber(x) {
            return x.sinh();
          }
        });
      });
    }
  });

  // node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/function/trigonometry/tan.js
  var require_tan = __commonJS({
    "node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/function/trigonometry/tan.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.createTan = void 0;
      var _factory = require_factory();
      var _trigUnit = require_trigUnit();
      var name18 = "tan";
      var dependencies19 = ["typed"];
      var createTan2 = exports.createTan = /* @__PURE__ */ (0, _factory.factory)(name18, dependencies19, function(_ref) {
        var typed2 = _ref.typed;
        var trigUnit = (0, _trigUnit.createTrigUnit)({
          typed: typed2
        });
        return typed2(name18, {
          number: Math.tan,
          "Complex | BigNumber": function ComplexBigNumber(x) {
            return x.tan();
          }
        }, trigUnit);
      });
    }
  });

  // node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/function/trigonometry/tanh.js
  var require_tanh = __commonJS({
    "node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/function/trigonometry/tanh.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.createTanh = void 0;
      var _factory = require_factory();
      var _number = require_number();
      var name18 = "tanh";
      var dependencies19 = ["typed"];
      var createTanh2 = exports.createTanh = /* @__PURE__ */ (0, _factory.factory)(name18, dependencies19, function(_ref) {
        var typed2 = _ref.typed;
        return typed2("tanh", {
          number: _number.tanh,
          "Complex | BigNumber": function ComplexBigNumber(x) {
            return x.tanh();
          }
        });
      });
    }
  });

  // node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/function/set/setCartesian.js
  var require_setCartesian = __commonJS({
    "node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/function/set/setCartesian.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.createSetCartesian = void 0;
      var _array = require_array();
      var _factory = require_factory();
      var name18 = "setCartesian";
      var dependencies19 = ["typed", "size", "subset", "compareNatural", "Index", "DenseMatrix"];
      var createSetCartesian2 = exports.createSetCartesian = /* @__PURE__ */ (0, _factory.factory)(name18, dependencies19, function(_ref) {
        var typed2 = _ref.typed, size2 = _ref.size, subset = _ref.subset, compareNatural = _ref.compareNatural, Index = _ref.Index, DenseMatrix2 = _ref.DenseMatrix;
        return typed2(name18, {
          "Array | Matrix, Array | Matrix": function ArrayMatrixArrayMatrix(a1, a2) {
            var result = [];
            if (subset(size2(a1), new Index(0)) !== 0 && subset(size2(a2), new Index(0)) !== 0) {
              var b1 = (0, _array.flatten)(Array.isArray(a1) ? a1 : a1.toArray()).sort(compareNatural);
              var b2 = (0, _array.flatten)(Array.isArray(a2) ? a2 : a2.toArray()).sort(compareNatural);
              result = [];
              for (var i = 0; i < b1.length; i++) {
                for (var j = 0; j < b2.length; j++) {
                  result.push([b1[i], b2[j]]);
                }
              }
            }
            if (Array.isArray(a1) && Array.isArray(a2)) {
              return result;
            }
            return new DenseMatrix2(result);
          }
        });
      });
    }
  });

  // node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/function/set/setDifference.js
  var require_setDifference = __commonJS({
    "node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/function/set/setDifference.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.createSetDifference = void 0;
      var _array = require_array();
      var _factory = require_factory();
      var name18 = "setDifference";
      var dependencies19 = ["typed", "size", "subset", "compareNatural", "Index", "DenseMatrix"];
      var createSetDifference2 = exports.createSetDifference = /* @__PURE__ */ (0, _factory.factory)(name18, dependencies19, function(_ref) {
        var typed2 = _ref.typed, size2 = _ref.size, subset = _ref.subset, compareNatural = _ref.compareNatural, Index = _ref.Index, DenseMatrix2 = _ref.DenseMatrix;
        return typed2(name18, {
          "Array | Matrix, Array | Matrix": function ArrayMatrixArrayMatrix(a1, a2) {
            var result;
            if (subset(size2(a1), new Index(0)) === 0) {
              result = [];
            } else if (subset(size2(a2), new Index(0)) === 0) {
              return (0, _array.flatten)(a1.toArray());
            } else {
              var b1 = (0, _array.identify)((0, _array.flatten)(Array.isArray(a1) ? a1 : a1.toArray()).sort(compareNatural));
              var b2 = (0, _array.identify)((0, _array.flatten)(Array.isArray(a2) ? a2 : a2.toArray()).sort(compareNatural));
              result = [];
              var inb2;
              for (var i = 0; i < b1.length; i++) {
                inb2 = false;
                for (var j = 0; j < b2.length; j++) {
                  if (compareNatural(b1[i].value, b2[j].value) === 0 && b1[i].identifier === b2[j].identifier) {
                    inb2 = true;
                    break;
                  }
                }
                if (!inb2) {
                  result.push(b1[i]);
                }
              }
            }
            if (Array.isArray(a1) && Array.isArray(a2)) {
              return (0, _array.generalize)(result);
            }
            return new DenseMatrix2((0, _array.generalize)(result));
          }
        });
      });
    }
  });

  // node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/function/set/setDistinct.js
  var require_setDistinct = __commonJS({
    "node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/function/set/setDistinct.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.createSetDistinct = void 0;
      var _array = require_array();
      var _factory = require_factory();
      var name18 = "setDistinct";
      var dependencies19 = ["typed", "size", "subset", "compareNatural", "Index", "DenseMatrix"];
      var createSetDistinct2 = exports.createSetDistinct = /* @__PURE__ */ (0, _factory.factory)(name18, dependencies19, function(_ref) {
        var typed2 = _ref.typed, size2 = _ref.size, subset = _ref.subset, compareNatural = _ref.compareNatural, Index = _ref.Index, DenseMatrix2 = _ref.DenseMatrix;
        return typed2(name18, {
          "Array | Matrix": function ArrayMatrix(a) {
            var result;
            if (subset(size2(a), new Index(0)) === 0) {
              result = [];
            } else {
              var b = (0, _array.flatten)(Array.isArray(a) ? a : a.toArray()).sort(compareNatural);
              result = [];
              result.push(b[0]);
              for (var i = 1; i < b.length; i++) {
                if (compareNatural(b[i], b[i - 1]) !== 0) {
                  result.push(b[i]);
                }
              }
            }
            if (Array.isArray(a)) {
              return result;
            }
            return new DenseMatrix2(result);
          }
        });
      });
    }
  });

  // node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/function/set/setIntersect.js
  var require_setIntersect = __commonJS({
    "node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/function/set/setIntersect.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.createSetIntersect = void 0;
      var _array = require_array();
      var _factory = require_factory();
      var name18 = "setIntersect";
      var dependencies19 = ["typed", "size", "subset", "compareNatural", "Index", "DenseMatrix"];
      var createSetIntersect2 = exports.createSetIntersect = /* @__PURE__ */ (0, _factory.factory)(name18, dependencies19, function(_ref) {
        var typed2 = _ref.typed, size2 = _ref.size, subset = _ref.subset, compareNatural = _ref.compareNatural, Index = _ref.Index, DenseMatrix2 = _ref.DenseMatrix;
        return typed2(name18, {
          "Array | Matrix, Array | Matrix": function ArrayMatrixArrayMatrix(a1, a2) {
            var result;
            if (subset(size2(a1), new Index(0)) === 0 || subset(size2(a2), new Index(0)) === 0) {
              result = [];
            } else {
              var b1 = (0, _array.identify)((0, _array.flatten)(Array.isArray(a1) ? a1 : a1.toArray()).sort(compareNatural));
              var b2 = (0, _array.identify)((0, _array.flatten)(Array.isArray(a2) ? a2 : a2.toArray()).sort(compareNatural));
              result = [];
              for (var i = 0; i < b1.length; i++) {
                for (var j = 0; j < b2.length; j++) {
                  if (compareNatural(b1[i].value, b2[j].value) === 0 && b1[i].identifier === b2[j].identifier) {
                    result.push(b1[i]);
                    break;
                  }
                }
              }
            }
            if (Array.isArray(a1) && Array.isArray(a2)) {
              return (0, _array.generalize)(result);
            }
            return new DenseMatrix2((0, _array.generalize)(result));
          }
        });
      });
    }
  });

  // node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/function/set/setIsSubset.js
  var require_setIsSubset = __commonJS({
    "node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/function/set/setIsSubset.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.createSetIsSubset = void 0;
      var _array = require_array();
      var _factory = require_factory();
      var name18 = "setIsSubset";
      var dependencies19 = ["typed", "size", "subset", "compareNatural", "Index"];
      var createSetIsSubset2 = exports.createSetIsSubset = /* @__PURE__ */ (0, _factory.factory)(name18, dependencies19, function(_ref) {
        var typed2 = _ref.typed, size2 = _ref.size, subset = _ref.subset, compareNatural = _ref.compareNatural, Index = _ref.Index;
        return typed2(name18, {
          "Array | Matrix, Array | Matrix": function ArrayMatrixArrayMatrix(a1, a2) {
            if (subset(size2(a1), new Index(0)) === 0) {
              return true;
            } else if (subset(size2(a2), new Index(0)) === 0) {
              return false;
            }
            var b1 = (0, _array.identify)((0, _array.flatten)(Array.isArray(a1) ? a1 : a1.toArray()).sort(compareNatural));
            var b2 = (0, _array.identify)((0, _array.flatten)(Array.isArray(a2) ? a2 : a2.toArray()).sort(compareNatural));
            var inb2;
            for (var i = 0; i < b1.length; i++) {
              inb2 = false;
              for (var j = 0; j < b2.length; j++) {
                if (compareNatural(b1[i].value, b2[j].value) === 0 && b1[i].identifier === b2[j].identifier) {
                  inb2 = true;
                  break;
                }
              }
              if (inb2 === false) {
                return false;
              }
            }
            return true;
          }
        });
      });
    }
  });

  // node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/function/set/setMultiplicity.js
  var require_setMultiplicity = __commonJS({
    "node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/function/set/setMultiplicity.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.createSetMultiplicity = void 0;
      var _array = require_array();
      var _factory = require_factory();
      var name18 = "setMultiplicity";
      var dependencies19 = ["typed", "size", "subset", "compareNatural", "Index"];
      var createSetMultiplicity2 = exports.createSetMultiplicity = /* @__PURE__ */ (0, _factory.factory)(name18, dependencies19, function(_ref) {
        var typed2 = _ref.typed, size2 = _ref.size, subset = _ref.subset, compareNatural = _ref.compareNatural, Index = _ref.Index;
        return typed2(name18, {
          "number | BigNumber | Fraction | Complex, Array | Matrix": function numberBigNumberFractionComplexArrayMatrix(e, a) {
            if (subset(size2(a), new Index(0)) === 0) {
              return 0;
            }
            var b = (0, _array.flatten)(Array.isArray(a) ? a : a.toArray());
            var count = 0;
            for (var i = 0; i < b.length; i++) {
              if (compareNatural(b[i], e) === 0) {
                count++;
              }
            }
            return count;
          }
        });
      });
    }
  });

  // node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/function/set/setPowerset.js
  var require_setPowerset = __commonJS({
    "node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/function/set/setPowerset.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.createSetPowerset = void 0;
      var _array = require_array();
      var _factory = require_factory();
      var name18 = "setPowerset";
      var dependencies19 = ["typed", "size", "subset", "compareNatural", "Index"];
      var createSetPowerset2 = exports.createSetPowerset = /* @__PURE__ */ (0, _factory.factory)(name18, dependencies19, function(_ref) {
        var typed2 = _ref.typed, size2 = _ref.size, subset = _ref.subset, compareNatural = _ref.compareNatural, Index = _ref.Index;
        return typed2(name18, {
          "Array | Matrix": function ArrayMatrix(a) {
            if (subset(size2(a), new Index(0)) === 0) {
              return [];
            }
            var b = (0, _array.flatten)(Array.isArray(a) ? a : a.toArray()).sort(compareNatural);
            var result = [];
            var number = 0;
            while (number.toString(2).length <= b.length) {
              result.push(_subset(b, number.toString(2).split("").reverse()));
              number++;
            }
            return _sort(result);
          }
        });
        function _subset(array, bitarray) {
          var result = [];
          for (var i = 0; i < bitarray.length; i++) {
            if (bitarray[i] === "1") {
              result.push(array[i]);
            }
          }
          return result;
        }
        function _sort(array) {
          var temp = [];
          for (var i = array.length - 1; i > 0; i--) {
            for (var j = 0; j < i; j++) {
              if (array[j].length > array[j + 1].length) {
                temp = array[j];
                array[j] = array[j + 1];
                array[j + 1] = temp;
              }
            }
          }
          return array;
        }
      });
    }
  });

  // node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/function/set/setSize.js
  var require_setSize = __commonJS({
    "node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/function/set/setSize.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.createSetSize = void 0;
      var _array = require_array();
      var _factory = require_factory();
      var name18 = "setSize";
      var dependencies19 = ["typed", "compareNatural"];
      var createSetSize2 = exports.createSetSize = /* @__PURE__ */ (0, _factory.factory)(name18, dependencies19, function(_ref) {
        var typed2 = _ref.typed, compareNatural = _ref.compareNatural;
        return typed2(name18, {
          "Array | Matrix": function ArrayMatrix(a) {
            return Array.isArray(a) ? (0, _array.flatten)(a).length : (0, _array.flatten)(a.toArray()).length;
          },
          "Array | Matrix, boolean": function ArrayMatrixBoolean(a, unique) {
            if (unique === false || a.length === 0) {
              return Array.isArray(a) ? (0, _array.flatten)(a).length : (0, _array.flatten)(a.toArray()).length;
            } else {
              var b = (0, _array.flatten)(Array.isArray(a) ? a : a.toArray()).sort(compareNatural);
              var count = 1;
              for (var i = 1; i < b.length; i++) {
                if (compareNatural(b[i], b[i - 1]) !== 0) {
                  count++;
                }
              }
              return count;
            }
          }
        });
      });
    }
  });

  // node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/function/set/setSymDifference.js
  var require_setSymDifference = __commonJS({
    "node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/function/set/setSymDifference.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.createSetSymDifference = void 0;
      var _array = require_array();
      var _factory = require_factory();
      var name18 = "setSymDifference";
      var dependencies19 = ["typed", "size", "concat", "subset", "setDifference", "Index"];
      var createSetSymDifference2 = exports.createSetSymDifference = /* @__PURE__ */ (0, _factory.factory)(name18, dependencies19, function(_ref) {
        var typed2 = _ref.typed, size2 = _ref.size, concat2 = _ref.concat, subset = _ref.subset, setDifference = _ref.setDifference, Index = _ref.Index;
        return typed2(name18, {
          "Array | Matrix, Array | Matrix": function ArrayMatrixArrayMatrix(a1, a2) {
            if (subset(size2(a1), new Index(0)) === 0) {
              return (0, _array.flatten)(a2);
            } else if (subset(size2(a2), new Index(0)) === 0) {
              return (0, _array.flatten)(a1);
            }
            var b1 = (0, _array.flatten)(a1);
            var b2 = (0, _array.flatten)(a2);
            return concat2(setDifference(b1, b2), setDifference(b2, b1));
          }
        });
      });
    }
  });

  // node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/function/set/setUnion.js
  var require_setUnion = __commonJS({
    "node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/function/set/setUnion.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.createSetUnion = void 0;
      var _array = require_array();
      var _factory = require_factory();
      var name18 = "setUnion";
      var dependencies19 = ["typed", "size", "concat", "subset", "setIntersect", "setSymDifference", "Index"];
      var createSetUnion2 = exports.createSetUnion = /* @__PURE__ */ (0, _factory.factory)(name18, dependencies19, function(_ref) {
        var typed2 = _ref.typed, size2 = _ref.size, concat2 = _ref.concat, subset = _ref.subset, setIntersect = _ref.setIntersect, setSymDifference = _ref.setSymDifference, Index = _ref.Index;
        return typed2(name18, {
          "Array | Matrix, Array | Matrix": function ArrayMatrixArrayMatrix(a1, a2) {
            if (subset(size2(a1), new Index(0)) === 0) {
              return (0, _array.flatten)(a2);
            } else if (subset(size2(a2), new Index(0)) === 0) {
              return (0, _array.flatten)(a1);
            }
            var b1 = (0, _array.flatten)(a1);
            var b2 = (0, _array.flatten)(a2);
            return concat2(setSymDifference(b1, b2), setIntersect(b1, b2));
          }
        });
      });
    }
  });

  // node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/function/arithmetic/add.js
  var require_add = __commonJS({
    "node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/function/arithmetic/add.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.createAdd = void 0;
      var _factory = require_factory();
      var _matAlgo01xDSid = require_matAlgo01xDSid();
      var _matAlgo04xSidSid = require_matAlgo04xSidSid();
      var _matAlgo10xSids = require_matAlgo10xSids();
      var _matrixAlgorithmSuite = require_matrixAlgorithmSuite();
      var name18 = "add";
      var dependencies19 = ["typed", "matrix", "addScalar", "equalScalar", "DenseMatrix", "SparseMatrix", "concat"];
      var createAdd2 = exports.createAdd = /* @__PURE__ */ (0, _factory.factory)(name18, dependencies19, function(_ref) {
        var typed2 = _ref.typed, matrix2 = _ref.matrix, addScalar2 = _ref.addScalar, equalScalar2 = _ref.equalScalar, DenseMatrix2 = _ref.DenseMatrix, SparseMatrix2 = _ref.SparseMatrix, concat2 = _ref.concat;
        var matAlgo01xDSid = (0, _matAlgo01xDSid.createMatAlgo01xDSid)({
          typed: typed2
        });
        var matAlgo04xSidSid = (0, _matAlgo04xSidSid.createMatAlgo04xSidSid)({
          typed: typed2,
          equalScalar: equalScalar2
        });
        var matAlgo10xSids = (0, _matAlgo10xSids.createMatAlgo10xSids)({
          typed: typed2,
          DenseMatrix: DenseMatrix2
        });
        var matrixAlgorithmSuite = (0, _matrixAlgorithmSuite.createMatrixAlgorithmSuite)({
          typed: typed2,
          matrix: matrix2,
          concat: concat2
        });
        return typed2(name18, {
          "any, any": addScalar2,
          "any, any, ...any": typed2.referToSelf(function(self2) {
            return function(x, y, rest) {
              var result = self2(x, y);
              for (var i = 0; i < rest.length; i++) {
                result = self2(result, rest[i]);
              }
              return result;
            };
          })
        }, matrixAlgorithmSuite({
          elop: addScalar2,
          DS: matAlgo01xDSid,
          SS: matAlgo04xSidSid,
          Ss: matAlgo10xSids
        }));
      });
    }
  });

  // node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/function/arithmetic/hypot.js
  var require_hypot = __commonJS({
    "node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/function/arithmetic/hypot.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.createHypot = void 0;
      var _factory = require_factory();
      var _array = require_array();
      var _is = require_is();
      var name18 = "hypot";
      var dependencies19 = ["typed", "abs", "addScalar", "divideScalar", "multiplyScalar", "sqrt", "smaller", "isPositive"];
      var createHypot2 = exports.createHypot = /* @__PURE__ */ (0, _factory.factory)(name18, dependencies19, function(_ref) {
        var typed2 = _ref.typed, abs2 = _ref.abs, addScalar2 = _ref.addScalar, divideScalar = _ref.divideScalar, multiplyScalar2 = _ref.multiplyScalar, sqrt2 = _ref.sqrt, smaller = _ref.smaller, isPositive = _ref.isPositive;
        return typed2(name18, {
          "... number | BigNumber": _hypot,
          Array: _hypot,
          Matrix: function Matrix2(M) {
            return _hypot((0, _array.flatten)(M.toArray()));
          }
        });
        function _hypot(args) {
          var result = 0;
          var largest = 0;
          for (var i = 0; i < args.length; i++) {
            if ((0, _is.isComplex)(args[i])) {
              throw new TypeError("Unexpected type of argument to hypot");
            }
            var value = abs2(args[i]);
            if (smaller(largest, value)) {
              result = multiplyScalar2(result, multiplyScalar2(divideScalar(largest, value), divideScalar(largest, value)));
              result = addScalar2(result, 1);
              largest = value;
            } else {
              result = addScalar2(result, isPositive(value) ? multiplyScalar2(divideScalar(value, largest), divideScalar(value, largest)) : value);
            }
          }
          return multiplyScalar2(largest, sqrt2(result));
        }
      });
    }
  });

  // node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/function/arithmetic/norm.js
  var require_norm = __commonJS({
    "node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/function/arithmetic/norm.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.createNorm = void 0;
      var _factory = require_factory();
      var name18 = "norm";
      var dependencies19 = ["typed", "abs", "add", "pow", "conj", "sqrt", "multiply", "equalScalar", "larger", "smaller", "matrix", "ctranspose", "eigs"];
      var createNorm2 = exports.createNorm = /* @__PURE__ */ (0, _factory.factory)(name18, dependencies19, function(_ref) {
        var typed2 = _ref.typed, abs2 = _ref.abs, add2 = _ref.add, pow2 = _ref.pow, conj2 = _ref.conj, sqrt2 = _ref.sqrt, multiply2 = _ref.multiply, equalScalar2 = _ref.equalScalar, larger = _ref.larger, smaller = _ref.smaller, matrix2 = _ref.matrix, ctranspose = _ref.ctranspose, eigs = _ref.eigs;
        return typed2(name18, {
          number: Math.abs,
          Complex: function Complex3(x) {
            return x.abs();
          },
          BigNumber: function BigNumber2(x) {
            return x.abs();
          },
          "boolean": function boolean(x) {
            return Math.abs(x);
          },
          Array: function Array2(x) {
            return _norm(matrix2(x), 2);
          },
          Matrix: function Matrix2(x) {
            return _norm(x, 2);
          },
          "Array, number | BigNumber | string": function ArrayNumberBigNumberString(x, p) {
            return _norm(matrix2(x), p);
          },
          "Matrix, number | BigNumber | string": function MatrixNumberBigNumberString(x, p) {
            return _norm(x, p);
          }
        });
        function _vectorNormPlusInfinity(x) {
          var pinf = 0;
          x.forEach(function(value) {
            var v = abs2(value);
            if (larger(v, pinf)) {
              pinf = v;
            }
          }, true);
          return pinf;
        }
        function _vectorNormMinusInfinity(x) {
          var ninf;
          x.forEach(function(value) {
            var v = abs2(value);
            if (!ninf || smaller(v, ninf)) {
              ninf = v;
            }
          }, true);
          return ninf || 0;
        }
        function _vectorNorm(x, p) {
          if (p === Number.POSITIVE_INFINITY || p === "inf") {
            return _vectorNormPlusInfinity(x);
          }
          if (p === Number.NEGATIVE_INFINITY || p === "-inf") {
            return _vectorNormMinusInfinity(x);
          }
          if (p === "fro") {
            return _norm(x, 2);
          }
          if (typeof p === "number" && !isNaN(p)) {
            if (!equalScalar2(p, 0)) {
              var n = 0;
              x.forEach(function(value) {
                n = add2(pow2(abs2(value), p), n);
              }, true);
              return pow2(n, 1 / p);
            }
            return Number.POSITIVE_INFINITY;
          }
          throw new Error("Unsupported parameter value");
        }
        function _matrixNormFrobenius(x) {
          var fro = 0;
          x.forEach(function(value, index) {
            fro = add2(fro, multiply2(value, conj2(value)));
          });
          return abs2(sqrt2(fro));
        }
        function _matrixNormOne(x) {
          var c = [];
          var maxc = 0;
          x.forEach(function(value, index) {
            var j = index[1];
            var cj = add2(c[j] || 0, abs2(value));
            if (larger(cj, maxc)) {
              maxc = cj;
            }
            c[j] = cj;
          }, true);
          return maxc;
        }
        function _matrixNormTwo(x) {
          var sizeX = x.size();
          if (sizeX[0] !== sizeX[1]) {
            throw new RangeError("Invalid matrix dimensions");
          }
          var tx = ctranspose(x);
          var squaredX = multiply2(tx, x);
          var eigenVals = eigs(squaredX).values.toArray();
          var rho = eigenVals[eigenVals.length - 1];
          return abs2(sqrt2(rho));
        }
        function _matrixNormInfinity(x) {
          var r = [];
          var maxr = 0;
          x.forEach(function(value, index) {
            var i = index[0];
            var ri = add2(r[i] || 0, abs2(value));
            if (larger(ri, maxr)) {
              maxr = ri;
            }
            r[i] = ri;
          }, true);
          return maxr;
        }
        function _matrixNorm(x, p) {
          if (p === 1) {
            return _matrixNormOne(x);
          }
          if (p === Number.POSITIVE_INFINITY || p === "inf") {
            return _matrixNormInfinity(x);
          }
          if (p === "fro") {
            return _matrixNormFrobenius(x);
          }
          if (p === 2) {
            return _matrixNormTwo(x);
          }
          throw new Error("Unsupported parameter value " + p);
        }
        function _norm(x, p) {
          var sizeX = x.size();
          if (sizeX.length === 1) {
            return _vectorNorm(x, p);
          }
          if (sizeX.length === 2) {
            if (sizeX[0] && sizeX[1]) {
              return _matrixNorm(x, p);
            } else {
              throw new RangeError("Invalid matrix dimensions");
            }
          }
        }
      });
    }
  });

  // node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/function/matrix/dot.js
  var require_dot = __commonJS({
    "node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/function/matrix/dot.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.createDot = void 0;
      var _factory = require_factory();
      var _is = require_is();
      var name18 = "dot";
      var dependencies19 = ["typed", "addScalar", "multiplyScalar", "conj", "size"];
      var createDot2 = exports.createDot = /* @__PURE__ */ (0, _factory.factory)(name18, dependencies19, function(_ref) {
        var typed2 = _ref.typed, addScalar2 = _ref.addScalar, multiplyScalar2 = _ref.multiplyScalar, conj2 = _ref.conj, size2 = _ref.size;
        return typed2(name18, {
          "Array | DenseMatrix, Array | DenseMatrix": _denseDot,
          "SparseMatrix, SparseMatrix": _sparseDot
        });
        function _validateDim(x, y) {
          var xSize = _size(x);
          var ySize = _size(y);
          var xLen, yLen;
          if (xSize.length === 1) {
            xLen = xSize[0];
          } else if (xSize.length === 2 && xSize[1] === 1) {
            xLen = xSize[0];
          } else {
            throw new RangeError("Expected a column vector, instead got a matrix of size (" + xSize.join(", ") + ")");
          }
          if (ySize.length === 1) {
            yLen = ySize[0];
          } else if (ySize.length === 2 && ySize[1] === 1) {
            yLen = ySize[0];
          } else {
            throw new RangeError("Expected a column vector, instead got a matrix of size (" + ySize.join(", ") + ")");
          }
          if (xLen !== yLen) throw new RangeError("Vectors must have equal length (" + xLen + " != " + yLen + ")");
          if (xLen === 0) throw new RangeError("Cannot calculate the dot product of empty vectors");
          return xLen;
        }
        function _denseDot(a, b) {
          var N = _validateDim(a, b);
          var adata = (0, _is.isMatrix)(a) ? a._data : a;
          var adt = (0, _is.isMatrix)(a) ? a._datatype || a.getDataType() : void 0;
          var bdata = (0, _is.isMatrix)(b) ? b._data : b;
          var bdt = (0, _is.isMatrix)(b) ? b._datatype || b.getDataType() : void 0;
          var aIsColumn = _size(a).length === 2;
          var bIsColumn = _size(b).length === 2;
          var add2 = addScalar2;
          var mul2 = multiplyScalar2;
          if (adt && bdt && adt === bdt && typeof adt === "string" && adt !== "mixed") {
            var dt = adt;
            add2 = typed2.find(addScalar2, [dt, dt]);
            mul2 = typed2.find(multiplyScalar2, [dt, dt]);
          }
          if (!aIsColumn && !bIsColumn) {
            var c = mul2(conj2(adata[0]), bdata[0]);
            for (var i = 1; i < N; i++) {
              c = add2(c, mul2(conj2(adata[i]), bdata[i]));
            }
            return c;
          }
          if (!aIsColumn && bIsColumn) {
            var _c = mul2(conj2(adata[0]), bdata[0][0]);
            for (var _i = 1; _i < N; _i++) {
              _c = add2(_c, mul2(conj2(adata[_i]), bdata[_i][0]));
            }
            return _c;
          }
          if (aIsColumn && !bIsColumn) {
            var _c2 = mul2(conj2(adata[0][0]), bdata[0]);
            for (var _i2 = 1; _i2 < N; _i2++) {
              _c2 = add2(_c2, mul2(conj2(adata[_i2][0]), bdata[_i2]));
            }
            return _c2;
          }
          if (aIsColumn && bIsColumn) {
            var _c3 = mul2(conj2(adata[0][0]), bdata[0][0]);
            for (var _i3 = 1; _i3 < N; _i3++) {
              _c3 = add2(_c3, mul2(conj2(adata[_i3][0]), bdata[_i3][0]));
            }
            return _c3;
          }
        }
        function _sparseDot(x, y) {
          _validateDim(x, y);
          var xindex = x._index;
          var xvalues = x._values;
          var yindex = y._index;
          var yvalues = y._values;
          var c = 0;
          var add2 = addScalar2;
          var mul2 = multiplyScalar2;
          var i = 0;
          var j = 0;
          while (i < xindex.length && j < yindex.length) {
            var I = xindex[i];
            var J = yindex[j];
            if (I < J) {
              i++;
              continue;
            }
            if (I > J) {
              j++;
              continue;
            }
            if (I === J) {
              c = add2(c, mul2(xvalues[i], yvalues[j]));
              i++;
              j++;
            }
          }
          return c;
        }
        function _size(x) {
          return (0, _is.isMatrix)(x) ? x.size() : size2(x);
        }
      });
    }
  });

  // node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/function/matrix/trace.js
  var require_trace = __commonJS({
    "node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/function/matrix/trace.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.createTrace = void 0;
      var _object = require_object();
      var _string = require_string();
      var _factory = require_factory();
      var name18 = "trace";
      var dependencies19 = ["typed", "matrix", "add"];
      var createTrace2 = exports.createTrace = /* @__PURE__ */ (0, _factory.factory)(name18, dependencies19, function(_ref) {
        var typed2 = _ref.typed, matrix2 = _ref.matrix, add2 = _ref.add;
        return typed2("trace", {
          Array: function _arrayTrace(x) {
            return _denseTrace(matrix2(x));
          },
          SparseMatrix: _sparseTrace,
          DenseMatrix: _denseTrace,
          any: _object.clone
        });
        function _denseTrace(m) {
          var size2 = m._size;
          var data = m._data;
          switch (size2.length) {
            case 1:
              if (size2[0] === 1) {
                return (0, _object.clone)(data[0]);
              }
              throw new RangeError("Matrix must be square (size: " + (0, _string.format)(size2) + ")");
            case 2: {
              var rows = size2[0];
              var cols = size2[1];
              if (rows === cols) {
                var sum2 = 0;
                for (var i = 0; i < rows; i++) {
                  sum2 = add2(sum2, data[i][i]);
                }
                return sum2;
              } else {
                throw new RangeError("Matrix must be square (size: " + (0, _string.format)(size2) + ")");
              }
            }
            default:
              throw new RangeError("Matrix must be two dimensional (size: " + (0, _string.format)(size2) + ")");
          }
        }
        function _sparseTrace(m) {
          var values = m._values;
          var index = m._index;
          var ptr = m._ptr;
          var size2 = m._size;
          var rows = size2[0];
          var columns = size2[1];
          if (rows === columns) {
            var sum2 = 0;
            if (values.length > 0) {
              for (var j = 0; j < columns; j++) {
                var k0 = ptr[j];
                var k1 = ptr[j + 1];
                for (var k = k0; k < k1; k++) {
                  var i = index[k];
                  if (i === j) {
                    sum2 = add2(sum2, values[k]);
                    break;
                  }
                  if (i > j) {
                    break;
                  }
                }
              }
            }
            return sum2;
          }
          throw new RangeError("Matrix must be square (size: " + (0, _string.format)(size2) + ")");
        }
      });
    }
  });

  // node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/type/matrix/function/index.js
  var require_function2 = __commonJS({
    "node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/type/matrix/function/index.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.createIndex = void 0;
      var _is = require_is();
      var _factory = require_factory();
      var name18 = "index";
      var dependencies19 = ["typed", "Index"];
      var createIndex2 = exports.createIndex = /* @__PURE__ */ (0, _factory.factory)(name18, dependencies19, function(_ref) {
        var typed2 = _ref.typed, Index = _ref.Index;
        return typed2(name18, {
          "...number | string | BigNumber | Range | Array | Matrix": function numberStringBigNumberRangeArrayMatrix(args) {
            var ranges = args.map(function(arg) {
              if ((0, _is.isBigNumber)(arg)) {
                return arg.toNumber();
              } else if ((0, _is.isArray)(arg) || (0, _is.isMatrix)(arg)) {
                return arg.map(function(elem) {
                  return (0, _is.isBigNumber)(elem) ? elem.toNumber() : elem;
                });
              } else {
                return arg;
              }
            });
            var res = new Index();
            Index.apply(res, ranges);
            return res;
          }
        });
      });
    }
  });

  // node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/expression/keywords.js
  var require_keywords = __commonJS({
    "node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/expression/keywords.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.keywords = void 0;
      var keywords = exports.keywords = /* @__PURE__ */ new Set(["end"]);
    }
  });

  // node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/expression/node/Node.js
  var require_Node = __commonJS({
    "node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/expression/node/Node.js"(exports) {
      "use strict";
      var _interopRequireDefault = require_interopRequireDefault();
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.createNode = void 0;
      var _typeof2 = _interopRequireDefault(require_typeof());
      var _classCallCheck2 = _interopRequireDefault(require_classCallCheck());
      var _createClass2 = _interopRequireDefault(require_createClass());
      var _toConsumableArray2 = _interopRequireDefault(require_toConsumableArray());
      var _is = require_is();
      var _keywords = require_keywords();
      var _object = require_object();
      var _factory = require_factory();
      var _map = require_map();
      var name18 = "Node";
      var dependencies19 = ["mathWithTransform"];
      var createNode = exports.createNode = /* @__PURE__ */ (0, _factory.factory)(name18, dependencies19, function(_ref) {
        var mathWithTransform = _ref.mathWithTransform;
        function _validateScope(scope) {
          for (var _i = 0, _arr = (0, _toConsumableArray2["default"])(_keywords.keywords); _i < _arr.length; _i++) {
            var symbol = _arr[_i];
            if (scope.has(symbol)) {
              throw new Error('Scope contains an illegal symbol, "' + symbol + '" is a reserved keyword');
            }
          }
        }
        var Node = /* @__PURE__ */ (function() {
          function Node2() {
            (0, _classCallCheck2["default"])(this, Node2);
          }
          return (0, _createClass2["default"])(Node2, [{
            key: "type",
            get: function get() {
              return "Node";
            }
          }, {
            key: "isNode",
            get: function get() {
              return true;
            }
            /**
             * Evaluate the node
             * @param {Object} [scope]  Scope to read/write variables
             * @return {*}              Returns the result
             */
          }, {
            key: "evaluate",
            value: function evaluate(scope) {
              return this.compile().evaluate(scope);
            }
            /**
             * Compile the node into an optimized, evauatable JavaScript function
             * @return {{evaluate: function([Object])}} object
             *                Returns an object with a function 'evaluate',
             *                which can be invoked as expr.evaluate([scope: Object]),
             *                where scope is an optional object with
             *                variables.
             */
          }, {
            key: "compile",
            value: function compile() {
              var expr = this._compile(mathWithTransform, {});
              var args = {};
              var context = null;
              function evaluate(scope) {
                var s = (0, _map.createMap)(scope);
                _validateScope(s);
                return expr(s, args, context);
              }
              return {
                evaluate
              };
            }
            /**
             * Compile a node into a JavaScript function.
             * This basically pre-calculates as much as possible and only leaves open
             * calculations which depend on a dynamic scope with variables.
             * @param {Object} math     Math.js namespace with functions and constants.
             * @param {Object} argNames An object with argument names as key and `true`
             *                          as value. Used in the SymbolNode to optimize
             *                          for arguments from user assigned functions
             *                          (see FunctionAssignmentNode) or special symbols
             *                          like `end` (see IndexNode).
             * @return {function} Returns a function which can be called like:
             *                        evalNode(scope: Object, args: Object, context: *)
             */
          }, {
            key: "_compile",
            value: function _compile(math, argNames) {
              throw new Error("Method _compile must be implemented by type " + this.type);
            }
            /**
             * Execute a callback for each of the child nodes of this node
             * @param {function(child: Node, path: string, parent: Node)} callback
             */
          }, {
            key: "forEach",
            value: function forEach(callback) {
              throw new Error("Cannot run forEach on a Node interface");
            }
            /**
             * Create a new Node whose children are the results of calling the
             * provided callback function for each child of the original node.
             * @param {function(child: Node, path: string, parent: Node): Node} callback
             * @returns {OperatorNode} Returns a transformed copy of the node
             */
          }, {
            key: "map",
            value: function map(callback) {
              throw new Error("Cannot run map on a Node interface");
            }
            /**
             * Validate whether an object is a Node, for use with map
             * @param {Node} node
             * @returns {Node} Returns the input if it's a node, else throws an Error
             * @protected
             */
          }, {
            key: "_ifNode",
            value: function _ifNode(node) {
              if (!(0, _is.isNode)(node)) {
                throw new TypeError("Callback function must return a Node");
              }
              return node;
            }
            /**
             * Recursively traverse all nodes in a node tree. Executes given callback for
             * this node and each of its child nodes.
             * @param {function(node: Node, path: string, parent: Node)} callback
             *          A callback called for every node in the node tree.
             */
          }, {
            key: "traverse",
            value: function traverse(callback) {
              callback(this, null, null);
              function _traverse(node, callback2) {
                node.forEach(function(child, path, parent) {
                  callback2(child, path, parent);
                  _traverse(child, callback2);
                });
              }
              _traverse(this, callback);
            }
            /**
             * Recursively transform a node tree via a transform function.
             *
             * For example, to replace all nodes of type SymbolNode having name 'x' with
             * a ConstantNode with value 2:
             *
             *     const res = Node.transform(function (node, path, parent) {
             *       if (node && node.isSymbolNode) && (node.name === 'x')) {
             *         return new ConstantNode(2)
             *       }
             *       else {
             *         return node
             *       }
             *     })
             *
             * @param {function(node: Node, path: string, parent: Node) : Node} callback
             *          A mapping function accepting a node, and returning
             *          a replacement for the node or the original node. The "signature"
             *          of the callback must be:
             *          callback(node: Node, index: string, parent: Node) : Node
             * @return {Node} Returns the original node or its replacement
             */
          }, {
            key: "transform",
            value: function transform(callback) {
              function _transform(child, path, parent) {
                var replacement = callback(child, path, parent);
                if (replacement !== child) {
                  return replacement;
                }
                return child.map(_transform);
              }
              return _transform(this, null, null);
            }
            /**
             * Find any node in the node tree matching given filter function. For
             * example, to find all nodes of type SymbolNode having name 'x':
             *
             *     const results = Node.filter(function (node) {
             *       return (node && node.isSymbolNode) && (node.name === 'x')
             *     })
             *
             * @param {function(node: Node, path: string, parent: Node) : Node} callback
             *            A test function returning true when a node matches, and false
             *            otherwise. Function signature:
             *            callback(node: Node, index: string, parent: Node) : boolean
             * @return {Node[]} nodes
             *            An array with nodes matching given filter criteria
             */
          }, {
            key: "filter",
            value: function filter(callback) {
              var nodes = [];
              this.traverse(function(node, path, parent) {
                if (callback(node, path, parent)) {
                  nodes.push(node);
                }
              });
              return nodes;
            }
            /**
             * Create a shallow clone of this node
             * @return {Node}
             */
          }, {
            key: "clone",
            value: function clone4() {
              throw new Error("Cannot clone a Node interface");
            }
            /**
             * Create a deep clone of this node
             * @return {Node}
             */
          }, {
            key: "cloneDeep",
            value: function cloneDeep() {
              return this.map(function(node) {
                return node.cloneDeep();
              });
            }
            /**
             * Deep compare this node with another node.
             * @param {Node} other
             * @return {boolean} Returns true when both nodes are of the same type and
             *                   contain the same values (as do their childs)
             */
          }, {
            key: "equals",
            value: function equals(other) {
              return other ? this.type === other.type && (0, _object.deepStrictEqual)(this, other) : false;
            }
            /**
             * Get string representation. (wrapper function)
             *
             * This function can get an object of the following form:
             * {
             *    handler: //This can be a callback function of the form
             *             // "function callback(node, options)"or
             *             // a map that maps function names (used in FunctionNodes)
             *             // to callbacks
             *    parenthesis: "keep" //the parenthesis option (This is optional)
             * }
             *
             * @param {Object} [options]
             * @return {string}
             */
          }, {
            key: "toString",
            value: function toString(options) {
              var customString = this._getCustomString(options);
              if (typeof customString !== "undefined") {
                return customString;
              }
              return this._toString(options);
            }
            /**
             * Internal function to generate the string output.
             * This has to be implemented by every Node
             *
             * @throws {Error}
             */
          }, {
            key: "_toString",
            value: function _toString() {
              throw new Error("_toString not implemented for " + this.type);
            }
            /**
             * Get a JSON representation of the node
             * Both .toJSON() and the static .fromJSON(json) should be implemented by all
             * implementations of Node
             * @returns {Object}
             */
          }, {
            key: "toJSON",
            value: function toJSON() {
              throw new Error("Cannot serialize object: toJSON not implemented by " + this.type);
            }
            /**
             * Get HTML representation. (wrapper function)
             *
             * This function can get an object of the following form:
             * {
             *    handler: //This can be a callback function of the form
             *             // "function callback(node, options)" or
             *             // a map that maps function names (used in FunctionNodes)
             *             // to callbacks
             *    parenthesis: "keep" //the parenthesis option (This is optional)
             * }
             *
             * @param {Object} [options]
             * @return {string}
             */
          }, {
            key: "toHTML",
            value: function toHTML(options) {
              var customString = this._getCustomString(options);
              if (typeof customString !== "undefined") {
                return customString;
              }
              return this._toHTML(options);
            }
            /**
             * Internal function to generate the HTML output.
             * This has to be implemented by every Node
             *
             * @throws {Error}
             */
          }, {
            key: "_toHTML",
            value: function _toHTML() {
              throw new Error("_toHTML not implemented for " + this.type);
            }
            /**
             * Get LaTeX representation. (wrapper function)
             *
             * This function can get an object of the following form:
             * {
             *    handler: //This can be a callback function of the form
             *             // "function callback(node, options)"or
             *             // a map that maps function names (used in FunctionNodes)
             *             // to callbacks
             *    parenthesis: "keep" //the parenthesis option (This is optional)
             * }
             *
             * @param {Object} [options]
             * @return {string}
             */
          }, {
            key: "toTex",
            value: function toTex(options) {
              var customString = this._getCustomString(options);
              if (typeof customString !== "undefined") {
                return customString;
              }
              return this._toTex(options);
            }
            /**
             * Internal function to generate the LaTeX output.
             * This has to be implemented by every Node
             *
             * @param {Object} [options]
             * @throws {Error}
             */
          }, {
            key: "_toTex",
            value: function _toTex(options) {
              throw new Error("_toTex not implemented for " + this.type);
            }
            /**
             * Helper used by `to...` functions.
             */
          }, {
            key: "_getCustomString",
            value: function _getCustomString(options) {
              if (options && (0, _typeof2["default"])(options) === "object") {
                switch ((0, _typeof2["default"])(options.handler)) {
                  case "object":
                  case "undefined":
                    return;
                  case "function":
                    return options.handler(this, options);
                  default:
                    throw new TypeError("Object or function expected as callback");
                }
              }
            }
            /**
             * Get identifier.
             * @return {string}
             */
          }, {
            key: "getIdentifier",
            value: function getIdentifier() {
              return this.type;
            }
            /**
             * Get the content of the current Node.
             * @return {Node} node
             **/
          }, {
            key: "getContent",
            value: function getContent() {
              return this;
            }
          }]);
        })();
        return Node;
      }, {
        isClass: true,
        isNode: true
      });
    }
  });

  // node_modules/.pnpm/@babel+runtime@7.28.4/node_modules/@babel/runtime/helpers/assertThisInitialized.js
  var require_assertThisInitialized = __commonJS({
    "node_modules/.pnpm/@babel+runtime@7.28.4/node_modules/@babel/runtime/helpers/assertThisInitialized.js"(exports, module) {
      function _assertThisInitialized(e) {
        if (void 0 === e) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
        return e;
      }
      module.exports = _assertThisInitialized, module.exports.__esModule = true, module.exports["default"] = module.exports;
    }
  });

  // node_modules/.pnpm/@babel+runtime@7.28.4/node_modules/@babel/runtime/helpers/possibleConstructorReturn.js
  var require_possibleConstructorReturn = __commonJS({
    "node_modules/.pnpm/@babel+runtime@7.28.4/node_modules/@babel/runtime/helpers/possibleConstructorReturn.js"(exports, module) {
      var _typeof = require_typeof()["default"];
      var assertThisInitialized = require_assertThisInitialized();
      function _possibleConstructorReturn(t, e) {
        if (e && ("object" == _typeof(e) || "function" == typeof e)) return e;
        if (void 0 !== e) throw new TypeError("Derived constructors may only return object or undefined");
        return assertThisInitialized(t);
      }
      module.exports = _possibleConstructorReturn, module.exports.__esModule = true, module.exports["default"] = module.exports;
    }
  });

  // node_modules/.pnpm/@babel+runtime@7.28.4/node_modules/@babel/runtime/helpers/getPrototypeOf.js
  var require_getPrototypeOf = __commonJS({
    "node_modules/.pnpm/@babel+runtime@7.28.4/node_modules/@babel/runtime/helpers/getPrototypeOf.js"(exports, module) {
      function _getPrototypeOf(t) {
        return module.exports = _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function(t2) {
          return t2.__proto__ || Object.getPrototypeOf(t2);
        }, module.exports.__esModule = true, module.exports["default"] = module.exports, _getPrototypeOf(t);
      }
      module.exports = _getPrototypeOf, module.exports.__esModule = true, module.exports["default"] = module.exports;
    }
  });

  // node_modules/.pnpm/@babel+runtime@7.28.4/node_modules/@babel/runtime/helpers/setPrototypeOf.js
  var require_setPrototypeOf = __commonJS({
    "node_modules/.pnpm/@babel+runtime@7.28.4/node_modules/@babel/runtime/helpers/setPrototypeOf.js"(exports, module) {
      function _setPrototypeOf(t, e) {
        return module.exports = _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(t2, e2) {
          return t2.__proto__ = e2, t2;
        }, module.exports.__esModule = true, module.exports["default"] = module.exports, _setPrototypeOf(t, e);
      }
      module.exports = _setPrototypeOf, module.exports.__esModule = true, module.exports["default"] = module.exports;
    }
  });

  // node_modules/.pnpm/@babel+runtime@7.28.4/node_modules/@babel/runtime/helpers/inherits.js
  var require_inherits = __commonJS({
    "node_modules/.pnpm/@babel+runtime@7.28.4/node_modules/@babel/runtime/helpers/inherits.js"(exports, module) {
      var setPrototypeOf = require_setPrototypeOf();
      function _inherits(t, e) {
        if ("function" != typeof e && null !== e) throw new TypeError("Super expression must either be null or a function");
        t.prototype = Object.create(e && e.prototype, {
          constructor: {
            value: t,
            writable: true,
            configurable: true
          }
        }), Object.defineProperty(t, "prototype", {
          writable: false
        }), e && setPrototypeOf(t, e);
      }
      module.exports = _inherits, module.exports.__esModule = true, module.exports["default"] = module.exports;
    }
  });

  // node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/expression/transform/utils/errorTransform.js
  var require_errorTransform = __commonJS({
    "node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/expression/transform/utils/errorTransform.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.errorTransform = errorTransform;
      var _IndexError = require_IndexError();
      function errorTransform(err) {
        if (err && err.isIndexError) {
          return new _IndexError.IndexError(err.index + 1, err.min + 1, err.max !== void 0 ? err.max + 1 : void 0);
        }
        return err;
      }
    }
  });

  // node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/expression/node/utils/access.js
  var require_access = __commonJS({
    "node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/expression/node/utils/access.js"(exports) {
      "use strict";
      var _interopRequireDefault = require_interopRequireDefault();
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.accessFactory = accessFactory;
      var _typeof2 = _interopRequireDefault(require_typeof());
      var _errorTransform = require_errorTransform();
      var _customs = require_customs();
      function accessFactory(_ref) {
        var subset = _ref.subset;
        return function access(object, index) {
          try {
            if (Array.isArray(object)) {
              return subset(object, index);
            } else if (object && typeof object.subset === "function") {
              return object.subset(index);
            } else if (typeof object === "string") {
              return subset(object, index);
            } else if ((0, _typeof2["default"])(object) === "object") {
              if (!index.isObjectProperty()) {
                throw new TypeError("Cannot apply a numeric index as object property");
              }
              return (0, _customs.getSafeProperty)(object, index.getObjectProperty());
            } else {
              throw new TypeError("Cannot apply index: unsupported type of object");
            }
          } catch (err) {
            throw (0, _errorTransform.errorTransform)(err);
          }
        };
      }
    }
  });

  // node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/expression/node/AccessorNode.js
  var require_AccessorNode = __commonJS({
    "node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/expression/node/AccessorNode.js"(exports) {
      "use strict";
      var _interopRequireDefault = require_interopRequireDefault();
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.createAccessorNode = void 0;
      var _classCallCheck2 = _interopRequireDefault(require_classCallCheck());
      var _createClass2 = _interopRequireDefault(require_createClass());
      var _possibleConstructorReturn2 = _interopRequireDefault(require_possibleConstructorReturn());
      var _getPrototypeOf2 = _interopRequireDefault(require_getPrototypeOf());
      var _inherits2 = _interopRequireDefault(require_inherits());
      var _defineProperty2 = _interopRequireDefault(require_defineProperty());
      var _is = require_is();
      var _customs = require_customs();
      var _factory = require_factory();
      var _access = require_access();
      function _callSuper(t, o, e) {
        return o = (0, _getPrototypeOf2["default"])(o), (0, _possibleConstructorReturn2["default"])(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], (0, _getPrototypeOf2["default"])(t).constructor) : o.apply(t, e));
      }
      function _isNativeReflectConstruct() {
        try {
          var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
          }));
        } catch (t2) {
        }
        return (_isNativeReflectConstruct = function _isNativeReflectConstruct2() {
          return !!t;
        })();
      }
      var name18 = "AccessorNode";
      var dependencies19 = ["subset", "Node"];
      var createAccessorNode = exports.createAccessorNode = /* @__PURE__ */ (0, _factory.factory)(name18, dependencies19, function(_ref) {
        var subset = _ref.subset, Node = _ref.Node;
        var access = (0, _access.accessFactory)({
          subset
        });
        function needParenthesis(node) {
          return !((0, _is.isAccessorNode)(node) || (0, _is.isArrayNode)(node) || (0, _is.isConstantNode)(node) || (0, _is.isFunctionNode)(node) || (0, _is.isObjectNode)(node) || (0, _is.isParenthesisNode)(node) || (0, _is.isSymbolNode)(node));
        }
        var AccessorNode = /* @__PURE__ */ (function(_Node) {
          function AccessorNode2(object, index) {
            var _this;
            (0, _classCallCheck2["default"])(this, AccessorNode2);
            _this = _callSuper(this, AccessorNode2);
            if (!(0, _is.isNode)(object)) {
              throw new TypeError('Node expected for parameter "object"');
            }
            if (!(0, _is.isIndexNode)(index)) {
              throw new TypeError('IndexNode expected for parameter "index"');
            }
            _this.object = object;
            _this.index = index;
            return _this;
          }
          (0, _inherits2["default"])(AccessorNode2, _Node);
          return (0, _createClass2["default"])(AccessorNode2, [{
            key: "name",
            get: function get() {
              if (this.index) {
                return this.index.isObjectProperty() ? this.index.getObjectProperty() : "";
              } else {
                return this.object.name || "";
              }
            }
          }, {
            key: "type",
            get: function get() {
              return name18;
            }
          }, {
            key: "isAccessorNode",
            get: function get() {
              return true;
            }
            /**
             * Compile a node into a JavaScript function.
             * This basically pre-calculates as much as possible and only leaves open
             * calculations which depend on a dynamic scope with variables.
             * @param {Object} math     Math.js namespace with functions and constants.
             * @param {Object} argNames An object with argument names as key and `true`
             *                          as value. Used in the SymbolNode to optimize
             *                          for arguments from user assigned functions
             *                          (see FunctionAssignmentNode) or special symbols
             *                          like `end` (see IndexNode).
             * @return {function} Returns a function which can be called like:
             *                        evalNode(scope: Object, args: Object, context: *)
             */
          }, {
            key: "_compile",
            value: function _compile(math, argNames) {
              var evalObject = this.object._compile(math, argNames);
              var evalIndex = this.index._compile(math, argNames);
              if (this.index.isObjectProperty()) {
                var prop = this.index.getObjectProperty();
                return function evalAccessorNode(scope, args, context) {
                  return (0, _customs.getSafeProperty)(evalObject(scope, args, context), prop);
                };
              } else {
                return function evalAccessorNode(scope, args, context) {
                  var object = evalObject(scope, args, context);
                  var index = evalIndex(scope, args, object);
                  return access(object, index);
                };
              }
            }
            /**
             * Execute a callback for each of the child nodes of this node
             * @param {function(child: Node, path: string, parent: Node)} callback
             */
          }, {
            key: "forEach",
            value: function forEach(callback) {
              callback(this.object, "object", this);
              callback(this.index, "index", this);
            }
            /**
             * Create a new AccessorNode whose children are the results of calling
             * the provided callback function for each child of the original node.
             * @param {function(child: Node, path: string, parent: Node): Node} callback
             * @returns {AccessorNode} Returns a transformed copy of the node
             */
          }, {
            key: "map",
            value: function map(callback) {
              return new AccessorNode2(this._ifNode(callback(this.object, "object", this)), this._ifNode(callback(this.index, "index", this)));
            }
            /**
             * Create a clone of this node, a shallow copy
             * @return {AccessorNode}
             */
          }, {
            key: "clone",
            value: function clone4() {
              return new AccessorNode2(this.object, this.index);
            }
            /**
             * Get string representation
             * @param {Object} options
             * @return {string}
             */
          }, {
            key: "_toString",
            value: function _toString(options) {
              var object = this.object.toString(options);
              if (needParenthesis(this.object)) {
                object = "(" + object + ")";
              }
              return object + this.index.toString(options);
            }
            /**
             * Get HTML representation
             * @param {Object} options
             * @return {string}
             */
          }, {
            key: "_toHTML",
            value: function _toHTML(options) {
              var object = this.object.toHTML(options);
              if (needParenthesis(this.object)) {
                object = '<span class="math-parenthesis math-round-parenthesis">(</span>' + object + '<span class="math-parenthesis math-round-parenthesis">)</span>';
              }
              return object + this.index.toHTML(options);
            }
            /**
             * Get LaTeX representation
             * @param {Object} options
             * @return {string}
             */
          }, {
            key: "_toTex",
            value: function _toTex(options) {
              var object = this.object.toTex(options);
              if (needParenthesis(this.object)) {
                object = "\\left(' + object + '\\right)";
              }
              return object + this.index.toTex(options);
            }
            /**
             * Get a JSON representation of the node
             * @returns {Object}
             */
          }, {
            key: "toJSON",
            value: function toJSON() {
              return {
                mathjs: name18,
                object: this.object,
                index: this.index
              };
            }
            /**
             * Instantiate an AccessorNode from its JSON representation
             * @param {Object} json
             *     An object structured like
             *     `{"mathjs": "AccessorNode", object: ..., index: ...}`,
             *     where mathjs is optional
             * @returns {AccessorNode}
             */
          }], [{
            key: "fromJSON",
            value: function fromJSON(json) {
              return new AccessorNode2(json.object, json.index);
            }
          }]);
        })(Node);
        (0, _defineProperty2["default"])(AccessorNode, "name", name18);
        return AccessorNode;
      }, {
        isClass: true,
        isNode: true
      });
    }
  });

  // node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/expression/node/ArrayNode.js
  var require_ArrayNode = __commonJS({
    "node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/expression/node/ArrayNode.js"(exports) {
      "use strict";
      var _interopRequireDefault = require_interopRequireDefault();
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.createArrayNode = void 0;
      var _classCallCheck2 = _interopRequireDefault(require_classCallCheck());
      var _createClass2 = _interopRequireDefault(require_createClass());
      var _possibleConstructorReturn2 = _interopRequireDefault(require_possibleConstructorReturn());
      var _getPrototypeOf2 = _interopRequireDefault(require_getPrototypeOf());
      var _inherits2 = _interopRequireDefault(require_inherits());
      var _defineProperty2 = _interopRequireDefault(require_defineProperty());
      var _is = require_is();
      var _array = require_array();
      var _factory = require_factory();
      function _callSuper(t, o, e) {
        return o = (0, _getPrototypeOf2["default"])(o), (0, _possibleConstructorReturn2["default"])(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], (0, _getPrototypeOf2["default"])(t).constructor) : o.apply(t, e));
      }
      function _isNativeReflectConstruct() {
        try {
          var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
          }));
        } catch (t2) {
        }
        return (_isNativeReflectConstruct = function _isNativeReflectConstruct2() {
          return !!t;
        })();
      }
      var name18 = "ArrayNode";
      var dependencies19 = ["Node"];
      var createArrayNode = exports.createArrayNode = /* @__PURE__ */ (0, _factory.factory)(name18, dependencies19, function(_ref) {
        var Node = _ref.Node;
        var ArrayNode = /* @__PURE__ */ (function(_Node) {
          function ArrayNode2(items) {
            var _this;
            (0, _classCallCheck2["default"])(this, ArrayNode2);
            _this = _callSuper(this, ArrayNode2);
            _this.items = items || [];
            if (!Array.isArray(_this.items) || !_this.items.every(_is.isNode)) {
              throw new TypeError("Array containing Nodes expected");
            }
            return _this;
          }
          (0, _inherits2["default"])(ArrayNode2, _Node);
          return (0, _createClass2["default"])(ArrayNode2, [{
            key: "type",
            get: function get() {
              return name18;
            }
          }, {
            key: "isArrayNode",
            get: function get() {
              return true;
            }
            /**
             * Compile a node into a JavaScript function.
             * This basically pre-calculates as much as possible and only leaves open
             * calculations which depend on a dynamic scope with variables.
             * @param {Object} math     Math.js namespace with functions and constants.
             * @param {Object} argNames An object with argument names as key and `true`
             *                          as value. Used in the SymbolNode to optimize
             *                          for arguments from user assigned functions
             *                          (see FunctionAssignmentNode) or special symbols
             *                          like `end` (see IndexNode).
             * @return {function} Returns a function which can be called like:
             *                        evalNode(scope: Object, args: Object, context: *)
             */
          }, {
            key: "_compile",
            value: function _compile(math, argNames) {
              var evalItems = (0, _array.map)(this.items, function(item) {
                return item._compile(math, argNames);
              });
              var asMatrix = math.config.matrix !== "Array";
              if (asMatrix) {
                var matrix2 = math.matrix;
                return function evalArrayNode(scope, args, context) {
                  return matrix2((0, _array.map)(evalItems, function(evalItem) {
                    return evalItem(scope, args, context);
                  }));
                };
              } else {
                return function evalArrayNode(scope, args, context) {
                  return (0, _array.map)(evalItems, function(evalItem) {
                    return evalItem(scope, args, context);
                  });
                };
              }
            }
            /**
             * Execute a callback for each of the child nodes of this node
             * @param {function(child: Node, path: string, parent: Node)} callback
             */
          }, {
            key: "forEach",
            value: function forEach(callback) {
              for (var i = 0; i < this.items.length; i++) {
                var node = this.items[i];
                callback(node, "items[" + i + "]", this);
              }
            }
            /**
             * Create a new ArrayNode whose children are the results of calling
             * the provided callback function for each child of the original node.
             * @param {function(child: Node, path: string, parent: Node): Node} callback
             * @returns {ArrayNode} Returns a transformed copy of the node
             */
          }, {
            key: "map",
            value: function map(callback) {
              var items = [];
              for (var i = 0; i < this.items.length; i++) {
                items[i] = this._ifNode(callback(this.items[i], "items[" + i + "]", this));
              }
              return new ArrayNode2(items);
            }
            /**
             * Create a clone of this node, a shallow copy
             * @return {ArrayNode}
             */
          }, {
            key: "clone",
            value: function clone4() {
              return new ArrayNode2(this.items.slice(0));
            }
            /**
             * Get string representation
             * @param {Object} options
             * @return {string} str
             * @override
             */
          }, {
            key: "_toString",
            value: function _toString(options) {
              var items = this.items.map(function(node) {
                return node.toString(options);
              });
              return "[" + items.join(", ") + "]";
            }
            /**
             * Get a JSON representation of the node
             * @returns {Object}
             */
          }, {
            key: "toJSON",
            value: function toJSON() {
              return {
                mathjs: name18,
                items: this.items
              };
            }
            /**
             * Instantiate an ArrayNode from its JSON representation
             * @param {Object} json  An object structured like
             *                       `{"mathjs": "ArrayNode", items: [...]}`,
             *                       where mathjs is optional
             * @returns {ArrayNode}
             */
          }, {
            key: "_toHTML",
            value: (
              /**
               * Get HTML representation
               * @param {Object} options
               * @return {string} str
               * @override
               */
              function _toHTML(options) {
                var items = this.items.map(function(node) {
                  return node.toHTML(options);
                });
                return '<span class="math-parenthesis math-square-parenthesis">[</span>' + items.join('<span class="math-separator">,</span>') + '<span class="math-parenthesis math-square-parenthesis">]</span>';
              }
            )
            /**
             * Get LaTeX representation
             * @param {Object} options
             * @return {string} str
             */
          }, {
            key: "_toTex",
            value: function _toTex(options) {
              function itemsToTex(items, nested) {
                var mixedItems = items.some(_is.isArrayNode) && !items.every(_is.isArrayNode);
                var itemsFormRow = nested || mixedItems;
                var itemSep = itemsFormRow ? "&" : "\\\\";
                var itemsTex = items.map(function(node) {
                  if (node.items) {
                    return itemsToTex(node.items, !nested);
                  } else {
                    return node.toTex(options);
                  }
                }).join(itemSep);
                return mixedItems || !itemsFormRow || itemsFormRow && !nested ? "\\begin{bmatrix}" + itemsTex + "\\end{bmatrix}" : itemsTex;
              }
              return itemsToTex(this.items, false);
            }
          }], [{
            key: "fromJSON",
            value: function fromJSON(json) {
              return new ArrayNode2(json.items);
            }
          }]);
        })(Node);
        (0, _defineProperty2["default"])(ArrayNode, "name", name18);
        return ArrayNode;
      }, {
        isClass: true,
        isNode: true
      });
    }
  });

  // node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/expression/node/utils/assign.js
  var require_assign = __commonJS({
    "node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/expression/node/utils/assign.js"(exports) {
      "use strict";
      var _interopRequireDefault = require_interopRequireDefault();
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.assignFactory = assignFactory;
      var _typeof2 = _interopRequireDefault(require_typeof());
      var _errorTransform = require_errorTransform();
      var _customs = require_customs();
      function assignFactory(_ref) {
        var subset = _ref.subset, matrix2 = _ref.matrix;
        return function assign(object, index, value) {
          try {
            if (Array.isArray(object)) {
              var result = matrix2(object).subset(index, value).valueOf();
              result.forEach(function(item, index2) {
                object[index2] = item;
              });
              return object;
            } else if (object && typeof object.subset === "function") {
              return object.subset(index, value);
            } else if (typeof object === "string") {
              return subset(object, index, value);
            } else if ((0, _typeof2["default"])(object) === "object") {
              if (!index.isObjectProperty()) {
                throw TypeError("Cannot apply a numeric index as object property");
              }
              (0, _customs.setSafeProperty)(object, index.getObjectProperty(), value);
              return object;
            } else {
              throw new TypeError("Cannot apply index: unsupported type of object");
            }
          } catch (err) {
            throw (0, _errorTransform.errorTransform)(err);
          }
        };
      }
    }
  });

  // node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/expression/operators.js
  var require_operators = __commonJS({
    "node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/expression/operators.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.getAssociativity = getAssociativity;
      exports.getOperator = getOperator;
      exports.getPrecedence = getPrecedence;
      exports.isAssociativeWith = isAssociativeWith;
      exports.properties = void 0;
      var _object = require_object();
      var _is = require_is();
      function _createForOfIteratorHelper(o, allowArrayLike) {
        var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"];
        if (!it) {
          if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") {
            if (it) o = it;
            var i = 0;
            var F = function F2() {
            };
            return { s: F, n: function n() {
              if (i >= o.length) return { done: true };
              return { done: false, value: o[i++] };
            }, e: function e(_e) {
              throw _e;
            }, f: F };
          }
          throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
        }
        var normalCompletion = true, didErr = false, err;
        return { s: function s() {
          it = it.call(o);
        }, n: function n() {
          var step = it.next();
          normalCompletion = step.done;
          return step;
        }, e: function e(_e2) {
          didErr = true;
          err = _e2;
        }, f: function f() {
          try {
            if (!normalCompletion && it["return"] != null) it["return"]();
          } finally {
            if (didErr) throw err;
          }
        } };
      }
      function _unsupportedIterableToArray(o, minLen) {
        if (!o) return;
        if (typeof o === "string") return _arrayLikeToArray(o, minLen);
        var n = Object.prototype.toString.call(o).slice(8, -1);
        if (n === "Object" && o.constructor) n = o.constructor.name;
        if (n === "Map" || n === "Set") return Array.from(o);
        if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);
      }
      function _arrayLikeToArray(arr, len) {
        if (len == null || len > arr.length) len = arr.length;
        for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];
        return arr2;
      }
      var properties = exports.properties = [{
        // assignment
        AssignmentNode: {},
        FunctionAssignmentNode: {}
      }, {
        // conditional expression
        ConditionalNode: {
          latexLeftParens: false,
          latexRightParens: false,
          latexParens: false
          // conditionals don't need parentheses in LaTeX because
          // they are 2 dimensional
        }
      }, {
        // logical or
        "OperatorNode:or": {
          op: "or",
          associativity: "left",
          associativeWith: []
        }
      }, {
        // logical xor
        "OperatorNode:xor": {
          op: "xor",
          associativity: "left",
          associativeWith: []
        }
      }, {
        // logical and
        "OperatorNode:and": {
          op: "and",
          associativity: "left",
          associativeWith: []
        }
      }, {
        // bitwise or
        "OperatorNode:bitOr": {
          op: "|",
          associativity: "left",
          associativeWith: []
        }
      }, {
        // bitwise xor
        "OperatorNode:bitXor": {
          op: "^|",
          associativity: "left",
          associativeWith: []
        }
      }, {
        // bitwise and
        "OperatorNode:bitAnd": {
          op: "&",
          associativity: "left",
          associativeWith: []
        }
      }, {
        // relational operators
        "OperatorNode:equal": {
          op: "==",
          associativity: "left",
          associativeWith: []
        },
        "OperatorNode:unequal": {
          op: "!=",
          associativity: "left",
          associativeWith: []
        },
        "OperatorNode:smaller": {
          op: "<",
          associativity: "left",
          associativeWith: []
        },
        "OperatorNode:larger": {
          op: ">",
          associativity: "left",
          associativeWith: []
        },
        "OperatorNode:smallerEq": {
          op: "<=",
          associativity: "left",
          associativeWith: []
        },
        "OperatorNode:largerEq": {
          op: ">=",
          associativity: "left",
          associativeWith: []
        },
        RelationalNode: {
          associativity: "left",
          associativeWith: []
        }
      }, {
        // bitshift operators
        "OperatorNode:leftShift": {
          op: "<<",
          associativity: "left",
          associativeWith: []
        },
        "OperatorNode:rightArithShift": {
          op: ">>",
          associativity: "left",
          associativeWith: []
        },
        "OperatorNode:rightLogShift": {
          op: ">>>",
          associativity: "left",
          associativeWith: []
        }
      }, {
        // unit conversion
        "OperatorNode:to": {
          op: "to",
          associativity: "left",
          associativeWith: []
        }
      }, {
        // range
        RangeNode: {}
      }, {
        // addition, subtraction
        "OperatorNode:add": {
          op: "+",
          associativity: "left",
          associativeWith: ["OperatorNode:add", "OperatorNode:subtract"]
        },
        "OperatorNode:subtract": {
          op: "-",
          associativity: "left",
          associativeWith: []
        }
      }, {
        // multiply, divide, modulus
        "OperatorNode:multiply": {
          op: "*",
          associativity: "left",
          associativeWith: ["OperatorNode:multiply", "OperatorNode:divide", "Operator:dotMultiply", "Operator:dotDivide"]
        },
        "OperatorNode:divide": {
          op: "/",
          associativity: "left",
          associativeWith: [],
          latexLeftParens: false,
          latexRightParens: false,
          latexParens: false
          // fractions don't require parentheses because
          // they're 2 dimensional, so parens aren't needed
          // in LaTeX
        },
        "OperatorNode:dotMultiply": {
          op: ".*",
          associativity: "left",
          associativeWith: ["OperatorNode:multiply", "OperatorNode:divide", "OperatorNode:dotMultiply", "OperatorNode:doDivide"]
        },
        "OperatorNode:dotDivide": {
          op: "./",
          associativity: "left",
          associativeWith: []
        },
        "OperatorNode:mod": {
          op: "mod",
          associativity: "left",
          associativeWith: []
        }
      }, {
        // Repeat multiplication for implicit multiplication
        "OperatorNode:multiply": {
          associativity: "left",
          associativeWith: ["OperatorNode:multiply", "OperatorNode:divide", "Operator:dotMultiply", "Operator:dotDivide"]
        }
      }, {
        // unary prefix operators
        "OperatorNode:unaryPlus": {
          op: "+",
          associativity: "right"
        },
        "OperatorNode:unaryMinus": {
          op: "-",
          associativity: "right"
        },
        "OperatorNode:bitNot": {
          op: "~",
          associativity: "right"
        },
        "OperatorNode:not": {
          op: "not",
          associativity: "right"
        }
      }, {
        // exponentiation
        "OperatorNode:pow": {
          op: "^",
          associativity: "right",
          associativeWith: [],
          latexRightParens: false
          // the exponent doesn't need parentheses in
          // LaTeX because it's 2 dimensional
          // (it's on top)
        },
        "OperatorNode:dotPow": {
          op: ".^",
          associativity: "right",
          associativeWith: []
        }
      }, {
        // factorial
        "OperatorNode:factorial": {
          op: "!",
          associativity: "left"
        }
      }, {
        // matrix transpose
        "OperatorNode:ctranspose": {
          op: "'",
          associativity: "left"
        }
      }];
      function unwrapParen(_node, parenthesis) {
        if (!parenthesis || parenthesis !== "auto") return _node;
        var node = _node;
        while ((0, _is.isParenthesisNode)(node)) node = node.content;
        return node;
      }
      function getPrecedence(_node, parenthesis, implicit, parent) {
        var node = _node;
        if (parenthesis !== "keep") {
          node = _node.getContent();
        }
        var identifier = node.getIdentifier();
        var precedence = null;
        for (var i = 0; i < properties.length; i++) {
          if (identifier in properties[i]) {
            precedence = i;
            break;
          }
        }
        if (identifier === "OperatorNode:multiply" && node.implicit && implicit !== "show") {
          var leftArg = unwrapParen(node.args[0], parenthesis);
          if (!((0, _is.isConstantNode)(leftArg) && parent && parent.getIdentifier() === "OperatorNode:divide" && (0, _is.rule2Node)(unwrapParen(parent.args[0], parenthesis))) && !(leftArg.getIdentifier() === "OperatorNode:divide" && (0, _is.rule2Node)(unwrapParen(leftArg.args[0], parenthesis)) && (0, _is.isConstantNode)(unwrapParen(leftArg.args[1])))) {
            precedence += 1;
          }
        }
        return precedence;
      }
      function getAssociativity(_node, parenthesis) {
        var node = _node;
        if (parenthesis !== "keep") {
          node = _node.getContent();
        }
        var identifier = node.getIdentifier();
        var index = getPrecedence(node, parenthesis);
        if (index === null) {
          return null;
        }
        var property = properties[index][identifier];
        if ((0, _object.hasOwnProperty)(property, "associativity")) {
          if (property.associativity === "left") {
            return "left";
          }
          if (property.associativity === "right") {
            return "right";
          }
          throw Error("'" + identifier + "' has the invalid associativity '" + property.associativity + "'.");
        }
        return null;
      }
      function isAssociativeWith(nodeA, nodeB, parenthesis) {
        var a = parenthesis !== "keep" ? nodeA.getContent() : nodeA;
        var b = parenthesis !== "keep" ? nodeA.getContent() : nodeB;
        var identifierA = a.getIdentifier();
        var identifierB = b.getIdentifier();
        var index = getPrecedence(a, parenthesis);
        if (index === null) {
          return null;
        }
        var property = properties[index][identifierA];
        if ((0, _object.hasOwnProperty)(property, "associativeWith") && property.associativeWith instanceof Array) {
          for (var i = 0; i < property.associativeWith.length; i++) {
            if (property.associativeWith[i] === identifierB) {
              return true;
            }
          }
          return false;
        }
        return null;
      }
      function getOperator(fn) {
        var identifier = "OperatorNode:" + fn;
        var _iterator = _createForOfIteratorHelper(properties), _step;
        try {
          for (_iterator.s(); !(_step = _iterator.n()).done; ) {
            var group = _step.value;
            if (identifier in group) {
              return group[identifier].op;
            }
          }
        } catch (err) {
          _iterator.e(err);
        } finally {
          _iterator.f();
        }
        return null;
      }
    }
  });

  // node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/expression/node/AssignmentNode.js
  var require_AssignmentNode = __commonJS({
    "node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/expression/node/AssignmentNode.js"(exports) {
      "use strict";
      var _interopRequireDefault = require_interopRequireDefault();
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.createAssignmentNode = void 0;
      var _classCallCheck2 = _interopRequireDefault(require_classCallCheck());
      var _createClass2 = _interopRequireDefault(require_createClass());
      var _possibleConstructorReturn2 = _interopRequireDefault(require_possibleConstructorReturn());
      var _getPrototypeOf2 = _interopRequireDefault(require_getPrototypeOf());
      var _inherits2 = _interopRequireDefault(require_inherits());
      var _defineProperty2 = _interopRequireDefault(require_defineProperty());
      var _is = require_is();
      var _customs = require_customs();
      var _factory = require_factory();
      var _access = require_access();
      var _assign = require_assign();
      var _operators = require_operators();
      function _callSuper(t, o, e) {
        return o = (0, _getPrototypeOf2["default"])(o), (0, _possibleConstructorReturn2["default"])(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], (0, _getPrototypeOf2["default"])(t).constructor) : o.apply(t, e));
      }
      function _isNativeReflectConstruct() {
        try {
          var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
          }));
        } catch (t2) {
        }
        return (_isNativeReflectConstruct = function _isNativeReflectConstruct2() {
          return !!t;
        })();
      }
      var name18 = "AssignmentNode";
      var dependencies19 = [
        "subset",
        "?matrix",
        // FIXME: should not be needed at all, should be handled by subset
        "Node"
      ];
      var createAssignmentNode = exports.createAssignmentNode = /* @__PURE__ */ (0, _factory.factory)(name18, dependencies19, function(_ref) {
        var subset = _ref.subset, matrix2 = _ref.matrix, Node = _ref.Node;
        var access = (0, _access.accessFactory)({
          subset
        });
        var assign = (0, _assign.assignFactory)({
          subset,
          matrix: matrix2
        });
        function needParenthesis(node, parenthesis, implicit) {
          if (!parenthesis) {
            parenthesis = "keep";
          }
          var precedence = (0, _operators.getPrecedence)(node, parenthesis, implicit);
          var exprPrecedence = (0, _operators.getPrecedence)(node.value, parenthesis, implicit);
          return parenthesis === "all" || exprPrecedence !== null && exprPrecedence <= precedence;
        }
        var AssignmentNode = /* @__PURE__ */ (function(_Node) {
          function AssignmentNode2(object, index, value) {
            var _this;
            (0, _classCallCheck2["default"])(this, AssignmentNode2);
            _this = _callSuper(this, AssignmentNode2);
            _this.object = object;
            _this.index = value ? index : null;
            _this.value = value || index;
            if (!(0, _is.isSymbolNode)(object) && !(0, _is.isAccessorNode)(object)) {
              throw new TypeError('SymbolNode or AccessorNode expected as "object"');
            }
            if ((0, _is.isSymbolNode)(object) && object.name === "end") {
              throw new Error('Cannot assign to symbol "end"');
            }
            if (_this.index && !(0, _is.isIndexNode)(_this.index)) {
              throw new TypeError('IndexNode expected as "index"');
            }
            if (!(0, _is.isNode)(_this.value)) {
              throw new TypeError('Node expected as "value"');
            }
            return _this;
          }
          (0, _inherits2["default"])(AssignmentNode2, _Node);
          return (0, _createClass2["default"])(AssignmentNode2, [{
            key: "name",
            get: (
              // readonly property name
              function get() {
                if (this.index) {
                  return this.index.isObjectProperty() ? this.index.getObjectProperty() : "";
                } else {
                  return this.object.name || "";
                }
              }
            )
          }, {
            key: "type",
            get: function get() {
              return name18;
            }
          }, {
            key: "isAssignmentNode",
            get: function get() {
              return true;
            }
            /**
             * Compile a node into a JavaScript function.
             * This basically pre-calculates as much as possible and only leaves open
             * calculations which depend on a dynamic scope with variables.
             * @param {Object} math     Math.js namespace with functions and constants.
             * @param {Object} argNames An object with argument names as key and `true`
             *                          as value. Used in the SymbolNode to optimize
             *                          for arguments from user assigned functions
             *                          (see FunctionAssignmentNode) or special symbols
             *                          like `end` (see IndexNode).
             * @return {function} Returns a function which can be called like:
             *                        evalNode(scope: Object, args: Object, context: *)
             */
          }, {
            key: "_compile",
            value: function _compile(math, argNames) {
              var evalObject = this.object._compile(math, argNames);
              var evalIndex = this.index ? this.index._compile(math, argNames) : null;
              var evalValue = this.value._compile(math, argNames);
              var name19 = this.object.name;
              if (!this.index) {
                if (!(0, _is.isSymbolNode)(this.object)) {
                  throw new TypeError("SymbolNode expected as object");
                }
                return function evalAssignmentNode(scope, args, context) {
                  var value = evalValue(scope, args, context);
                  scope.set(name19, value);
                  return value;
                };
              } else if (this.index.isObjectProperty()) {
                var prop = this.index.getObjectProperty();
                return function evalAssignmentNode(scope, args, context) {
                  var object = evalObject(scope, args, context);
                  var value = evalValue(scope, args, context);
                  (0, _customs.setSafeProperty)(object, prop, value);
                  return value;
                };
              } else if ((0, _is.isSymbolNode)(this.object)) {
                return function evalAssignmentNode(scope, args, context) {
                  var childObject = evalObject(scope, args, context);
                  var value = evalValue(scope, args, context);
                  var index = evalIndex(scope, args, childObject);
                  scope.set(name19, assign(childObject, index, value));
                  return value;
                };
              } else {
                var evalParentObject = this.object.object._compile(math, argNames);
                if (this.object.index.isObjectProperty()) {
                  var parentProp = this.object.index.getObjectProperty();
                  return function evalAssignmentNode(scope, args, context) {
                    var parent = evalParentObject(scope, args, context);
                    var childObject = (0, _customs.getSafeProperty)(parent, parentProp);
                    var index = evalIndex(scope, args, childObject);
                    var value = evalValue(scope, args, context);
                    (0, _customs.setSafeProperty)(parent, parentProp, assign(childObject, index, value));
                    return value;
                  };
                } else {
                  var evalParentIndex = this.object.index._compile(math, argNames);
                  return function evalAssignmentNode(scope, args, context) {
                    var parent = evalParentObject(scope, args, context);
                    var parentIndex = evalParentIndex(scope, args, parent);
                    var childObject = access(parent, parentIndex);
                    var index = evalIndex(scope, args, childObject);
                    var value = evalValue(scope, args, context);
                    assign(parent, parentIndex, assign(childObject, index, value));
                    return value;
                  };
                }
              }
            }
            /**
             * Execute a callback for each of the child nodes of this node
             * @param {function(child: Node, path: string, parent: Node)} callback
             */
          }, {
            key: "forEach",
            value: function forEach(callback) {
              callback(this.object, "object", this);
              if (this.index) {
                callback(this.index, "index", this);
              }
              callback(this.value, "value", this);
            }
            /**
             * Create a new AssignmentNode whose children are the results of calling
             * the provided callback function for each child of the original node.
             * @param {function(child: Node, path: string, parent: Node): Node} callback
             * @returns {AssignmentNode} Returns a transformed copy of the node
             */
          }, {
            key: "map",
            value: function map(callback) {
              var object = this._ifNode(callback(this.object, "object", this));
              var index = this.index ? this._ifNode(callback(this.index, "index", this)) : null;
              var value = this._ifNode(callback(this.value, "value", this));
              return new AssignmentNode2(object, index, value);
            }
            /**
             * Create a clone of this node, a shallow copy
             * @return {AssignmentNode}
             */
          }, {
            key: "clone",
            value: function clone4() {
              return new AssignmentNode2(this.object, this.index, this.value);
            }
            /**
             * Get string representation
             * @param {Object} options
             * @return {string}
             */
          }, {
            key: "_toString",
            value: function _toString(options) {
              var object = this.object.toString(options);
              var index = this.index ? this.index.toString(options) : "";
              var value = this.value.toString(options);
              if (needParenthesis(this, options && options.parenthesis, options && options.implicit)) {
                value = "(" + value + ")";
              }
              return object + index + " = " + value;
            }
            /**
             * Get a JSON representation of the node
             * @returns {Object}
             */
          }, {
            key: "toJSON",
            value: function toJSON() {
              return {
                mathjs: name18,
                object: this.object,
                index: this.index,
                value: this.value
              };
            }
            /**
             * Instantiate an AssignmentNode from its JSON representation
             * @param {Object} json
             *     An object structured like
             *     `{"mathjs": "AssignmentNode", object: ..., index: ..., value: ...}`,
             *     where mathjs is optional
             * @returns {AssignmentNode}
             */
          }, {
            key: "_toHTML",
            value: (
              /**
               * Get HTML representation
               * @param {Object} options
               * @return {string}
               */
              function _toHTML(options) {
                var object = this.object.toHTML(options);
                var index = this.index ? this.index.toHTML(options) : "";
                var value = this.value.toHTML(options);
                if (needParenthesis(this, options && options.parenthesis, options && options.implicit)) {
                  value = '<span class="math-paranthesis math-round-parenthesis">(</span>' + value + '<span class="math-paranthesis math-round-parenthesis">)</span>';
                }
                return object + index + '<span class="math-operator math-assignment-operator math-variable-assignment-operator math-binary-operator">=</span>' + value;
              }
            )
            /**
             * Get LaTeX representation
             * @param {Object} options
             * @return {string}
             */
          }, {
            key: "_toTex",
            value: function _toTex(options) {
              var object = this.object.toTex(options);
              var index = this.index ? this.index.toTex(options) : "";
              var value = this.value.toTex(options);
              if (needParenthesis(this, options && options.parenthesis, options && options.implicit)) {
                value = "\\left(".concat(value, "\\right)");
              }
              return object + index + "=" + value;
            }
          }], [{
            key: "fromJSON",
            value: function fromJSON(json) {
              return new AssignmentNode2(json.object, json.index, json.value);
            }
          }]);
        })(Node);
        (0, _defineProperty2["default"])(AssignmentNode, "name", name18);
        return AssignmentNode;
      }, {
        isClass: true,
        isNode: true
      });
    }
  });

  // node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/expression/node/BlockNode.js
  var require_BlockNode = __commonJS({
    "node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/expression/node/BlockNode.js"(exports) {
      "use strict";
      var _interopRequireDefault = require_interopRequireDefault();
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.createBlockNode = void 0;
      var _classCallCheck2 = _interopRequireDefault(require_classCallCheck());
      var _createClass2 = _interopRequireDefault(require_createClass());
      var _possibleConstructorReturn2 = _interopRequireDefault(require_possibleConstructorReturn());
      var _getPrototypeOf2 = _interopRequireDefault(require_getPrototypeOf());
      var _inherits2 = _interopRequireDefault(require_inherits());
      var _defineProperty2 = _interopRequireDefault(require_defineProperty());
      var _is = require_is();
      var _array = require_array();
      var _factory = require_factory();
      function _callSuper(t, o, e) {
        return o = (0, _getPrototypeOf2["default"])(o), (0, _possibleConstructorReturn2["default"])(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], (0, _getPrototypeOf2["default"])(t).constructor) : o.apply(t, e));
      }
      function _isNativeReflectConstruct() {
        try {
          var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
          }));
        } catch (t2) {
        }
        return (_isNativeReflectConstruct = function _isNativeReflectConstruct2() {
          return !!t;
        })();
      }
      var name18 = "BlockNode";
      var dependencies19 = ["ResultSet", "Node"];
      var createBlockNode = exports.createBlockNode = /* @__PURE__ */ (0, _factory.factory)(name18, dependencies19, function(_ref) {
        var ResultSet = _ref.ResultSet, Node = _ref.Node;
        var BlockNode = /* @__PURE__ */ (function(_Node) {
          function BlockNode2(blocks) {
            var _this;
            (0, _classCallCheck2["default"])(this, BlockNode2);
            _this = _callSuper(this, BlockNode2);
            if (!Array.isArray(blocks)) throw new Error("Array expected");
            _this.blocks = blocks.map(function(block) {
              var node = block && block.node;
              var visible = block && block.visible !== void 0 ? block.visible : true;
              if (!(0, _is.isNode)(node)) throw new TypeError('Property "node" must be a Node');
              if (typeof visible !== "boolean") {
                throw new TypeError('Property "visible" must be a boolean');
              }
              return {
                node,
                visible
              };
            });
            return _this;
          }
          (0, _inherits2["default"])(BlockNode2, _Node);
          return (0, _createClass2["default"])(BlockNode2, [{
            key: "type",
            get: function get() {
              return name18;
            }
          }, {
            key: "isBlockNode",
            get: function get() {
              return true;
            }
            /**
             * Compile a node into a JavaScript function.
             * This basically pre-calculates as much as possible and only leaves open
             * calculations which depend on a dynamic scope with variables.
             * @param {Object} math     Math.js namespace with functions and constants.
             * @param {Object} argNames An object with argument names as key and `true`
             *                          as value. Used in the SymbolNode to optimize
             *                          for arguments from user assigned functions
             *                          (see FunctionAssignmentNode) or special symbols
             *                          like `end` (see IndexNode).
             * @return {function} Returns a function which can be called like:
             *                        evalNode(scope: Object, args: Object, context: *)
             */
          }, {
            key: "_compile",
            value: function _compile(math, argNames) {
              var evalBlocks = (0, _array.map)(this.blocks, function(block) {
                return {
                  evaluate: block.node._compile(math, argNames),
                  visible: block.visible
                };
              });
              return function evalBlockNodes(scope, args, context) {
                var results = [];
                (0, _array.forEach)(evalBlocks, function evalBlockNode(block) {
                  var result = block.evaluate(scope, args, context);
                  if (block.visible) {
                    results.push(result);
                  }
                });
                return new ResultSet(results);
              };
            }
            /**
             * Execute a callback for each of the child blocks of this node
             * @param {function(child: Node, path: string, parent: Node)} callback
             */
          }, {
            key: "forEach",
            value: function forEach(callback) {
              for (var i = 0; i < this.blocks.length; i++) {
                callback(this.blocks[i].node, "blocks[" + i + "].node", this);
              }
            }
            /**
             * Create a new BlockNode whose children are the results of calling
             * the provided callback function for each child of the original node.
             * @param {function(child: Node, path: string, parent: Node): Node} callback
             * @returns {BlockNode} Returns a transformed copy of the node
             */
          }, {
            key: "map",
            value: function map(callback) {
              var blocks = [];
              for (var i = 0; i < this.blocks.length; i++) {
                var block = this.blocks[i];
                var node = this._ifNode(callback(block.node, "blocks[" + i + "].node", this));
                blocks[i] = {
                  node,
                  visible: block.visible
                };
              }
              return new BlockNode2(blocks);
            }
            /**
             * Create a clone of this node, a shallow copy
             * @return {BlockNode}
             */
          }, {
            key: "clone",
            value: function clone4() {
              var blocks = this.blocks.map(function(block) {
                return {
                  node: block.node,
                  visible: block.visible
                };
              });
              return new BlockNode2(blocks);
            }
            /**
             * Get string representation
             * @param {Object} options
             * @return {string} str
             * @override
             */
          }, {
            key: "_toString",
            value: function _toString(options) {
              return this.blocks.map(function(param) {
                return param.node.toString(options) + (param.visible ? "" : ";");
              }).join("\n");
            }
            /**
             * Get a JSON representation of the node
             * @returns {Object}
             */
          }, {
            key: "toJSON",
            value: function toJSON() {
              return {
                mathjs: name18,
                blocks: this.blocks
              };
            }
            /**
             * Instantiate an BlockNode from its JSON representation
             * @param {Object} json
             *     An object structured like
             *     `{"mathjs": "BlockNode", blocks: [{node: ..., visible: false}, ...]}`,
             *     where mathjs is optional
             * @returns {BlockNode}
             */
          }, {
            key: "_toHTML",
            value: (
              /**
               * Get HTML representation
               * @param {Object} options
               * @return {string} str
               * @override
               */
              function _toHTML(options) {
                return this.blocks.map(function(param) {
                  return param.node.toHTML(options) + (param.visible ? "" : '<span class="math-separator">;</span>');
                }).join('<span class="math-separator"><br /></span>');
              }
            )
            /**
             * Get LaTeX representation
             * @param {Object} options
             * @return {string} str
             */
          }, {
            key: "_toTex",
            value: function _toTex(options) {
              return this.blocks.map(function(param) {
                return param.node.toTex(options) + (param.visible ? "" : ";");
              }).join("\\;\\;\n");
            }
          }], [{
            key: "fromJSON",
            value: function fromJSON(json) {
              return new BlockNode2(json.blocks);
            }
          }]);
        })(Node);
        (0, _defineProperty2["default"])(BlockNode, "name", name18);
        return BlockNode;
      }, {
        isClass: true,
        isNode: true
      });
    }
  });

  // node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/expression/node/ConditionalNode.js
  var require_ConditionalNode = __commonJS({
    "node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/expression/node/ConditionalNode.js"(exports) {
      "use strict";
      var _interopRequireDefault = require_interopRequireDefault();
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.createConditionalNode = void 0;
      var _classCallCheck2 = _interopRequireDefault(require_classCallCheck());
      var _createClass2 = _interopRequireDefault(require_createClass());
      var _possibleConstructorReturn2 = _interopRequireDefault(require_possibleConstructorReturn());
      var _getPrototypeOf2 = _interopRequireDefault(require_getPrototypeOf());
      var _inherits2 = _interopRequireDefault(require_inherits());
      var _defineProperty2 = _interopRequireDefault(require_defineProperty());
      var _is = require_is();
      var _factory = require_factory();
      var _operators = require_operators();
      function _callSuper(t, o, e) {
        return o = (0, _getPrototypeOf2["default"])(o), (0, _possibleConstructorReturn2["default"])(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], (0, _getPrototypeOf2["default"])(t).constructor) : o.apply(t, e));
      }
      function _isNativeReflectConstruct() {
        try {
          var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
          }));
        } catch (t2) {
        }
        return (_isNativeReflectConstruct = function _isNativeReflectConstruct2() {
          return !!t;
        })();
      }
      var name18 = "ConditionalNode";
      var dependencies19 = ["Node"];
      var createConditionalNode = exports.createConditionalNode = /* @__PURE__ */ (0, _factory.factory)(name18, dependencies19, function(_ref) {
        var Node = _ref.Node;
        function testCondition(condition) {
          if (typeof condition === "number" || typeof condition === "boolean" || typeof condition === "string") {
            return !!condition;
          }
          if (condition) {
            if ((0, _is.isBigNumber)(condition)) {
              return !condition.isZero();
            }
            if ((0, _is.isComplex)(condition)) {
              return !!(condition.re || condition.im);
            }
            if ((0, _is.isUnit)(condition)) {
              return !!condition.value;
            }
          }
          if (condition === null || condition === void 0) {
            return false;
          }
          throw new TypeError('Unsupported type of condition "' + (0, _is.typeOf)(condition) + '"');
        }
        var ConditionalNode = /* @__PURE__ */ (function(_Node) {
          function ConditionalNode2(condition, trueExpr, falseExpr) {
            var _this;
            (0, _classCallCheck2["default"])(this, ConditionalNode2);
            _this = _callSuper(this, ConditionalNode2);
            if (!(0, _is.isNode)(condition)) {
              throw new TypeError("Parameter condition must be a Node");
            }
            if (!(0, _is.isNode)(trueExpr)) {
              throw new TypeError("Parameter trueExpr must be a Node");
            }
            if (!(0, _is.isNode)(falseExpr)) {
              throw new TypeError("Parameter falseExpr must be a Node");
            }
            _this.condition = condition;
            _this.trueExpr = trueExpr;
            _this.falseExpr = falseExpr;
            return _this;
          }
          (0, _inherits2["default"])(ConditionalNode2, _Node);
          return (0, _createClass2["default"])(ConditionalNode2, [{
            key: "type",
            get: function get() {
              return name18;
            }
          }, {
            key: "isConditionalNode",
            get: function get() {
              return true;
            }
            /**
             * Compile a node into a JavaScript function.
             * This basically pre-calculates as much as possible and only leaves open
             * calculations which depend on a dynamic scope with variables.
             * @param {Object} math     Math.js namespace with functions and constants.
             * @param {Object} argNames An object with argument names as key and `true`
             *                          as value. Used in the SymbolNode to optimize
             *                          for arguments from user assigned functions
             *                          (see FunctionAssignmentNode) or special symbols
             *                          like `end` (see IndexNode).
             * @return {function} Returns a function which can be called like:
             *                        evalNode(scope: Object, args: Object, context: *)
             */
          }, {
            key: "_compile",
            value: function _compile(math, argNames) {
              var evalCondition = this.condition._compile(math, argNames);
              var evalTrueExpr = this.trueExpr._compile(math, argNames);
              var evalFalseExpr = this.falseExpr._compile(math, argNames);
              return function evalConditionalNode(scope, args, context) {
                return testCondition(evalCondition(scope, args, context)) ? evalTrueExpr(scope, args, context) : evalFalseExpr(scope, args, context);
              };
            }
            /**
             * Execute a callback for each of the child nodes of this node
             * @param {function(child: Node, path: string, parent: Node)} callback
             */
          }, {
            key: "forEach",
            value: function forEach(callback) {
              callback(this.condition, "condition", this);
              callback(this.trueExpr, "trueExpr", this);
              callback(this.falseExpr, "falseExpr", this);
            }
            /**
             * Create a new ConditionalNode whose children are the results of calling
             * the provided callback function for each child of the original node.
             * @param {function(child: Node, path: string, parent: Node): Node} callback
             * @returns {ConditionalNode} Returns a transformed copy of the node
             */
          }, {
            key: "map",
            value: function map(callback) {
              return new ConditionalNode2(this._ifNode(callback(this.condition, "condition", this)), this._ifNode(callback(this.trueExpr, "trueExpr", this)), this._ifNode(callback(this.falseExpr, "falseExpr", this)));
            }
            /**
             * Create a clone of this node, a shallow copy
             * @return {ConditionalNode}
             */
          }, {
            key: "clone",
            value: function clone4() {
              return new ConditionalNode2(this.condition, this.trueExpr, this.falseExpr);
            }
            /**
             * Get string representation
             * @param {Object} options
             * @return {string} str
             */
          }, {
            key: "_toString",
            value: function _toString(options) {
              var parenthesis = options && options.parenthesis ? options.parenthesis : "keep";
              var precedence = (0, _operators.getPrecedence)(this, parenthesis, options && options.implicit);
              var condition = this.condition.toString(options);
              var conditionPrecedence = (0, _operators.getPrecedence)(this.condition, parenthesis, options && options.implicit);
              if (parenthesis === "all" || this.condition.type === "OperatorNode" || conditionPrecedence !== null && conditionPrecedence <= precedence) {
                condition = "(" + condition + ")";
              }
              var trueExpr = this.trueExpr.toString(options);
              var truePrecedence = (0, _operators.getPrecedence)(this.trueExpr, parenthesis, options && options.implicit);
              if (parenthesis === "all" || this.trueExpr.type === "OperatorNode" || truePrecedence !== null && truePrecedence <= precedence) {
                trueExpr = "(" + trueExpr + ")";
              }
              var falseExpr = this.falseExpr.toString(options);
              var falsePrecedence = (0, _operators.getPrecedence)(this.falseExpr, parenthesis, options && options.implicit);
              if (parenthesis === "all" || this.falseExpr.type === "OperatorNode" || falsePrecedence !== null && falsePrecedence <= precedence) {
                falseExpr = "(" + falseExpr + ")";
              }
              return condition + " ? " + trueExpr + " : " + falseExpr;
            }
            /**
             * Get a JSON representation of the node
             * @returns {Object}
             */
          }, {
            key: "toJSON",
            value: function toJSON() {
              return {
                mathjs: name18,
                condition: this.condition,
                trueExpr: this.trueExpr,
                falseExpr: this.falseExpr
              };
            }
            /**
             * Instantiate an ConditionalNode from its JSON representation
             * @param {Object} json
             *     An object structured like
             *     ```
             *     {"mathjs": "ConditionalNode",
             *      "condition": ...,
             *      "trueExpr": ...,
             *      "falseExpr": ...}
             *     ```
             *     where mathjs is optional
             * @returns {ConditionalNode}
             */
          }, {
            key: "_toHTML",
            value: (
              /**
               * Get HTML representation
               * @param {Object} options
               * @return {string} str
               */
              function _toHTML(options) {
                var parenthesis = options && options.parenthesis ? options.parenthesis : "keep";
                var precedence = (0, _operators.getPrecedence)(this, parenthesis, options && options.implicit);
                var condition = this.condition.toHTML(options);
                var conditionPrecedence = (0, _operators.getPrecedence)(this.condition, parenthesis, options && options.implicit);
                if (parenthesis === "all" || this.condition.type === "OperatorNode" || conditionPrecedence !== null && conditionPrecedence <= precedence) {
                  condition = '<span class="math-parenthesis math-round-parenthesis">(</span>' + condition + '<span class="math-parenthesis math-round-parenthesis">)</span>';
                }
                var trueExpr = this.trueExpr.toHTML(options);
                var truePrecedence = (0, _operators.getPrecedence)(this.trueExpr, parenthesis, options && options.implicit);
                if (parenthesis === "all" || this.trueExpr.type === "OperatorNode" || truePrecedence !== null && truePrecedence <= precedence) {
                  trueExpr = '<span class="math-parenthesis math-round-parenthesis">(</span>' + trueExpr + '<span class="math-parenthesis math-round-parenthesis">)</span>';
                }
                var falseExpr = this.falseExpr.toHTML(options);
                var falsePrecedence = (0, _operators.getPrecedence)(this.falseExpr, parenthesis, options && options.implicit);
                if (parenthesis === "all" || this.falseExpr.type === "OperatorNode" || falsePrecedence !== null && falsePrecedence <= precedence) {
                  falseExpr = '<span class="math-parenthesis math-round-parenthesis">(</span>' + falseExpr + '<span class="math-parenthesis math-round-parenthesis">)</span>';
                }
                return condition + '<span class="math-operator math-conditional-operator">?</span>' + trueExpr + '<span class="math-operator math-conditional-operator">:</span>' + falseExpr;
              }
            )
            /**
             * Get LaTeX representation
             * @param {Object} options
             * @return {string} str
             */
          }, {
            key: "_toTex",
            value: function _toTex(options) {
              return "\\begin{cases} {" + this.trueExpr.toTex(options) + "}, &\\quad{\\text{if }\\;" + this.condition.toTex(options) + "}\\\\{" + this.falseExpr.toTex(options) + "}, &\\quad{\\text{otherwise}}\\end{cases}";
            }
          }], [{
            key: "fromJSON",
            value: function fromJSON(json) {
              return new ConditionalNode2(json.condition, json.trueExpr, json.falseExpr);
            }
          }]);
        })(Node);
        (0, _defineProperty2["default"])(ConditionalNode, "name", name18);
        return ConditionalNode;
      }, {
        isClass: true,
        isNode: true
      });
    }
  });

  // node_modules/.pnpm/escape-latex@1.2.0/node_modules/escape-latex/dist/index.js
  var require_dist = __commonJS({
    "node_modules/.pnpm/escape-latex@1.2.0/node_modules/escape-latex/dist/index.js"(exports, module) {
      "use strict";
      var _extends2 = Object.assign || function(target) {
        for (var i = 1; i < arguments.length; i++) {
          var source = arguments[i];
          for (var key in source) {
            if (Object.prototype.hasOwnProperty.call(source, key)) {
              target[key] = source[key];
            }
          }
        }
        return target;
      };
      var defaultEscapes = {
        "{": "\\{",
        "}": "\\}",
        "\\": "\\textbackslash{}",
        "#": "\\#",
        $: "\\$",
        "%": "\\%",
        "&": "\\&",
        "^": "\\textasciicircum{}",
        _: "\\_",
        "~": "\\textasciitilde{}"
      };
      var formatEscapes = {
        "\u2013": "\\--",
        "\u2014": "\\---",
        " ": "~",
        "	": "\\qquad{}",
        "\r\n": "\\newline{}",
        "\n": "\\newline{}"
      };
      var defaultEscapeMapFn = function defaultEscapeMapFn2(defaultEscapes2, formatEscapes2) {
        return _extends2({}, defaultEscapes2, formatEscapes2);
      };
      module.exports = function(str) {
        var _ref = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, _ref$preserveFormatti = _ref.preserveFormatting, preserveFormatting = _ref$preserveFormatti === void 0 ? false : _ref$preserveFormatti, _ref$escapeMapFn = _ref.escapeMapFn, escapeMapFn = _ref$escapeMapFn === void 0 ? defaultEscapeMapFn : _ref$escapeMapFn;
        var runningStr = String(str);
        var result = "";
        var escapes = escapeMapFn(_extends2({}, defaultEscapes), preserveFormatting ? _extends2({}, formatEscapes) : {});
        var escapeKeys = Object.keys(escapes);
        var _loop = function _loop2() {
          var specialCharFound = false;
          escapeKeys.forEach(function(key, index) {
            if (specialCharFound) {
              return;
            }
            if (runningStr.length >= key.length && runningStr.slice(0, key.length) === key) {
              result += escapes[escapeKeys[index]];
              runningStr = runningStr.slice(key.length, runningStr.length);
              specialCharFound = true;
            }
          });
          if (!specialCharFound) {
            result += runningStr.slice(0, 1);
            runningStr = runningStr.slice(1, runningStr.length);
          }
        };
        while (runningStr) {
          _loop();
        }
        return result;
      };
    }
  });

  // node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/utils/latex.js
  var require_latex = __commonJS({
    "node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/utils/latex.js"(exports) {
      "use strict";
      var _interopRequireDefault = require_interopRequireDefault();
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.defaultTemplate = void 0;
      exports.escapeLatex = escapeLatex;
      exports.latexSymbols = exports.latexOperators = exports.latexFunctions = void 0;
      exports.toSymbol = toSymbol;
      var _escapeLatex = _interopRequireDefault(require_dist());
      var _object = require_object();
      var latexSymbols = exports.latexSymbols = {
        // GREEK LETTERS
        Alpha: "A",
        alpha: "\\alpha",
        Beta: "B",
        beta: "\\beta",
        Gamma: "\\Gamma",
        gamma: "\\gamma",
        Delta: "\\Delta",
        delta: "\\delta",
        Epsilon: "E",
        epsilon: "\\epsilon",
        varepsilon: "\\varepsilon",
        Zeta: "Z",
        zeta: "\\zeta",
        Eta: "H",
        eta: "\\eta",
        Theta: "\\Theta",
        theta: "\\theta",
        vartheta: "\\vartheta",
        Iota: "I",
        iota: "\\iota",
        Kappa: "K",
        kappa: "\\kappa",
        varkappa: "\\varkappa",
        Lambda: "\\Lambda",
        lambda: "\\lambda",
        Mu: "M",
        mu: "\\mu",
        Nu: "N",
        nu: "\\nu",
        Xi: "\\Xi",
        xi: "\\xi",
        Omicron: "O",
        omicron: "o",
        Pi: "\\Pi",
        pi: "\\pi",
        varpi: "\\varpi",
        Rho: "P",
        rho: "\\rho",
        varrho: "\\varrho",
        Sigma: "\\Sigma",
        sigma: "\\sigma",
        varsigma: "\\varsigma",
        Tau: "T",
        tau: "\\tau",
        Upsilon: "\\Upsilon",
        upsilon: "\\upsilon",
        Phi: "\\Phi",
        phi: "\\phi",
        varphi: "\\varphi",
        Chi: "X",
        chi: "\\chi",
        Psi: "\\Psi",
        psi: "\\psi",
        Omega: "\\Omega",
        omega: "\\omega",
        // logic
        "true": "\\mathrm{True}",
        "false": "\\mathrm{False}",
        // other
        i: "i",
        // TODO use \i ??
        inf: "\\infty",
        Inf: "\\infty",
        infinity: "\\infty",
        Infinity: "\\infty",
        oo: "\\infty",
        lim: "\\lim",
        undefined: "\\mathbf{?}"
      };
      var latexOperators = exports.latexOperators = {
        transpose: "^\\top",
        ctranspose: "^H",
        factorial: "!",
        pow: "^",
        dotPow: ".^\\wedge",
        // TODO find ideal solution
        unaryPlus: "+",
        unaryMinus: "-",
        bitNot: "\\~",
        // TODO find ideal solution
        not: "\\neg",
        multiply: "\\cdot",
        divide: "\\frac",
        // TODO how to handle that properly?
        dotMultiply: ".\\cdot",
        // TODO find ideal solution
        dotDivide: ".:",
        // TODO find ideal solution
        mod: "\\mod",
        add: "+",
        subtract: "-",
        to: "\\rightarrow",
        leftShift: "<<",
        rightArithShift: ">>",
        rightLogShift: ">>>",
        equal: "=",
        unequal: "\\neq",
        smaller: "<",
        larger: ">",
        smallerEq: "\\leq",
        largerEq: "\\geq",
        bitAnd: "\\&",
        bitXor: "\\underline{|}",
        bitOr: "|",
        and: "\\wedge",
        xor: "\\veebar",
        or: "\\vee"
      };
      var latexFunctions = exports.latexFunctions = {
        // arithmetic
        abs: {
          1: "\\left|${args[0]}\\right|"
        },
        add: {
          2: "\\left(${args[0]}".concat(latexOperators.add, "${args[1]}\\right)")
        },
        cbrt: {
          1: "\\sqrt[3]{${args[0]}}"
        },
        ceil: {
          1: "\\left\\lceil${args[0]}\\right\\rceil"
        },
        cube: {
          1: "\\left(${args[0]}\\right)^3"
        },
        divide: {
          2: "\\frac{${args[0]}}{${args[1]}}"
        },
        dotDivide: {
          2: "\\left(${args[0]}".concat(latexOperators.dotDivide, "${args[1]}\\right)")
        },
        dotMultiply: {
          2: "\\left(${args[0]}".concat(latexOperators.dotMultiply, "${args[1]}\\right)")
        },
        dotPow: {
          2: "\\left(${args[0]}".concat(latexOperators.dotPow, "${args[1]}\\right)")
        },
        exp: {
          1: "\\exp\\left(${args[0]}\\right)"
        },
        expm1: "\\left(e".concat(latexOperators.pow, "{${args[0]}}-1\\right)"),
        fix: {
          1: "\\mathrm{${name}}\\left(${args[0]}\\right)"
        },
        floor: {
          1: "\\left\\lfloor${args[0]}\\right\\rfloor"
        },
        gcd: "\\gcd\\left(${args}\\right)",
        hypot: "\\hypot\\left(${args}\\right)",
        log: {
          1: "\\ln\\left(${args[0]}\\right)",
          2: "\\log_{${args[1]}}\\left(${args[0]}\\right)"
        },
        log10: {
          1: "\\log_{10}\\left(${args[0]}\\right)"
        },
        log1p: {
          1: "\\ln\\left(${args[0]}+1\\right)",
          2: "\\log_{${args[1]}}\\left(${args[0]}+1\\right)"
        },
        log2: "\\log_{2}\\left(${args[0]}\\right)",
        mod: {
          2: "\\left(${args[0]}".concat(latexOperators.mod, "${args[1]}\\right)")
        },
        multiply: {
          2: "\\left(${args[0]}".concat(latexOperators.multiply, "${args[1]}\\right)")
        },
        norm: {
          1: "\\left\\|${args[0]}\\right\\|",
          2: void 0
          // use default template
        },
        nthRoot: {
          2: "\\sqrt[${args[1]}]{${args[0]}}"
        },
        nthRoots: {
          2: "\\{y : $y^{args[1]} = {${args[0]}}\\}"
        },
        pow: {
          2: "\\left(${args[0]}\\right)".concat(latexOperators.pow, "{${args[1]}}")
        },
        round: {
          1: "\\left\\lfloor${args[0]}\\right\\rceil",
          2: void 0
          // use default template
        },
        sign: {
          1: "\\mathrm{${name}}\\left(${args[0]}\\right)"
        },
        sqrt: {
          1: "\\sqrt{${args[0]}}"
        },
        square: {
          1: "\\left(${args[0]}\\right)^2"
        },
        subtract: {
          2: "\\left(${args[0]}".concat(latexOperators.subtract, "${args[1]}\\right)")
        },
        unaryMinus: {
          1: "".concat(latexOperators.unaryMinus, "\\left(${args[0]}\\right)")
        },
        unaryPlus: {
          1: "".concat(latexOperators.unaryPlus, "\\left(${args[0]}\\right)")
        },
        // bitwise
        bitAnd: {
          2: "\\left(${args[0]}".concat(latexOperators.bitAnd, "${args[1]}\\right)")
        },
        bitNot: {
          1: latexOperators.bitNot + "\\left(${args[0]}\\right)"
        },
        bitOr: {
          2: "\\left(${args[0]}".concat(latexOperators.bitOr, "${args[1]}\\right)")
        },
        bitXor: {
          2: "\\left(${args[0]}".concat(latexOperators.bitXor, "${args[1]}\\right)")
        },
        leftShift: {
          2: "\\left(${args[0]}".concat(latexOperators.leftShift, "${args[1]}\\right)")
        },
        rightArithShift: {
          2: "\\left(${args[0]}".concat(latexOperators.rightArithShift, "${args[1]}\\right)")
        },
        rightLogShift: {
          2: "\\left(${args[0]}".concat(latexOperators.rightLogShift, "${args[1]}\\right)")
        },
        // combinatorics
        bellNumbers: {
          1: "\\mathrm{B}_{${args[0]}}"
        },
        catalan: {
          1: "\\mathrm{C}_{${args[0]}}"
        },
        stirlingS2: {
          2: "\\mathrm{S}\\left(${args}\\right)"
        },
        // complex
        arg: {
          1: "\\arg\\left(${args[0]}\\right)"
        },
        conj: {
          1: "\\left(${args[0]}\\right)^*"
        },
        im: {
          1: "\\Im\\left\\lbrace${args[0]}\\right\\rbrace"
        },
        re: {
          1: "\\Re\\left\\lbrace${args[0]}\\right\\rbrace"
        },
        // logical
        and: {
          2: "\\left(${args[0]}".concat(latexOperators.and, "${args[1]}\\right)")
        },
        not: {
          1: latexOperators.not + "\\left(${args[0]}\\right)"
        },
        or: {
          2: "\\left(${args[0]}".concat(latexOperators.or, "${args[1]}\\right)")
        },
        xor: {
          2: "\\left(${args[0]}".concat(latexOperators.xor, "${args[1]}\\right)")
        },
        // matrix
        cross: {
          2: "\\left(${args[0]}\\right)\\times\\left(${args[1]}\\right)"
        },
        ctranspose: {
          1: "\\left(${args[0]}\\right)".concat(latexOperators.ctranspose)
        },
        det: {
          1: "\\det\\left(${args[0]}\\right)"
        },
        dot: {
          2: "\\left(${args[0]}\\cdot${args[1]}\\right)"
        },
        expm: {
          1: "\\exp\\left(${args[0]}\\right)"
        },
        inv: {
          1: "\\left(${args[0]}\\right)^{-1}"
        },
        pinv: {
          1: "\\left(${args[0]}\\right)^{+}"
        },
        sqrtm: {
          1: "{${args[0]}}".concat(latexOperators.pow, "{\\frac{1}{2}}")
        },
        trace: {
          1: "\\mathrm{tr}\\left(${args[0]}\\right)"
        },
        transpose: {
          1: "\\left(${args[0]}\\right)".concat(latexOperators.transpose)
        },
        // probability
        combinations: {
          2: "\\binom{${args[0]}}{${args[1]}}"
        },
        combinationsWithRep: {
          2: "\\left(\\!\\!{\\binom{${args[0]}}{${args[1]}}}\\!\\!\\right)"
        },
        factorial: {
          1: "\\left(${args[0]}\\right)".concat(latexOperators.factorial)
        },
        gamma: {
          1: "\\Gamma\\left(${args[0]}\\right)"
        },
        lgamma: {
          1: "\\ln\\Gamma\\left(${args[0]}\\right)"
        },
        // relational
        equal: {
          2: "\\left(${args[0]}".concat(latexOperators.equal, "${args[1]}\\right)")
        },
        larger: {
          2: "\\left(${args[0]}".concat(latexOperators.larger, "${args[1]}\\right)")
        },
        largerEq: {
          2: "\\left(${args[0]}".concat(latexOperators.largerEq, "${args[1]}\\right)")
        },
        smaller: {
          2: "\\left(${args[0]}".concat(latexOperators.smaller, "${args[1]}\\right)")
        },
        smallerEq: {
          2: "\\left(${args[0]}".concat(latexOperators.smallerEq, "${args[1]}\\right)")
        },
        unequal: {
          2: "\\left(${args[0]}".concat(latexOperators.unequal, "${args[1]}\\right)")
        },
        // special
        erf: {
          1: "erf\\left(${args[0]}\\right)"
        },
        // statistics
        max: "\\max\\left(${args}\\right)",
        min: "\\min\\left(${args}\\right)",
        variance: "\\mathrm{Var}\\left(${args}\\right)",
        // trigonometry
        acos: {
          1: "\\cos^{-1}\\left(${args[0]}\\right)"
        },
        acosh: {
          1: "\\cosh^{-1}\\left(${args[0]}\\right)"
        },
        acot: {
          1: "\\cot^{-1}\\left(${args[0]}\\right)"
        },
        acoth: {
          1: "\\coth^{-1}\\left(${args[0]}\\right)"
        },
        acsc: {
          1: "\\csc^{-1}\\left(${args[0]}\\right)"
        },
        acsch: {
          1: "\\mathrm{csch}^{-1}\\left(${args[0]}\\right)"
        },
        asec: {
          1: "\\sec^{-1}\\left(${args[0]}\\right)"
        },
        asech: {
          1: "\\mathrm{sech}^{-1}\\left(${args[0]}\\right)"
        },
        asin: {
          1: "\\sin^{-1}\\left(${args[0]}\\right)"
        },
        asinh: {
          1: "\\sinh^{-1}\\left(${args[0]}\\right)"
        },
        atan: {
          1: "\\tan^{-1}\\left(${args[0]}\\right)"
        },
        atan2: {
          2: "\\mathrm{atan2}\\left(${args}\\right)"
        },
        atanh: {
          1: "\\tanh^{-1}\\left(${args[0]}\\right)"
        },
        cos: {
          1: "\\cos\\left(${args[0]}\\right)"
        },
        cosh: {
          1: "\\cosh\\left(${args[0]}\\right)"
        },
        cot: {
          1: "\\cot\\left(${args[0]}\\right)"
        },
        coth: {
          1: "\\coth\\left(${args[0]}\\right)"
        },
        csc: {
          1: "\\csc\\left(${args[0]}\\right)"
        },
        csch: {
          1: "\\mathrm{csch}\\left(${args[0]}\\right)"
        },
        sec: {
          1: "\\sec\\left(${args[0]}\\right)"
        },
        sech: {
          1: "\\mathrm{sech}\\left(${args[0]}\\right)"
        },
        sin: {
          1: "\\sin\\left(${args[0]}\\right)"
        },
        sinh: {
          1: "\\sinh\\left(${args[0]}\\right)"
        },
        tan: {
          1: "\\tan\\left(${args[0]}\\right)"
        },
        tanh: {
          1: "\\tanh\\left(${args[0]}\\right)"
        },
        // unit
        to: {
          2: "\\left(${args[0]}".concat(latexOperators.to, "${args[1]}\\right)")
        },
        // utils
        numeric: function numeric(node, options) {
          return node.args[0].toTex();
        },
        // type
        number: {
          0: "0",
          1: "\\left(${args[0]}\\right)",
          2: "\\left(\\left(${args[0]}\\right)${args[1]}\\right)"
        },
        string: {
          0: '\\mathtt{""}',
          1: "\\mathrm{string}\\left(${args[0]}\\right)"
        },
        bignumber: {
          0: "0",
          1: "\\left(${args[0]}\\right)"
        },
        complex: {
          0: "0",
          1: "\\left(${args[0]}\\right)",
          2: "\\left(\\left(${args[0]}\\right)+".concat(latexSymbols.i, "\\cdot\\left(${args[1]}\\right)\\right)")
        },
        matrix: {
          0: "\\begin{bmatrix}\\end{bmatrix}",
          1: "\\left(${args[0]}\\right)",
          2: "\\left(${args[0]}\\right)"
        },
        sparse: {
          0: "\\begin{bsparse}\\end{bsparse}",
          1: "\\left(${args[0]}\\right)"
        },
        unit: {
          1: "\\left(${args[0]}\\right)",
          2: "\\left(\\left(${args[0]}\\right)${args[1]}\\right)"
        }
      };
      var defaultTemplate = exports.defaultTemplate = "\\mathrm{${name}}\\left(${args}\\right)";
      var latexUnits = {
        deg: "^\\circ"
      };
      function escapeLatex(string) {
        return (0, _escapeLatex["default"])(string, {
          preserveFormatting: true
        });
      }
      function toSymbol(name18, isUnit2) {
        isUnit2 = typeof isUnit2 === "undefined" ? false : isUnit2;
        if (isUnit2) {
          if ((0, _object.hasOwnProperty)(latexUnits, name18)) {
            return latexUnits[name18];
          }
          return "\\mathrm{" + escapeLatex(name18) + "}";
        }
        if ((0, _object.hasOwnProperty)(latexSymbols, name18)) {
          return latexSymbols[name18];
        }
        return escapeLatex(name18);
      }
    }
  });

  // node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/expression/node/ConstantNode.js
  var require_ConstantNode = __commonJS({
    "node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/expression/node/ConstantNode.js"(exports) {
      "use strict";
      var _interopRequireDefault = require_interopRequireDefault();
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.createConstantNode = void 0;
      var _classCallCheck2 = _interopRequireDefault(require_classCallCheck());
      var _createClass2 = _interopRequireDefault(require_createClass());
      var _possibleConstructorReturn2 = _interopRequireDefault(require_possibleConstructorReturn());
      var _getPrototypeOf2 = _interopRequireDefault(require_getPrototypeOf());
      var _inherits2 = _interopRequireDefault(require_inherits());
      var _defineProperty2 = _interopRequireDefault(require_defineProperty());
      var _string = require_string();
      var _is = require_is();
      var _latex = require_latex();
      var _factory = require_factory();
      function _callSuper(t, o, e) {
        return o = (0, _getPrototypeOf2["default"])(o), (0, _possibleConstructorReturn2["default"])(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], (0, _getPrototypeOf2["default"])(t).constructor) : o.apply(t, e));
      }
      function _isNativeReflectConstruct() {
        try {
          var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
          }));
        } catch (t2) {
        }
        return (_isNativeReflectConstruct = function _isNativeReflectConstruct2() {
          return !!t;
        })();
      }
      var name18 = "ConstantNode";
      var dependencies19 = ["Node"];
      var createConstantNode = exports.createConstantNode = /* @__PURE__ */ (0, _factory.factory)(name18, dependencies19, function(_ref) {
        var Node = _ref.Node;
        var ConstantNode = /* @__PURE__ */ (function(_Node) {
          function ConstantNode2(value) {
            var _this;
            (0, _classCallCheck2["default"])(this, ConstantNode2);
            _this = _callSuper(this, ConstantNode2);
            _this.value = value;
            return _this;
          }
          (0, _inherits2["default"])(ConstantNode2, _Node);
          return (0, _createClass2["default"])(ConstantNode2, [{
            key: "type",
            get: function get() {
              return name18;
            }
          }, {
            key: "isConstantNode",
            get: function get() {
              return true;
            }
            /**
             * Compile a node into a JavaScript function.
             * This basically pre-calculates as much as possible and only leaves open
             * calculations which depend on a dynamic scope with variables.
             * @param {Object} math     Math.js namespace with functions and constants.
             * @param {Object} argNames An object with argument names as key and `true`
             *                          as value. Used in the SymbolNode to optimize
             *                          for arguments from user assigned functions
             *                          (see FunctionAssignmentNode) or special symbols
             *                          like `end` (see IndexNode).
             * @return {function} Returns a function which can be called like:
             *                        evalNode(scope: Object, args: Object, context: *)
             */
          }, {
            key: "_compile",
            value: function _compile(math, argNames) {
              var value = this.value;
              return function evalConstantNode() {
                return value;
              };
            }
            /**
             * Execute a callback for each of the child nodes of this node
             * @param {function(child: Node, path: string, parent: Node)} callback
             */
          }, {
            key: "forEach",
            value: function forEach(callback) {
            }
            /**
             * Create a new ConstantNode with children produced by the given callback.
             * Trivial because there are no children.
             * @param {function(child: Node, path: string, parent: Node) : Node} callback
             * @returns {ConstantNode} Returns a clone of the node
             */
          }, {
            key: "map",
            value: function map(callback) {
              return this.clone();
            }
            /**
             * Create a clone of this node, a shallow copy
             * @return {ConstantNode}
             */
          }, {
            key: "clone",
            value: function clone4() {
              return new ConstantNode2(this.value);
            }
            /**
             * Get string representation
             * @param {Object} options
             * @return {string} str
             */
          }, {
            key: "_toString",
            value: function _toString(options) {
              return (0, _string.format)(this.value, options);
            }
            /**
             * Get HTML representation
             * @param {Object} options
             * @return {string} str
             */
          }, {
            key: "_toHTML",
            value: function _toHTML(options) {
              var value = this._toString(options);
              switch ((0, _is.typeOf)(this.value)) {
                case "number":
                case "BigNumber":
                case "Fraction":
                  return '<span class="math-number">' + value + "</span>";
                case "string":
                  return '<span class="math-string">' + value + "</span>";
                case "boolean":
                  return '<span class="math-boolean">' + value + "</span>";
                case "null":
                  return '<span class="math-null-symbol">' + value + "</span>";
                case "undefined":
                  return '<span class="math-undefined">' + value + "</span>";
                default:
                  return '<span class="math-symbol">' + value + "</span>";
              }
            }
            /**
             * Get a JSON representation of the node
             * @returns {Object}
             */
          }, {
            key: "toJSON",
            value: function toJSON() {
              return {
                mathjs: name18,
                value: this.value
              };
            }
            /**
             * Instantiate a ConstantNode from its JSON representation
             * @param {Object} json  An object structured like
             *                       `{"mathjs": "SymbolNode", value: 2.3}`,
             *                       where mathjs is optional
             * @returns {ConstantNode}
             */
          }, {
            key: "_toTex",
            value: (
              /**
               * Get LaTeX representation
               * @param {Object} options
               * @return {string} str
               */
              function _toTex(options) {
                var value = this._toString(options);
                var type = (0, _is.typeOf)(this.value);
                switch (type) {
                  case "string":
                    return "\\mathtt{" + (0, _latex.escapeLatex)(value) + "}";
                  case "number":
                  case "BigNumber": {
                    var finite = type === "BigNumber" ? this.value.isFinite() : isFinite(this.value);
                    if (!finite) {
                      return this.value.valueOf() < 0 ? "-\\infty" : "\\infty";
                    }
                    var index = value.toLowerCase().indexOf("e");
                    if (index !== -1) {
                      return value.substring(0, index) + "\\cdot10^{" + value.substring(index + 1) + "}";
                    }
                    return value;
                  }
                  case "Fraction":
                    return this.value.toLatex();
                  default:
                    return value;
                }
              }
            )
          }], [{
            key: "fromJSON",
            value: function fromJSON(json) {
              return new ConstantNode2(json.value);
            }
          }]);
        })(Node);
        (0, _defineProperty2["default"])(ConstantNode, "name", name18);
        return ConstantNode;
      }, {
        isClass: true,
        isNode: true
      });
    }
  });

  // node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/expression/node/FunctionAssignmentNode.js
  var require_FunctionAssignmentNode = __commonJS({
    "node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/expression/node/FunctionAssignmentNode.js"(exports) {
      "use strict";
      var _interopRequireDefault = require_interopRequireDefault();
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.createFunctionAssignmentNode = void 0;
      var _classCallCheck2 = _interopRequireDefault(require_classCallCheck());
      var _createClass2 = _interopRequireDefault(require_createClass());
      var _possibleConstructorReturn2 = _interopRequireDefault(require_possibleConstructorReturn());
      var _getPrototypeOf2 = _interopRequireDefault(require_getPrototypeOf());
      var _inherits2 = _interopRequireDefault(require_inherits());
      var _defineProperty2 = _interopRequireDefault(require_defineProperty());
      var _is = require_is();
      var _keywords = require_keywords();
      var _string = require_string();
      var _array = require_array();
      var _latex = require_latex();
      var _operators = require_operators();
      var _factory = require_factory();
      function _createForOfIteratorHelper(o, allowArrayLike) {
        var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"];
        if (!it) {
          if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") {
            if (it) o = it;
            var i = 0;
            var F = function F2() {
            };
            return { s: F, n: function n() {
              if (i >= o.length) return { done: true };
              return { done: false, value: o[i++] };
            }, e: function e(_e) {
              throw _e;
            }, f: F };
          }
          throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
        }
        var normalCompletion = true, didErr = false, err;
        return { s: function s() {
          it = it.call(o);
        }, n: function n() {
          var step = it.next();
          normalCompletion = step.done;
          return step;
        }, e: function e(_e2) {
          didErr = true;
          err = _e2;
        }, f: function f() {
          try {
            if (!normalCompletion && it["return"] != null) it["return"]();
          } finally {
            if (didErr) throw err;
          }
        } };
      }
      function _unsupportedIterableToArray(o, minLen) {
        if (!o) return;
        if (typeof o === "string") return _arrayLikeToArray(o, minLen);
        var n = Object.prototype.toString.call(o).slice(8, -1);
        if (n === "Object" && o.constructor) n = o.constructor.name;
        if (n === "Map" || n === "Set") return Array.from(o);
        if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);
      }
      function _arrayLikeToArray(arr, len) {
        if (len == null || len > arr.length) len = arr.length;
        for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];
        return arr2;
      }
      function _callSuper(t, o, e) {
        return o = (0, _getPrototypeOf2["default"])(o), (0, _possibleConstructorReturn2["default"])(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], (0, _getPrototypeOf2["default"])(t).constructor) : o.apply(t, e));
      }
      function _isNativeReflectConstruct() {
        try {
          var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
          }));
        } catch (t2) {
        }
        return (_isNativeReflectConstruct = function _isNativeReflectConstruct2() {
          return !!t;
        })();
      }
      var name18 = "FunctionAssignmentNode";
      var dependencies19 = ["typed", "Node"];
      var createFunctionAssignmentNode = exports.createFunctionAssignmentNode = /* @__PURE__ */ (0, _factory.factory)(name18, dependencies19, function(_ref) {
        var typed2 = _ref.typed, Node = _ref.Node;
        function needParenthesis(node, parenthesis, implicit) {
          var precedence = (0, _operators.getPrecedence)(node, parenthesis, implicit);
          var exprPrecedence = (0, _operators.getPrecedence)(node.expr, parenthesis, implicit);
          return parenthesis === "all" || exprPrecedence !== null && exprPrecedence <= precedence;
        }
        var FunctionAssignmentNode = /* @__PURE__ */ (function(_Node) {
          function FunctionAssignmentNode2(name19, params, expr) {
            var _this;
            (0, _classCallCheck2["default"])(this, FunctionAssignmentNode2);
            _this = _callSuper(this, FunctionAssignmentNode2);
            if (typeof name19 !== "string") {
              throw new TypeError('String expected for parameter "name"');
            }
            if (!Array.isArray(params)) {
              throw new TypeError('Array containing strings or objects expected for parameter "params"');
            }
            if (!(0, _is.isNode)(expr)) {
              throw new TypeError('Node expected for parameter "expr"');
            }
            if (_keywords.keywords.has(name19)) {
              throw new Error('Illegal function name, "' + name19 + '" is a reserved keyword');
            }
            var paramNames = /* @__PURE__ */ new Set();
            var _iterator = _createForOfIteratorHelper(params), _step;
            try {
              for (_iterator.s(); !(_step = _iterator.n()).done; ) {
                var param = _step.value;
                var _name = typeof param === "string" ? param : param.name;
                if (paramNames.has(_name)) {
                  throw new Error('Duplicate parameter name "'.concat(_name, '"'));
                } else {
                  paramNames.add(_name);
                }
              }
            } catch (err) {
              _iterator.e(err);
            } finally {
              _iterator.f();
            }
            _this.name = name19;
            _this.params = params.map(function(param2) {
              return param2 && param2.name || param2;
            });
            _this.types = params.map(function(param2) {
              return param2 && param2.type || "any";
            });
            _this.expr = expr;
            return _this;
          }
          (0, _inherits2["default"])(FunctionAssignmentNode2, _Node);
          return (0, _createClass2["default"])(FunctionAssignmentNode2, [{
            key: "type",
            get: function get() {
              return name18;
            }
          }, {
            key: "isFunctionAssignmentNode",
            get: function get() {
              return true;
            }
            /**
             * Compile a node into a JavaScript function.
             * This basically pre-calculates as much as possible and only leaves open
             * calculations which depend on a dynamic scope with variables.
             * @param {Object} math     Math.js namespace with functions and constants.
             * @param {Object} argNames An object with argument names as key and `true`
             *                          as value. Used in the SymbolNode to optimize
             *                          for arguments from user assigned functions
             *                          (see FunctionAssignmentNode) or special symbols
             *                          like `end` (see IndexNode).
             * @return {function} Returns a function which can be called like:
             *                        evalNode(scope: Object, args: Object, context: *)
             */
          }, {
            key: "_compile",
            value: function _compile(math, argNames) {
              var childArgNames = Object.create(argNames);
              (0, _array.forEach)(this.params, function(param) {
                childArgNames[param] = true;
              });
              var evalExpr = this.expr._compile(math, childArgNames);
              var name19 = this.name;
              var params = this.params;
              var signature = (0, _array.join)(this.types, ",");
              var syntax = name19 + "(" + (0, _array.join)(this.params, ", ") + ")";
              return function evalFunctionAssignmentNode(scope, args, context) {
                var signatures = {};
                signatures[signature] = function() {
                  var childArgs = Object.create(args);
                  for (var i = 0; i < params.length; i++) {
                    childArgs[params[i]] = arguments[i];
                  }
                  return evalExpr(scope, childArgs, context);
                };
                var fn = typed2(name19, signatures);
                fn.syntax = syntax;
                scope.set(name19, fn);
                return fn;
              };
            }
            /**
             * Execute a callback for each of the child nodes of this node
             * @param {function(child: Node, path: string, parent: Node)} callback
             */
          }, {
            key: "forEach",
            value: function forEach(callback) {
              callback(this.expr, "expr", this);
            }
            /**
             * Create a new FunctionAssignmentNode whose children are the results of
             * calling the provided callback function for each child of the original
             * node.
             * @param {function(child: Node, path: string, parent: Node): Node} callback
             * @returns {FunctionAssignmentNode} Returns a transformed copy of the node
             */
          }, {
            key: "map",
            value: function map(callback) {
              var expr = this._ifNode(callback(this.expr, "expr", this));
              return new FunctionAssignmentNode2(this.name, this.params.slice(0), expr);
            }
            /**
             * Create a clone of this node, a shallow copy
             * @return {FunctionAssignmentNode}
             */
          }, {
            key: "clone",
            value: function clone4() {
              return new FunctionAssignmentNode2(this.name, this.params.slice(0), this.expr);
            }
            /**
             * get string representation
             * @param {Object} options
             * @return {string} str
             */
          }, {
            key: "_toString",
            value: function _toString(options) {
              var parenthesis = options && options.parenthesis ? options.parenthesis : "keep";
              var expr = this.expr.toString(options);
              if (needParenthesis(this, parenthesis, options && options.implicit)) {
                expr = "(" + expr + ")";
              }
              return this.name + "(" + this.params.join(", ") + ") = " + expr;
            }
            /**
             * Get a JSON representation of the node
             * @returns {Object}
             */
          }, {
            key: "toJSON",
            value: function toJSON() {
              var types = this.types;
              return {
                mathjs: name18,
                name: this.name,
                params: this.params.map(function(param, index) {
                  return {
                    name: param,
                    type: types[index]
                  };
                }),
                expr: this.expr
              };
            }
            /**
             * Instantiate an FunctionAssignmentNode from its JSON representation
             * @param {Object} json
             *     An object structured like
             *     ```
             *     {"mathjs": "FunctionAssignmentNode",
             *      name: ..., params: ..., expr: ...}
             *     ```
             *     where mathjs is optional
             * @returns {FunctionAssignmentNode}
             */
          }, {
            key: "_toHTML",
            value: (
              /**
               * get HTML representation
               * @param {Object} options
               * @return {string} str
               */
              function _toHTML(options) {
                var parenthesis = options && options.parenthesis ? options.parenthesis : "keep";
                var params = [];
                for (var i = 0; i < this.params.length; i++) {
                  params.push('<span class="math-symbol math-parameter">' + (0, _string.escape)(this.params[i]) + "</span>");
                }
                var expr = this.expr.toHTML(options);
                if (needParenthesis(this, parenthesis, options && options.implicit)) {
                  expr = '<span class="math-parenthesis math-round-parenthesis">(</span>' + expr + '<span class="math-parenthesis math-round-parenthesis">)</span>';
                }
                return '<span class="math-function">' + (0, _string.escape)(this.name) + '</span><span class="math-parenthesis math-round-parenthesis">(</span>' + params.join('<span class="math-separator">,</span>') + '<span class="math-parenthesis math-round-parenthesis">)</span><span class="math-operator math-assignment-operator math-variable-assignment-operator math-binary-operator">=</span>' + expr;
              }
            )
            /**
             * get LaTeX representation
             * @param {Object} options
             * @return {string} str
             */
          }, {
            key: "_toTex",
            value: function _toTex(options) {
              var parenthesis = options && options.parenthesis ? options.parenthesis : "keep";
              var expr = this.expr.toTex(options);
              if (needParenthesis(this, parenthesis, options && options.implicit)) {
                expr = "\\left(".concat(expr, "\\right)");
              }
              return "\\mathrm{" + this.name + "}\\left(" + this.params.map(_latex.toSymbol).join(",") + "\\right)=" + expr;
            }
          }], [{
            key: "fromJSON",
            value: function fromJSON(json) {
              return new FunctionAssignmentNode2(json.name, json.params, json.expr);
            }
          }]);
        })(Node);
        (0, _defineProperty2["default"])(FunctionAssignmentNode, "name", name18);
        return FunctionAssignmentNode;
      }, {
        isClass: true,
        isNode: true
      });
    }
  });

  // node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/expression/node/IndexNode.js
  var require_IndexNode = __commonJS({
    "node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/expression/node/IndexNode.js"(exports) {
      "use strict";
      var _interopRequireDefault = require_interopRequireDefault();
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.createIndexNode = void 0;
      var _toConsumableArray2 = _interopRequireDefault(require_toConsumableArray());
      var _classCallCheck2 = _interopRequireDefault(require_classCallCheck());
      var _createClass2 = _interopRequireDefault(require_createClass());
      var _possibleConstructorReturn2 = _interopRequireDefault(require_possibleConstructorReturn());
      var _getPrototypeOf2 = _interopRequireDefault(require_getPrototypeOf());
      var _inherits2 = _interopRequireDefault(require_inherits());
      var _defineProperty2 = _interopRequireDefault(require_defineProperty());
      var _array = require_array();
      var _customs = require_customs();
      var _factory = require_factory();
      var _is = require_is();
      var _string = require_string();
      function _callSuper(t, o, e) {
        return o = (0, _getPrototypeOf2["default"])(o), (0, _possibleConstructorReturn2["default"])(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], (0, _getPrototypeOf2["default"])(t).constructor) : o.apply(t, e));
      }
      function _isNativeReflectConstruct() {
        try {
          var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
          }));
        } catch (t2) {
        }
        return (_isNativeReflectConstruct = function _isNativeReflectConstruct2() {
          return !!t;
        })();
      }
      var name18 = "IndexNode";
      var dependencies19 = ["Node", "size"];
      var createIndexNode = exports.createIndexNode = /* @__PURE__ */ (0, _factory.factory)(name18, dependencies19, function(_ref) {
        var Node = _ref.Node, size2 = _ref.size;
        var IndexNode = /* @__PURE__ */ (function(_Node) {
          function IndexNode2(dimensions, dotNotation) {
            var _this;
            (0, _classCallCheck2["default"])(this, IndexNode2);
            _this = _callSuper(this, IndexNode2);
            _this.dimensions = dimensions;
            _this.dotNotation = dotNotation || false;
            if (!Array.isArray(dimensions) || !dimensions.every(_is.isNode)) {
              throw new TypeError('Array containing Nodes expected for parameter "dimensions"');
            }
            if (_this.dotNotation && !_this.isObjectProperty()) {
              throw new Error("dotNotation only applicable for object properties");
            }
            return _this;
          }
          (0, _inherits2["default"])(IndexNode2, _Node);
          return (0, _createClass2["default"])(IndexNode2, [{
            key: "type",
            get: function get() {
              return name18;
            }
          }, {
            key: "isIndexNode",
            get: function get() {
              return true;
            }
            /**
             * Compile a node into a JavaScript function.
             * This basically pre-calculates as much as possible and only leaves open
             * calculations which depend on a dynamic scope with variables.
             * @param {Object} math     Math.js namespace with functions and constants.
             * @param {Object} argNames An object with argument names as key and `true`
             *                          as value. Used in the SymbolNode to optimize
             *                          for arguments from user assigned functions
             *                          (see FunctionAssignmentNode) or special symbols
             *                          like `end` (see IndexNode).
             * @return {function} Returns a function which can be called like:
             *                        evalNode(scope: Object, args: Object, context: *)
             */
          }, {
            key: "_compile",
            value: function _compile(math, argNames) {
              var evalDimensions = (0, _array.map)(this.dimensions, function(dimension, i) {
                var needsEnd = dimension.filter(function(node) {
                  return node.isSymbolNode && node.name === "end";
                }).length > 0;
                if (needsEnd) {
                  var childArgNames = Object.create(argNames);
                  childArgNames.end = true;
                  var _evalDimension = dimension._compile(math, childArgNames);
                  return function evalDimension(scope, args, context) {
                    if (!(0, _is.isMatrix)(context) && !(0, _is.isArray)(context) && !(0, _is.isString)(context)) {
                      throw new TypeError('Cannot resolve "end": context must be a Matrix, Array, or string but is ' + (0, _is.typeOf)(context));
                    }
                    var s = size2(context).valueOf();
                    var childArgs = Object.create(args);
                    childArgs.end = s[i];
                    return _evalDimension(scope, childArgs, context);
                  };
                } else {
                  return dimension._compile(math, argNames);
                }
              });
              var index = (0, _customs.getSafeProperty)(math, "index");
              return function evalIndexNode(scope, args, context) {
                var dimensions = (0, _array.map)(evalDimensions, function(evalDimension) {
                  return evalDimension(scope, args, context);
                });
                return index.apply(void 0, (0, _toConsumableArray2["default"])(dimensions));
              };
            }
            /**
             * Execute a callback for each of the child nodes of this node
             * @param {function(child: Node, path: string, parent: Node)} callback
             */
          }, {
            key: "forEach",
            value: function forEach(callback) {
              for (var i = 0; i < this.dimensions.length; i++) {
                callback(this.dimensions[i], "dimensions[" + i + "]", this);
              }
            }
            /**
             * Create a new IndexNode whose children are the results of calling
             * the provided callback function for each child of the original node.
             * @param {function(child: Node, path: string, parent: Node): Node} callback
             * @returns {IndexNode} Returns a transformed copy of the node
             */
          }, {
            key: "map",
            value: function map(callback) {
              var dimensions = [];
              for (var i = 0; i < this.dimensions.length; i++) {
                dimensions[i] = this._ifNode(callback(this.dimensions[i], "dimensions[" + i + "]", this));
              }
              return new IndexNode2(dimensions, this.dotNotation);
            }
            /**
             * Create a clone of this node, a shallow copy
             * @return {IndexNode}
             */
          }, {
            key: "clone",
            value: function clone4() {
              return new IndexNode2(this.dimensions.slice(0), this.dotNotation);
            }
            /**
             * Test whether this IndexNode contains a single property name
             * @return {boolean}
             */
          }, {
            key: "isObjectProperty",
            value: function isObjectProperty() {
              return this.dimensions.length === 1 && (0, _is.isConstantNode)(this.dimensions[0]) && typeof this.dimensions[0].value === "string";
            }
            /**
             * Returns the property name if IndexNode contains a property.
             * If not, returns null.
             * @return {string | null}
             */
          }, {
            key: "getObjectProperty",
            value: function getObjectProperty() {
              return this.isObjectProperty() ? this.dimensions[0].value : null;
            }
            /**
             * Get string representation
             * @param {Object} options
             * @return {string} str
             */
          }, {
            key: "_toString",
            value: function _toString(options) {
              return this.dotNotation ? "." + this.getObjectProperty() : "[" + this.dimensions.join(", ") + "]";
            }
            /**
             * Get a JSON representation of the node
             * @returns {Object}
             */
          }, {
            key: "toJSON",
            value: function toJSON() {
              return {
                mathjs: name18,
                dimensions: this.dimensions,
                dotNotation: this.dotNotation
              };
            }
            /**
             * Instantiate an IndexNode from its JSON representation
             * @param {Object} json
             *     An object structured like
             *     `{"mathjs": "IndexNode", dimensions: [...], dotNotation: false}`,
             *     where mathjs is optional
             * @returns {IndexNode}
             */
          }, {
            key: "_toHTML",
            value: (
              /**
               * Get HTML representation
               * @param {Object} options
               * @return {string} str
               */
              function _toHTML(options) {
                var dimensions = [];
                for (var i = 0; i < this.dimensions.length; i++) {
                  dimensions[i] = this.dimensions[i].toHTML();
                }
                if (this.dotNotation) {
                  return '<span class="math-operator math-accessor-operator">.</span><span class="math-symbol math-property">' + (0, _string.escape)(this.getObjectProperty()) + "</span>";
                } else {
                  return '<span class="math-parenthesis math-square-parenthesis">[</span>' + dimensions.join('<span class="math-separator">,</span>') + '<span class="math-parenthesis math-square-parenthesis">]</span>';
                }
              }
            )
            /**
             * Get LaTeX representation
             * @param {Object} options
             * @return {string} str
             */
          }, {
            key: "_toTex",
            value: function _toTex(options) {
              var dimensions = this.dimensions.map(function(range) {
                return range.toTex(options);
              });
              return this.dotNotation ? "." + this.getObjectProperty() : "_{" + dimensions.join(",") + "}";
            }
          }], [{
            key: "fromJSON",
            value: function fromJSON(json) {
              return new IndexNode2(json.dimensions, json.dotNotation);
            }
          }]);
        })(Node);
        (0, _defineProperty2["default"])(IndexNode, "name", name18);
        return IndexNode;
      }, {
        isClass: true,
        isNode: true
      });
    }
  });

  // node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/expression/node/ObjectNode.js
  var require_ObjectNode = __commonJS({
    "node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/expression/node/ObjectNode.js"(exports) {
      "use strict";
      var _interopRequireDefault = require_interopRequireDefault();
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.createObjectNode = void 0;
      var _typeof2 = _interopRequireDefault(require_typeof());
      var _classCallCheck2 = _interopRequireDefault(require_classCallCheck());
      var _createClass2 = _interopRequireDefault(require_createClass());
      var _possibleConstructorReturn2 = _interopRequireDefault(require_possibleConstructorReturn());
      var _getPrototypeOf2 = _interopRequireDefault(require_getPrototypeOf());
      var _inherits2 = _interopRequireDefault(require_inherits());
      var _defineProperty2 = _interopRequireDefault(require_defineProperty());
      var _customs = require_customs();
      var _factory = require_factory();
      var _is = require_is();
      var _object = require_object();
      var _string = require_string();
      function _callSuper(t, o, e) {
        return o = (0, _getPrototypeOf2["default"])(o), (0, _possibleConstructorReturn2["default"])(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], (0, _getPrototypeOf2["default"])(t).constructor) : o.apply(t, e));
      }
      function _isNativeReflectConstruct() {
        try {
          var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
          }));
        } catch (t2) {
        }
        return (_isNativeReflectConstruct = function _isNativeReflectConstruct2() {
          return !!t;
        })();
      }
      var name18 = "ObjectNode";
      var dependencies19 = ["Node"];
      var createObjectNode = exports.createObjectNode = /* @__PURE__ */ (0, _factory.factory)(name18, dependencies19, function(_ref) {
        var Node = _ref.Node;
        var ObjectNode = /* @__PURE__ */ (function(_Node) {
          function ObjectNode2(properties) {
            var _this;
            (0, _classCallCheck2["default"])(this, ObjectNode2);
            _this = _callSuper(this, ObjectNode2);
            _this.properties = properties || {};
            if (properties) {
              if (!((0, _typeof2["default"])(properties) === "object") || !Object.keys(properties).every(function(key) {
                return (0, _is.isNode)(properties[key]);
              })) {
                throw new TypeError("Object containing Nodes expected");
              }
            }
            return _this;
          }
          (0, _inherits2["default"])(ObjectNode2, _Node);
          return (0, _createClass2["default"])(ObjectNode2, [{
            key: "type",
            get: function get() {
              return name18;
            }
          }, {
            key: "isObjectNode",
            get: function get() {
              return true;
            }
            /**
             * Compile a node into a JavaScript function.
             * This basically pre-calculates as much as possible and only leaves open
             * calculations which depend on a dynamic scope with variables.
             * @param {Object} math     Math.js namespace with functions and constants.
             * @param {Object} argNames An object with argument names as key and `true`
             *                          as value. Used in the SymbolNode to optimize
             *                          for arguments from user assigned functions
             *                          (see FunctionAssignmentNode) or special symbols
             *                          like `end` (see IndexNode).
             * @return {function} Returns a function which can be called like:
             *                        evalNode(scope: Object, args: Object, context: *)
             */
          }, {
            key: "_compile",
            value: function _compile(math, argNames) {
              var evalEntries = {};
              for (var key in this.properties) {
                if ((0, _object.hasOwnProperty)(this.properties, key)) {
                  var stringifiedKey = (0, _string.stringify)(key);
                  var parsedKey = JSON.parse(stringifiedKey);
                  var prop = (0, _customs.getSafeProperty)(this.properties, key);
                  evalEntries[parsedKey] = prop._compile(math, argNames);
                }
              }
              return function evalObjectNode(scope, args, context) {
                var obj = {};
                for (var _key in evalEntries) {
                  if ((0, _object.hasOwnProperty)(evalEntries, _key)) {
                    obj[_key] = evalEntries[_key](scope, args, context);
                  }
                }
                return obj;
              };
            }
            /**
             * Execute a callback for each of the child nodes of this node
             * @param {function(child: Node, path: string, parent: Node)} callback
             */
          }, {
            key: "forEach",
            value: function forEach(callback) {
              for (var key in this.properties) {
                if ((0, _object.hasOwnProperty)(this.properties, key)) {
                  callback(this.properties[key], "properties[" + (0, _string.stringify)(key) + "]", this);
                }
              }
            }
            /**
             * Create a new ObjectNode whose children are the results of calling
             * the provided callback function for each child of the original node.
             * @param {function(child: Node, path: string, parent: Node): Node} callback
             * @returns {ObjectNode} Returns a transformed copy of the node
             */
          }, {
            key: "map",
            value: function map(callback) {
              var properties = {};
              for (var key in this.properties) {
                if ((0, _object.hasOwnProperty)(this.properties, key)) {
                  properties[key] = this._ifNode(callback(this.properties[key], "properties[" + (0, _string.stringify)(key) + "]", this));
                }
              }
              return new ObjectNode2(properties);
            }
            /**
             * Create a clone of this node, a shallow copy
             * @return {ObjectNode}
             */
          }, {
            key: "clone",
            value: function clone4() {
              var properties = {};
              for (var key in this.properties) {
                if ((0, _object.hasOwnProperty)(this.properties, key)) {
                  properties[key] = this.properties[key];
                }
              }
              return new ObjectNode2(properties);
            }
            /**
             * Get string representation
             * @param {Object} options
             * @return {string} str
             * @override
             */
          }, {
            key: "_toString",
            value: function _toString(options) {
              var entries = [];
              for (var key in this.properties) {
                if ((0, _object.hasOwnProperty)(this.properties, key)) {
                  entries.push((0, _string.stringify)(key) + ": " + this.properties[key].toString(options));
                }
              }
              return "{" + entries.join(", ") + "}";
            }
            /**
             * Get a JSON representation of the node
             * @returns {Object}
             */
          }, {
            key: "toJSON",
            value: function toJSON() {
              return {
                mathjs: name18,
                properties: this.properties
              };
            }
            /**
             * Instantiate an OperatorNode from its JSON representation
             * @param {Object} json  An object structured like
             *                       `{"mathjs": "ObjectNode", "properties": {...}}`,
             *                       where mathjs is optional
             * @returns {ObjectNode}
             */
          }, {
            key: "_toHTML",
            value: (
              /**
               * Get HTML representation
               * @param {Object} options
               * @return {string} str
               * @override
               */
              function _toHTML(options) {
                var entries = [];
                for (var key in this.properties) {
                  if ((0, _object.hasOwnProperty)(this.properties, key)) {
                    entries.push('<span class="math-symbol math-property">' + (0, _string.escape)(key) + '</span><span class="math-operator math-assignment-operator math-property-assignment-operator math-binary-operator">:</span>' + this.properties[key].toHTML(options));
                  }
                }
                return '<span class="math-parenthesis math-curly-parenthesis">{</span>' + entries.join('<span class="math-separator">,</span>') + '<span class="math-parenthesis math-curly-parenthesis">}</span>';
              }
            )
            /**
             * Get LaTeX representation
             * @param {Object} options
             * @return {string} str
             */
          }, {
            key: "_toTex",
            value: function _toTex(options) {
              var entries = [];
              for (var key in this.properties) {
                if ((0, _object.hasOwnProperty)(this.properties, key)) {
                  entries.push("\\mathbf{" + key + ":} & " + this.properties[key].toTex(options) + "\\\\");
                }
              }
              var tex = "\\left\\{\\begin{array}{ll}" + entries.join("\n") + "\\end{array}\\right\\}";
              return tex;
            }
          }], [{
            key: "fromJSON",
            value: function fromJSON(json) {
              return new ObjectNode2(json.properties);
            }
          }]);
        })(Node);
        (0, _defineProperty2["default"])(ObjectNode, "name", name18);
        return ObjectNode;
      }, {
        isClass: true,
        isNode: true
      });
    }
  });

  // node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/utils/scope.js
  var require_scope = __commonJS({
    "node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/utils/scope.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.createSubScope = createSubScope;
      var _map = require_map();
      function createSubScope(parentScope, args) {
        return new _map.PartitionedMap(parentScope, new _map.ObjectWrappingMap(args), new Set(Object.keys(args)));
      }
    }
  });

  // node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/expression/node/OperatorNode.js
  var require_OperatorNode = __commonJS({
    "node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/expression/node/OperatorNode.js"(exports) {
      "use strict";
      var _interopRequireDefault = require_interopRequireDefault();
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.createOperatorNode = void 0;
      var _classCallCheck2 = _interopRequireDefault(require_classCallCheck());
      var _createClass2 = _interopRequireDefault(require_createClass());
      var _possibleConstructorReturn2 = _interopRequireDefault(require_possibleConstructorReturn());
      var _getPrototypeOf2 = _interopRequireDefault(require_getPrototypeOf());
      var _inherits2 = _interopRequireDefault(require_inherits());
      var _defineProperty2 = _interopRequireDefault(require_defineProperty());
      var _is = require_is();
      var _array = require_array();
      var _scope = require_scope();
      var _string = require_string();
      var _customs = require_customs();
      var _operators = require_operators();
      var _latex = require_latex();
      var _factory = require_factory();
      function _callSuper(t, o, e) {
        return o = (0, _getPrototypeOf2["default"])(o), (0, _possibleConstructorReturn2["default"])(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], (0, _getPrototypeOf2["default"])(t).constructor) : o.apply(t, e));
      }
      function _isNativeReflectConstruct() {
        try {
          var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
          }));
        } catch (t2) {
        }
        return (_isNativeReflectConstruct = function _isNativeReflectConstruct2() {
          return !!t;
        })();
      }
      var name18 = "OperatorNode";
      var dependencies19 = ["Node"];
      var createOperatorNode = exports.createOperatorNode = /* @__PURE__ */ (0, _factory.factory)(name18, dependencies19, function(_ref) {
        var Node = _ref.Node;
        function startsWithConstant(expr, parenthesis) {
          var curNode = expr;
          if (parenthesis === "auto") {
            while ((0, _is.isParenthesisNode)(curNode)) curNode = curNode.content;
          }
          if ((0, _is.isConstantNode)(curNode)) return true;
          if ((0, _is.isOperatorNode)(curNode)) {
            return startsWithConstant(curNode.args[0], parenthesis);
          }
          return false;
        }
        function calculateNecessaryParentheses(root, parenthesis, implicit, args, latex) {
          var precedence = (0, _operators.getPrecedence)(root, parenthesis, implicit);
          var associativity = (0, _operators.getAssociativity)(root, parenthesis);
          if (parenthesis === "all" || args.length > 2 && root.getIdentifier() !== "OperatorNode:add" && root.getIdentifier() !== "OperatorNode:multiply") {
            return args.map(function(arg) {
              switch (arg.getContent().type) {
                // Nodes that don't need extra parentheses
                case "ArrayNode":
                case "ConstantNode":
                case "SymbolNode":
                case "ParenthesisNode":
                  return false;
                default:
                  return true;
              }
            });
          }
          var result;
          switch (args.length) {
            case 0:
              result = [];
              break;
            case 1:
              {
                var operandPrecedence = (0, _operators.getPrecedence)(args[0], parenthesis, implicit, root);
                if (latex && operandPrecedence !== null) {
                  var operandIdentifier;
                  var rootIdentifier;
                  if (parenthesis === "keep") {
                    operandIdentifier = args[0].getIdentifier();
                    rootIdentifier = root.getIdentifier();
                  } else {
                    operandIdentifier = args[0].getContent().getIdentifier();
                    rootIdentifier = root.getContent().getIdentifier();
                  }
                  if (_operators.properties[precedence][rootIdentifier].latexLeftParens === false) {
                    result = [false];
                    break;
                  }
                  if (_operators.properties[operandPrecedence][operandIdentifier].latexParens === false) {
                    result = [false];
                    break;
                  }
                }
                if (operandPrecedence === null) {
                  result = [false];
                  break;
                }
                if (operandPrecedence <= precedence) {
                  result = [true];
                  break;
                }
                result = [false];
              }
              break;
            case 2:
              {
                var lhsParens;
                var lhsPrecedence = (0, _operators.getPrecedence)(args[0], parenthesis, implicit, root);
                var assocWithLhs = (0, _operators.isAssociativeWith)(root, args[0], parenthesis);
                if (lhsPrecedence === null) {
                  lhsParens = false;
                } else if (lhsPrecedence === precedence && associativity === "right" && !assocWithLhs) {
                  lhsParens = true;
                } else if (lhsPrecedence < precedence) {
                  lhsParens = true;
                } else {
                  lhsParens = false;
                }
                var rhsParens;
                var rhsPrecedence = (0, _operators.getPrecedence)(args[1], parenthesis, implicit, root);
                var assocWithRhs = (0, _operators.isAssociativeWith)(root, args[1], parenthesis);
                if (rhsPrecedence === null) {
                  rhsParens = false;
                } else if (rhsPrecedence === precedence && associativity === "left" && !assocWithRhs) {
                  rhsParens = true;
                } else if (rhsPrecedence < precedence) {
                  rhsParens = true;
                } else {
                  rhsParens = false;
                }
                if (latex) {
                  var _rootIdentifier;
                  var lhsIdentifier;
                  var rhsIdentifier;
                  if (parenthesis === "keep") {
                    _rootIdentifier = root.getIdentifier();
                    lhsIdentifier = root.args[0].getIdentifier();
                    rhsIdentifier = root.args[1].getIdentifier();
                  } else {
                    _rootIdentifier = root.getContent().getIdentifier();
                    lhsIdentifier = root.args[0].getContent().getIdentifier();
                    rhsIdentifier = root.args[1].getContent().getIdentifier();
                  }
                  if (lhsPrecedence !== null) {
                    if (_operators.properties[precedence][_rootIdentifier].latexLeftParens === false) {
                      lhsParens = false;
                    }
                    if (_operators.properties[lhsPrecedence][lhsIdentifier].latexParens === false) {
                      lhsParens = false;
                    }
                  }
                  if (rhsPrecedence !== null) {
                    if (_operators.properties[precedence][_rootIdentifier].latexRightParens === false) {
                      rhsParens = false;
                    }
                    if (_operators.properties[rhsPrecedence][rhsIdentifier].latexParens === false) {
                      rhsParens = false;
                    }
                  }
                }
                result = [lhsParens, rhsParens];
              }
              break;
            default:
              if (root.getIdentifier() === "OperatorNode:add" || root.getIdentifier() === "OperatorNode:multiply") {
                result = args.map(function(arg) {
                  var argPrecedence = (0, _operators.getPrecedence)(arg, parenthesis, implicit, root);
                  var assocWithArg = (0, _operators.isAssociativeWith)(root, arg, parenthesis);
                  var argAssociativity = (0, _operators.getAssociativity)(arg, parenthesis);
                  if (argPrecedence === null) {
                    return false;
                  } else if (precedence === argPrecedence && associativity === argAssociativity && !assocWithArg) {
                    return true;
                  } else if (argPrecedence < precedence) {
                    return true;
                  }
                  return false;
                });
              }
              break;
          }
          if (args.length >= 2 && root.getIdentifier() === "OperatorNode:multiply" && root.implicit && parenthesis !== "all" && implicit === "hide") {
            for (var i = 1; i < result.length; ++i) {
              if (startsWithConstant(args[i], parenthesis) && !result[i - 1] && (parenthesis !== "keep" || !(0, _is.isParenthesisNode)(args[i - 1]))) {
                result[i] = true;
              }
            }
          }
          return result;
        }
        var OperatorNode = /* @__PURE__ */ (function(_Node) {
          function OperatorNode2(op, fn, args, implicit, isPercentage) {
            var _this;
            (0, _classCallCheck2["default"])(this, OperatorNode2);
            _this = _callSuper(this, OperatorNode2);
            if (typeof op !== "string") {
              throw new TypeError('string expected for parameter "op"');
            }
            if (typeof fn !== "string") {
              throw new TypeError('string expected for parameter "fn"');
            }
            if (!Array.isArray(args) || !args.every(_is.isNode)) {
              throw new TypeError('Array containing Nodes expected for parameter "args"');
            }
            _this.implicit = implicit === true;
            _this.isPercentage = isPercentage === true;
            _this.op = op;
            _this.fn = fn;
            _this.args = args || [];
            return _this;
          }
          (0, _inherits2["default"])(OperatorNode2, _Node);
          return (0, _createClass2["default"])(OperatorNode2, [{
            key: "type",
            get: function get() {
              return name18;
            }
          }, {
            key: "isOperatorNode",
            get: function get() {
              return true;
            }
            /**
             * Compile a node into a JavaScript function.
             * This basically pre-calculates as much as possible and only leaves open
             * calculations which depend on a dynamic scope with variables.
             * @param {Object} math     Math.js namespace with functions and constants.
             * @param {Object} argNames An object with argument names as key and `true`
             *                          as value. Used in the SymbolNode to optimize
             *                          for arguments from user assigned functions
             *                          (see FunctionAssignmentNode) or special symbols
             *                          like `end` (see IndexNode).
             * @return {function} Returns a function which can be called like:
             *                        evalNode(scope: Object, args: Object, context: *)
             */
          }, {
            key: "_compile",
            value: function _compile(math, argNames) {
              if (typeof this.fn !== "string" || !(0, _customs.isSafeMethod)(math, this.fn)) {
                if (!math[this.fn]) {
                  throw new Error("Function " + this.fn + ' missing in provided namespace "math"');
                } else {
                  throw new Error('No access to function "' + this.fn + '"');
                }
              }
              var fn = (0, _customs.getSafeProperty)(math, this.fn);
              var evalArgs = (0, _array.map)(this.args, function(arg) {
                return arg._compile(math, argNames);
              });
              if (typeof fn === "function" && fn.rawArgs === true) {
                var rawArgs = this.args;
                return function evalOperatorNode(scope, args, context) {
                  return fn(rawArgs, math, (0, _scope.createSubScope)(scope, args));
                };
              } else if (evalArgs.length === 1) {
                var evalArg0 = evalArgs[0];
                return function evalOperatorNode(scope, args, context) {
                  return fn(evalArg0(scope, args, context));
                };
              } else if (evalArgs.length === 2) {
                var _evalArg = evalArgs[0];
                var evalArg1 = evalArgs[1];
                return function evalOperatorNode(scope, args, context) {
                  return fn(_evalArg(scope, args, context), evalArg1(scope, args, context));
                };
              } else {
                return function evalOperatorNode(scope, args, context) {
                  return fn.apply(null, (0, _array.map)(evalArgs, function(evalArg) {
                    return evalArg(scope, args, context);
                  }));
                };
              }
            }
            /**
             * Execute a callback for each of the child nodes of this node
             * @param {function(child: Node, path: string, parent: Node)} callback
             */
          }, {
            key: "forEach",
            value: function forEach(callback) {
              for (var i = 0; i < this.args.length; i++) {
                callback(this.args[i], "args[" + i + "]", this);
              }
            }
            /**
             * Create a new OperatorNode whose children are the results of calling
             * the provided callback function for each child of the original node.
             * @param {function(child: Node, path: string, parent: Node): Node} callback
             * @returns {OperatorNode} Returns a transformed copy of the node
             */
          }, {
            key: "map",
            value: function map(callback) {
              var args = [];
              for (var i = 0; i < this.args.length; i++) {
                args[i] = this._ifNode(callback(this.args[i], "args[" + i + "]", this));
              }
              return new OperatorNode2(this.op, this.fn, args, this.implicit, this.isPercentage);
            }
            /**
             * Create a clone of this node, a shallow copy
             * @return {OperatorNode}
             */
          }, {
            key: "clone",
            value: function clone4() {
              return new OperatorNode2(this.op, this.fn, this.args.slice(0), this.implicit, this.isPercentage);
            }
            /**
             * Check whether this is an unary OperatorNode:
             * has exactly one argument, like `-a`.
             * @return {boolean}
             *     Returns true when an unary operator node, false otherwise.
             */
          }, {
            key: "isUnary",
            value: function isUnary() {
              return this.args.length === 1;
            }
            /**
             * Check whether this is a binary OperatorNode:
             * has exactly two arguments, like `a + b`.
             * @return {boolean}
             *     Returns true when a binary operator node, false otherwise.
             */
          }, {
            key: "isBinary",
            value: function isBinary2() {
              return this.args.length === 2;
            }
            /**
             * Get string representation.
             * @param {Object} options
             * @return {string} str
             */
          }, {
            key: "_toString",
            value: function _toString(options) {
              var parenthesis = options && options.parenthesis ? options.parenthesis : "keep";
              var implicit = options && options.implicit ? options.implicit : "hide";
              var args = this.args;
              var parens = calculateNecessaryParentheses(this, parenthesis, implicit, args, false);
              if (args.length === 1) {
                var assoc = (0, _operators.getAssociativity)(this, parenthesis);
                var operand = args[0].toString(options);
                if (parens[0]) {
                  operand = "(" + operand + ")";
                }
                var opIsNamed = /[a-zA-Z]+/.test(this.op);
                if (assoc === "right") {
                  return this.op + (opIsNamed ? " " : "") + operand;
                } else if (assoc === "left") {
                  return operand + (opIsNamed ? " " : "") + this.op;
                }
                return operand + this.op;
              } else if (args.length === 2) {
                var lhs = args[0].toString(options);
                var rhs = args[1].toString(options);
                if (parens[0]) {
                  lhs = "(" + lhs + ")";
                }
                if (parens[1]) {
                  rhs = "(" + rhs + ")";
                }
                if (this.implicit && this.getIdentifier() === "OperatorNode:multiply" && implicit === "hide") {
                  return lhs + " " + rhs;
                }
                return lhs + " " + this.op + " " + rhs;
              } else if (args.length > 2 && (this.getIdentifier() === "OperatorNode:add" || this.getIdentifier() === "OperatorNode:multiply")) {
                var stringifiedArgs = args.map(function(arg, index) {
                  arg = arg.toString(options);
                  if (parens[index]) {
                    arg = "(" + arg + ")";
                  }
                  return arg;
                });
                if (this.implicit && this.getIdentifier() === "OperatorNode:multiply" && implicit === "hide") {
                  return stringifiedArgs.join(" ");
                }
                return stringifiedArgs.join(" " + this.op + " ");
              } else {
                return this.fn + "(" + this.args.join(", ") + ")";
              }
            }
            /**
             * Get a JSON representation of the node
             * @returns {Object}
             */
          }, {
            key: "toJSON",
            value: function toJSON() {
              return {
                mathjs: name18,
                op: this.op,
                fn: this.fn,
                args: this.args,
                implicit: this.implicit,
                isPercentage: this.isPercentage
              };
            }
            /**
             * Instantiate an OperatorNode from its JSON representation
             * @param {Object} json
             *     An object structured like
             *     ```
             *     {"mathjs": "OperatorNode",
             *      "op": "+", "fn": "add", "args": [...],
             *      "implicit": false,
             *      "isPercentage":false}
             *     ```
             *     where mathjs is optional
             * @returns {OperatorNode}
             */
          }, {
            key: "_toHTML",
            value: (
              /**
               * Get HTML representation.
               * @param {Object} options
               * @return {string} str
               */
              function _toHTML(options) {
                var parenthesis = options && options.parenthesis ? options.parenthesis : "keep";
                var implicit = options && options.implicit ? options.implicit : "hide";
                var args = this.args;
                var parens = calculateNecessaryParentheses(this, parenthesis, implicit, args, false);
                if (args.length === 1) {
                  var assoc = (0, _operators.getAssociativity)(this, parenthesis);
                  var operand = args[0].toHTML(options);
                  if (parens[0]) {
                    operand = '<span class="math-parenthesis math-round-parenthesis">(</span>' + operand + '<span class="math-parenthesis math-round-parenthesis">)</span>';
                  }
                  if (assoc === "right") {
                    return '<span class="math-operator math-unary-operator math-lefthand-unary-operator">' + (0, _string.escape)(this.op) + "</span>" + operand;
                  } else {
                    return operand + '<span class="math-operator math-unary-operator math-righthand-unary-operator">' + (0, _string.escape)(this.op) + "</span>";
                  }
                } else if (args.length === 2) {
                  var lhs = args[0].toHTML(options);
                  var rhs = args[1].toHTML(options);
                  if (parens[0]) {
                    lhs = '<span class="math-parenthesis math-round-parenthesis">(</span>' + lhs + '<span class="math-parenthesis math-round-parenthesis">)</span>';
                  }
                  if (parens[1]) {
                    rhs = '<span class="math-parenthesis math-round-parenthesis">(</span>' + rhs + '<span class="math-parenthesis math-round-parenthesis">)</span>';
                  }
                  if (this.implicit && this.getIdentifier() === "OperatorNode:multiply" && implicit === "hide") {
                    return lhs + '<span class="math-operator math-binary-operator math-implicit-binary-operator"></span>' + rhs;
                  }
                  return lhs + '<span class="math-operator math-binary-operator math-explicit-binary-operator">' + (0, _string.escape)(this.op) + "</span>" + rhs;
                } else {
                  var stringifiedArgs = args.map(function(arg, index) {
                    arg = arg.toHTML(options);
                    if (parens[index]) {
                      arg = '<span class="math-parenthesis math-round-parenthesis">(</span>' + arg + '<span class="math-parenthesis math-round-parenthesis">)</span>';
                    }
                    return arg;
                  });
                  if (args.length > 2 && (this.getIdentifier() === "OperatorNode:add" || this.getIdentifier() === "OperatorNode:multiply")) {
                    if (this.implicit && this.getIdentifier() === "OperatorNode:multiply" && implicit === "hide") {
                      return stringifiedArgs.join('<span class="math-operator math-binary-operator math-implicit-binary-operator"></span>');
                    }
                    return stringifiedArgs.join('<span class="math-operator math-binary-operator math-explicit-binary-operator">' + (0, _string.escape)(this.op) + "</span>");
                  } else {
                    return '<span class="math-function">' + (0, _string.escape)(this.fn) + '</span><span class="math-paranthesis math-round-parenthesis">(</span>' + stringifiedArgs.join('<span class="math-separator">,</span>') + '<span class="math-paranthesis math-round-parenthesis">)</span>';
                  }
                }
              }
            )
            /**
             * Get LaTeX representation
             * @param {Object} options
             * @return {string} str
             */
          }, {
            key: "_toTex",
            value: function _toTex(options) {
              var parenthesis = options && options.parenthesis ? options.parenthesis : "keep";
              var implicit = options && options.implicit ? options.implicit : "hide";
              var args = this.args;
              var parens = calculateNecessaryParentheses(this, parenthesis, implicit, args, true);
              var op = _latex.latexOperators[this.fn];
              op = typeof op === "undefined" ? this.op : op;
              if (args.length === 1) {
                var assoc = (0, _operators.getAssociativity)(this, parenthesis);
                var operand = args[0].toTex(options);
                if (parens[0]) {
                  operand = "\\left(".concat(operand, "\\right)");
                }
                if (assoc === "right") {
                  return op + operand;
                } else if (assoc === "left") {
                  return operand + op;
                }
                return operand + op;
              } else if (args.length === 2) {
                var lhs = args[0];
                var lhsTex = lhs.toTex(options);
                if (parens[0]) {
                  lhsTex = "\\left(".concat(lhsTex, "\\right)");
                }
                var rhs = args[1];
                var rhsTex = rhs.toTex(options);
                if (parens[1]) {
                  rhsTex = "\\left(".concat(rhsTex, "\\right)");
                }
                var lhsIdentifier;
                if (parenthesis === "keep") {
                  lhsIdentifier = lhs.getIdentifier();
                } else {
                  lhsIdentifier = lhs.getContent().getIdentifier();
                }
                switch (this.getIdentifier()) {
                  case "OperatorNode:divide":
                    return op + "{" + lhsTex + "}{" + rhsTex + "}";
                  case "OperatorNode:pow":
                    lhsTex = "{" + lhsTex + "}";
                    rhsTex = "{" + rhsTex + "}";
                    switch (lhsIdentifier) {
                      case "ConditionalNode":
                      //
                      case "OperatorNode:divide":
                        lhsTex = "\\left(".concat(lhsTex, "\\right)");
                    }
                    break;
                  case "OperatorNode:multiply":
                    if (this.implicit && implicit === "hide") {
                      return lhsTex + "~" + rhsTex;
                    }
                }
                return lhsTex + op + rhsTex;
              } else if (args.length > 2 && (this.getIdentifier() === "OperatorNode:add" || this.getIdentifier() === "OperatorNode:multiply")) {
                var texifiedArgs = args.map(function(arg, index) {
                  arg = arg.toTex(options);
                  if (parens[index]) {
                    arg = "\\left(".concat(arg, "\\right)");
                  }
                  return arg;
                });
                if (this.getIdentifier() === "OperatorNode:multiply" && this.implicit && implicit === "hide") {
                  return texifiedArgs.join("~");
                }
                return texifiedArgs.join(op);
              } else {
                return "\\mathrm{" + this.fn + "}\\left(" + args.map(function(arg) {
                  return arg.toTex(options);
                }).join(",") + "\\right)";
              }
            }
            /**
             * Get identifier.
             * @return {string}
             */
          }, {
            key: "getIdentifier",
            value: function getIdentifier() {
              return this.type + ":" + this.fn;
            }
          }], [{
            key: "fromJSON",
            value: function fromJSON(json) {
              return new OperatorNode2(json.op, json.fn, json.args, json.implicit, json.isPercentage);
            }
          }]);
        })(Node);
        (0, _defineProperty2["default"])(OperatorNode, "name", name18);
        return OperatorNode;
      }, {
        isClass: true,
        isNode: true
      });
    }
  });

  // node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/expression/node/ParenthesisNode.js
  var require_ParenthesisNode = __commonJS({
    "node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/expression/node/ParenthesisNode.js"(exports) {
      "use strict";
      var _interopRequireDefault = require_interopRequireDefault();
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.createParenthesisNode = void 0;
      var _classCallCheck2 = _interopRequireDefault(require_classCallCheck());
      var _createClass2 = _interopRequireDefault(require_createClass());
      var _possibleConstructorReturn2 = _interopRequireDefault(require_possibleConstructorReturn());
      var _getPrototypeOf2 = _interopRequireDefault(require_getPrototypeOf());
      var _inherits2 = _interopRequireDefault(require_inherits());
      var _defineProperty2 = _interopRequireDefault(require_defineProperty());
      var _is = require_is();
      var _factory = require_factory();
      function _callSuper(t, o, e) {
        return o = (0, _getPrototypeOf2["default"])(o), (0, _possibleConstructorReturn2["default"])(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], (0, _getPrototypeOf2["default"])(t).constructor) : o.apply(t, e));
      }
      function _isNativeReflectConstruct() {
        try {
          var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
          }));
        } catch (t2) {
        }
        return (_isNativeReflectConstruct = function _isNativeReflectConstruct2() {
          return !!t;
        })();
      }
      var name18 = "ParenthesisNode";
      var dependencies19 = ["Node"];
      var createParenthesisNode = exports.createParenthesisNode = /* @__PURE__ */ (0, _factory.factory)(name18, dependencies19, function(_ref) {
        var Node = _ref.Node;
        var ParenthesisNode = /* @__PURE__ */ (function(_Node) {
          function ParenthesisNode2(content) {
            var _this;
            (0, _classCallCheck2["default"])(this, ParenthesisNode2);
            _this = _callSuper(this, ParenthesisNode2);
            if (!(0, _is.isNode)(content)) {
              throw new TypeError('Node expected for parameter "content"');
            }
            _this.content = content;
            return _this;
          }
          (0, _inherits2["default"])(ParenthesisNode2, _Node);
          return (0, _createClass2["default"])(ParenthesisNode2, [{
            key: "type",
            get: function get() {
              return name18;
            }
          }, {
            key: "isParenthesisNode",
            get: function get() {
              return true;
            }
            /**
             * Compile a node into a JavaScript function.
             * This basically pre-calculates as much as possible and only leaves open
             * calculations which depend on a dynamic scope with variables.
             * @param {Object} math     Math.js namespace with functions and constants.
             * @param {Object} argNames An object with argument names as key and `true`
             *                          as value. Used in the SymbolNode to optimize
             *                          for arguments from user assigned functions
             *                          (see FunctionAssignmentNode) or special symbols
             *                          like `end` (see IndexNode).
             * @return {function} Returns a function which can be called like:
             *                        evalNode(scope: Object, args: Object, context: *)
             */
          }, {
            key: "_compile",
            value: function _compile(math, argNames) {
              return this.content._compile(math, argNames);
            }
            /**
             * Get the content of the current Node.
             * @return {Node} content
             * @override
             **/
          }, {
            key: "getContent",
            value: function getContent() {
              return this.content.getContent();
            }
            /**
             * Execute a callback for each of the child nodes of this node
             * @param {function(child: Node, path: string, parent: Node)} callback
             */
          }, {
            key: "forEach",
            value: function forEach(callback) {
              callback(this.content, "content", this);
            }
            /**
             * Create a new ParenthesisNode whose child is the result of calling
             * the provided callback function on the child of this node.
             * @param {function(child: Node, path: string, parent: Node) : Node} callback
             * @returns {ParenthesisNode} Returns a clone of the node
             */
          }, {
            key: "map",
            value: function map(callback) {
              var content = callback(this.content, "content", this);
              return new ParenthesisNode2(content);
            }
            /**
             * Create a clone of this node, a shallow copy
             * @return {ParenthesisNode}
             */
          }, {
            key: "clone",
            value: function clone4() {
              return new ParenthesisNode2(this.content);
            }
            /**
             * Get string representation
             * @param {Object} options
             * @return {string} str
             * @override
             */
          }, {
            key: "_toString",
            value: function _toString(options) {
              if (!options || options && !options.parenthesis || options && options.parenthesis === "keep") {
                return "(" + this.content.toString(options) + ")";
              }
              return this.content.toString(options);
            }
            /**
             * Get a JSON representation of the node
             * @returns {Object}
             */
          }, {
            key: "toJSON",
            value: function toJSON() {
              return {
                mathjs: name18,
                content: this.content
              };
            }
            /**
             * Instantiate an ParenthesisNode from its JSON representation
             * @param {Object} json  An object structured like
             *                       `{"mathjs": "ParenthesisNode", "content": ...}`,
             *                       where mathjs is optional
             * @returns {ParenthesisNode}
             */
          }, {
            key: "_toHTML",
            value: (
              /**
               * Get HTML representation
               * @param {Object} options
               * @return {string} str
               * @override
               */
              function _toHTML(options) {
                if (!options || options && !options.parenthesis || options && options.parenthesis === "keep") {
                  return '<span class="math-parenthesis math-round-parenthesis">(</span>' + this.content.toHTML(options) + '<span class="math-parenthesis math-round-parenthesis">)</span>';
                }
                return this.content.toHTML(options);
              }
            )
            /**
             * Get LaTeX representation
             * @param {Object} options
             * @return {string} str
             * @override
             */
          }, {
            key: "_toTex",
            value: function _toTex(options) {
              if (!options || options && !options.parenthesis || options && options.parenthesis === "keep") {
                return "\\left(".concat(this.content.toTex(options), "\\right)");
              }
              return this.content.toTex(options);
            }
          }], [{
            key: "fromJSON",
            value: function fromJSON(json) {
              return new ParenthesisNode2(json.content);
            }
          }]);
        })(Node);
        (0, _defineProperty2["default"])(ParenthesisNode, "name", name18);
        return ParenthesisNode;
      }, {
        isClass: true,
        isNode: true
      });
    }
  });

  // node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/expression/node/RangeNode.js
  var require_RangeNode = __commonJS({
    "node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/expression/node/RangeNode.js"(exports) {
      "use strict";
      var _interopRequireDefault = require_interopRequireDefault();
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.createRangeNode = void 0;
      var _classCallCheck2 = _interopRequireDefault(require_classCallCheck());
      var _createClass2 = _interopRequireDefault(require_createClass());
      var _possibleConstructorReturn2 = _interopRequireDefault(require_possibleConstructorReturn());
      var _getPrototypeOf2 = _interopRequireDefault(require_getPrototypeOf());
      var _inherits2 = _interopRequireDefault(require_inherits());
      var _defineProperty2 = _interopRequireDefault(require_defineProperty());
      var _is = require_is();
      var _factory = require_factory();
      var _operators = require_operators();
      function _callSuper(t, o, e) {
        return o = (0, _getPrototypeOf2["default"])(o), (0, _possibleConstructorReturn2["default"])(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], (0, _getPrototypeOf2["default"])(t).constructor) : o.apply(t, e));
      }
      function _isNativeReflectConstruct() {
        try {
          var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
          }));
        } catch (t2) {
        }
        return (_isNativeReflectConstruct = function _isNativeReflectConstruct2() {
          return !!t;
        })();
      }
      var name18 = "RangeNode";
      var dependencies19 = ["Node"];
      var createRangeNode = exports.createRangeNode = /* @__PURE__ */ (0, _factory.factory)(name18, dependencies19, function(_ref) {
        var Node = _ref.Node;
        function calculateNecessaryParentheses(node, parenthesis, implicit) {
          var precedence = (0, _operators.getPrecedence)(node, parenthesis, implicit);
          var parens = {};
          var startPrecedence = (0, _operators.getPrecedence)(node.start, parenthesis, implicit);
          parens.start = startPrecedence !== null && startPrecedence <= precedence || parenthesis === "all";
          if (node.step) {
            var stepPrecedence = (0, _operators.getPrecedence)(node.step, parenthesis, implicit);
            parens.step = stepPrecedence !== null && stepPrecedence <= precedence || parenthesis === "all";
          }
          var endPrecedence = (0, _operators.getPrecedence)(node.end, parenthesis, implicit);
          parens.end = endPrecedence !== null && endPrecedence <= precedence || parenthesis === "all";
          return parens;
        }
        var RangeNode = /* @__PURE__ */ (function(_Node) {
          function RangeNode2(start, end, step) {
            var _this;
            (0, _classCallCheck2["default"])(this, RangeNode2);
            _this = _callSuper(this, RangeNode2);
            if (!(0, _is.isNode)(start)) throw new TypeError("Node expected");
            if (!(0, _is.isNode)(end)) throw new TypeError("Node expected");
            if (step && !(0, _is.isNode)(step)) throw new TypeError("Node expected");
            if (arguments.length > 3) throw new Error("Too many arguments");
            _this.start = start;
            _this.end = end;
            _this.step = step || null;
            return _this;
          }
          (0, _inherits2["default"])(RangeNode2, _Node);
          return (0, _createClass2["default"])(RangeNode2, [{
            key: "type",
            get: function get() {
              return name18;
            }
          }, {
            key: "isRangeNode",
            get: function get() {
              return true;
            }
            /**
             * Check whether the RangeNode needs the `end` symbol to be defined.
             * This end is the size of the Matrix in current dimension.
             * @return {boolean}
             */
          }, {
            key: "needsEnd",
            value: function needsEnd() {
              var endSymbols = this.filter(function(node) {
                return (0, _is.isSymbolNode)(node) && node.name === "end";
              });
              return endSymbols.length > 0;
            }
            /**
             * Compile a node into a JavaScript function.
             * This basically pre-calculates as much as possible and only leaves open
             * calculations which depend on a dynamic scope with variables.
             * @param {Object} math     Math.js namespace with functions and constants.
             * @param {Object} argNames An object with argument names as key and `true`
             *                          as value. Used in the SymbolNode to optimize
             *                          for arguments from user assigned functions
             *                          (see FunctionAssignmentNode) or special symbols
             *                          like `end` (see IndexNode).
             * @return {function} Returns a function which can be called like:
             *                        evalNode(scope: Object, args: Object, context: *)
             */
          }, {
            key: "_compile",
            value: function _compile(math, argNames) {
              var range = math.range;
              var evalStart = this.start._compile(math, argNames);
              var evalEnd = this.end._compile(math, argNames);
              if (this.step) {
                var evalStep = this.step._compile(math, argNames);
                return function evalRangeNode(scope, args, context) {
                  return range(evalStart(scope, args, context), evalEnd(scope, args, context), evalStep(scope, args, context));
                };
              } else {
                return function evalRangeNode(scope, args, context) {
                  return range(evalStart(scope, args, context), evalEnd(scope, args, context));
                };
              }
            }
            /**
             * Execute a callback for each of the child nodes of this node
             * @param {function(child: Node, path: string, parent: Node)} callback
             */
          }, {
            key: "forEach",
            value: function forEach(callback) {
              callback(this.start, "start", this);
              callback(this.end, "end", this);
              if (this.step) {
                callback(this.step, "step", this);
              }
            }
            /**
             * Create a new RangeNode whose children are the results of calling
             * the provided callback function for each child of the original node.
             * @param {function(child: Node, path: string, parent: Node): Node} callback
             * @returns {RangeNode} Returns a transformed copy of the node
             */
          }, {
            key: "map",
            value: function map(callback) {
              return new RangeNode2(this._ifNode(callback(this.start, "start", this)), this._ifNode(callback(this.end, "end", this)), this.step && this._ifNode(callback(this.step, "step", this)));
            }
            /**
             * Create a clone of this node, a shallow copy
             * @return {RangeNode}
             */
          }, {
            key: "clone",
            value: function clone4() {
              return new RangeNode2(this.start, this.end, this.step && this.step);
            }
            /**
             * Get string representation
             * @param {Object} options
             * @return {string} str
             */
          }, {
            key: "_toString",
            value: function _toString(options) {
              var parenthesis = options && options.parenthesis ? options.parenthesis : "keep";
              var parens = calculateNecessaryParentheses(this, parenthesis, options && options.implicit);
              var str;
              var start = this.start.toString(options);
              if (parens.start) {
                start = "(" + start + ")";
              }
              str = start;
              if (this.step) {
                var step = this.step.toString(options);
                if (parens.step) {
                  step = "(" + step + ")";
                }
                str += ":" + step;
              }
              var end = this.end.toString(options);
              if (parens.end) {
                end = "(" + end + ")";
              }
              str += ":" + end;
              return str;
            }
            /**
             * Get a JSON representation of the node
             * @returns {Object}
             */
          }, {
            key: "toJSON",
            value: function toJSON() {
              return {
                mathjs: name18,
                start: this.start,
                end: this.end,
                step: this.step
              };
            }
            /**
             * Instantiate an RangeNode from its JSON representation
             * @param {Object} json
             *     An object structured like
             *     `{"mathjs": "RangeNode", "start": ..., "end": ..., "step": ...}`,
             *     where mathjs is optional
             * @returns {RangeNode}
             */
          }, {
            key: "_toHTML",
            value: (
              /**
               * Get HTML representation
               * @param {Object} options
               * @return {string} str
               */
              function _toHTML(options) {
                var parenthesis = options && options.parenthesis ? options.parenthesis : "keep";
                var parens = calculateNecessaryParentheses(this, parenthesis, options && options.implicit);
                var str;
                var start = this.start.toHTML(options);
                if (parens.start) {
                  start = '<span class="math-parenthesis math-round-parenthesis">(</span>' + start + '<span class="math-parenthesis math-round-parenthesis">)</span>';
                }
                str = start;
                if (this.step) {
                  var step = this.step.toHTML(options);
                  if (parens.step) {
                    step = '<span class="math-parenthesis math-round-parenthesis">(</span>' + step + '<span class="math-parenthesis math-round-parenthesis">)</span>';
                  }
                  str += '<span class="math-operator math-range-operator">:</span>' + step;
                }
                var end = this.end.toHTML(options);
                if (parens.end) {
                  end = '<span class="math-parenthesis math-round-parenthesis">(</span>' + end + '<span class="math-parenthesis math-round-parenthesis">)</span>';
                }
                str += '<span class="math-operator math-range-operator">:</span>' + end;
                return str;
              }
            )
            /**
             * Get LaTeX representation
             * @params {Object} options
             * @return {string} str
             */
          }, {
            key: "_toTex",
            value: function _toTex(options) {
              var parenthesis = options && options.parenthesis ? options.parenthesis : "keep";
              var parens = calculateNecessaryParentheses(this, parenthesis, options && options.implicit);
              var str = this.start.toTex(options);
              if (parens.start) {
                str = "\\left(".concat(str, "\\right)");
              }
              if (this.step) {
                var step = this.step.toTex(options);
                if (parens.step) {
                  step = "\\left(".concat(step, "\\right)");
                }
                str += ":" + step;
              }
              var end = this.end.toTex(options);
              if (parens.end) {
                end = "\\left(".concat(end, "\\right)");
              }
              str += ":" + end;
              return str;
            }
          }], [{
            key: "fromJSON",
            value: function fromJSON(json) {
              return new RangeNode2(json.start, json.end, json.step);
            }
          }]);
        })(Node);
        (0, _defineProperty2["default"])(RangeNode, "name", name18);
        return RangeNode;
      }, {
        isClass: true,
        isNode: true
      });
    }
  });

  // node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/expression/node/RelationalNode.js
  var require_RelationalNode = __commonJS({
    "node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/expression/node/RelationalNode.js"(exports) {
      "use strict";
      var _interopRequireDefault = require_interopRequireDefault();
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.createRelationalNode = void 0;
      var _classCallCheck2 = _interopRequireDefault(require_classCallCheck());
      var _createClass2 = _interopRequireDefault(require_createClass());
      var _possibleConstructorReturn2 = _interopRequireDefault(require_possibleConstructorReturn());
      var _getPrototypeOf2 = _interopRequireDefault(require_getPrototypeOf());
      var _inherits2 = _interopRequireDefault(require_inherits());
      var _defineProperty2 = _interopRequireDefault(require_defineProperty());
      var _operators = require_operators();
      var _string = require_string();
      var _customs = require_customs();
      var _latex = require_latex();
      var _factory = require_factory();
      function _callSuper(t, o, e) {
        return o = (0, _getPrototypeOf2["default"])(o), (0, _possibleConstructorReturn2["default"])(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], (0, _getPrototypeOf2["default"])(t).constructor) : o.apply(t, e));
      }
      function _isNativeReflectConstruct() {
        try {
          var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
          }));
        } catch (t2) {
        }
        return (_isNativeReflectConstruct = function _isNativeReflectConstruct2() {
          return !!t;
        })();
      }
      var name18 = "RelationalNode";
      var dependencies19 = ["Node"];
      var createRelationalNode = exports.createRelationalNode = /* @__PURE__ */ (0, _factory.factory)(name18, dependencies19, function(_ref) {
        var Node = _ref.Node;
        var operatorMap = {
          equal: "==",
          unequal: "!=",
          smaller: "<",
          larger: ">",
          smallerEq: "<=",
          largerEq: ">="
        };
        var RelationalNode = /* @__PURE__ */ (function(_Node) {
          function RelationalNode2(conditionals, params) {
            var _this;
            (0, _classCallCheck2["default"])(this, RelationalNode2);
            _this = _callSuper(this, RelationalNode2);
            if (!Array.isArray(conditionals)) {
              throw new TypeError("Parameter conditionals must be an array");
            }
            if (!Array.isArray(params)) {
              throw new TypeError("Parameter params must be an array");
            }
            if (conditionals.length !== params.length - 1) {
              throw new TypeError("Parameter params must contain exactly one more element than parameter conditionals");
            }
            _this.conditionals = conditionals;
            _this.params = params;
            return _this;
          }
          (0, _inherits2["default"])(RelationalNode2, _Node);
          return (0, _createClass2["default"])(RelationalNode2, [{
            key: "type",
            get: function get() {
              return name18;
            }
          }, {
            key: "isRelationalNode",
            get: function get() {
              return true;
            }
            /**
             * Compile a node into a JavaScript function.
             * This basically pre-calculates as much as possible and only leaves open
             * calculations which depend on a dynamic scope with variables.
             * @param {Object} math     Math.js namespace with functions and constants.
             * @param {Object} argNames An object with argument names as key and `true`
             *                          as value. Used in the SymbolNode to optimize
             *                          for arguments from user assigned functions
             *                          (see FunctionAssignmentNode) or special symbols
             *                          like `end` (see IndexNode).
             * @return {function} Returns a function which can be called like:
             *                        evalNode(scope: Object, args: Object, context: *)
             */
          }, {
            key: "_compile",
            value: function _compile(math, argNames) {
              var self2 = this;
              var compiled = this.params.map(function(p) {
                return p._compile(math, argNames);
              });
              return function evalRelationalNode(scope, args, context) {
                var evalLhs;
                var evalRhs = compiled[0](scope, args, context);
                for (var i = 0; i < self2.conditionals.length; i++) {
                  evalLhs = evalRhs;
                  evalRhs = compiled[i + 1](scope, args, context);
                  var condFn = (0, _customs.getSafeProperty)(math, self2.conditionals[i]);
                  if (!condFn(evalLhs, evalRhs)) {
                    return false;
                  }
                }
                return true;
              };
            }
            /**
             * Execute a callback for each of the child nodes of this node
             * @param {function(child: Node, path: string, parent: Node)} callback
             */
          }, {
            key: "forEach",
            value: function forEach(callback) {
              var _this2 = this;
              this.params.forEach(function(n, i) {
                return callback(n, "params[" + i + "]", _this2);
              }, this);
            }
            /**
             * Create a new RelationalNode whose children are the results of calling
             * the provided callback function for each child of the original node.
             * @param {function(child: Node, path: string, parent: Node): Node} callback
             * @returns {RelationalNode} Returns a transformed copy of the node
             */
          }, {
            key: "map",
            value: function map(callback) {
              var _this3 = this;
              return new RelationalNode2(this.conditionals.slice(), this.params.map(function(n, i) {
                return _this3._ifNode(callback(n, "params[" + i + "]", _this3));
              }, this));
            }
            /**
             * Create a clone of this node, a shallow copy
             * @return {RelationalNode}
             */
          }, {
            key: "clone",
            value: function clone4() {
              return new RelationalNode2(this.conditionals, this.params);
            }
            /**
             * Get string representation.
             * @param {Object} options
             * @return {string} str
             */
          }, {
            key: "_toString",
            value: function _toString(options) {
              var parenthesis = options && options.parenthesis ? options.parenthesis : "keep";
              var precedence = (0, _operators.getPrecedence)(this, parenthesis, options && options.implicit);
              var paramStrings = this.params.map(function(p, index) {
                var paramPrecedence = (0, _operators.getPrecedence)(p, parenthesis, options && options.implicit);
                return parenthesis === "all" || paramPrecedence !== null && paramPrecedence <= precedence ? "(" + p.toString(options) + ")" : p.toString(options);
              });
              var ret = paramStrings[0];
              for (var i = 0; i < this.conditionals.length; i++) {
                ret += " " + operatorMap[this.conditionals[i]];
                ret += " " + paramStrings[i + 1];
              }
              return ret;
            }
            /**
             * Get a JSON representation of the node
             * @returns {Object}
             */
          }, {
            key: "toJSON",
            value: function toJSON() {
              return {
                mathjs: name18,
                conditionals: this.conditionals,
                params: this.params
              };
            }
            /**
             * Instantiate a RelationalNode from its JSON representation
             * @param {Object} json
             *     An object structured like
             *     `{"mathjs": "RelationalNode", "conditionals": ..., "params": ...}`,
             *     where mathjs is optional
             * @returns {RelationalNode}
             */
          }, {
            key: "_toHTML",
            value: (
              /**
               * Get HTML representation
               * @param {Object} options
               * @return {string} str
               */
              function _toHTML(options) {
                var parenthesis = options && options.parenthesis ? options.parenthesis : "keep";
                var precedence = (0, _operators.getPrecedence)(this, parenthesis, options && options.implicit);
                var paramStrings = this.params.map(function(p, index) {
                  var paramPrecedence = (0, _operators.getPrecedence)(p, parenthesis, options && options.implicit);
                  return parenthesis === "all" || paramPrecedence !== null && paramPrecedence <= precedence ? '<span class="math-parenthesis math-round-parenthesis">(</span>' + p.toHTML(options) + '<span class="math-parenthesis math-round-parenthesis">)</span>' : p.toHTML(options);
                });
                var ret = paramStrings[0];
                for (var i = 0; i < this.conditionals.length; i++) {
                  ret += '<span class="math-operator math-binary-operator math-explicit-binary-operator">' + (0, _string.escape)(operatorMap[this.conditionals[i]]) + "</span>" + paramStrings[i + 1];
                }
                return ret;
              }
            )
            /**
             * Get LaTeX representation
             * @param {Object} options
             * @return {string} str
             */
          }, {
            key: "_toTex",
            value: function _toTex(options) {
              var parenthesis = options && options.parenthesis ? options.parenthesis : "keep";
              var precedence = (0, _operators.getPrecedence)(this, parenthesis, options && options.implicit);
              var paramStrings = this.params.map(function(p, index) {
                var paramPrecedence = (0, _operators.getPrecedence)(p, parenthesis, options && options.implicit);
                return parenthesis === "all" || paramPrecedence !== null && paramPrecedence <= precedence ? "\\left(" + p.toTex(options) + "\right)" : p.toTex(options);
              });
              var ret = paramStrings[0];
              for (var i = 0; i < this.conditionals.length; i++) {
                ret += _latex.latexOperators[this.conditionals[i]] + paramStrings[i + 1];
              }
              return ret;
            }
          }], [{
            key: "fromJSON",
            value: function fromJSON(json) {
              return new RelationalNode2(json.conditionals, json.params);
            }
          }]);
        })(Node);
        (0, _defineProperty2["default"])(RelationalNode, "name", name18);
        return RelationalNode;
      }, {
        isClass: true,
        isNode: true
      });
    }
  });

  // node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/expression/node/SymbolNode.js
  var require_SymbolNode = __commonJS({
    "node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/expression/node/SymbolNode.js"(exports) {
      "use strict";
      var _interopRequireDefault = require_interopRequireDefault();
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.createSymbolNode = void 0;
      var _classCallCheck2 = _interopRequireDefault(require_classCallCheck());
      var _createClass2 = _interopRequireDefault(require_createClass());
      var _possibleConstructorReturn2 = _interopRequireDefault(require_possibleConstructorReturn());
      var _getPrototypeOf2 = _interopRequireDefault(require_getPrototypeOf());
      var _inherits2 = _interopRequireDefault(require_inherits());
      var _string = require_string();
      var _customs = require_customs();
      var _factory = require_factory();
      var _latex = require_latex();
      function _callSuper(t, o, e) {
        return o = (0, _getPrototypeOf2["default"])(o), (0, _possibleConstructorReturn2["default"])(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], (0, _getPrototypeOf2["default"])(t).constructor) : o.apply(t, e));
      }
      function _isNativeReflectConstruct() {
        try {
          var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
          }));
        } catch (t2) {
        }
        return (_isNativeReflectConstruct = function _isNativeReflectConstruct2() {
          return !!t;
        })();
      }
      var name18 = "SymbolNode";
      var dependencies19 = ["math", "?Unit", "Node"];
      var createSymbolNode = exports.createSymbolNode = /* @__PURE__ */ (0, _factory.factory)(name18, dependencies19, function(_ref) {
        var math = _ref.math, Unit = _ref.Unit, Node = _ref.Node;
        function isValuelessUnit(name19) {
          return Unit ? Unit.isValuelessUnit(name19) : false;
        }
        var SymbolNode = /* @__PURE__ */ (function(_Node) {
          function SymbolNode2(name19) {
            var _this;
            (0, _classCallCheck2["default"])(this, SymbolNode2);
            _this = _callSuper(this, SymbolNode2);
            if (typeof name19 !== "string") {
              throw new TypeError('String expected for parameter "name"');
            }
            _this.name = name19;
            return _this;
          }
          (0, _inherits2["default"])(SymbolNode2, _Node);
          return (0, _createClass2["default"])(SymbolNode2, [{
            key: "type",
            get: function get() {
              return "SymbolNode";
            }
          }, {
            key: "isSymbolNode",
            get: function get() {
              return true;
            }
            /**
             * Compile a node into a JavaScript function.
             * This basically pre-calculates as much as possible and only leaves open
             * calculations which depend on a dynamic scope with variables.
             * @param {Object} math     Math.js namespace with functions and constants.
             * @param {Object} argNames An object with argument names as key and `true`
             *                          as value. Used in the SymbolNode to optimize
             *                          for arguments from user assigned functions
             *                          (see FunctionAssignmentNode) or special symbols
             *                          like `end` (see IndexNode).
             * @return {function} Returns a function which can be called like:
             *                        evalNode(scope: Object, args: Object, context: *)
             */
          }, {
            key: "_compile",
            value: function _compile(math2, argNames) {
              var name19 = this.name;
              if (argNames[name19] === true) {
                return function(scope, args, context) {
                  return (0, _customs.getSafeProperty)(args, name19);
                };
              } else if (name19 in math2) {
                return function(scope, args, context) {
                  return scope.has(name19) ? scope.get(name19) : (0, _customs.getSafeProperty)(math2, name19);
                };
              } else {
                var isUnit2 = isValuelessUnit(name19);
                return function(scope, args, context) {
                  return scope.has(name19) ? scope.get(name19) : isUnit2 ? new Unit(null, name19) : SymbolNode2.onUndefinedSymbol(name19);
                };
              }
            }
            /**
             * Execute a callback for each of the child nodes of this node
             * @param {function(child: Node, path: string, parent: Node)} callback
             */
          }, {
            key: "forEach",
            value: function forEach(callback) {
            }
            /**
             * Create a new SymbolNode with children produced by the given callback.
             * Trivial since a SymbolNode has no children
             * @param {function(child: Node, path: string, parent: Node) : Node} callback
             * @returns {SymbolNode} Returns a clone of the node
             */
          }, {
            key: "map",
            value: function map(callback) {
              return this.clone();
            }
            /**
             * Throws an error 'Undefined symbol {name}'
             * @param {string} name
             */
          }, {
            key: "clone",
            value: (
              /**
               * Create a clone of this node, a shallow copy
               * @return {SymbolNode}
               */
              function clone4() {
                return new SymbolNode2(this.name);
              }
            )
            /**
             * Get string representation
             * @param {Object} options
             * @return {string} str
             * @override
             */
          }, {
            key: "_toString",
            value: function _toString(options) {
              return this.name;
            }
            /**
             * Get HTML representation
             * @param {Object} options
             * @return {string} str
             * @override
             */
          }, {
            key: "_toHTML",
            value: function _toHTML(options) {
              var name19 = (0, _string.escape)(this.name);
              if (name19 === "true" || name19 === "false") {
                return '<span class="math-symbol math-boolean">' + name19 + "</span>";
              } else if (name19 === "i") {
                return '<span class="math-symbol math-imaginary-symbol">' + name19 + "</span>";
              } else if (name19 === "Infinity") {
                return '<span class="math-symbol math-infinity-symbol">' + name19 + "</span>";
              } else if (name19 === "NaN") {
                return '<span class="math-symbol math-nan-symbol">' + name19 + "</span>";
              } else if (name19 === "null") {
                return '<span class="math-symbol math-null-symbol">' + name19 + "</span>";
              } else if (name19 === "undefined") {
                return '<span class="math-symbol math-undefined-symbol">' + name19 + "</span>";
              }
              return '<span class="math-symbol">' + name19 + "</span>";
            }
            /**
             * Get a JSON representation of the node
             * @returns {Object}
             */
          }, {
            key: "toJSON",
            value: function toJSON() {
              return {
                mathjs: "SymbolNode",
                name: this.name
              };
            }
            /**
             * Instantiate a SymbolNode from its JSON representation
             * @param {Object} json  An object structured like
             *                       `{"mathjs": "SymbolNode", name: "x"}`,
             *                       where mathjs is optional
             * @returns {SymbolNode}
             */
          }, {
            key: "_toTex",
            value: (
              /**
               * Get LaTeX representation
               * @param {Object} options
               * @return {string} str
               * @override
               */
              function _toTex(options) {
                var isUnit2 = false;
                if (typeof math[this.name] === "undefined" && isValuelessUnit(this.name)) {
                  isUnit2 = true;
                }
                var symbol = (0, _latex.toSymbol)(this.name, isUnit2);
                if (symbol[0] === "\\") {
                  return symbol;
                }
                return " " + symbol;
              }
            )
          }], [{
            key: "onUndefinedSymbol",
            value: function onUndefinedSymbol(name19) {
              throw new Error("Undefined symbol " + name19);
            }
          }, {
            key: "fromJSON",
            value: function fromJSON(json) {
              return new SymbolNode2(json.name);
            }
          }]);
        })(Node);
        return SymbolNode;
      }, {
        isClass: true,
        isNode: true
      });
    }
  });

  // node_modules/.pnpm/@babel+runtime@7.28.4/node_modules/@babel/runtime/helpers/superPropBase.js
  var require_superPropBase = __commonJS({
    "node_modules/.pnpm/@babel+runtime@7.28.4/node_modules/@babel/runtime/helpers/superPropBase.js"(exports, module) {
      var getPrototypeOf = require_getPrototypeOf();
      function _superPropBase(t, o) {
        for (; !{}.hasOwnProperty.call(t, o) && null !== (t = getPrototypeOf(t)); ) ;
        return t;
      }
      module.exports = _superPropBase, module.exports.__esModule = true, module.exports["default"] = module.exports;
    }
  });

  // node_modules/.pnpm/@babel+runtime@7.28.4/node_modules/@babel/runtime/helpers/get.js
  var require_get = __commonJS({
    "node_modules/.pnpm/@babel+runtime@7.28.4/node_modules/@babel/runtime/helpers/get.js"(exports, module) {
      var superPropBase = require_superPropBase();
      function _get() {
        return module.exports = _get = "undefined" != typeof Reflect && Reflect.get ? Reflect.get.bind() : function(e, t, r) {
          var p = superPropBase(e, t);
          if (p) {
            var n = Object.getOwnPropertyDescriptor(p, t);
            return n.get ? n.get.call(arguments.length < 3 ? e : r) : n.value;
          }
        }, module.exports.__esModule = true, module.exports["default"] = module.exports, _get.apply(null, arguments);
      }
      module.exports = _get, module.exports.__esModule = true, module.exports["default"] = module.exports;
    }
  });

  // node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/expression/node/FunctionNode.js
  var require_FunctionNode = __commonJS({
    "node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/expression/node/FunctionNode.js"(exports) {
      "use strict";
      var _interopRequireDefault = require_interopRequireDefault();
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.createFunctionNode = void 0;
      var _toConsumableArray2 = _interopRequireDefault(require_toConsumableArray());
      var _classCallCheck2 = _interopRequireDefault(require_classCallCheck());
      var _createClass2 = _interopRequireDefault(require_createClass());
      var _possibleConstructorReturn2 = _interopRequireDefault(require_possibleConstructorReturn());
      var _get2 = _interopRequireDefault(require_get());
      var _getPrototypeOf2 = _interopRequireDefault(require_getPrototypeOf());
      var _inherits2 = _interopRequireDefault(require_inherits());
      var _defineProperty2 = _interopRequireDefault(require_defineProperty());
      var _typeof2 = _interopRequireDefault(require_typeof());
      var _is = require_is();
      var _string = require_string();
      var _object = require_object();
      var _customs = require_customs();
      var _scope = require_scope();
      var _factory = require_factory();
      var _latex = require_latex();
      function _callSuper(t, o, e) {
        return o = (0, _getPrototypeOf2["default"])(o), (0, _possibleConstructorReturn2["default"])(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], (0, _getPrototypeOf2["default"])(t).constructor) : o.apply(t, e));
      }
      function _isNativeReflectConstruct() {
        try {
          var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
          }));
        } catch (t2) {
        }
        return (_isNativeReflectConstruct = function _isNativeReflectConstruct2() {
          return !!t;
        })();
      }
      var name18 = "FunctionNode";
      var dependencies19 = ["math", "Node", "SymbolNode"];
      var createFunctionNode = exports.createFunctionNode = /* @__PURE__ */ (0, _factory.factory)(name18, dependencies19, function(_ref) {
        var _FunctionNode;
        var math = _ref.math, Node = _ref.Node, SymbolNode = _ref.SymbolNode;
        var strin = function strin2(entity) {
          return (0, _string.format)(entity, {
            truncate: 78
          });
        };
        function expandTemplate(template, node, options) {
          var latex = "";
          var regex = /\$(?:\{([a-z_][a-z_0-9]*)(?:\[([0-9]+)\])?\}|\$)/gi;
          var inputPos = 0;
          var match;
          while ((match = regex.exec(template)) !== null) {
            latex += template.substring(inputPos, match.index);
            inputPos = match.index;
            if (match[0] === "$$") {
              latex += "$";
              inputPos++;
            } else {
              inputPos += match[0].length;
              var property = node[match[1]];
              if (!property) {
                throw new ReferenceError("Template: Property " + match[1] + " does not exist.");
              }
              if (match[2] === void 0) {
                switch ((0, _typeof2["default"])(property)) {
                  case "string":
                    latex += property;
                    break;
                  case "object":
                    if ((0, _is.isNode)(property)) {
                      latex += property.toTex(options);
                    } else if (Array.isArray(property)) {
                      latex += property.map(function(arg, index) {
                        if ((0, _is.isNode)(arg)) {
                          return arg.toTex(options);
                        }
                        throw new TypeError("Template: " + match[1] + "[" + index + "] is not a Node.");
                      }).join(",");
                    } else {
                      throw new TypeError("Template: " + match[1] + " has to be a Node, String or array of Nodes");
                    }
                    break;
                  default:
                    throw new TypeError("Template: " + match[1] + " has to be a Node, String or array of Nodes");
                }
              } else {
                if ((0, _is.isNode)(property[match[2]] && property[match[2]])) {
                  latex += property[match[2]].toTex(options);
                } else {
                  throw new TypeError("Template: " + match[1] + "[" + match[2] + "] is not a Node.");
                }
              }
            }
          }
          latex += template.slice(inputPos);
          return latex;
        }
        var FunctionNode = /* @__PURE__ */ (function(_Node) {
          function FunctionNode2(fn, args) {
            var _this;
            (0, _classCallCheck2["default"])(this, FunctionNode2);
            _this = _callSuper(this, FunctionNode2);
            if (typeof fn === "string") {
              fn = new SymbolNode(fn);
            }
            if (!(0, _is.isNode)(fn)) throw new TypeError('Node expected as parameter "fn"');
            if (!Array.isArray(args) || !args.every(_is.isNode)) {
              throw new TypeError('Array containing Nodes expected for parameter "args"');
            }
            _this.fn = fn;
            _this.args = args || [];
            return _this;
          }
          (0, _inherits2["default"])(FunctionNode2, _Node);
          return (0, _createClass2["default"])(FunctionNode2, [{
            key: "name",
            get: function get() {
              return this.fn.name || "";
            }
          }, {
            key: "type",
            get: function get() {
              return name18;
            }
          }, {
            key: "isFunctionNode",
            get: function get() {
              return true;
            }
            /**
             * Compile a node into a JavaScript function.
             * This basically pre-calculates as much as possible and only leaves open
             * calculations which depend on a dynamic scope with variables.
             * @param {Object} math     Math.js namespace with functions and constants.
             * @param {Object} argNames An object with argument names as key and `true`
             *                          as value. Used in the SymbolNode to optimize
             *                          for arguments from user assigned functions
             *                          (see FunctionAssignmentNode) or special symbols
             *                          like `end` (see IndexNode).
             * @return {function} Returns a function which can be called like:
             *                        evalNode(scope: Object, args: Object, context: *)
             */
          }, {
            key: "_compile",
            value: function _compile(math2, argNames) {
              var evalArgs = this.args.map(function(arg) {
                return arg._compile(math2, argNames);
              });
              if ((0, _is.isSymbolNode)(this.fn)) {
                var _name = this.fn.name;
                if (!argNames[_name]) {
                  var fn = _name in math2 ? (0, _customs.getSafeProperty)(math2, _name) : void 0;
                  var isRaw = typeof fn === "function" && fn.rawArgs === true;
                  var resolveFn = function resolveFn2(scope) {
                    var value;
                    if (scope.has(_name)) {
                      value = scope.get(_name);
                    } else if (_name in math2) {
                      value = (0, _customs.getSafeProperty)(math2, _name);
                    } else {
                      return FunctionNode2.onUndefinedFunction(_name);
                    }
                    if (typeof value === "function") {
                      return value;
                    }
                    throw new TypeError("'".concat(_name, "' is not a function; its value is:\n  ").concat(strin(value)));
                  };
                  if (isRaw) {
                    var rawArgs = this.args;
                    return function evalFunctionNode(scope, args, context) {
                      var fn2 = resolveFn(scope);
                      return fn2(rawArgs, math2, (0, _scope.createSubScope)(scope, args));
                    };
                  } else {
                    switch (evalArgs.length) {
                      case 0:
                        return function evalFunctionNode(scope, args, context) {
                          var fn2 = resolveFn(scope);
                          return fn2();
                        };
                      case 1:
                        return function evalFunctionNode(scope, args, context) {
                          var fn2 = resolveFn(scope);
                          var evalArg0 = evalArgs[0];
                          return fn2(evalArg0(scope, args, context));
                        };
                      case 2:
                        return function evalFunctionNode(scope, args, context) {
                          var fn2 = resolveFn(scope);
                          var evalArg0 = evalArgs[0];
                          var evalArg1 = evalArgs[1];
                          return fn2(evalArg0(scope, args, context), evalArg1(scope, args, context));
                        };
                      default:
                        return function evalFunctionNode(scope, args, context) {
                          var fn2 = resolveFn(scope);
                          var values = evalArgs.map(function(evalArg) {
                            return evalArg(scope, args, context);
                          });
                          return fn2.apply(void 0, (0, _toConsumableArray2["default"])(values));
                        };
                    }
                  }
                } else {
                  var _rawArgs = this.args;
                  return function evalFunctionNode(scope, args, context) {
                    var fn2 = (0, _customs.getSafeProperty)(args, _name);
                    if (typeof fn2 !== "function") {
                      throw new TypeError("Argument '".concat(_name, "' was not a function; received: ").concat(strin(fn2)));
                    }
                    if (fn2.rawArgs) {
                      return fn2(_rawArgs, math2, (0, _scope.createSubScope)(scope, args));
                    } else {
                      var values = evalArgs.map(function(evalArg) {
                        return evalArg(scope, args, context);
                      });
                      return fn2.apply(fn2, values);
                    }
                  };
                }
              } else if ((0, _is.isAccessorNode)(this.fn) && (0, _is.isIndexNode)(this.fn.index) && this.fn.index.isObjectProperty()) {
                var evalObject = this.fn.object._compile(math2, argNames);
                var prop = this.fn.index.getObjectProperty();
                var _rawArgs2 = this.args;
                return function evalFunctionNode(scope, args, context) {
                  var object = evalObject(scope, args, context);
                  var fn2 = (0, _customs.getSafeMethod)(object, prop);
                  if (fn2 !== null && fn2 !== void 0 && fn2.rawArgs) {
                    return fn2(_rawArgs2, math2, (0, _scope.createSubScope)(scope, args));
                  } else {
                    var values = evalArgs.map(function(evalArg) {
                      return evalArg(scope, args, context);
                    });
                    return fn2.apply(object, values);
                  }
                };
              } else {
                var fnExpr = this.fn.toString();
                var evalFn = this.fn._compile(math2, argNames);
                var _rawArgs3 = this.args;
                return function evalFunctionNode(scope, args, context) {
                  var fn2 = evalFn(scope, args, context);
                  if (typeof fn2 !== "function") {
                    throw new TypeError("Expression '".concat(fnExpr, "' did not evaluate to a function; value is:") + "\n  ".concat(strin(fn2)));
                  }
                  if (fn2.rawArgs) {
                    return fn2(_rawArgs3, math2, (0, _scope.createSubScope)(scope, args));
                  } else {
                    var values = evalArgs.map(function(evalArg) {
                      return evalArg(scope, args, context);
                    });
                    return fn2.apply(fn2, values);
                  }
                };
              }
            }
            /**
             * Execute a callback for each of the child nodes of this node
             * @param {function(child: Node, path: string, parent: Node)} callback
             */
          }, {
            key: "forEach",
            value: function forEach(callback) {
              callback(this.fn, "fn", this);
              for (var i = 0; i < this.args.length; i++) {
                callback(this.args[i], "args[" + i + "]", this);
              }
            }
            /**
             * Create a new FunctionNode whose children are the results of calling
             * the provided callback function for each child of the original node.
             * @param {function(child: Node, path: string, parent: Node): Node} callback
             * @returns {FunctionNode} Returns a transformed copy of the node
             */
          }, {
            key: "map",
            value: function map(callback) {
              var fn = this._ifNode(callback(this.fn, "fn", this));
              var args = [];
              for (var i = 0; i < this.args.length; i++) {
                args[i] = this._ifNode(callback(this.args[i], "args[" + i + "]", this));
              }
              return new FunctionNode2(fn, args);
            }
            /**
             * Create a clone of this node, a shallow copy
             * @return {FunctionNode}
             */
          }, {
            key: "clone",
            value: function clone4() {
              return new FunctionNode2(this.fn, this.args.slice(0));
            }
            /**
             * Throws an error 'Undefined function {name}'
             * @param {string} name
             */
          }, {
            key: "toString",
            value: (
              /**
               * Get string representation. (wrapper function)
               * This overrides parts of Node's toString function.
               * If callback is an object containing callbacks, it
               * calls the correct callback for the current node,
               * otherwise it falls back to calling Node's toString
               * function.
               *
               * @param {Object} options
               * @return {string} str
               * @override
               */
              function toString(options) {
                var customString;
                var name19 = this.fn.toString(options);
                if (options && (0, _typeof2["default"])(options.handler) === "object" && (0, _object.hasOwnProperty)(options.handler, name19)) {
                  customString = options.handler[name19](this, options);
                }
                if (typeof customString !== "undefined") {
                  return customString;
                }
                return (0, _get2["default"])((0, _getPrototypeOf2["default"])(FunctionNode2.prototype), "toString", this).call(this, options);
              }
            )
            /**
             * Get string representation
             * @param {Object} options
             * @return {string} str
             */
          }, {
            key: "_toString",
            value: function _toString(options) {
              var args = this.args.map(function(arg) {
                return arg.toString(options);
              });
              var fn = (0, _is.isFunctionAssignmentNode)(this.fn) ? "(" + this.fn.toString(options) + ")" : this.fn.toString(options);
              return fn + "(" + args.join(", ") + ")";
            }
            /**
             * Get a JSON representation of the node
             * @returns {Object}
             */
          }, {
            key: "toJSON",
            value: function toJSON() {
              return {
                mathjs: name18,
                fn: this.fn,
                args: this.args
              };
            }
            /**
             * Instantiate an AssignmentNode from its JSON representation
             * @param {Object} json  An object structured like
             *                       `{"mathjs": "FunctionNode", fn: ..., args: ...}`,
             *                       where mathjs is optional
             * @returns {FunctionNode}
             */
          }, {
            key: "_toHTML",
            value: (
              /**
               * Get HTML representation
               * @param {Object} options
               * @return {string} str
               */
              function _toHTML(options) {
                var args = this.args.map(function(arg) {
                  return arg.toHTML(options);
                });
                return '<span class="math-function">' + (0, _string.escape)(this.fn) + '</span><span class="math-paranthesis math-round-parenthesis">(</span>' + args.join('<span class="math-separator">,</span>') + '<span class="math-paranthesis math-round-parenthesis">)</span>';
              }
            )
            /**
             * Get LaTeX representation. (wrapper function)
             * This overrides parts of Node's toTex function.
             * If callback is an object containing callbacks, it
             * calls the correct callback for the current node,
             * otherwise it falls back to calling Node's toTex
             * function.
             *
             * @param {Object} options
             * @return {string}
             */
          }, {
            key: "toTex",
            value: function toTex(options) {
              var customTex;
              if (options && (0, _typeof2["default"])(options.handler) === "object" && (0, _object.hasOwnProperty)(options.handler, this.name)) {
                customTex = options.handler[this.name](this, options);
              }
              if (typeof customTex !== "undefined") {
                return customTex;
              }
              return (0, _get2["default"])((0, _getPrototypeOf2["default"])(FunctionNode2.prototype), "toTex", this).call(this, options);
            }
            /**
             * Get LaTeX representation
             * @param {Object} options
             * @return {string} str
             */
          }, {
            key: "_toTex",
            value: function _toTex(options) {
              var args = this.args.map(function(arg) {
                return arg.toTex(options);
              });
              var latexConverter;
              if (_latex.latexFunctions[this.name]) {
                latexConverter = _latex.latexFunctions[this.name];
              }
              if (math[this.name] && (typeof math[this.name].toTex === "function" || (0, _typeof2["default"])(math[this.name].toTex) === "object" || typeof math[this.name].toTex === "string")) {
                latexConverter = math[this.name].toTex;
              }
              var customToTex;
              switch ((0, _typeof2["default"])(latexConverter)) {
                case "function":
                  customToTex = latexConverter(this, options);
                  break;
                case "string":
                  customToTex = expandTemplate(latexConverter, this, options);
                  break;
                case "object":
                  switch ((0, _typeof2["default"])(latexConverter[args.length])) {
                    case "function":
                      customToTex = latexConverter[args.length](this, options);
                      break;
                    case "string":
                      customToTex = expandTemplate(latexConverter[args.length], this, options);
                      break;
                  }
              }
              if (typeof customToTex !== "undefined") {
                return customToTex;
              }
              return expandTemplate(_latex.defaultTemplate, this, options);
            }
            /**
             * Get identifier.
             * @return {string}
             */
          }, {
            key: "getIdentifier",
            value: function getIdentifier() {
              return this.type + ":" + this.name;
            }
          }]);
        })(Node);
        _FunctionNode = FunctionNode;
        (0, _defineProperty2["default"])(FunctionNode, "name", name18);
        (0, _defineProperty2["default"])(FunctionNode, "onUndefinedFunction", function(name19) {
          throw new Error("Undefined function " + name19);
        });
        (0, _defineProperty2["default"])(FunctionNode, "fromJSON", function(json) {
          return new _FunctionNode(json.fn, json.args);
        });
        return FunctionNode;
      }, {
        isClass: true,
        isNode: true
      });
    }
  });

  // node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/expression/parse.js
  var require_parse = __commonJS({
    "node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/expression/parse.js"(exports) {
      "use strict";
      var _interopRequireDefault = require_interopRequireDefault();
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.createParse = void 0;
      var _extends2 = _interopRequireDefault(require_extends());
      var _factory = require_factory();
      var _is = require_is();
      var _collection = require_collection();
      var _object = require_object();
      var name18 = "parse";
      var dependencies19 = ["typed", "numeric", "config", "AccessorNode", "ArrayNode", "AssignmentNode", "BlockNode", "ConditionalNode", "ConstantNode", "FunctionAssignmentNode", "FunctionNode", "IndexNode", "ObjectNode", "OperatorNode", "ParenthesisNode", "RangeNode", "RelationalNode", "SymbolNode"];
      var createParse = exports.createParse = /* @__PURE__ */ (0, _factory.factory)(name18, dependencies19, function(_ref) {
        var typed2 = _ref.typed, numeric = _ref.numeric, config4 = _ref.config, AccessorNode = _ref.AccessorNode, ArrayNode = _ref.ArrayNode, AssignmentNode = _ref.AssignmentNode, BlockNode = _ref.BlockNode, ConditionalNode = _ref.ConditionalNode, ConstantNode = _ref.ConstantNode, FunctionAssignmentNode = _ref.FunctionAssignmentNode, FunctionNode = _ref.FunctionNode, IndexNode = _ref.IndexNode, ObjectNode = _ref.ObjectNode, OperatorNode = _ref.OperatorNode, ParenthesisNode = _ref.ParenthesisNode, RangeNode = _ref.RangeNode, RelationalNode = _ref.RelationalNode, SymbolNode = _ref.SymbolNode;
        var parse2 = typed2(name18, {
          string: function string(expression) {
            return parseStart(expression, {});
          },
          "Array | Matrix": function ArrayMatrix(expressions) {
            return parseMultiple(expressions, {});
          },
          "string, Object": function stringObject(expression, options) {
            var extraNodes = options.nodes !== void 0 ? options.nodes : {};
            return parseStart(expression, extraNodes);
          },
          "Array | Matrix, Object": parseMultiple
        });
        function parseMultiple(expressions) {
          var options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
          var extraNodes = options.nodes !== void 0 ? options.nodes : {};
          return (0, _collection.deepMap)(expressions, function(elem) {
            if (typeof elem !== "string") throw new TypeError("String expected");
            return parseStart(elem, extraNodes);
          });
        }
        var TOKENTYPE = {
          NULL: 0,
          DELIMITER: 1,
          NUMBER: 2,
          SYMBOL: 3,
          UNKNOWN: 4
        };
        var DELIMITERS = {
          ",": true,
          "(": true,
          ")": true,
          "[": true,
          "]": true,
          "{": true,
          "}": true,
          '"': true,
          "'": true,
          ";": true,
          "+": true,
          "-": true,
          "*": true,
          ".*": true,
          "/": true,
          "./": true,
          "%": true,
          "^": true,
          ".^": true,
          "~": true,
          "!": true,
          "&": true,
          "|": true,
          "^|": true,
          "=": true,
          ":": true,
          "?": true,
          "==": true,
          "!=": true,
          "<": true,
          ">": true,
          "<=": true,
          ">=": true,
          "<<": true,
          ">>": true,
          ">>>": true
        };
        var NAMED_DELIMITERS = {
          mod: true,
          to: true,
          "in": true,
          and: true,
          xor: true,
          or: true,
          not: true
        };
        var CONSTANTS = {
          "true": true,
          "false": false,
          "null": null,
          undefined: void 0
        };
        var NUMERIC_CONSTANTS = ["NaN", "Infinity"];
        var ESCAPE_CHARACTERS = {
          '"': '"',
          "'": "'",
          "\\": "\\",
          "/": "/",
          b: "\b",
          f: "\f",
          n: "\n",
          r: "\r",
          t: "	"
          // note that \u is handled separately in parseStringToken()
        };
        function initialState() {
          return {
            extraNodes: {},
            // current extra nodes, must be careful not to mutate
            expression: "",
            // current expression
            comment: "",
            // last parsed comment
            index: 0,
            // current index in expr
            token: "",
            // current token
            tokenType: TOKENTYPE.NULL,
            // type of the token
            nestingLevel: 0,
            // level of nesting inside parameters, used to ignore newline characters
            conditionalLevel: null
            // when a conditional is being parsed, the level of the conditional is stored here
          };
        }
        function currentString(state, length) {
          return state.expression.substr(state.index, length);
        }
        function currentCharacter(state) {
          return currentString(state, 1);
        }
        function next(state) {
          state.index++;
        }
        function prevCharacter(state) {
          return state.expression.charAt(state.index - 1);
        }
        function nextCharacter(state) {
          return state.expression.charAt(state.index + 1);
        }
        function getToken(state) {
          state.tokenType = TOKENTYPE.NULL;
          state.token = "";
          state.comment = "";
          while (true) {
            if (currentCharacter(state) === "#") {
              while (currentCharacter(state) !== "\n" && currentCharacter(state) !== "") {
                state.comment += currentCharacter(state);
                next(state);
              }
            }
            if (parse2.isWhitespace(currentCharacter(state), state.nestingLevel)) {
              next(state);
            } else {
              break;
            }
          }
          if (currentCharacter(state) === "") {
            state.tokenType = TOKENTYPE.DELIMITER;
            return;
          }
          if (currentCharacter(state) === "\n" && !state.nestingLevel) {
            state.tokenType = TOKENTYPE.DELIMITER;
            state.token = currentCharacter(state);
            next(state);
            return;
          }
          var c1 = currentCharacter(state);
          var c2 = currentString(state, 2);
          var c3 = currentString(state, 3);
          if (c3.length === 3 && DELIMITERS[c3]) {
            state.tokenType = TOKENTYPE.DELIMITER;
            state.token = c3;
            next(state);
            next(state);
            next(state);
            return;
          }
          if (c2.length === 2 && DELIMITERS[c2]) {
            state.tokenType = TOKENTYPE.DELIMITER;
            state.token = c2;
            next(state);
            next(state);
            return;
          }
          if (DELIMITERS[c1]) {
            state.tokenType = TOKENTYPE.DELIMITER;
            state.token = c1;
            next(state);
            return;
          }
          if (parse2.isDigitDot(c1)) {
            state.tokenType = TOKENTYPE.NUMBER;
            var _c = currentString(state, 2);
            if (_c === "0b" || _c === "0o" || _c === "0x") {
              state.token += currentCharacter(state);
              next(state);
              state.token += currentCharacter(state);
              next(state);
              while (parse2.isHexDigit(currentCharacter(state))) {
                state.token += currentCharacter(state);
                next(state);
              }
              if (currentCharacter(state) === ".") {
                state.token += ".";
                next(state);
                while (parse2.isHexDigit(currentCharacter(state))) {
                  state.token += currentCharacter(state);
                  next(state);
                }
              } else if (currentCharacter(state) === "i") {
                state.token += "i";
                next(state);
                while (parse2.isDigit(currentCharacter(state))) {
                  state.token += currentCharacter(state);
                  next(state);
                }
              }
              return;
            }
            if (currentCharacter(state) === ".") {
              state.token += currentCharacter(state);
              next(state);
              if (!parse2.isDigit(currentCharacter(state))) {
                state.tokenType = TOKENTYPE.DELIMITER;
                return;
              }
            } else {
              while (parse2.isDigit(currentCharacter(state))) {
                state.token += currentCharacter(state);
                next(state);
              }
              if (parse2.isDecimalMark(currentCharacter(state), nextCharacter(state))) {
                state.token += currentCharacter(state);
                next(state);
              }
            }
            while (parse2.isDigit(currentCharacter(state))) {
              state.token += currentCharacter(state);
              next(state);
            }
            if (currentCharacter(state) === "E" || currentCharacter(state) === "e") {
              if (parse2.isDigit(nextCharacter(state)) || nextCharacter(state) === "-" || nextCharacter(state) === "+") {
                state.token += currentCharacter(state);
                next(state);
                if (currentCharacter(state) === "+" || currentCharacter(state) === "-") {
                  state.token += currentCharacter(state);
                  next(state);
                }
                if (!parse2.isDigit(currentCharacter(state))) {
                  throw createSyntaxError(state, 'Digit expected, got "' + currentCharacter(state) + '"');
                }
                while (parse2.isDigit(currentCharacter(state))) {
                  state.token += currentCharacter(state);
                  next(state);
                }
                if (parse2.isDecimalMark(currentCharacter(state), nextCharacter(state))) {
                  throw createSyntaxError(state, 'Digit expected, got "' + currentCharacter(state) + '"');
                }
              } else if (nextCharacter(state) === ".") {
                next(state);
                throw createSyntaxError(state, 'Digit expected, got "' + currentCharacter(state) + '"');
              }
            }
            return;
          }
          if (parse2.isAlpha(currentCharacter(state), prevCharacter(state), nextCharacter(state))) {
            while (parse2.isAlpha(currentCharacter(state), prevCharacter(state), nextCharacter(state)) || parse2.isDigit(currentCharacter(state))) {
              state.token += currentCharacter(state);
              next(state);
            }
            if ((0, _object.hasOwnProperty)(NAMED_DELIMITERS, state.token)) {
              state.tokenType = TOKENTYPE.DELIMITER;
            } else {
              state.tokenType = TOKENTYPE.SYMBOL;
            }
            return;
          }
          state.tokenType = TOKENTYPE.UNKNOWN;
          while (currentCharacter(state) !== "") {
            state.token += currentCharacter(state);
            next(state);
          }
          throw createSyntaxError(state, 'Syntax error in part "' + state.token + '"');
        }
        function getTokenSkipNewline(state) {
          do {
            getToken(state);
          } while (state.token === "\n");
        }
        function openParams(state) {
          state.nestingLevel++;
        }
        function closeParams(state) {
          state.nestingLevel--;
        }
        parse2.isAlpha = function isAlpha(c, cPrev, cNext) {
          return parse2.isValidLatinOrGreek(c) || parse2.isValidMathSymbol(c, cNext) || parse2.isValidMathSymbol(cPrev, c);
        };
        parse2.isValidLatinOrGreek = function isValidLatinOrGreek(c) {
          return /^[a-zA-Z_$\u00C0-\u02AF\u0370-\u03FF\u2100-\u214F]$/.test(c);
        };
        parse2.isValidMathSymbol = function isValidMathSymbol(high, low) {
          return /^[\uD835]$/.test(high) && /^[\uDC00-\uDFFF]$/.test(low) && /^[^\uDC55\uDC9D\uDCA0\uDCA1\uDCA3\uDCA4\uDCA7\uDCA8\uDCAD\uDCBA\uDCBC\uDCC4\uDD06\uDD0B\uDD0C\uDD15\uDD1D\uDD3A\uDD3F\uDD45\uDD47-\uDD49\uDD51\uDEA6\uDEA7\uDFCC\uDFCD]$/.test(low);
        };
        parse2.isWhitespace = function isWhitespace(c, nestingLevel) {
          return c === " " || c === "	" || c === "\n" && nestingLevel > 0;
        };
        parse2.isDecimalMark = function isDecimalMark(c, cNext) {
          return c === "." && cNext !== "/" && cNext !== "*" && cNext !== "^";
        };
        parse2.isDigitDot = function isDigitDot(c) {
          return c >= "0" && c <= "9" || c === ".";
        };
        parse2.isDigit = function isDigit(c) {
          return c >= "0" && c <= "9";
        };
        parse2.isHexDigit = function isHexDigit(c) {
          return c >= "0" && c <= "9" || c >= "a" && c <= "f" || c >= "A" && c <= "F";
        };
        function parseStart(expression, extraNodes) {
          var state = initialState();
          (0, _extends2["default"])(state, {
            expression,
            extraNodes
          });
          getToken(state);
          var node = parseBlock(state);
          if (state.token !== "") {
            if (state.tokenType === TOKENTYPE.DELIMITER) {
              throw createError(state, "Unexpected operator " + state.token);
            } else {
              throw createSyntaxError(state, 'Unexpected part "' + state.token + '"');
            }
          }
          return node;
        }
        function parseBlock(state) {
          var node;
          var blocks = [];
          var visible;
          if (state.token !== "" && state.token !== "\n" && state.token !== ";") {
            node = parseAssignment(state);
            if (state.comment) {
              node.comment = state.comment;
            }
          }
          while (state.token === "\n" || state.token === ";") {
            if (blocks.length === 0 && node) {
              visible = state.token !== ";";
              blocks.push({
                node,
                visible
              });
            }
            getToken(state);
            if (state.token !== "\n" && state.token !== ";" && state.token !== "") {
              node = parseAssignment(state);
              if (state.comment) {
                node.comment = state.comment;
              }
              visible = state.token !== ";";
              blocks.push({
                node,
                visible
              });
            }
          }
          if (blocks.length > 0) {
            return new BlockNode(blocks);
          } else {
            if (!node) {
              node = new ConstantNode(void 0);
              if (state.comment) {
                node.comment = state.comment;
              }
            }
            return node;
          }
        }
        function parseAssignment(state) {
          var name19, args, value, valid;
          var node = parseConditional(state);
          if (state.token === "=") {
            if ((0, _is.isSymbolNode)(node)) {
              name19 = node.name;
              getTokenSkipNewline(state);
              value = parseAssignment(state);
              return new AssignmentNode(new SymbolNode(name19), value);
            } else if ((0, _is.isAccessorNode)(node)) {
              getTokenSkipNewline(state);
              value = parseAssignment(state);
              return new AssignmentNode(node.object, node.index, value);
            } else if ((0, _is.isFunctionNode)(node) && (0, _is.isSymbolNode)(node.fn)) {
              valid = true;
              args = [];
              name19 = node.name;
              node.args.forEach(function(arg, index) {
                if ((0, _is.isSymbolNode)(arg)) {
                  args[index] = arg.name;
                } else {
                  valid = false;
                }
              });
              if (valid) {
                getTokenSkipNewline(state);
                value = parseAssignment(state);
                return new FunctionAssignmentNode(name19, args, value);
              }
            }
            throw createSyntaxError(state, "Invalid left hand side of assignment operator =");
          }
          return node;
        }
        function parseConditional(state) {
          var node = parseLogicalOr(state);
          while (state.token === "?") {
            var prev = state.conditionalLevel;
            state.conditionalLevel = state.nestingLevel;
            getTokenSkipNewline(state);
            var condition = node;
            var trueExpr = parseAssignment(state);
            if (state.token !== ":") throw createSyntaxError(state, "False part of conditional expression expected");
            state.conditionalLevel = null;
            getTokenSkipNewline(state);
            var falseExpr = parseAssignment(state);
            node = new ConditionalNode(condition, trueExpr, falseExpr);
            state.conditionalLevel = prev;
          }
          return node;
        }
        function parseLogicalOr(state) {
          var node = parseLogicalXor(state);
          while (state.token === "or") {
            getTokenSkipNewline(state);
            node = new OperatorNode("or", "or", [node, parseLogicalXor(state)]);
          }
          return node;
        }
        function parseLogicalXor(state) {
          var node = parseLogicalAnd(state);
          while (state.token === "xor") {
            getTokenSkipNewline(state);
            node = new OperatorNode("xor", "xor", [node, parseLogicalAnd(state)]);
          }
          return node;
        }
        function parseLogicalAnd(state) {
          var node = parseBitwiseOr(state);
          while (state.token === "and") {
            getTokenSkipNewline(state);
            node = new OperatorNode("and", "and", [node, parseBitwiseOr(state)]);
          }
          return node;
        }
        function parseBitwiseOr(state) {
          var node = parseBitwiseXor(state);
          while (state.token === "|") {
            getTokenSkipNewline(state);
            node = new OperatorNode("|", "bitOr", [node, parseBitwiseXor(state)]);
          }
          return node;
        }
        function parseBitwiseXor(state) {
          var node = parseBitwiseAnd(state);
          while (state.token === "^|") {
            getTokenSkipNewline(state);
            node = new OperatorNode("^|", "bitXor", [node, parseBitwiseAnd(state)]);
          }
          return node;
        }
        function parseBitwiseAnd(state) {
          var node = parseRelational(state);
          while (state.token === "&") {
            getTokenSkipNewline(state);
            node = new OperatorNode("&", "bitAnd", [node, parseRelational(state)]);
          }
          return node;
        }
        function parseRelational(state) {
          var params = [parseShift(state)];
          var conditionals = [];
          var operators = {
            "==": "equal",
            "!=": "unequal",
            "<": "smaller",
            ">": "larger",
            "<=": "smallerEq",
            ">=": "largerEq"
          };
          while ((0, _object.hasOwnProperty)(operators, state.token)) {
            var cond = {
              name: state.token,
              fn: operators[state.token]
            };
            conditionals.push(cond);
            getTokenSkipNewline(state);
            params.push(parseShift(state));
          }
          if (params.length === 1) {
            return params[0];
          } else if (params.length === 2) {
            return new OperatorNode(conditionals[0].name, conditionals[0].fn, params);
          } else {
            return new RelationalNode(conditionals.map(function(c) {
              return c.fn;
            }), params);
          }
        }
        function parseShift(state) {
          var node, name19, fn, params;
          node = parseConversion(state);
          var operators = {
            "<<": "leftShift",
            ">>": "rightArithShift",
            ">>>": "rightLogShift"
          };
          while ((0, _object.hasOwnProperty)(operators, state.token)) {
            name19 = state.token;
            fn = operators[name19];
            getTokenSkipNewline(state);
            params = [node, parseConversion(state)];
            node = new OperatorNode(name19, fn, params);
          }
          return node;
        }
        function parseConversion(state) {
          var node, name19, fn, params;
          node = parseRange(state);
          var operators = {
            to: "to",
            "in": "to"
            // alias of 'to'
          };
          while ((0, _object.hasOwnProperty)(operators, state.token)) {
            name19 = state.token;
            fn = operators[name19];
            getTokenSkipNewline(state);
            if (name19 === "in" && state.token === "") {
              node = new OperatorNode("*", "multiply", [node, new SymbolNode("in")], true);
            } else {
              params = [node, parseRange(state)];
              node = new OperatorNode(name19, fn, params);
            }
          }
          return node;
        }
        function parseRange(state) {
          var node;
          var params = [];
          if (state.token === ":") {
            node = new ConstantNode(1);
          } else {
            node = parseAddSubtract(state);
          }
          if (state.token === ":" && state.conditionalLevel !== state.nestingLevel) {
            params.push(node);
            while (state.token === ":" && params.length < 3) {
              getTokenSkipNewline(state);
              if (state.token === ")" || state.token === "]" || state.token === "," || state.token === "") {
                params.push(new SymbolNode("end"));
              } else {
                params.push(parseAddSubtract(state));
              }
            }
            if (params.length === 3) {
              node = new RangeNode(params[0], params[2], params[1]);
            } else {
              node = new RangeNode(params[0], params[1]);
            }
          }
          return node;
        }
        function parseAddSubtract(state) {
          var node, name19, fn, params;
          node = parseMultiplyDivide(state);
          var operators = {
            "+": "add",
            "-": "subtract"
          };
          while ((0, _object.hasOwnProperty)(operators, state.token)) {
            name19 = state.token;
            fn = operators[name19];
            getTokenSkipNewline(state);
            var rightNode = parseMultiplyDivide(state);
            if (rightNode.isPercentage) {
              params = [node, new OperatorNode("*", "multiply", [node, rightNode])];
            } else {
              params = [node, rightNode];
            }
            node = new OperatorNode(name19, fn, params);
          }
          return node;
        }
        function parseMultiplyDivide(state) {
          var node, last, name19, fn;
          node = parseImplicitMultiplication(state);
          last = node;
          var operators = {
            "*": "multiply",
            ".*": "dotMultiply",
            "/": "divide",
            "./": "dotDivide"
          };
          while (true) {
            if ((0, _object.hasOwnProperty)(operators, state.token)) {
              name19 = state.token;
              fn = operators[name19];
              getTokenSkipNewline(state);
              last = parseImplicitMultiplication(state);
              node = new OperatorNode(name19, fn, [node, last]);
            } else {
              break;
            }
          }
          return node;
        }
        function parseImplicitMultiplication(state) {
          var node, last;
          node = parseRule2(state);
          last = node;
          while (true) {
            if (state.tokenType === TOKENTYPE.SYMBOL || state.token === "in" && (0, _is.isConstantNode)(node) || state.tokenType === TOKENTYPE.NUMBER && !(0, _is.isConstantNode)(last) && (!(0, _is.isOperatorNode)(last) || last.op === "!") || state.token === "(") {
              last = parseRule2(state);
              node = new OperatorNode(
                "*",
                "multiply",
                [node, last],
                true
                /* implicit */
              );
            } else {
              break;
            }
          }
          return node;
        }
        function parseRule2(state) {
          var node = parseModulusPercentage(state);
          var last = node;
          var tokenStates = [];
          while (true) {
            if (state.token === "/" && (0, _is.rule2Node)(last)) {
              tokenStates.push((0, _extends2["default"])({}, state));
              getTokenSkipNewline(state);
              if (state.tokenType === TOKENTYPE.NUMBER) {
                tokenStates.push((0, _extends2["default"])({}, state));
                getTokenSkipNewline(state);
                if (state.tokenType === TOKENTYPE.SYMBOL || state.token === "(") {
                  (0, _extends2["default"])(state, tokenStates.pop());
                  tokenStates.pop();
                  last = parseModulusPercentage(state);
                  node = new OperatorNode("/", "divide", [node, last]);
                } else {
                  tokenStates.pop();
                  (0, _extends2["default"])(state, tokenStates.pop());
                  break;
                }
              } else {
                (0, _extends2["default"])(state, tokenStates.pop());
                break;
              }
            } else {
              break;
            }
          }
          return node;
        }
        function parseModulusPercentage(state) {
          var node, name19, fn, params;
          node = parseUnary(state);
          var operators = {
            "%": "mod",
            mod: "mod"
          };
          while ((0, _object.hasOwnProperty)(operators, state.token)) {
            name19 = state.token;
            fn = operators[name19];
            getTokenSkipNewline(state);
            if (name19 === "%" && state.tokenType === TOKENTYPE.DELIMITER && state.token !== "(") {
              node = new OperatorNode("/", "divide", [node, new ConstantNode(100)], false, true);
            } else {
              params = [node, parseUnary(state)];
              node = new OperatorNode(name19, fn, params);
            }
          }
          return node;
        }
        function parseUnary(state) {
          var name19, params, fn;
          var operators = {
            "-": "unaryMinus",
            "+": "unaryPlus",
            "~": "bitNot",
            not: "not"
          };
          if ((0, _object.hasOwnProperty)(operators, state.token)) {
            fn = operators[state.token];
            name19 = state.token;
            getTokenSkipNewline(state);
            params = [parseUnary(state)];
            return new OperatorNode(name19, fn, params);
          }
          return parsePow(state);
        }
        function parsePow(state) {
          var node, name19, fn, params;
          node = parseLeftHandOperators(state);
          if (state.token === "^" || state.token === ".^") {
            name19 = state.token;
            fn = name19 === "^" ? "pow" : "dotPow";
            getTokenSkipNewline(state);
            params = [node, parseUnary(state)];
            node = new OperatorNode(name19, fn, params);
          }
          return node;
        }
        function parseLeftHandOperators(state) {
          var node, name19, fn, params;
          node = parseCustomNodes(state);
          var operators = {
            "!": "factorial",
            "'": "ctranspose"
          };
          while ((0, _object.hasOwnProperty)(operators, state.token)) {
            name19 = state.token;
            fn = operators[name19];
            getToken(state);
            params = [node];
            node = new OperatorNode(name19, fn, params);
            node = parseAccessors(state, node);
          }
          return node;
        }
        function parseCustomNodes(state) {
          var params = [];
          if (state.tokenType === TOKENTYPE.SYMBOL && (0, _object.hasOwnProperty)(state.extraNodes, state.token)) {
            var CustomNode = state.extraNodes[state.token];
            getToken(state);
            if (state.token === "(") {
              params = [];
              openParams(state);
              getToken(state);
              if (state.token !== ")") {
                params.push(parseAssignment(state));
                while (state.token === ",") {
                  getToken(state);
                  params.push(parseAssignment(state));
                }
              }
              if (state.token !== ")") {
                throw createSyntaxError(state, "Parenthesis ) expected");
              }
              closeParams(state);
              getToken(state);
            }
            return new CustomNode(params);
          }
          return parseSymbol(state);
        }
        function parseSymbol(state) {
          var node, name19;
          if (state.tokenType === TOKENTYPE.SYMBOL || state.tokenType === TOKENTYPE.DELIMITER && state.token in NAMED_DELIMITERS) {
            name19 = state.token;
            getToken(state);
            if ((0, _object.hasOwnProperty)(CONSTANTS, name19)) {
              node = new ConstantNode(CONSTANTS[name19]);
            } else if (NUMERIC_CONSTANTS.includes(name19)) {
              node = new ConstantNode(numeric(name19, "number"));
            } else {
              node = new SymbolNode(name19);
            }
            node = parseAccessors(state, node);
            return node;
          }
          return parseString(state);
        }
        function parseAccessors(state, node, types) {
          var params;
          while ((state.token === "(" || state.token === "[" || state.token === ".") && (!types || types.includes(state.token))) {
            params = [];
            if (state.token === "(") {
              if ((0, _is.isSymbolNode)(node) || (0, _is.isAccessorNode)(node)) {
                openParams(state);
                getToken(state);
                if (state.token !== ")") {
                  params.push(parseAssignment(state));
                  while (state.token === ",") {
                    getToken(state);
                    params.push(parseAssignment(state));
                  }
                }
                if (state.token !== ")") {
                  throw createSyntaxError(state, "Parenthesis ) expected");
                }
                closeParams(state);
                getToken(state);
                node = new FunctionNode(node, params);
              } else {
                return node;
              }
            } else if (state.token === "[") {
              openParams(state);
              getToken(state);
              if (state.token !== "]") {
                params.push(parseAssignment(state));
                while (state.token === ",") {
                  getToken(state);
                  params.push(parseAssignment(state));
                }
              }
              if (state.token !== "]") {
                throw createSyntaxError(state, "Parenthesis ] expected");
              }
              closeParams(state);
              getToken(state);
              node = new AccessorNode(node, new IndexNode(params));
            } else {
              getToken(state);
              var isPropertyName = state.tokenType === TOKENTYPE.SYMBOL || state.tokenType === TOKENTYPE.DELIMITER && state.token in NAMED_DELIMITERS;
              if (!isPropertyName) {
                throw createSyntaxError(state, "Property name expected after dot");
              }
              params.push(new ConstantNode(state.token));
              getToken(state);
              var dotNotation = true;
              node = new AccessorNode(node, new IndexNode(params, dotNotation));
            }
          }
          return node;
        }
        function parseString(state) {
          var node, str;
          if (state.token === '"' || state.token === "'") {
            str = parseStringToken(state, state.token);
            node = new ConstantNode(str);
            node = parseAccessors(state, node);
            return node;
          }
          return parseMatrix(state);
        }
        function parseStringToken(state, quote) {
          var str = "";
          while (currentCharacter(state) !== "" && currentCharacter(state) !== quote) {
            if (currentCharacter(state) === "\\") {
              next(state);
              var _char = currentCharacter(state);
              var escapeChar = ESCAPE_CHARACTERS[_char];
              if (escapeChar !== void 0) {
                str += escapeChar;
                state.index += 1;
              } else if (_char === "u") {
                var unicode = state.expression.slice(state.index + 1, state.index + 5);
                if (/^[0-9A-Fa-f]{4}$/.test(unicode)) {
                  str += String.fromCharCode(parseInt(unicode, 16));
                  state.index += 5;
                } else {
                  throw createSyntaxError(state, "Invalid unicode character \\u".concat(unicode));
                }
              } else {
                throw createSyntaxError(state, "Bad escape character \\".concat(_char));
              }
            } else {
              str += currentCharacter(state);
              next(state);
            }
          }
          getToken(state);
          if (state.token !== quote) {
            throw createSyntaxError(state, "End of string ".concat(quote, " expected"));
          }
          getToken(state);
          return str;
        }
        function parseMatrix(state) {
          var array, params, rows, cols;
          if (state.token === "[") {
            openParams(state);
            getToken(state);
            if (state.token !== "]") {
              var row = parseRow(state);
              if (state.token === ";") {
                rows = 1;
                params = [row];
                while (state.token === ";") {
                  getToken(state);
                  if (state.token !== "]") {
                    params[rows] = parseRow(state);
                    rows++;
                  }
                }
                if (state.token !== "]") {
                  throw createSyntaxError(state, "End of matrix ] expected");
                }
                closeParams(state);
                getToken(state);
                cols = params[0].items.length;
                for (var r = 1; r < rows; r++) {
                  if (params[r].items.length !== cols) {
                    throw createError(state, "Column dimensions mismatch (" + params[r].items.length + " !== " + cols + ")");
                  }
                }
                array = new ArrayNode(params);
              } else {
                if (state.token !== "]") {
                  throw createSyntaxError(state, "End of matrix ] expected");
                }
                closeParams(state);
                getToken(state);
                array = row;
              }
            } else {
              closeParams(state);
              getToken(state);
              array = new ArrayNode([]);
            }
            return parseAccessors(state, array);
          }
          return parseObject(state);
        }
        function parseRow(state) {
          var params = [parseAssignment(state)];
          var len = 1;
          while (state.token === ",") {
            getToken(state);
            if (state.token !== "]" && state.token !== ";") {
              params[len] = parseAssignment(state);
              len++;
            }
          }
          return new ArrayNode(params);
        }
        function parseObject(state) {
          if (state.token === "{") {
            openParams(state);
            var key;
            var properties = {};
            do {
              getToken(state);
              if (state.token !== "}") {
                if (state.token === '"' || state.token === "'") {
                  key = parseStringToken(state, state.token);
                } else if (state.tokenType === TOKENTYPE.SYMBOL || state.tokenType === TOKENTYPE.DELIMITER && state.token in NAMED_DELIMITERS) {
                  key = state.token;
                  getToken(state);
                } else {
                  throw createSyntaxError(state, "Symbol or string expected as object key");
                }
                if (state.token !== ":") {
                  throw createSyntaxError(state, "Colon : expected after object key");
                }
                getToken(state);
                properties[key] = parseAssignment(state);
              }
            } while (state.token === ",");
            if (state.token !== "}") {
              throw createSyntaxError(state, "Comma , or bracket } expected after object value");
            }
            closeParams(state);
            getToken(state);
            var node = new ObjectNode(properties);
            node = parseAccessors(state, node);
            return node;
          }
          return parseNumber(state);
        }
        function parseNumber(state) {
          var numberStr;
          if (state.tokenType === TOKENTYPE.NUMBER) {
            numberStr = state.token;
            getToken(state);
            return new ConstantNode(numeric(numberStr, config4.number));
          }
          return parseParentheses(state);
        }
        function parseParentheses(state) {
          var node;
          if (state.token === "(") {
            openParams(state);
            getToken(state);
            node = parseAssignment(state);
            if (state.token !== ")") {
              throw createSyntaxError(state, "Parenthesis ) expected");
            }
            closeParams(state);
            getToken(state);
            node = new ParenthesisNode(node);
            node = parseAccessors(state, node);
            return node;
          }
          return parseEnd(state);
        }
        function parseEnd(state) {
          if (state.token === "") {
            throw createSyntaxError(state, "Unexpected end of expression");
          } else {
            throw createSyntaxError(state, "Value expected");
          }
        }
        function col(state) {
          return state.index - state.token.length + 1;
        }
        function createSyntaxError(state, message) {
          var c = col(state);
          var error = new SyntaxError(message + " (char " + c + ")");
          error["char"] = c;
          return error;
        }
        function createError(state, message) {
          var c = col(state);
          var error = new SyntaxError(message + " (char " + c + ")");
          error["char"] = c;
          return error;
        }
        typed2.addConversion({
          from: "string",
          to: "Node",
          convert: parse2
        });
        return parse2;
      });
    }
  });

  // node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/expression/function/compile.js
  var require_compile = __commonJS({
    "node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/expression/function/compile.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.createCompile = void 0;
      var _collection = require_collection();
      var _factory = require_factory();
      var name18 = "compile";
      var dependencies19 = ["typed", "parse"];
      var createCompile = exports.createCompile = /* @__PURE__ */ (0, _factory.factory)(name18, dependencies19, function(_ref) {
        var typed2 = _ref.typed, parse2 = _ref.parse;
        return typed2(name18, {
          string: function string(expr) {
            return parse2(expr).compile();
          },
          "Array | Matrix": function ArrayMatrix(expr) {
            return (0, _collection.deepMap)(expr, function(entry) {
              return parse2(entry).compile();
            });
          }
        });
      });
    }
  });

  // node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/expression/function/evaluate.js
  var require_evaluate = __commonJS({
    "node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/expression/function/evaluate.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.createEvaluate = void 0;
      var _collection = require_collection();
      var _factory = require_factory();
      var _map = require_map();
      var name18 = "evaluate";
      var dependencies19 = ["typed", "parse"];
      var createEvaluate = exports.createEvaluate = /* @__PURE__ */ (0, _factory.factory)(name18, dependencies19, function(_ref) {
        var typed2 = _ref.typed, parse2 = _ref.parse;
        return typed2(name18, {
          string: function string(expr) {
            var scope = (0, _map.createEmptyMap)();
            return parse2(expr).compile().evaluate(scope);
          },
          "string, Map | Object": function stringMapObject(expr, scope) {
            return parse2(expr).compile().evaluate(scope);
          },
          "Array | Matrix": function ArrayMatrix(expr) {
            var scope = (0, _map.createEmptyMap)();
            return (0, _collection.deepMap)(expr, function(entry) {
              return parse2(entry).compile().evaluate(scope);
            });
          },
          "Array | Matrix, Map | Object": function ArrayMatrixMapObject(expr, scope) {
            return (0, _collection.deepMap)(expr, function(entry) {
              return parse2(entry).compile().evaluate(scope);
            });
          }
        });
      });
    }
  });

  // node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/expression/Parser.js
  var require_Parser = __commonJS({
    "node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/expression/Parser.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.createParserClass = void 0;
      var _factory = require_factory();
      var _map = require_map();
      var name18 = "Parser";
      var dependencies19 = ["evaluate"];
      var createParserClass = exports.createParserClass = /* @__PURE__ */ (0, _factory.factory)(name18, dependencies19, function(_ref) {
        var evaluate = _ref.evaluate;
        function Parser() {
          if (!(this instanceof Parser)) {
            throw new SyntaxError("Constructor must be called with the new operator");
          }
          Object.defineProperty(this, "scope", {
            value: (0, _map.createEmptyMap)(),
            writable: false
          });
        }
        Parser.prototype.type = "Parser";
        Parser.prototype.isParser = true;
        Parser.prototype.evaluate = function(expr) {
          return evaluate(expr, this.scope);
        };
        Parser.prototype.get = function(name19) {
          if (this.scope.has(name19)) {
            return this.scope.get(name19);
          }
        };
        Parser.prototype.getAll = function() {
          return (0, _map.toObject)(this.scope);
        };
        Parser.prototype.getAllAsMap = function() {
          return this.scope;
        };
        Parser.prototype.set = function(name19, value) {
          this.scope.set(name19, value);
          return value;
        };
        Parser.prototype.remove = function(name19) {
          this.scope["delete"](name19);
        };
        Parser.prototype.clear = function() {
          this.scope.clear();
        };
        return Parser;
      }, {
        isClass: true
      });
    }
  });

  // node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/expression/function/parser.js
  var require_parser = __commonJS({
    "node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/expression/function/parser.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.createParser = void 0;
      var _factory = require_factory();
      var name18 = "parser";
      var dependencies19 = ["typed", "Parser"];
      var createParser = exports.createParser = /* @__PURE__ */ (0, _factory.factory)(name18, dependencies19, function(_ref) {
        var typed2 = _ref.typed, Parser = _ref.Parser;
        return typed2(name18, {
          "": function _() {
            return new Parser();
          }
        });
      });
    }
  });

  // node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/function/algebra/decomposition/lup.js
  var require_lup = __commonJS({
    "node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/function/algebra/decomposition/lup.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.createLup = void 0;
      var _object = require_object();
      var _factory = require_factory();
      var name18 = "lup";
      var dependencies19 = ["typed", "matrix", "abs", "addScalar", "divideScalar", "multiplyScalar", "subtractScalar", "larger", "equalScalar", "unaryMinus", "DenseMatrix", "SparseMatrix", "Spa"];
      var createLup2 = exports.createLup = /* @__PURE__ */ (0, _factory.factory)(name18, dependencies19, function(_ref) {
        var typed2 = _ref.typed, matrix2 = _ref.matrix, abs2 = _ref.abs, addScalar2 = _ref.addScalar, divideScalar = _ref.divideScalar, multiplyScalar2 = _ref.multiplyScalar, subtractScalar = _ref.subtractScalar, larger = _ref.larger, equalScalar2 = _ref.equalScalar, unaryMinus = _ref.unaryMinus, DenseMatrix2 = _ref.DenseMatrix, SparseMatrix2 = _ref.SparseMatrix, Spa = _ref.Spa;
        return typed2(name18, {
          DenseMatrix: function DenseMatrix3(m) {
            return _denseLUP(m);
          },
          SparseMatrix: function SparseMatrix3(m) {
            return _sparseLUP(m);
          },
          Array: function Array2(a) {
            var m = matrix2(a);
            var r = _denseLUP(m);
            return {
              L: r.L.valueOf(),
              U: r.U.valueOf(),
              p: r.p
            };
          }
        });
        function _denseLUP(m) {
          var rows = m._size[0];
          var columns = m._size[1];
          var n = Math.min(rows, columns);
          var data = (0, _object.clone)(m._data);
          var ldata = [];
          var lsize = [rows, n];
          var udata = [];
          var usize = [n, columns];
          var i, j, k;
          var p = [];
          for (i = 0; i < rows; i++) {
            p[i] = i;
          }
          for (j = 0; j < columns; j++) {
            if (j > 0) {
              for (i = 0; i < rows; i++) {
                var min2 = Math.min(i, j);
                var s = 0;
                for (k = 0; k < min2; k++) {
                  s = addScalar2(s, multiplyScalar2(data[i][k], data[k][j]));
                }
                data[i][j] = subtractScalar(data[i][j], s);
              }
            }
            var pi = j;
            var pabsv = 0;
            var vjj = 0;
            for (i = j; i < rows; i++) {
              var v = data[i][j];
              var absv = abs2(v);
              if (larger(absv, pabsv)) {
                pi = i;
                pabsv = absv;
                vjj = v;
              }
            }
            if (j !== pi) {
              p[j] = [p[pi], p[pi] = p[j]][0];
              DenseMatrix2._swapRows(j, pi, data);
            }
            if (j < rows) {
              for (i = j + 1; i < rows; i++) {
                var vij = data[i][j];
                if (!equalScalar2(vij, 0)) {
                  data[i][j] = divideScalar(data[i][j], vjj);
                }
              }
            }
          }
          for (j = 0; j < columns; j++) {
            for (i = 0; i < rows; i++) {
              if (j === 0) {
                if (i < columns) {
                  udata[i] = [];
                }
                ldata[i] = [];
              }
              if (i < j) {
                if (i < columns) {
                  udata[i][j] = data[i][j];
                }
                if (j < rows) {
                  ldata[i][j] = 0;
                }
                continue;
              }
              if (i === j) {
                if (i < columns) {
                  udata[i][j] = data[i][j];
                }
                if (j < rows) {
                  ldata[i][j] = 1;
                }
                continue;
              }
              if (i < columns) {
                udata[i][j] = 0;
              }
              if (j < rows) {
                ldata[i][j] = data[i][j];
              }
            }
          }
          var l = new DenseMatrix2({
            data: ldata,
            size: lsize
          });
          var u = new DenseMatrix2({
            data: udata,
            size: usize
          });
          var pv = [];
          for (i = 0, n = p.length; i < n; i++) {
            pv[p[i]] = i;
          }
          return {
            L: l,
            U: u,
            p: pv,
            toString: function toString() {
              return "L: " + this.L.toString() + "\nU: " + this.U.toString() + "\nP: " + this.p;
            }
          };
        }
        function _sparseLUP(m) {
          var rows = m._size[0];
          var columns = m._size[1];
          var n = Math.min(rows, columns);
          var values = m._values;
          var index = m._index;
          var ptr = m._ptr;
          var lvalues = [];
          var lindex = [];
          var lptr = [];
          var lsize = [rows, n];
          var uvalues = [];
          var uindex = [];
          var uptr = [];
          var usize = [n, columns];
          var i, j, k;
          var pvCo = [];
          var pvOc = [];
          for (i = 0; i < rows; i++) {
            pvCo[i] = i;
            pvOc[i] = i;
          }
          var swapIndeces = function swapIndeces2(x, y) {
            var kx = pvOc[x];
            var ky = pvOc[y];
            pvCo[kx] = y;
            pvCo[ky] = x;
            pvOc[x] = ky;
            pvOc[y] = kx;
          };
          var _loop = function _loop2() {
            var spa = new Spa();
            if (j < rows) {
              lptr.push(lvalues.length);
              lvalues.push(1);
              lindex.push(j);
            }
            uptr.push(uvalues.length);
            var k0 = ptr[j];
            var k1 = ptr[j + 1];
            for (k = k0; k < k1; k++) {
              i = index[k];
              spa.set(pvCo[i], values[k]);
            }
            if (j > 0) {
              spa.forEach(0, j - 1, function(k2, vkj) {
                SparseMatrix2._forEachRow(k2, lvalues, lindex, lptr, function(i2, vik) {
                  if (i2 > k2) {
                    spa.accumulate(i2, unaryMinus(multiplyScalar2(vik, vkj)));
                  }
                });
              });
            }
            var pi = j;
            var vjj = spa.get(j);
            var pabsv = abs2(vjj);
            spa.forEach(j + 1, rows - 1, function(x, v) {
              var absv = abs2(v);
              if (larger(absv, pabsv)) {
                pi = x;
                pabsv = absv;
                vjj = v;
              }
            });
            if (j !== pi) {
              SparseMatrix2._swapRows(j, pi, lsize[1], lvalues, lindex, lptr);
              SparseMatrix2._swapRows(j, pi, usize[1], uvalues, uindex, uptr);
              spa.swap(j, pi);
              swapIndeces(j, pi);
            }
            spa.forEach(0, rows - 1, function(x, v) {
              if (x <= j) {
                uvalues.push(v);
                uindex.push(x);
              } else {
                v = divideScalar(v, vjj);
                if (!equalScalar2(v, 0)) {
                  lvalues.push(v);
                  lindex.push(x);
                }
              }
            });
          };
          for (j = 0; j < columns; j++) {
            _loop();
          }
          uptr.push(uvalues.length);
          lptr.push(lvalues.length);
          return {
            L: new SparseMatrix2({
              values: lvalues,
              index: lindex,
              ptr: lptr,
              size: lsize
            }),
            U: new SparseMatrix2({
              values: uvalues,
              index: uindex,
              ptr: uptr,
              size: usize
            }),
            p: pvCo,
            toString: function toString() {
              return "L: " + this.L.toString() + "\nU: " + this.U.toString() + "\nP: " + this.p;
            }
          };
        }
      });
    }
  });

  // node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/function/algebra/decomposition/qr.js
  var require_qr = __commonJS({
    "node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/function/algebra/decomposition/qr.js"(exports) {
      "use strict";
      var _interopRequireDefault = require_interopRequireDefault();
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.createQr = void 0;
      var _extends2 = _interopRequireDefault(require_extends());
      var _factory = require_factory();
      var name18 = "qr";
      var dependencies19 = ["typed", "matrix", "zeros", "identity", "isZero", "equal", "sign", "sqrt", "conj", "unaryMinus", "addScalar", "divideScalar", "multiplyScalar", "subtractScalar", "complex"];
      var createQr2 = exports.createQr = /* @__PURE__ */ (0, _factory.factory)(name18, dependencies19, function(_ref) {
        var typed2 = _ref.typed, matrix2 = _ref.matrix, zeros2 = _ref.zeros, identity = _ref.identity, isZero = _ref.isZero, equal = _ref.equal, sign3 = _ref.sign, sqrt2 = _ref.sqrt, conj2 = _ref.conj, unaryMinus = _ref.unaryMinus, addScalar2 = _ref.addScalar, divideScalar = _ref.divideScalar, multiplyScalar2 = _ref.multiplyScalar, subtractScalar = _ref.subtractScalar, complex2 = _ref.complex;
        return (0, _extends2["default"])(typed2(name18, {
          DenseMatrix: function DenseMatrix2(m) {
            return _denseQR(m);
          },
          SparseMatrix: function SparseMatrix2(m) {
            return _sparseQR(m);
          },
          Array: function Array2(a) {
            var m = matrix2(a);
            var r = _denseQR(m);
            return {
              Q: r.Q.valueOf(),
              R: r.R.valueOf()
            };
          }
        }), {
          _denseQRimpl
        });
        function _denseQRimpl(m) {
          var rows = m._size[0];
          var cols = m._size[1];
          var Q = identity([rows], "dense");
          var Qdata = Q._data;
          var R = m.clone();
          var Rdata = R._data;
          var i, j, k;
          var w = zeros2([rows], "");
          for (k = 0; k < Math.min(cols, rows); ++k) {
            var pivot = Rdata[k][k];
            var sgn = unaryMinus(equal(pivot, 0) ? 1 : sign3(pivot));
            var conjSgn = conj2(sgn);
            var alphaSquared = 0;
            for (i = k; i < rows; i++) {
              alphaSquared = addScalar2(alphaSquared, multiplyScalar2(Rdata[i][k], conj2(Rdata[i][k])));
            }
            var alpha = multiplyScalar2(sgn, sqrt2(alphaSquared));
            if (!isZero(alpha)) {
              var u1 = subtractScalar(pivot, alpha);
              w[k] = 1;
              for (i = k + 1; i < rows; i++) {
                w[i] = divideScalar(Rdata[i][k], u1);
              }
              var tau = unaryMinus(conj2(divideScalar(u1, alpha)));
              var s = void 0;
              for (j = k; j < cols; j++) {
                s = 0;
                for (i = k; i < rows; i++) {
                  s = addScalar2(s, multiplyScalar2(conj2(w[i]), Rdata[i][j]));
                }
                s = multiplyScalar2(s, tau);
                for (i = k; i < rows; i++) {
                  Rdata[i][j] = multiplyScalar2(subtractScalar(Rdata[i][j], multiplyScalar2(w[i], s)), conjSgn);
                }
              }
              for (i = 0; i < rows; i++) {
                s = 0;
                for (j = k; j < rows; j++) {
                  s = addScalar2(s, multiplyScalar2(Qdata[i][j], w[j]));
                }
                s = multiplyScalar2(s, tau);
                for (j = k; j < rows; ++j) {
                  Qdata[i][j] = divideScalar(subtractScalar(Qdata[i][j], multiplyScalar2(s, conj2(w[j]))), conjSgn);
                }
              }
            }
          }
          return {
            Q,
            R,
            toString: function toString() {
              return "Q: " + this.Q.toString() + "\nR: " + this.R.toString();
            }
          };
        }
        function _denseQR(m) {
          var ret = _denseQRimpl(m);
          var Rdata = ret.R._data;
          if (m._data.length > 0) {
            var zero = Rdata[0][0].type === "Complex" ? complex2(0) : 0;
            for (var i = 0; i < Rdata.length; ++i) {
              for (var j = 0; j < i && j < (Rdata[0] || []).length; ++j) {
                Rdata[i][j] = zero;
              }
            }
          }
          return ret;
        }
        function _sparseQR(m) {
          throw new Error("qr not implemented for sparse matrices yet");
        }
      });
    }
  });

  // node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/function/algebra/sparse/csPermute.js
  var require_csPermute = __commonJS({
    "node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/function/algebra/sparse/csPermute.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.csPermute = csPermute;
      function csPermute(a, pinv, q, values) {
        var avalues = a._values;
        var aindex = a._index;
        var aptr = a._ptr;
        var asize = a._size;
        var adt = a._datatype;
        var m = asize[0];
        var n = asize[1];
        var cvalues = values && a._values ? [] : null;
        var cindex = [];
        var cptr = [];
        var nz = 0;
        for (var k = 0; k < n; k++) {
          cptr[k] = nz;
          var j = q ? q[k] : k;
          for (var t0 = aptr[j], t1 = aptr[j + 1], t = t0; t < t1; t++) {
            var r = pinv ? pinv[aindex[t]] : aindex[t];
            cindex[nz] = r;
            if (cvalues) {
              cvalues[nz] = avalues[t];
            }
            nz++;
          }
        }
        cptr[n] = nz;
        return a.createSparseMatrix({
          values: cvalues,
          index: cindex,
          ptr: cptr,
          size: [m, n],
          datatype: adt
        });
      }
    }
  });

  // node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/function/algebra/sparse/csTdfs.js
  var require_csTdfs = __commonJS({
    "node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/function/algebra/sparse/csTdfs.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.csTdfs = csTdfs;
      function csTdfs(j, k, w, head, next, post, stack) {
        var top = 0;
        w[stack] = j;
        while (top >= 0) {
          var p = w[stack + top];
          var i = w[head + p];
          if (i === -1) {
            top--;
            post[k++] = p;
          } else {
            w[head + p] = w[next + i];
            ++top;
            w[stack + top] = i;
          }
        }
        return k;
      }
    }
  });

  // node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/function/algebra/sparse/csPost.js
  var require_csPost = __commonJS({
    "node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/function/algebra/sparse/csPost.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.csPost = csPost;
      var _csTdfs = require_csTdfs();
      function csPost(parent, n) {
        if (!parent) {
          return null;
        }
        var k = 0;
        var j;
        var post = [];
        var w = [];
        var head = 0;
        var next = n;
        var stack = 2 * n;
        for (j = 0; j < n; j++) {
          w[head + j] = -1;
        }
        for (j = n - 1; j >= 0; j--) {
          if (parent[j] === -1) {
            continue;
          }
          w[next + j] = w[head + parent[j]];
          w[head + parent[j]] = j;
        }
        for (j = 0; j < n; j++) {
          if (parent[j] !== -1) {
            continue;
          }
          k = (0, _csTdfs.csTdfs)(j, k, w, head, next, post, stack);
        }
        return post;
      }
    }
  });

  // node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/function/algebra/sparse/csEtree.js
  var require_csEtree = __commonJS({
    "node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/function/algebra/sparse/csEtree.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.csEtree = csEtree;
      function csEtree(a, ata) {
        if (!a) {
          return null;
        }
        var aindex = a._index;
        var aptr = a._ptr;
        var asize = a._size;
        var m = asize[0];
        var n = asize[1];
        var parent = [];
        var w = [];
        var ancestor = 0;
        var prev = n;
        var i, inext;
        if (ata) {
          for (i = 0; i < m; i++) {
            w[prev + i] = -1;
          }
        }
        for (var k = 0; k < n; k++) {
          parent[k] = -1;
          w[ancestor + k] = -1;
          for (var p0 = aptr[k], p1 = aptr[k + 1], p = p0; p < p1; p++) {
            var r = aindex[p];
            i = ata ? w[prev + r] : r;
            for (; i !== -1 && i < k; i = inext) {
              inext = w[ancestor + i];
              w[ancestor + i] = k;
              if (inext === -1) {
                parent[i] = k;
              }
            }
            if (ata) {
              w[prev + r] = k;
            }
          }
        }
        return parent;
      }
    }
  });

  // node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/function/algebra/sparse/csFkeep.js
  var require_csFkeep = __commonJS({
    "node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/function/algebra/sparse/csFkeep.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.csFkeep = csFkeep;
      function csFkeep(a, callback, other) {
        var avalues = a._values;
        var aindex = a._index;
        var aptr = a._ptr;
        var asize = a._size;
        var n = asize[1];
        var nz = 0;
        for (var j = 0; j < n; j++) {
          var p = aptr[j];
          aptr[j] = nz;
          for (; p < aptr[j + 1]; p++) {
            if (callback(aindex[p], j, avalues ? avalues[p] : 1, other)) {
              aindex[nz] = aindex[p];
              if (avalues) {
                avalues[nz] = avalues[p];
              }
              nz++;
            }
          }
        }
        aptr[n] = nz;
        aindex.splice(nz, aindex.length - nz);
        if (avalues) {
          avalues.splice(nz, avalues.length - nz);
        }
        return nz;
      }
    }
  });

  // node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/function/algebra/sparse/csFlip.js
  var require_csFlip = __commonJS({
    "node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/function/algebra/sparse/csFlip.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.csFlip = csFlip;
      function csFlip(i) {
        return -i - 2;
      }
    }
  });

  // node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/function/algebra/sparse/csAmd.js
  var require_csAmd = __commonJS({
    "node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/function/algebra/sparse/csAmd.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.createCsAmd = void 0;
      var _factory = require_factory();
      var _csFkeep = require_csFkeep();
      var _csFlip = require_csFlip();
      var _csTdfs = require_csTdfs();
      var name18 = "csAmd";
      var dependencies19 = ["add", "multiply", "transpose"];
      var createCsAmd = exports.createCsAmd = /* @__PURE__ */ (0, _factory.factory)(name18, dependencies19, function(_ref) {
        var add2 = _ref.add, multiply2 = _ref.multiply, transpose = _ref.transpose;
        return function csAmd(order, a) {
          if (!a || order <= 0 || order > 3) {
            return null;
          }
          var asize = a._size;
          var m = asize[0];
          var n = asize[1];
          var lemax = 0;
          var dense = Math.max(16, 10 * Math.sqrt(n));
          dense = Math.min(n - 2, dense);
          var cm = _createTargetMatrix(order, a, m, n, dense);
          (0, _csFkeep.csFkeep)(cm, _diag, null);
          var cindex = cm._index;
          var cptr = cm._ptr;
          var cnz = cptr[n];
          var P3 = [];
          var W = [];
          var len = 0;
          var nv = n + 1;
          var next = 2 * (n + 1);
          var head = 3 * (n + 1);
          var elen = 4 * (n + 1);
          var degree = 5 * (n + 1);
          var w = 6 * (n + 1);
          var hhead = 7 * (n + 1);
          var last = P3;
          var mark = _initializeQuotientGraph(n, cptr, W, len, head, last, next, hhead, nv, w, elen, degree);
          var nel = _initializeDegreeLists(n, cptr, W, degree, elen, w, dense, nv, head, last, next);
          var mindeg = 0;
          var i, j, k, k1, k2, e, pj, ln2, nvi, pk, eln, p1, p2, pn, h, d;
          while (nel < n) {
            for (k = -1; mindeg < n && (k = W[head + mindeg]) === -1; mindeg++) ;
            if (W[next + k] !== -1) {
              last[W[next + k]] = -1;
            }
            W[head + mindeg] = W[next + k];
            var elenk = W[elen + k];
            var nvk = W[nv + k];
            nel += nvk;
            var dk = 0;
            W[nv + k] = -nvk;
            var p = cptr[k];
            var pk1 = elenk === 0 ? p : cnz;
            var pk2 = pk1;
            for (k1 = 1; k1 <= elenk + 1; k1++) {
              if (k1 > elenk) {
                e = k;
                pj = p;
                ln2 = W[len + k] - elenk;
              } else {
                e = cindex[p++];
                pj = cptr[e];
                ln2 = W[len + e];
              }
              for (k2 = 1; k2 <= ln2; k2++) {
                i = cindex[pj++];
                if ((nvi = W[nv + i]) <= 0) {
                  continue;
                }
                dk += nvi;
                W[nv + i] = -nvi;
                cindex[pk2++] = i;
                if (W[next + i] !== -1) {
                  last[W[next + i]] = last[i];
                }
                if (last[i] !== -1) {
                  W[next + last[i]] = W[next + i];
                } else {
                  W[head + W[degree + i]] = W[next + i];
                }
              }
              if (e !== k) {
                cptr[e] = (0, _csFlip.csFlip)(k);
                W[w + e] = 0;
              }
            }
            if (elenk !== 0) {
              cnz = pk2;
            }
            W[degree + k] = dk;
            cptr[k] = pk1;
            W[len + k] = pk2 - pk1;
            W[elen + k] = -2;
            mark = _wclear(mark, lemax, W, w, n);
            for (pk = pk1; pk < pk2; pk++) {
              i = cindex[pk];
              if ((eln = W[elen + i]) <= 0) {
                continue;
              }
              nvi = -W[nv + i];
              var wnvi = mark - nvi;
              for (p = cptr[i], p1 = cptr[i] + eln - 1; p <= p1; p++) {
                e = cindex[p];
                if (W[w + e] >= mark) {
                  W[w + e] -= nvi;
                } else if (W[w + e] !== 0) {
                  W[w + e] = W[degree + e] + wnvi;
                }
              }
            }
            for (pk = pk1; pk < pk2; pk++) {
              i = cindex[pk];
              p1 = cptr[i];
              p2 = p1 + W[elen + i] - 1;
              pn = p1;
              for (h = 0, d = 0, p = p1; p <= p2; p++) {
                e = cindex[p];
                if (W[w + e] !== 0) {
                  var dext = W[w + e] - mark;
                  if (dext > 0) {
                    d += dext;
                    cindex[pn++] = e;
                    h += e;
                  } else {
                    cptr[e] = (0, _csFlip.csFlip)(k);
                    W[w + e] = 0;
                  }
                }
              }
              W[elen + i] = pn - p1 + 1;
              var p3 = pn;
              var p4 = p1 + W[len + i];
              for (p = p2 + 1; p < p4; p++) {
                j = cindex[p];
                var nvj = W[nv + j];
                if (nvj <= 0) {
                  continue;
                }
                d += nvj;
                cindex[pn++] = j;
                h += j;
              }
              if (d === 0) {
                cptr[i] = (0, _csFlip.csFlip)(k);
                nvi = -W[nv + i];
                dk -= nvi;
                nvk += nvi;
                nel += nvi;
                W[nv + i] = 0;
                W[elen + i] = -1;
              } else {
                W[degree + i] = Math.min(W[degree + i], d);
                cindex[pn] = cindex[p3];
                cindex[p3] = cindex[p1];
                cindex[p1] = k;
                W[len + i] = pn - p1 + 1;
                h = (h < 0 ? -h : h) % n;
                W[next + i] = W[hhead + h];
                W[hhead + h] = i;
                last[i] = h;
              }
            }
            W[degree + k] = dk;
            lemax = Math.max(lemax, dk);
            mark = _wclear(mark + lemax, lemax, W, w, n);
            for (pk = pk1; pk < pk2; pk++) {
              i = cindex[pk];
              if (W[nv + i] >= 0) {
                continue;
              }
              h = last[i];
              i = W[hhead + h];
              W[hhead + h] = -1;
              for (; i !== -1 && W[next + i] !== -1; i = W[next + i], mark++) {
                ln2 = W[len + i];
                eln = W[elen + i];
                for (p = cptr[i] + 1; p <= cptr[i] + ln2 - 1; p++) {
                  W[w + cindex[p]] = mark;
                }
                var jlast = i;
                for (j = W[next + i]; j !== -1; ) {
                  var ok = W[len + j] === ln2 && W[elen + j] === eln;
                  for (p = cptr[j] + 1; ok && p <= cptr[j] + ln2 - 1; p++) {
                    if (W[w + cindex[p]] !== mark) {
                      ok = 0;
                    }
                  }
                  if (ok) {
                    cptr[j] = (0, _csFlip.csFlip)(i);
                    W[nv + i] += W[nv + j];
                    W[nv + j] = 0;
                    W[elen + j] = -1;
                    j = W[next + j];
                    W[next + jlast] = j;
                  } else {
                    jlast = j;
                    j = W[next + j];
                  }
                }
              }
            }
            for (p = pk1, pk = pk1; pk < pk2; pk++) {
              i = cindex[pk];
              if ((nvi = -W[nv + i]) <= 0) {
                continue;
              }
              W[nv + i] = nvi;
              d = W[degree + i] + dk - nvi;
              d = Math.min(d, n - nel - nvi);
              if (W[head + d] !== -1) {
                last[W[head + d]] = i;
              }
              W[next + i] = W[head + d];
              last[i] = -1;
              W[head + d] = i;
              mindeg = Math.min(mindeg, d);
              W[degree + i] = d;
              cindex[p++] = i;
            }
            W[nv + k] = nvk;
            if ((W[len + k] = p - pk1) === 0) {
              cptr[k] = -1;
              W[w + k] = 0;
            }
            if (elenk !== 0) {
              cnz = p;
            }
          }
          for (i = 0; i < n; i++) {
            cptr[i] = (0, _csFlip.csFlip)(cptr[i]);
          }
          for (j = 0; j <= n; j++) {
            W[head + j] = -1;
          }
          for (j = n; j >= 0; j--) {
            if (W[nv + j] > 0) {
              continue;
            }
            W[next + j] = W[head + cptr[j]];
            W[head + cptr[j]] = j;
          }
          for (e = n; e >= 0; e--) {
            if (W[nv + e] <= 0) {
              continue;
            }
            if (cptr[e] !== -1) {
              W[next + e] = W[head + cptr[e]];
              W[head + cptr[e]] = e;
            }
          }
          for (k = 0, i = 0; i <= n; i++) {
            if (cptr[i] === -1) {
              k = (0, _csTdfs.csTdfs)(i, k, W, head, next, P3, w);
            }
          }
          P3.splice(P3.length - 1, 1);
          return P3;
        };
        function _createTargetMatrix(order, a, m, n, dense) {
          var at = transpose(a);
          if (order === 1 && n === m) {
            return add2(a, at);
          }
          if (order === 2) {
            var tindex = at._index;
            var tptr = at._ptr;
            var p2 = 0;
            for (var j = 0; j < m; j++) {
              var p = tptr[j];
              tptr[j] = p2;
              if (tptr[j + 1] - p > dense) {
                continue;
              }
              for (var p1 = tptr[j + 1]; p < p1; p++) {
                tindex[p2++] = tindex[p];
              }
            }
            tptr[m] = p2;
            a = transpose(at);
            return multiply2(at, a);
          }
          return multiply2(at, a);
        }
        function _initializeQuotientGraph(n, cptr, W, len, head, last, next, hhead, nv, w, elen, degree) {
          for (var k = 0; k < n; k++) {
            W[len + k] = cptr[k + 1] - cptr[k];
          }
          W[len + n] = 0;
          for (var i = 0; i <= n; i++) {
            W[head + i] = -1;
            last[i] = -1;
            W[next + i] = -1;
            W[hhead + i] = -1;
            W[nv + i] = 1;
            W[w + i] = 1;
            W[elen + i] = 0;
            W[degree + i] = W[len + i];
          }
          var mark = _wclear(0, 0, W, w, n);
          W[elen + n] = -2;
          cptr[n] = -1;
          W[w + n] = 0;
          return mark;
        }
        function _initializeDegreeLists(n, cptr, W, degree, elen, w, dense, nv, head, last, next) {
          var nel = 0;
          for (var i = 0; i < n; i++) {
            var d = W[degree + i];
            if (d === 0) {
              W[elen + i] = -2;
              nel++;
              cptr[i] = -1;
              W[w + i] = 0;
            } else if (d > dense) {
              W[nv + i] = 0;
              W[elen + i] = -1;
              nel++;
              cptr[i] = (0, _csFlip.csFlip)(n);
              W[nv + n]++;
            } else {
              var h = W[head + d];
              if (h !== -1) {
                last[h] = i;
              }
              W[next + i] = W[head + d];
              W[head + d] = i;
            }
          }
          return nel;
        }
        function _wclear(mark, lemax, W, w, n) {
          if (mark < 2 || mark + lemax < 0) {
            for (var k = 0; k < n; k++) {
              if (W[w + k] !== 0) {
                W[w + k] = 1;
              }
            }
            mark = 2;
          }
          return mark;
        }
        function _diag(i, j) {
          return i !== j;
        }
      });
    }
  });

  // node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/function/algebra/sparse/csLeaf.js
  var require_csLeaf = __commonJS({
    "node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/function/algebra/sparse/csLeaf.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.csLeaf = csLeaf;
      function csLeaf(i, j, w, first, maxfirst, prevleaf, ancestor) {
        var s, sparent;
        var jleaf = 0;
        var q;
        if (i <= j || w[first + j] <= w[maxfirst + i]) {
          return -1;
        }
        w[maxfirst + i] = w[first + j];
        var jprev = w[prevleaf + i];
        w[prevleaf + i] = j;
        if (jprev === -1) {
          jleaf = 1;
          q = i;
        } else {
          jleaf = 2;
          for (q = jprev; q !== w[ancestor + q]; q = w[ancestor + q]) ;
          for (s = jprev; s !== q; s = sparent) {
            sparent = w[ancestor + s];
            w[ancestor + s] = q;
          }
        }
        return {
          jleaf,
          q
        };
      }
    }
  });

  // node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/function/algebra/sparse/csCounts.js
  var require_csCounts = __commonJS({
    "node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/function/algebra/sparse/csCounts.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.createCsCounts = void 0;
      var _factory = require_factory();
      var _csLeaf = require_csLeaf();
      var name18 = "csCounts";
      var dependencies19 = ["transpose"];
      var createCsCounts = exports.createCsCounts = /* @__PURE__ */ (0, _factory.factory)(name18, dependencies19, function(_ref) {
        var transpose = _ref.transpose;
        return function(a, parent, post, ata) {
          if (!a || !parent || !post) {
            return null;
          }
          var asize = a._size;
          var m = asize[0];
          var n = asize[1];
          var i, j, k, J, p, p0, p1;
          var s = 4 * n + (ata ? n + m + 1 : 0);
          var w = [];
          var ancestor = 0;
          var maxfirst = n;
          var prevleaf = 2 * n;
          var first = 3 * n;
          var head = 4 * n;
          var next = 5 * n + 1;
          for (k = 0; k < s; k++) {
            w[k] = -1;
          }
          var colcount = [];
          var at = transpose(a);
          var tindex = at._index;
          var tptr = at._ptr;
          for (k = 0; k < n; k++) {
            j = post[k];
            colcount[j] = w[first + j] === -1 ? 1 : 0;
            for (; j !== -1 && w[first + j] === -1; j = parent[j]) {
              w[first + j] = k;
            }
          }
          if (ata) {
            for (k = 0; k < n; k++) {
              w[post[k]] = k;
            }
            for (i = 0; i < m; i++) {
              for (k = n, p0 = tptr[i], p1 = tptr[i + 1], p = p0; p < p1; p++) {
                k = Math.min(k, w[tindex[p]]);
              }
              w[next + i] = w[head + k];
              w[head + k] = i;
            }
          }
          for (i = 0; i < n; i++) {
            w[ancestor + i] = i;
          }
          for (k = 0; k < n; k++) {
            j = post[k];
            if (parent[j] !== -1) {
              colcount[parent[j]]--;
            }
            for (J = ata ? w[head + k] : j; J !== -1; J = ata ? w[next + J] : -1) {
              for (p = tptr[J]; p < tptr[J + 1]; p++) {
                i = tindex[p];
                var r = (0, _csLeaf.csLeaf)(i, j, w, first, maxfirst, prevleaf, ancestor);
                if (r.jleaf >= 1) {
                  colcount[j]++;
                }
                if (r.jleaf === 2) {
                  colcount[r.q]--;
                }
              }
            }
            if (parent[j] !== -1) {
              w[ancestor + j] = parent[j];
            }
          }
          for (j = 0; j < n; j++) {
            if (parent[j] !== -1) {
              colcount[parent[j]] += colcount[j];
            }
          }
          return colcount;
        };
      });
    }
  });

  // node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/function/algebra/sparse/csSqr.js
  var require_csSqr = __commonJS({
    "node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/function/algebra/sparse/csSqr.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.createCsSqr = void 0;
      var _csPermute = require_csPermute();
      var _csPost = require_csPost();
      var _csEtree = require_csEtree();
      var _csAmd = require_csAmd();
      var _csCounts = require_csCounts();
      var _factory = require_factory();
      var name18 = "csSqr";
      var dependencies19 = ["add", "multiply", "transpose"];
      var createCsSqr = exports.createCsSqr = /* @__PURE__ */ (0, _factory.factory)(name18, dependencies19, function(_ref) {
        var add2 = _ref.add, multiply2 = _ref.multiply, transpose = _ref.transpose;
        var csAmd = (0, _csAmd.createCsAmd)({
          add: add2,
          multiply: multiply2,
          transpose
        });
        var csCounts = (0, _csCounts.createCsCounts)({
          transpose
        });
        return function csSqr(order, a, qr) {
          var aptr = a._ptr;
          var asize = a._size;
          var n = asize[1];
          var k;
          var s = {};
          s.q = csAmd(order, a);
          if (order && !s.q) {
            return null;
          }
          if (qr) {
            var c = order ? (0, _csPermute.csPermute)(a, null, s.q, 0) : a;
            s.parent = (0, _csEtree.csEtree)(c, 1);
            var post = (0, _csPost.csPost)(s.parent, n);
            s.cp = csCounts(c, s.parent, post, 1);
            if (c && s.parent && s.cp && _vcount(c, s)) {
              for (s.unz = 0, k = 0; k < n; k++) {
                s.unz += s.cp[k];
              }
            }
          } else {
            s.unz = 4 * aptr[n] + n;
            s.lnz = s.unz;
          }
          return s;
        };
        function _vcount(a, s) {
          var aptr = a._ptr;
          var aindex = a._index;
          var asize = a._size;
          var m = asize[0];
          var n = asize[1];
          s.pinv = [];
          s.leftmost = [];
          var parent = s.parent;
          var pinv = s.pinv;
          var leftmost = s.leftmost;
          var w = [];
          var next = 0;
          var head = m;
          var tail = m + n;
          var nque = m + 2 * n;
          var i, k, p, p0, p1;
          for (k = 0; k < n; k++) {
            w[head + k] = -1;
            w[tail + k] = -1;
            w[nque + k] = 0;
          }
          for (i = 0; i < m; i++) {
            leftmost[i] = -1;
          }
          for (k = n - 1; k >= 0; k--) {
            for (p0 = aptr[k], p1 = aptr[k + 1], p = p0; p < p1; p++) {
              leftmost[aindex[p]] = k;
            }
          }
          for (i = m - 1; i >= 0; i--) {
            pinv[i] = -1;
            k = leftmost[i];
            if (k === -1) {
              continue;
            }
            if (w[nque + k]++ === 0) {
              w[tail + k] = i;
            }
            w[next + i] = w[head + k];
            w[head + k] = i;
          }
          s.lnz = 0;
          s.m2 = m;
          for (k = 0; k < n; k++) {
            i = w[head + k];
            s.lnz++;
            if (i < 0) {
              i = s.m2++;
            }
            pinv[i] = k;
            if (--nque[k] <= 0) {
              continue;
            }
            s.lnz += w[nque + k];
            var pa = parent[k];
            if (pa !== -1) {
              if (w[nque + pa] === 0) {
                w[tail + pa] = w[tail + k];
              }
              w[next + w[tail + k]] = w[head + pa];
              w[head + pa] = w[next + i];
              w[nque + pa] += w[nque + k];
            }
          }
          for (i = 0; i < m; i++) {
            if (pinv[i] < 0) {
              pinv[i] = k++;
            }
          }
          return true;
        }
      });
    }
  });

  // node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/function/algebra/sparse/csMarked.js
  var require_csMarked = __commonJS({
    "node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/function/algebra/sparse/csMarked.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.csMarked = csMarked;
      function csMarked(w, j) {
        return w[j] < 0;
      }
    }
  });

  // node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/function/algebra/sparse/csMark.js
  var require_csMark = __commonJS({
    "node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/function/algebra/sparse/csMark.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.csMark = csMark;
      var _csFlip = require_csFlip();
      function csMark(w, j) {
        w[j] = (0, _csFlip.csFlip)(w[j]);
      }
    }
  });

  // node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/function/algebra/sparse/csUnflip.js
  var require_csUnflip = __commonJS({
    "node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/function/algebra/sparse/csUnflip.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.csUnflip = csUnflip;
      var _csFlip = require_csFlip();
      function csUnflip(i) {
        return i < 0 ? (0, _csFlip.csFlip)(i) : i;
      }
    }
  });

  // node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/function/algebra/sparse/csDfs.js
  var require_csDfs = __commonJS({
    "node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/function/algebra/sparse/csDfs.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.csDfs = csDfs;
      var _csMarked = require_csMarked();
      var _csMark = require_csMark();
      var _csUnflip = require_csUnflip();
      function csDfs(j, g, top, xi, pinv) {
        var index = g._index;
        var ptr = g._ptr;
        var size2 = g._size;
        var n = size2[1];
        var i, p, p2;
        var head = 0;
        xi[0] = j;
        while (head >= 0) {
          j = xi[head];
          var jnew = pinv ? pinv[j] : j;
          if (!(0, _csMarked.csMarked)(ptr, j)) {
            (0, _csMark.csMark)(ptr, j);
            xi[n + head] = jnew < 0 ? 0 : (0, _csUnflip.csUnflip)(ptr[jnew]);
          }
          var done = 1;
          for (p = xi[n + head], p2 = jnew < 0 ? 0 : (0, _csUnflip.csUnflip)(ptr[jnew + 1]); p < p2; p++) {
            i = index[p];
            if ((0, _csMarked.csMarked)(ptr, i)) {
              continue;
            }
            xi[n + head] = p;
            xi[++head] = i;
            done = 0;
            break;
          }
          if (done) {
            head--;
            xi[--top] = j;
          }
        }
        return top;
      }
    }
  });

  // node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/function/algebra/sparse/csReach.js
  var require_csReach = __commonJS({
    "node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/function/algebra/sparse/csReach.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.csReach = csReach;
      var _csMarked = require_csMarked();
      var _csMark = require_csMark();
      var _csDfs = require_csDfs();
      function csReach(g, b, k, xi, pinv) {
        var gptr = g._ptr;
        var gsize = g._size;
        var bindex = b._index;
        var bptr = b._ptr;
        var n = gsize[1];
        var p, p0, p1;
        var top = n;
        for (p0 = bptr[k], p1 = bptr[k + 1], p = p0; p < p1; p++) {
          var i = bindex[p];
          if (!(0, _csMarked.csMarked)(gptr, i)) {
            top = (0, _csDfs.csDfs)(i, g, top, xi, pinv);
          }
        }
        for (p = top; p < n; p++) {
          (0, _csMark.csMark)(gptr, xi[p]);
        }
        return top;
      }
    }
  });

  // node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/function/algebra/sparse/csSpsolve.js
  var require_csSpsolve = __commonJS({
    "node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/function/algebra/sparse/csSpsolve.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.createCsSpsolve = void 0;
      var _csReach = require_csReach();
      var _factory = require_factory();
      var name18 = "csSpsolve";
      var dependencies19 = ["divideScalar", "multiply", "subtract"];
      var createCsSpsolve = exports.createCsSpsolve = /* @__PURE__ */ (0, _factory.factory)(name18, dependencies19, function(_ref) {
        var divideScalar = _ref.divideScalar, multiply2 = _ref.multiply, subtract = _ref.subtract;
        return function csSpsolve(g, b, k, xi, x, pinv, lo) {
          var gvalues = g._values;
          var gindex = g._index;
          var gptr = g._ptr;
          var gsize = g._size;
          var n = gsize[1];
          var bvalues = b._values;
          var bindex = b._index;
          var bptr = b._ptr;
          var p, p0, p1, q;
          var top = (0, _csReach.csReach)(g, b, k, xi, pinv);
          for (p = top; p < n; p++) {
            x[xi[p]] = 0;
          }
          for (p0 = bptr[k], p1 = bptr[k + 1], p = p0; p < p1; p++) {
            x[bindex[p]] = bvalues[p];
          }
          for (var px = top; px < n; px++) {
            var j = xi[px];
            var J = pinv ? pinv[j] : j;
            if (J < 0) {
              continue;
            }
            p0 = gptr[J];
            p1 = gptr[J + 1];
            x[j] = divideScalar(x[j], gvalues[lo ? p0 : p1 - 1]);
            p = lo ? p0 + 1 : p0;
            q = lo ? p1 : p1 - 1;
            for (; p < q; p++) {
              var i = gindex[p];
              x[i] = subtract(x[i], multiply2(gvalues[p], x[j]));
            }
          }
          return top;
        };
      });
    }
  });

  // node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/function/algebra/sparse/csLu.js
  var require_csLu = __commonJS({
    "node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/function/algebra/sparse/csLu.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.createCsLu = void 0;
      var _factory = require_factory();
      var _csSpsolve = require_csSpsolve();
      var name18 = "csLu";
      var dependencies19 = ["abs", "divideScalar", "multiply", "subtract", "larger", "largerEq", "SparseMatrix"];
      var createCsLu = exports.createCsLu = /* @__PURE__ */ (0, _factory.factory)(name18, dependencies19, function(_ref) {
        var abs2 = _ref.abs, divideScalar = _ref.divideScalar, multiply2 = _ref.multiply, subtract = _ref.subtract, larger = _ref.larger, largerEq = _ref.largerEq, SparseMatrix2 = _ref.SparseMatrix;
        var csSpsolve = (0, _csSpsolve.createCsSpsolve)({
          divideScalar,
          multiply: multiply2,
          subtract
        });
        return function csLu(m, s, tol) {
          if (!m) {
            return null;
          }
          var size2 = m._size;
          var n = size2[1];
          var q;
          var lnz = 100;
          var unz = 100;
          if (s) {
            q = s.q;
            lnz = s.lnz || lnz;
            unz = s.unz || unz;
          }
          var lvalues = [];
          var lindex = [];
          var lptr = [];
          var L = new SparseMatrix2({
            values: lvalues,
            index: lindex,
            ptr: lptr,
            size: [n, n]
          });
          var uvalues = [];
          var uindex = [];
          var uptr = [];
          var U = new SparseMatrix2({
            values: uvalues,
            index: uindex,
            ptr: uptr,
            size: [n, n]
          });
          var pinv = [];
          var i, p;
          var x = [];
          var xi = [];
          for (i = 0; i < n; i++) {
            x[i] = 0;
            pinv[i] = -1;
            lptr[i + 1] = 0;
          }
          lnz = 0;
          unz = 0;
          for (var k = 0; k < n; k++) {
            lptr[k] = lnz;
            uptr[k] = unz;
            var col = q ? q[k] : k;
            var top = csSpsolve(L, m, col, xi, x, pinv, 1);
            var ipiv = -1;
            var a = -1;
            for (p = top; p < n; p++) {
              i = xi[p];
              if (pinv[i] < 0) {
                var xabs = abs2(x[i]);
                if (larger(xabs, a)) {
                  a = xabs;
                  ipiv = i;
                }
              } else {
                uindex[unz] = pinv[i];
                uvalues[unz++] = x[i];
              }
            }
            if (ipiv === -1 || a <= 0) {
              return null;
            }
            if (pinv[col] < 0 && largerEq(abs2(x[col]), multiply2(a, tol))) {
              ipiv = col;
            }
            var pivot = x[ipiv];
            uindex[unz] = k;
            uvalues[unz++] = pivot;
            pinv[ipiv] = k;
            lindex[lnz] = ipiv;
            lvalues[lnz++] = 1;
            for (p = top; p < n; p++) {
              i = xi[p];
              if (pinv[i] < 0) {
                lindex[lnz] = i;
                lvalues[lnz++] = divideScalar(x[i], pivot);
              }
              x[i] = 0;
            }
          }
          lptr[n] = lnz;
          uptr[n] = unz;
          for (p = 0; p < lnz; p++) {
            lindex[p] = pinv[lindex[p]];
          }
          lvalues.splice(lnz, lvalues.length - lnz);
          lindex.splice(lnz, lindex.length - lnz);
          uvalues.splice(unz, uvalues.length - unz);
          uindex.splice(unz, uindex.length - unz);
          return {
            L,
            U,
            pinv
          };
        };
      });
    }
  });

  // node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/function/algebra/decomposition/slu.js
  var require_slu = __commonJS({
    "node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/function/algebra/decomposition/slu.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.createSlu = void 0;
      var _number = require_number();
      var _factory = require_factory();
      var _csSqr = require_csSqr();
      var _csLu = require_csLu();
      var name18 = "slu";
      var dependencies19 = ["typed", "abs", "add", "multiply", "transpose", "divideScalar", "subtract", "larger", "largerEq", "SparseMatrix"];
      var createSlu2 = exports.createSlu = /* @__PURE__ */ (0, _factory.factory)(name18, dependencies19, function(_ref) {
        var typed2 = _ref.typed, abs2 = _ref.abs, add2 = _ref.add, multiply2 = _ref.multiply, transpose = _ref.transpose, divideScalar = _ref.divideScalar, subtract = _ref.subtract, larger = _ref.larger, largerEq = _ref.largerEq, SparseMatrix2 = _ref.SparseMatrix;
        var csSqr = (0, _csSqr.createCsSqr)({
          add: add2,
          multiply: multiply2,
          transpose
        });
        var csLu = (0, _csLu.createCsLu)({
          abs: abs2,
          divideScalar,
          multiply: multiply2,
          subtract,
          larger,
          largerEq,
          SparseMatrix: SparseMatrix2
        });
        return typed2(name18, {
          "SparseMatrix, number, number": function SparseMatrixNumberNumber(a, order, threshold) {
            if (!(0, _number.isInteger)(order) || order < 0 || order > 3) {
              throw new Error("Symbolic Ordering and Analysis order must be an integer number in the interval [0, 3]");
            }
            if (threshold < 0 || threshold > 1) {
              throw new Error("Partial pivoting threshold must be a number from 0 to 1");
            }
            var s = csSqr(order, a, false);
            var f = csLu(a, s, threshold);
            return {
              L: f.L,
              U: f.U,
              p: f.pinv,
              q: s.q,
              toString: function toString() {
                return "L: " + this.L.toString() + "\nU: " + this.U.toString() + "\np: " + this.p.toString() + (this.q ? "\nq: " + this.q.toString() : "") + "\n";
              }
            };
          }
        });
      });
    }
  });

  // node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/function/algebra/sparse/csIpvec.js
  var require_csIpvec = __commonJS({
    "node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/function/algebra/sparse/csIpvec.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.csIpvec = csIpvec;
      function csIpvec(p, b) {
        var k;
        var n = b.length;
        var x = [];
        if (p) {
          for (k = 0; k < n; k++) {
            x[p[k]] = b[k];
          }
        } else {
          for (k = 0; k < n; k++) {
            x[k] = b[k];
          }
        }
        return x;
      }
    }
  });

  // node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/function/algebra/solver/lusolve.js
  var require_lusolve = __commonJS({
    "node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/function/algebra/solver/lusolve.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.createLusolve = void 0;
      var _is = require_is();
      var _factory = require_factory();
      var _solveValidation = require_solveValidation();
      var _csIpvec = require_csIpvec();
      var name18 = "lusolve";
      var dependencies19 = ["typed", "matrix", "lup", "slu", "usolve", "lsolve", "DenseMatrix"];
      var createLusolve2 = exports.createLusolve = /* @__PURE__ */ (0, _factory.factory)(name18, dependencies19, function(_ref) {
        var typed2 = _ref.typed, matrix2 = _ref.matrix, lup = _ref.lup, slu = _ref.slu, usolve = _ref.usolve, lsolve = _ref.lsolve, DenseMatrix2 = _ref.DenseMatrix;
        var solveValidation = (0, _solveValidation.createSolveValidation)({
          DenseMatrix: DenseMatrix2
        });
        return typed2(name18, {
          "Array, Array | Matrix": function ArrayArrayMatrix(a, b) {
            a = matrix2(a);
            var d = lup(a);
            var x = _lusolve(d.L, d.U, d.p, null, b);
            return x.valueOf();
          },
          "DenseMatrix, Array | Matrix": function DenseMatrixArrayMatrix(a, b) {
            var d = lup(a);
            return _lusolve(d.L, d.U, d.p, null, b);
          },
          "SparseMatrix, Array | Matrix": function SparseMatrixArrayMatrix(a, b) {
            var d = lup(a);
            return _lusolve(d.L, d.U, d.p, null, b);
          },
          "SparseMatrix, Array | Matrix, number, number": function SparseMatrixArrayMatrixNumberNumber(a, b, order, threshold) {
            var d = slu(a, order, threshold);
            return _lusolve(d.L, d.U, d.p, d.q, b);
          },
          "Object, Array | Matrix": function ObjectArrayMatrix(d, b) {
            return _lusolve(d.L, d.U, d.p, d.q, b);
          }
        });
        function _toMatrix(a) {
          if ((0, _is.isMatrix)(a)) {
            return a;
          }
          if ((0, _is.isArray)(a)) {
            return matrix2(a);
          }
          throw new TypeError("Invalid Matrix LU decomposition");
        }
        function _lusolve(l, u, p, q, b) {
          l = _toMatrix(l);
          u = _toMatrix(u);
          if (p) {
            b = solveValidation(l, b, true);
            b._data = (0, _csIpvec.csIpvec)(p, b._data);
          }
          var y = lsolve(l, b);
          var x = usolve(u, y);
          if (q) {
            x._data = (0, _csIpvec.csIpvec)(q, x._data);
          }
          return x;
        }
      });
    }
  });

  // node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/function/algebra/polynomialRoot.js
  var require_polynomialRoot = __commonJS({
    "node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/function/algebra/polynomialRoot.js"(exports) {
      "use strict";
      var _interopRequireDefault = require_interopRequireDefault();
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.createPolynomialRoot = void 0;
      var _slicedToArray2 = _interopRequireDefault(require_slicedToArray());
      var _toConsumableArray2 = _interopRequireDefault(require_toConsumableArray());
      var _factory = require_factory();
      var name18 = "polynomialRoot";
      var dependencies19 = ["typed", "isZero", "equalScalar", "add", "subtract", "multiply", "divide", "sqrt", "unaryMinus", "cbrt", "typeOf", "im", "re"];
      var createPolynomialRoot2 = exports.createPolynomialRoot = /* @__PURE__ */ (0, _factory.factory)(name18, dependencies19, function(_ref) {
        var typed2 = _ref.typed, isZero = _ref.isZero, equalScalar2 = _ref.equalScalar, add2 = _ref.add, subtract = _ref.subtract, multiply2 = _ref.multiply, divide2 = _ref.divide, sqrt2 = _ref.sqrt, unaryMinus = _ref.unaryMinus, cbrt4 = _ref.cbrt, typeOf2 = _ref.typeOf, im = _ref.im, re = _ref.re;
        return typed2(name18, {
          "number|Complex, ...number|Complex": function numberComplexNumberComplex(constant, restCoeffs) {
            var coeffs = [constant].concat((0, _toConsumableArray2["default"])(restCoeffs));
            while (coeffs.length > 0 && isZero(coeffs[coeffs.length - 1])) {
              coeffs.pop();
            }
            if (coeffs.length < 2) {
              throw new RangeError("Polynomial [".concat(constant, ", ").concat(restCoeffs, "] must have a non-zero non-constant coefficient"));
            }
            switch (coeffs.length) {
              case 2:
                return [unaryMinus(divide2(coeffs[0], coeffs[1]))];
              case 3: {
                var _coeffs = (0, _slicedToArray2["default"])(coeffs, 3), c = _coeffs[0], b = _coeffs[1], a = _coeffs[2];
                var denom = multiply2(2, a);
                var d1 = multiply2(b, b);
                var d2 = multiply2(4, a, c);
                if (equalScalar2(d1, d2)) return [divide2(unaryMinus(b), denom)];
                var discriminant = sqrt2(subtract(d1, d2));
                return [divide2(subtract(discriminant, b), denom), divide2(subtract(unaryMinus(discriminant), b), denom)];
              }
              case 4: {
                var _coeffs2 = (0, _slicedToArray2["default"])(coeffs, 4), d = _coeffs2[0], _c = _coeffs2[1], _b = _coeffs2[2], _a = _coeffs2[3];
                var _denom = unaryMinus(multiply2(3, _a));
                var D0_1 = multiply2(_b, _b);
                var D0_2 = multiply2(3, _a, _c);
                var D1_1 = add2(multiply2(2, _b, _b, _b), multiply2(27, _a, _a, d));
                var D1_2 = multiply2(9, _a, _b, _c);
                if (equalScalar2(D0_1, D0_2) && equalScalar2(D1_1, D1_2)) {
                  return [divide2(_b, _denom)];
                }
                var Delta0 = subtract(D0_1, D0_2);
                var Delta1 = subtract(D1_1, D1_2);
                var discriminant1 = add2(multiply2(18, _a, _b, _c, d), multiply2(_b, _b, _c, _c));
                var discriminant2 = add2(multiply2(4, _b, _b, _b, d), multiply2(4, _a, _c, _c, _c), multiply2(27, _a, _a, d, d));
                if (equalScalar2(discriminant1, discriminant2)) {
                  return [
                    divide2(subtract(multiply2(4, _a, _b, _c), add2(multiply2(9, _a, _a, d), multiply2(_b, _b, _b))), multiply2(_a, Delta0)),
                    // simple root
                    divide2(subtract(multiply2(9, _a, d), multiply2(_b, _c)), multiply2(2, Delta0))
                    // double root
                  ];
                }
                var Ccubed;
                if (equalScalar2(D0_1, D0_2)) {
                  Ccubed = Delta1;
                } else {
                  Ccubed = divide2(add2(Delta1, sqrt2(subtract(multiply2(Delta1, Delta1), multiply2(4, Delta0, Delta0, Delta0)))), 2);
                }
                var allRoots = true;
                var rawRoots = cbrt4(Ccubed, allRoots).toArray().map(function(C) {
                  return divide2(add2(_b, C, divide2(Delta0, C)), _denom);
                });
                return rawRoots.map(function(r) {
                  if (typeOf2(r) === "Complex" && equalScalar2(re(r), re(r) + im(r))) {
                    return re(r);
                  }
                  return r;
                });
              }
              default:
                throw new RangeError("only implemented for cubic or lower-order polynomials, not ".concat(coeffs));
            }
          }
        });
      });
    }
  });

  // node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/expression/Help.js
  var require_Help = __commonJS({
    "node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/expression/Help.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.createHelpClass = void 0;
      var _is = require_is();
      var _object = require_object();
      var _string = require_string();
      var _factory = require_factory();
      var name18 = "Help";
      var dependencies19 = ["evaluate"];
      var createHelpClass = exports.createHelpClass = /* @__PURE__ */ (0, _factory.factory)(name18, dependencies19, function(_ref) {
        var evaluate = _ref.evaluate;
        function Help(doc) {
          if (!(this instanceof Help)) {
            throw new SyntaxError("Constructor must be called with the new operator");
          }
          if (!doc) throw new Error('Argument "doc" missing');
          this.doc = doc;
        }
        Help.prototype.type = "Help";
        Help.prototype.isHelp = true;
        Help.prototype.toString = function() {
          var doc = this.doc || {};
          var desc = "\n";
          if (doc.name) {
            desc += "Name: " + doc.name + "\n\n";
          }
          if (doc.category) {
            desc += "Category: " + doc.category + "\n\n";
          }
          if (doc.description) {
            desc += "Description:\n    " + doc.description + "\n\n";
          }
          if (doc.syntax) {
            desc += "Syntax:\n    " + doc.syntax.join("\n    ") + "\n\n";
          }
          if (doc.examples) {
            desc += "Examples:\n";
            var configChanged = false;
            var originalConfig = evaluate("config()");
            var scope = {
              config: function config4(newConfig) {
                configChanged = true;
                return evaluate("config(newConfig)", {
                  newConfig
                });
              }
            };
            for (var i = 0; i < doc.examples.length; i++) {
              var expr = doc.examples[i];
              desc += "    " + expr + "\n";
              var res = void 0;
              try {
                res = evaluate(expr, scope);
              } catch (e) {
                res = e;
              }
              if (res !== void 0 && !(0, _is.isHelp)(res)) {
                desc += "        " + (0, _string.format)(res, {
                  precision: 14
                }) + "\n";
              }
            }
            desc += "\n";
            if (configChanged) {
              evaluate("config(originalConfig)", {
                originalConfig
              });
            }
          }
          if (doc.mayThrow && doc.mayThrow.length) {
            desc += "Throws: " + doc.mayThrow.join(", ") + "\n\n";
          }
          if (doc.seealso && doc.seealso.length) {
            desc += "See also: " + doc.seealso.join(", ") + "\n";
          }
          return desc;
        };
        Help.prototype.toJSON = function() {
          var obj = (0, _object.clone)(this.doc);
          obj.mathjs = "Help";
          return obj;
        };
        Help.fromJSON = function(json) {
          var doc = {};
          Object.keys(json).filter(function(prop) {
            return prop !== "mathjs";
          }).forEach(function(prop) {
            doc[prop] = json[prop];
          });
          return new Help(doc);
        };
        Help.prototype.valueOf = Help.prototype.toString;
        return Help;
      }, {
        isClass: true
      });
    }
  });

  // node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/type/chain/Chain.js
  var require_Chain = __commonJS({
    "node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/type/chain/Chain.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.createChainClass = void 0;
      var _is = require_is();
      var _string = require_string();
      var _object = require_object();
      var _factory = require_factory();
      var name18 = "Chain";
      var dependencies19 = ["?on", "math", "typed"];
      var createChainClass = exports.createChainClass = /* @__PURE__ */ (0, _factory.factory)(name18, dependencies19, function(_ref) {
        var on = _ref.on, math = _ref.math, typed2 = _ref.typed;
        function Chain(value) {
          if (!(this instanceof Chain)) {
            throw new SyntaxError("Constructor must be called with the new operator");
          }
          if ((0, _is.isChain)(value)) {
            this.value = value.value;
          } else {
            this.value = value;
          }
        }
        Chain.prototype.type = "Chain";
        Chain.prototype.isChain = true;
        Chain.prototype.done = function() {
          return this.value;
        };
        Chain.prototype.valueOf = function() {
          return this.value;
        };
        Chain.prototype.toString = function() {
          return (0, _string.format)(this.value);
        };
        Chain.prototype.toJSON = function() {
          return {
            mathjs: "Chain",
            value: this.value
          };
        };
        Chain.fromJSON = function(json) {
          return new Chain(json.value);
        };
        function createProxy(name19, fn) {
          if (typeof fn === "function") {
            Chain.prototype[name19] = chainify(fn);
          }
        }
        function createLazyProxy(name19, resolver) {
          (0, _object.lazy)(Chain.prototype, name19, function outerResolver() {
            var fn = resolver();
            if (typeof fn === "function") {
              return chainify(fn);
            }
            return void 0;
          });
        }
        function chainify(fn) {
          return function() {
            if (arguments.length === 0) {
              return new Chain(fn(this.value));
            }
            var args = [this.value];
            for (var i = 0; i < arguments.length; i++) {
              args[i + 1] = arguments[i];
            }
            if (typed2.isTypedFunction(fn)) {
              var sigObject = typed2.resolve(fn, args);
              if (sigObject.params.length === 1) {
                throw new Error("chain function " + fn.name + " cannot match rest parameter between chain value and additional arguments.");
              }
              return new Chain(sigObject.implementation.apply(fn, args));
            }
            return new Chain(fn.apply(fn, args));
          };
        }
        Chain.createProxy = function(arg0, arg1) {
          if (typeof arg0 === "string") {
            createProxy(arg0, arg1);
          } else {
            var _loop = function _loop2(_name2) {
              if ((0, _object.hasOwnProperty)(arg0, _name2) && excludedNames[_name2] === void 0) {
                createLazyProxy(_name2, function() {
                  return arg0[_name2];
                });
              }
            };
            for (var _name in arg0) {
              _loop(_name);
            }
          }
        };
        var excludedNames = {
          expression: true,
          docs: true,
          type: true,
          classes: true,
          json: true,
          error: true,
          isChain: true
          // conflicts with the property isChain of a Chain instance
        };
        Chain.createProxy(math);
        if (on) {
          on("import", function(name19, resolver, path) {
            if (!path) {
              createLazyProxy(name19, resolver);
            }
          });
        }
        return Chain;
      }, {
        isClass: true
      });
    }
  });

  // node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/expression/embeddedDocs/constants/e.js
  var require_e = __commonJS({
    "node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/expression/embeddedDocs/constants/e.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.eDocs = void 0;
      var eDocs = exports.eDocs = {
        name: "e",
        category: "Constants",
        syntax: ["e"],
        description: "Euler's number, the base of the natural logarithm. Approximately equal to 2.71828",
        examples: ["e", "e ^ 2", "exp(2)", "log(e)"],
        seealso: ["exp"]
      };
    }
  });

  // node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/expression/embeddedDocs/constants/false.js
  var require_false = __commonJS({
    "node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/expression/embeddedDocs/constants/false.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.falseDocs = void 0;
      var falseDocs = exports.falseDocs = {
        name: "false",
        category: "Constants",
        syntax: ["false"],
        description: "Boolean value false",
        examples: ["false"],
        seealso: ["true"]
      };
    }
  });

  // node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/expression/embeddedDocs/constants/i.js
  var require_i = __commonJS({
    "node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/expression/embeddedDocs/constants/i.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.iDocs = void 0;
      var iDocs = exports.iDocs = {
        name: "i",
        category: "Constants",
        syntax: ["i"],
        description: "Imaginary unit, defined as i*i=-1. A complex number is described as a + b*i, where a is the real part, and b is the imaginary part.",
        examples: ["i", "i * i", "sqrt(-1)"],
        seealso: []
      };
    }
  });

  // node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/expression/embeddedDocs/constants/Infinity.js
  var require_Infinity = __commonJS({
    "node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/expression/embeddedDocs/constants/Infinity.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.InfinityDocs = void 0;
      var InfinityDocs = exports.InfinityDocs = {
        name: "Infinity",
        category: "Constants",
        syntax: ["Infinity"],
        description: "Infinity, a number which is larger than the maximum number that can be handled by a floating point number.",
        examples: ["Infinity", "1 / 0"],
        seealso: []
      };
    }
  });

  // node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/expression/embeddedDocs/constants/LN10.js
  var require_LN10 = __commonJS({
    "node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/expression/embeddedDocs/constants/LN10.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.LN10Docs = void 0;
      var LN10Docs = exports.LN10Docs = {
        name: "LN10",
        category: "Constants",
        syntax: ["LN10"],
        description: "Returns the natural logarithm of 10, approximately equal to 2.302",
        examples: ["LN10", "log(10)"],
        seealso: []
      };
    }
  });

  // node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/expression/embeddedDocs/constants/LN2.js
  var require_LN2 = __commonJS({
    "node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/expression/embeddedDocs/constants/LN2.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.LN2Docs = void 0;
      var LN2Docs = exports.LN2Docs = {
        name: "LN2",
        category: "Constants",
        syntax: ["LN2"],
        description: "Returns the natural logarithm of 2, approximately equal to 0.693",
        examples: ["LN2", "log(2)"],
        seealso: []
      };
    }
  });

  // node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/expression/embeddedDocs/constants/LOG10E.js
  var require_LOG10E = __commonJS({
    "node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/expression/embeddedDocs/constants/LOG10E.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.LOG10EDocs = void 0;
      var LOG10EDocs = exports.LOG10EDocs = {
        name: "LOG10E",
        category: "Constants",
        syntax: ["LOG10E"],
        description: "Returns the base-10 logarithm of E, approximately equal to 0.434",
        examples: ["LOG10E", "log(e, 10)"],
        seealso: []
      };
    }
  });

  // node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/expression/embeddedDocs/constants/LOG2E.js
  var require_LOG2E = __commonJS({
    "node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/expression/embeddedDocs/constants/LOG2E.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.LOG2EDocs = void 0;
      var LOG2EDocs = exports.LOG2EDocs = {
        name: "LOG2E",
        category: "Constants",
        syntax: ["LOG2E"],
        description: "Returns the base-2 logarithm of E, approximately equal to 1.442",
        examples: ["LOG2E", "log(e, 2)"],
        seealso: []
      };
    }
  });

  // node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/expression/embeddedDocs/constants/NaN.js
  var require_NaN = __commonJS({
    "node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/expression/embeddedDocs/constants/NaN.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.NaNDocs = void 0;
      var NaNDocs = exports.NaNDocs = {
        name: "NaN",
        category: "Constants",
        syntax: ["NaN"],
        description: "Not a number",
        examples: ["NaN", "0 / 0"],
        seealso: []
      };
    }
  });

  // node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/expression/embeddedDocs/constants/null.js
  var require_null = __commonJS({
    "node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/expression/embeddedDocs/constants/null.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.nullDocs = void 0;
      var nullDocs = exports.nullDocs = {
        name: "null",
        category: "Constants",
        syntax: ["null"],
        description: "Value null",
        examples: ["null"],
        seealso: ["true", "false"]
      };
    }
  });

  // node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/expression/embeddedDocs/constants/phi.js
  var require_phi = __commonJS({
    "node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/expression/embeddedDocs/constants/phi.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.phiDocs = void 0;
      var phiDocs = exports.phiDocs = {
        name: "phi",
        category: "Constants",
        syntax: ["phi"],
        description: "Phi is the golden ratio. Two quantities are in the golden ratio if their ratio is the same as the ratio of their sum to the larger of the two quantities. Phi is defined as `(1 + sqrt(5)) / 2` and is approximately 1.618034...",
        examples: ["phi"],
        seealso: []
      };
    }
  });

  // node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/expression/embeddedDocs/constants/pi.js
  var require_pi = __commonJS({
    "node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/expression/embeddedDocs/constants/pi.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.piDocs = void 0;
      var piDocs = exports.piDocs = {
        name: "pi",
        category: "Constants",
        syntax: ["pi"],
        description: "The number pi is a mathematical constant that is the ratio of a circle's circumference to its diameter, and is approximately equal to 3.14159",
        examples: ["pi", "sin(pi/2)"],
        seealso: ["tau"]
      };
    }
  });

  // node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/expression/embeddedDocs/constants/SQRT1_2.js
  var require_SQRT1_2 = __commonJS({
    "node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/expression/embeddedDocs/constants/SQRT1_2.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.SQRT12Docs = void 0;
      var SQRT12Docs = exports.SQRT12Docs = {
        name: "SQRT1_2",
        category: "Constants",
        syntax: ["SQRT1_2"],
        description: "Returns the square root of 1/2, approximately equal to 0.707",
        examples: ["SQRT1_2", "sqrt(1/2)"],
        seealso: []
      };
    }
  });

  // node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/expression/embeddedDocs/constants/SQRT2.js
  var require_SQRT2 = __commonJS({
    "node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/expression/embeddedDocs/constants/SQRT2.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.SQRT2Docs = void 0;
      var SQRT2Docs = exports.SQRT2Docs = {
        name: "SQRT2",
        category: "Constants",
        syntax: ["SQRT2"],
        description: "Returns the square root of 2, approximately equal to 1.414",
        examples: ["SQRT2", "sqrt(2)"],
        seealso: []
      };
    }
  });

  // node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/expression/embeddedDocs/constants/tau.js
  var require_tau = __commonJS({
    "node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/expression/embeddedDocs/constants/tau.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.tauDocs = void 0;
      var tauDocs = exports.tauDocs = {
        name: "tau",
        category: "Constants",
        syntax: ["tau"],
        description: "Tau is the ratio constant of a circle's circumference to radius, equal to 2 * pi, approximately 6.2832.",
        examples: ["tau", "2 * pi"],
        seealso: ["pi"]
      };
    }
  });

  // node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/expression/embeddedDocs/constants/true.js
  var require_true = __commonJS({
    "node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/expression/embeddedDocs/constants/true.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.trueDocs = void 0;
      var trueDocs = exports.trueDocs = {
        name: "true",
        category: "Constants",
        syntax: ["true"],
        description: "Boolean value true",
        examples: ["true"],
        seealso: ["false"]
      };
    }
  });

  // node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/expression/embeddedDocs/constants/version.js
  var require_version = __commonJS({
    "node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/expression/embeddedDocs/constants/version.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.versionDocs = void 0;
      var versionDocs = exports.versionDocs = {
        name: "version",
        category: "Constants",
        syntax: ["version"],
        description: "A string with the version number of math.js",
        examples: ["version"],
        seealso: []
      };
    }
  });

  // node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/expression/embeddedDocs/construction/bignumber.js
  var require_bignumber2 = __commonJS({
    "node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/expression/embeddedDocs/construction/bignumber.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.bignumberDocs = void 0;
      var bignumberDocs = exports.bignumberDocs = {
        name: "bignumber",
        category: "Construction",
        syntax: ["bignumber(x)"],
        description: "Create a big number from a number or string.",
        examples: ["0.1 + 0.2", "bignumber(0.1) + bignumber(0.2)", 'bignumber("7.2")', 'bignumber("7.2e500")', "bignumber([0.1, 0.2, 0.3])"],
        seealso: ["boolean", "complex", "fraction", "index", "matrix", "string", "unit"]
      };
    }
  });

  // node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/expression/embeddedDocs/construction/boolean.js
  var require_boolean2 = __commonJS({
    "node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/expression/embeddedDocs/construction/boolean.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.booleanDocs = void 0;
      var booleanDocs = exports.booleanDocs = {
        name: "boolean",
        category: "Construction",
        syntax: ["x", "boolean(x)"],
        description: "Convert a string or number into a boolean.",
        examples: ["boolean(0)", "boolean(1)", "boolean(3)", 'boolean("true")', 'boolean("false")', "boolean([1, 0, 1, 1])"],
        seealso: ["bignumber", "complex", "index", "matrix", "number", "string", "unit"]
      };
    }
  });

  // node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/expression/embeddedDocs/construction/complex.js
  var require_complex4 = __commonJS({
    "node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/expression/embeddedDocs/construction/complex.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.complexDocs = void 0;
      var complexDocs = exports.complexDocs = {
        name: "complex",
        category: "Construction",
        syntax: ["complex()", "complex(re, im)", "complex(string)"],
        description: "Create a complex number.",
        examples: ["complex()", "complex(2, 3)", 'complex("7 - 2i")'],
        seealso: ["bignumber", "boolean", "index", "matrix", "number", "string", "unit"]
      };
    }
  });

  // node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/expression/embeddedDocs/construction/createUnit.js
  var require_createUnit2 = __commonJS({
    "node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/expression/embeddedDocs/construction/createUnit.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.createUnitDocs = void 0;
      var createUnitDocs = exports.createUnitDocs = {
        name: "createUnit",
        category: "Construction",
        syntax: ["createUnit(definitions)", "createUnit(name, definition)"],
        description: "Create a user-defined unit and register it with the Unit type.",
        examples: ['createUnit("foo")', 'createUnit("knot", {definition: "0.514444444 m/s", aliases: ["knots", "kt", "kts"]})', 'createUnit("mph", "1 mile/hour")'],
        seealso: ["unit", "splitUnit"]
      };
    }
  });

  // node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/expression/embeddedDocs/construction/fraction.js
  var require_fraction3 = __commonJS({
    "node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/expression/embeddedDocs/construction/fraction.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.fractionDocs = void 0;
      var fractionDocs = exports.fractionDocs = {
        name: "fraction",
        category: "Construction",
        syntax: ["fraction(num)", "fraction(matrix)", "fraction(num,den)", "fraction({n: num, d: den})"],
        description: "Create a fraction from a number or from integer numerator and denominator.",
        examples: ["fraction(0.125)", "fraction(1, 3) + fraction(2, 5)", "fraction({n: 333, d: 53})", "fraction([sqrt(9), sqrt(10), sqrt(11)])"],
        seealso: ["bignumber", "boolean", "complex", "index", "matrix", "string", "unit"]
      };
    }
  });

  // node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/expression/embeddedDocs/construction/index.js
  var require_construction = __commonJS({
    "node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/expression/embeddedDocs/construction/index.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.indexDocs = void 0;
      var indexDocs = exports.indexDocs = {
        name: "index",
        category: "Construction",
        syntax: ["[start]", "[start:end]", "[start:step:end]", "[start1, start 2, ...]", "[start1:end1, start2:end2, ...]", "[start1:step1:end1, start2:step2:end2, ...]"],
        description: "Create an index to get or replace a subset of a matrix",
        examples: ["A = [1, 2, 3; 4, 5, 6]", "A[1, :]", "A[1, 2] = 50", "A[1:2, 1:2] = 1", "B = [1, 2, 3]", "B[B>1 and B<3]"],
        seealso: ["bignumber", "boolean", "complex", "matrix,", "number", "range", "string", "unit"]
      };
    }
  });

  // node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/expression/embeddedDocs/construction/matrix.js
  var require_matrix2 = __commonJS({
    "node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/expression/embeddedDocs/construction/matrix.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.matrixDocs = void 0;
      var matrixDocs = exports.matrixDocs = {
        name: "matrix",
        category: "Construction",
        syntax: ["[]", "[a1, b1, ...; a2, b2, ...]", "matrix()", 'matrix("dense")', "matrix([...])"],
        description: "Create a matrix.",
        examples: ["[]", "[1, 2, 3]", "[1, 2, 3; 4, 5, 6]", "matrix()", "matrix([3, 4])", 'matrix([3, 4; 5, 6], "sparse")', 'matrix([3, 4; 5, 6], "sparse", "number")'],
        seealso: ["bignumber", "boolean", "complex", "index", "number", "string", "unit", "sparse"]
      };
    }
  });

  // node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/expression/embeddedDocs/construction/number.js
  var require_number4 = __commonJS({
    "node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/expression/embeddedDocs/construction/number.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.numberDocs = void 0;
      var numberDocs = exports.numberDocs = {
        name: "number",
        category: "Construction",
        syntax: ["x", "number(x)", "number(unit, valuelessUnit)"],
        description: "Create a number or convert a string or boolean into a number.",
        examples: ["2", "2e3", "4.05", "number(2)", 'number("7.2")', "number(true)", "number([true, false, true, true])", 'number(unit("52cm"), "m")'],
        seealso: ["bignumber", "boolean", "complex", "fraction", "index", "matrix", "string", "unit"]
      };
    }
  });

  // node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/expression/embeddedDocs/construction/sparse.js
  var require_sparse2 = __commonJS({
    "node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/expression/embeddedDocs/construction/sparse.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.sparseDocs = void 0;
      var sparseDocs = exports.sparseDocs = {
        name: "sparse",
        category: "Construction",
        syntax: ["sparse()", "sparse([a1, b1, ...; a1, b2, ...])", 'sparse([a1, b1, ...; a1, b2, ...], "number")'],
        description: "Create a sparse matrix.",
        examples: ["sparse()", "sparse([3, 4; 5, 6])", 'sparse([3, 0; 5, 0], "number")'],
        seealso: ["bignumber", "boolean", "complex", "index", "number", "string", "unit", "matrix"]
      };
    }
  });

  // node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/expression/embeddedDocs/construction/splitUnit.js
  var require_splitUnit2 = __commonJS({
    "node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/expression/embeddedDocs/construction/splitUnit.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.splitUnitDocs = void 0;
      var splitUnitDocs = exports.splitUnitDocs = {
        name: "splitUnit",
        category: "Construction",
        syntax: ["splitUnit(unit: Unit, parts: Unit[])"],
        description: "Split a unit in an array of units whose sum is equal to the original unit.",
        examples: ['splitUnit(1 m, ["feet", "inch"])'],
        seealso: ["unit", "createUnit"]
      };
    }
  });

  // node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/expression/embeddedDocs/construction/string.js
  var require_string3 = __commonJS({
    "node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/expression/embeddedDocs/construction/string.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.stringDocs = void 0;
      var stringDocs = exports.stringDocs = {
        name: "string",
        category: "Construction",
        syntax: ['"text"', "string(x)"],
        description: "Create a string or convert a value to a string",
        examples: ['"Hello World!"', "string(4.2)", "string(3 + 2i)"],
        seealso: ["bignumber", "boolean", "complex", "index", "matrix", "number", "unit"]
      };
    }
  });

  // node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/expression/embeddedDocs/construction/unit.js
  var require_unit2 = __commonJS({
    "node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/expression/embeddedDocs/construction/unit.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.unitDocs = void 0;
      var unitDocs = exports.unitDocs = {
        name: "unit",
        category: "Construction",
        syntax: ["value unit", "unit(value, unit)", "unit(string)"],
        description: "Create a unit.",
        examples: ["5.5 mm", "3 inch", 'unit(7.1, "kilogram")', 'unit("23 deg")'],
        seealso: ["bignumber", "boolean", "complex", "index", "matrix", "number", "string"]
      };
    }
  });

  // node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/expression/embeddedDocs/core/config.js
  var require_config3 = __commonJS({
    "node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/expression/embeddedDocs/core/config.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.configDocs = void 0;
      var configDocs = exports.configDocs = {
        name: "config",
        category: "Core",
        syntax: ["config()", "config(options)"],
        description: "Get configuration or change configuration.",
        examples: ["config()", "1/3 + 1/4", 'config({number: "Fraction"})', "1/3 + 1/4"],
        seealso: []
      };
    }
  });

  // node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/expression/embeddedDocs/core/import.js
  var require_import = __commonJS({
    "node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/expression/embeddedDocs/core/import.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.importDocs = void 0;
      var importDocs = exports.importDocs = {
        name: "import",
        category: "Core",
        syntax: ["import(functions)", "import(functions, options)"],
        description: "Import functions or constants from an object.",
        examples: ["import({myFn: f(x)=x^2, myConstant: 32 })", "myFn(2)", "myConstant"],
        seealso: []
      };
    }
  });

  // node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/expression/embeddedDocs/core/typed.js
  var require_typed2 = __commonJS({
    "node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/expression/embeddedDocs/core/typed.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.typedDocs = void 0;
      var typedDocs = exports.typedDocs = {
        name: "typed",
        category: "Core",
        syntax: ["typed(signatures)", "typed(name, signatures)"],
        description: "Create a typed function.",
        examples: ['double = typed({ "number": f(x)=x+x, "string": f(x)=concat(x,x) })', "double(2)", 'double("hello")'],
        seealso: []
      };
    }
  });

  // node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/expression/embeddedDocs/function/algebra/derivative.js
  var require_derivative = __commonJS({
    "node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/expression/embeddedDocs/function/algebra/derivative.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.derivativeDocs = void 0;
      var derivativeDocs = exports.derivativeDocs = {
        name: "derivative",
        category: "Algebra",
        syntax: ["derivative(expr, variable)", "derivative(expr, variable, {simplify: boolean})"],
        description: "Takes the derivative of an expression expressed in parser Nodes. The derivative will be taken over the supplied variable in the second parameter. If there are multiple variables in the expression, it will return a partial derivative.",
        examples: ['derivative("2x^3", "x")', 'derivative("2x^3", "x", {simplify: false})', 'derivative("2x^2 + 3x + 4", "x")', 'derivative("sin(2x)", "x")', 'f = parse("x^2 + x")', 'x = parse("x")', "df = derivative(f, x)", "df.evaluate({x: 3})"],
        seealso: ["simplify", "parse", "evaluate"]
      };
    }
  });

  // node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/expression/embeddedDocs/function/algebra/leafCount.js
  var require_leafCount = __commonJS({
    "node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/expression/embeddedDocs/function/algebra/leafCount.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.leafCountDocs = void 0;
      var leafCountDocs = exports.leafCountDocs = {
        name: "leafCount",
        category: "Algebra",
        syntax: ["leafCount(expr)"],
        description: "Computes the number of leaves in the parse tree of the given expression",
        examples: ['leafCount("e^(i*pi)-1")', 'leafCount(parse("{a: 22/7, b: 10^(1/2)}"))'],
        seealso: ["simplify"]
      };
    }
  });

  // node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/expression/embeddedDocs/function/algebra/lsolve.js
  var require_lsolve2 = __commonJS({
    "node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/expression/embeddedDocs/function/algebra/lsolve.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.lsolveDocs = void 0;
      var lsolveDocs = exports.lsolveDocs = {
        name: "lsolve",
        category: "Algebra",
        syntax: ["x=lsolve(L, b)"],
        description: "Finds one solution of the linear system L * x = b where L is an [n x n] lower triangular matrix and b is a [n] column vector.",
        examples: ["a = [-2, 3; 2, 1]", "b = [11, 9]", "x = lsolve(a, b)"],
        seealso: ["lsolveAll", "lup", "lusolve", "usolve", "matrix", "sparse"]
      };
    }
  });

  // node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/expression/embeddedDocs/function/algebra/lsolveAll.js
  var require_lsolveAll2 = __commonJS({
    "node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/expression/embeddedDocs/function/algebra/lsolveAll.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.lsolveAllDocs = void 0;
      var lsolveAllDocs = exports.lsolveAllDocs = {
        name: "lsolveAll",
        category: "Algebra",
        syntax: ["x=lsolveAll(L, b)"],
        description: "Finds all solutions of the linear system L * x = b where L is an [n x n] lower triangular matrix and b is a [n] column vector.",
        examples: ["a = [-2, 3; 2, 1]", "b = [11, 9]", "x = lsolve(a, b)"],
        seealso: ["lsolve", "lup", "lusolve", "usolve", "matrix", "sparse"]
      };
    }
  });

  // node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/expression/embeddedDocs/function/algebra/lup.js
  var require_lup2 = __commonJS({
    "node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/expression/embeddedDocs/function/algebra/lup.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.lupDocs = void 0;
      var lupDocs = exports.lupDocs = {
        name: "lup",
        category: "Algebra",
        syntax: ["lup(m)"],
        description: "Calculate the Matrix LU decomposition with partial pivoting. Matrix A is decomposed in three matrices (L, U, P) where P * A = L * U",
        examples: ["lup([[2, 1], [1, 4]])", "lup(matrix([[2, 1], [1, 4]]))", "lup(sparse([[2, 1], [1, 4]]))"],
        seealso: ["lusolve", "lsolve", "usolve", "matrix", "sparse", "slu", "qr"]
      };
    }
  });

  // node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/expression/embeddedDocs/function/algebra/lusolve.js
  var require_lusolve2 = __commonJS({
    "node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/expression/embeddedDocs/function/algebra/lusolve.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.lusolveDocs = void 0;
      var lusolveDocs = exports.lusolveDocs = {
        name: "lusolve",
        category: "Algebra",
        syntax: ["x=lusolve(A, b)", "x=lusolve(lu, b)"],
        description: "Solves the linear system A * x = b where A is an [n x n] matrix and b is a [n] column vector.",
        examples: ["a = [-2, 3; 2, 1]", "b = [11, 9]", "x = lusolve(a, b)"],
        seealso: ["lup", "slu", "lsolve", "usolve", "matrix", "sparse"]
      };
    }
  });

  // node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/expression/embeddedDocs/function/algebra/polynomialRoot.js
  var require_polynomialRoot2 = __commonJS({
    "node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/expression/embeddedDocs/function/algebra/polynomialRoot.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.polynomialRootDocs = void 0;
      var polynomialRootDocs = exports.polynomialRootDocs = {
        name: "polynomialRoot",
        category: "Algebra",
        syntax: ["x=polynomialRoot(-6, 3)", "x=polynomialRoot(4, -4, 1)", "x=polynomialRoot(-8, 12, -6, 1)"],
        description: "Finds the roots of a univariate polynomial given by its coefficients starting from constant, linear, and so on, increasing in degree.",
        examples: ["a = polynomialRoot(-6, 11, -6, 1)"],
        seealso: ["cbrt", "sqrt"]
      };
    }
  });

  // node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/expression/embeddedDocs/function/algebra/qr.js
  var require_qr2 = __commonJS({
    "node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/expression/embeddedDocs/function/algebra/qr.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.qrDocs = void 0;
      var qrDocs = exports.qrDocs = {
        name: "qr",
        category: "Algebra",
        syntax: ["qr(A)"],
        description: "Calculates the Matrix QR decomposition. Matrix `A` is decomposed in two matrices (`Q`, `R`) where `Q` is an orthogonal matrix and `R` is an upper triangular matrix.",
        examples: ["qr([[1, -1,  4], [1,  4, -2], [1,  4,  2], [1,  -1, 0]])"],
        seealso: ["lup", "slu", "matrix"]
      };
    }
  });

  // node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/expression/embeddedDocs/function/algebra/rationalize.js
  var require_rationalize = __commonJS({
    "node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/expression/embeddedDocs/function/algebra/rationalize.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.rationalizeDocs = void 0;
      var rationalizeDocs = exports.rationalizeDocs = {
        name: "rationalize",
        category: "Algebra",
        syntax: ["rationalize(expr)", "rationalize(expr, scope)", "rationalize(expr, scope, detailed)"],
        description: "Transform a rationalizable expression in a rational fraction. If rational fraction is one variable polynomial then converts the numerator and denominator in canonical form, with decreasing exponents, returning the coefficients of numerator.",
        examples: ['rationalize("2x/y - y/(x+1)")', 'rationalize("2x/y - y/(x+1)", true)'],
        seealso: ["simplify"]
      };
    }
  });

  // node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/expression/embeddedDocs/function/algebra/resolve.js
  var require_resolve = __commonJS({
    "node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/expression/embeddedDocs/function/algebra/resolve.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.resolveDocs = void 0;
      var resolveDocs = exports.resolveDocs = {
        name: "resolve",
        category: "Algebra",
        syntax: ["resolve(node, scope)"],
        description: "Recursively substitute variables in an expression tree.",
        examples: ['resolve(parse("1 + x"), { x: 7 })', 'resolve(parse("size(text)"), { text: "Hello World" })', 'resolve(parse("x + y"), { x: parse("3z") })', 'resolve(parse("3x"), { x: parse("y+z"), z: parse("w^y") })'],
        seealso: ["simplify", "evaluate"],
        mayThrow: ["ReferenceError"]
      };
    }
  });

  // node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/expression/embeddedDocs/function/algebra/simplify.js
  var require_simplify = __commonJS({
    "node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/expression/embeddedDocs/function/algebra/simplify.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.simplifyDocs = void 0;
      var simplifyDocs = exports.simplifyDocs = {
        name: "simplify",
        category: "Algebra",
        syntax: ["simplify(expr)", "simplify(expr, rules)"],
        description: "Simplify an expression tree.",
        examples: ['simplify("3 + 2 / 4")', 'simplify("2x + x")', 'f = parse("x * (x + 2 + x)")', "simplified = simplify(f)", "simplified.evaluate({x: 2})"],
        seealso: ["simplifyCore", "derivative", "evaluate", "parse", "rationalize", "resolve"]
      };
    }
  });

  // node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/expression/embeddedDocs/function/algebra/simplifyConstant.js
  var require_simplifyConstant = __commonJS({
    "node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/expression/embeddedDocs/function/algebra/simplifyConstant.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.simplifyConstantDocs = void 0;
      var simplifyConstantDocs = exports.simplifyConstantDocs = {
        name: "simplifyConstant",
        category: "Algebra",
        syntax: ["simplifyConstant(expr)", "simplifyConstant(expr, options)"],
        description: "Replace constant subexpressions of node with their values.",
        examples: ['simplifyConstant("(3-3)*x")', 'simplifyConstant(parse("z-cos(tau/8)"))'],
        seealso: ["simplify", "simplifyCore", "evaluate"]
      };
    }
  });

  // node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/expression/embeddedDocs/function/algebra/simplifyCore.js
  var require_simplifyCore = __commonJS({
    "node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/expression/embeddedDocs/function/algebra/simplifyCore.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.simplifyCoreDocs = void 0;
      var simplifyCoreDocs = exports.simplifyCoreDocs = {
        name: "simplifyCore",
        category: "Algebra",
        syntax: ["simplifyCore(node)"],
        description: "Perform simple one-pass simplifications on an expression tree.",
        examples: ['simplifyCore(parse("0*x"))', 'simplifyCore(parse("(x+0)*2"))'],
        seealso: ["simplify", "simplifyConstant", "evaluate"]
      };
    }
  });

  // node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/expression/embeddedDocs/function/algebra/slu.js
  var require_slu2 = __commonJS({
    "node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/expression/embeddedDocs/function/algebra/slu.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.sluDocs = void 0;
      var sluDocs = exports.sluDocs = {
        name: "slu",
        category: "Algebra",
        syntax: ["slu(A, order, threshold)"],
        description: "Calculate the Matrix LU decomposition with full pivoting. Matrix A is decomposed in two matrices (L, U) and two permutation vectors (pinv, q) where P * A * Q = L * U",
        examples: ["slu(sparse([4.5, 0, 3.2, 0; 3.1, 2.9, 0, 0.9; 0, 1.7, 3, 0; 3.5, 0.4, 0, 1]), 1, 0.001)"],
        seealso: ["lusolve", "lsolve", "usolve", "matrix", "sparse", "lup", "qr"]
      };
    }
  });

  // node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/expression/embeddedDocs/function/algebra/symbolicEqual.js
  var require_symbolicEqual = __commonJS({
    "node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/expression/embeddedDocs/function/algebra/symbolicEqual.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.symbolicEqualDocs = void 0;
      var symbolicEqualDocs = exports.symbolicEqualDocs = {
        name: "symbolicEqual",
        category: "Algebra",
        syntax: ["symbolicEqual(expr1, expr2)", "symbolicEqual(expr1, expr2, options)"],
        description: "Returns true if the difference of the expressions simplifies to 0",
        examples: ['symbolicEqual("x*y","y*x")', 'symbolicEqual("abs(x^2)", "x^2")', 'symbolicEqual("abs(x)", "x", {context: {abs: {trivial: true}}})'],
        seealso: ["simplify", "evaluate"]
      };
    }
  });

  // node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/expression/embeddedDocs/function/algebra/usolve.js
  var require_usolve2 = __commonJS({
    "node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/expression/embeddedDocs/function/algebra/usolve.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.usolveDocs = void 0;
      var usolveDocs = exports.usolveDocs = {
        name: "usolve",
        category: "Algebra",
        syntax: ["x=usolve(U, b)"],
        description: "Finds one solution of the linear system U * x = b where U is an [n x n] upper triangular matrix and b is a [n] column vector.",
        examples: ["x=usolve(sparse([1, 1, 1, 1; 0, 1, 1, 1; 0, 0, 1, 1; 0, 0, 0, 1]), [1; 2; 3; 4])"],
        seealso: ["usolveAll", "lup", "lusolve", "lsolve", "matrix", "sparse"]
      };
    }
  });

  // node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/expression/embeddedDocs/function/algebra/usolveAll.js
  var require_usolveAll2 = __commonJS({
    "node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/expression/embeddedDocs/function/algebra/usolveAll.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.usolveAllDocs = void 0;
      var usolveAllDocs = exports.usolveAllDocs = {
        name: "usolveAll",
        category: "Algebra",
        syntax: ["x=usolve(U, b)"],
        description: "Finds all solutions of the linear system U * x = b where U is an [n x n] upper triangular matrix and b is a [n] column vector.",
        examples: ["x=usolve(sparse([1, 1, 1, 1; 0, 1, 1, 1; 0, 0, 1, 1; 0, 0, 0, 1]), [1; 2; 3; 4])"],
        seealso: ["usolve", "lup", "lusolve", "lsolve", "matrix", "sparse"]
      };
    }
  });

  // node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/expression/embeddedDocs/function/arithmetic/abs.js
  var require_abs2 = __commonJS({
    "node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/expression/embeddedDocs/function/arithmetic/abs.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.absDocs = void 0;
      var absDocs = exports.absDocs = {
        name: "abs",
        category: "Arithmetic",
        syntax: ["abs(x)"],
        description: "Compute the absolute value.",
        examples: ["abs(3.5)", "abs(-4.2)"],
        seealso: ["sign"]
      };
    }
  });

  // node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/expression/embeddedDocs/function/arithmetic/add.js
  var require_add2 = __commonJS({
    "node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/expression/embeddedDocs/function/arithmetic/add.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.addDocs = void 0;
      var addDocs = exports.addDocs = {
        name: "add",
        category: "Operators",
        syntax: ["x + y", "add(x, y)"],
        description: "Add two values.",
        examples: ["a = 2.1 + 3.6", "a - 3.6", "3 + 2i", "3 cm + 2 inch", '"2.3" + "4"'],
        seealso: ["subtract"]
      };
    }
  });

  // node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/expression/embeddedDocs/function/arithmetic/cbrt.js
  var require_cbrt2 = __commonJS({
    "node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/expression/embeddedDocs/function/arithmetic/cbrt.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.cbrtDocs = void 0;
      var cbrtDocs = exports.cbrtDocs = {
        name: "cbrt",
        category: "Arithmetic",
        syntax: ["cbrt(x)", "cbrt(x, allRoots)"],
        description: "Compute the cubic root value. If x = y * y * y, then y is the cubic root of x. When `x` is a number or complex number, an optional second argument `allRoots` can be provided to return all three cubic roots. If not provided, the principal root is returned",
        examples: ["cbrt(64)", "cube(4)", "cbrt(-8)", "cbrt(2 + 3i)", "cbrt(8i)", "cbrt(8i, true)", "cbrt(27 m^3)"],
        seealso: ["square", "sqrt", "cube", "multiply"]
      };
    }
  });

  // node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/expression/embeddedDocs/function/arithmetic/ceil.js
  var require_ceil2 = __commonJS({
    "node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/expression/embeddedDocs/function/arithmetic/ceil.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.ceilDocs = void 0;
      var ceilDocs = exports.ceilDocs = {
        name: "ceil",
        category: "Arithmetic",
        syntax: ["ceil(x)"],
        description: "Round a value towards plus infinity. If x is complex, both real and imaginary part are rounded towards plus infinity.",
        examples: ["ceil(3.2)", "ceil(3.8)", "ceil(-4.2)"],
        seealso: ["floor", "fix", "round"]
      };
    }
  });

  // node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/expression/embeddedDocs/function/arithmetic/cube.js
  var require_cube2 = __commonJS({
    "node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/expression/embeddedDocs/function/arithmetic/cube.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.cubeDocs = void 0;
      var cubeDocs = exports.cubeDocs = {
        name: "cube",
        category: "Arithmetic",
        syntax: ["cube(x)"],
        description: "Compute the cube of a value. The cube of x is x * x * x.",
        examples: ["cube(2)", "2^3", "2 * 2 * 2"],
        seealso: ["multiply", "square", "pow"]
      };
    }
  });

  // node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/expression/embeddedDocs/function/arithmetic/divide.js
  var require_divide = __commonJS({
    "node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/expression/embeddedDocs/function/arithmetic/divide.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.divideDocs = void 0;
      var divideDocs = exports.divideDocs = {
        name: "divide",
        category: "Operators",
        syntax: ["x / y", "divide(x, y)"],
        description: "Divide two values.",
        examples: ["a = 2 / 3", "a * 3", "4.5 / 2", "3 + 4 / 2", "(3 + 4) / 2", "18 km / 4.5"],
        seealso: ["multiply"]
      };
    }
  });

  // node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/expression/embeddedDocs/function/arithmetic/dotDivide.js
  var require_dotDivide2 = __commonJS({
    "node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/expression/embeddedDocs/function/arithmetic/dotDivide.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.dotDivideDocs = void 0;
      var dotDivideDocs = exports.dotDivideDocs = {
        name: "dotDivide",
        category: "Operators",
        syntax: ["x ./ y", "dotDivide(x, y)"],
        description: "Divide two values element wise.",
        examples: ["a = [1, 2, 3; 4, 5, 6]", "b = [2, 1, 1; 3, 2, 5]", "a ./ b"],
        seealso: ["multiply", "dotMultiply", "divide"]
      };
    }
  });

  // node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/expression/embeddedDocs/function/arithmetic/dotMultiply.js
  var require_dotMultiply2 = __commonJS({
    "node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/expression/embeddedDocs/function/arithmetic/dotMultiply.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.dotMultiplyDocs = void 0;
      var dotMultiplyDocs = exports.dotMultiplyDocs = {
        name: "dotMultiply",
        category: "Operators",
        syntax: ["x .* y", "dotMultiply(x, y)"],
        description: "Multiply two values element wise.",
        examples: ["a = [1, 2, 3; 4, 5, 6]", "b = [2, 1, 1; 3, 2, 5]", "a .* b"],
        seealso: ["multiply", "divide", "dotDivide"]
      };
    }
  });

  // node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/expression/embeddedDocs/function/arithmetic/dotPow.js
  var require_dotPow2 = __commonJS({
    "node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/expression/embeddedDocs/function/arithmetic/dotPow.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.dotPowDocs = void 0;
      var dotPowDocs = exports.dotPowDocs = {
        name: "dotPow",
        category: "Operators",
        syntax: ["x .^ y", "dotPow(x, y)"],
        description: "Calculates the power of x to y element wise.",
        examples: ["a = [1, 2, 3; 4, 5, 6]", "a .^ 2"],
        seealso: ["pow"]
      };
    }
  });

  // node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/expression/embeddedDocs/function/arithmetic/exp.js
  var require_exp2 = __commonJS({
    "node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/expression/embeddedDocs/function/arithmetic/exp.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.expDocs = void 0;
      var expDocs = exports.expDocs = {
        name: "exp",
        category: "Arithmetic",
        syntax: ["exp(x)"],
        description: "Calculate the exponent of a value.",
        examples: ["exp(1.3)", "e ^ 1.3", "log(exp(1.3))", "x = 2.4", "(exp(i*x) == cos(x) + i*sin(x))   # Euler's formula"],
        seealso: ["expm", "expm1", "pow", "log"]
      };
    }
  });

  // node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/expression/embeddedDocs/function/arithmetic/expm.js
  var require_expm = __commonJS({
    "node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/expression/embeddedDocs/function/arithmetic/expm.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.expmDocs = void 0;
      var expmDocs = exports.expmDocs = {
        name: "expm",
        category: "Arithmetic",
        syntax: ["exp(x)"],
        description: "Compute the matrix exponential, expm(A) = e^A. The matrix must be square. Not to be confused with exp(a), which performs element-wise exponentiation.",
        examples: ["expm([[0,2],[0,0]])"],
        seealso: ["exp"]
      };
    }
  });

  // node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/expression/embeddedDocs/function/arithmetic/expm1.js
  var require_expm12 = __commonJS({
    "node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/expression/embeddedDocs/function/arithmetic/expm1.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.expm1Docs = void 0;
      var expm1Docs = exports.expm1Docs = {
        name: "expm1",
        category: "Arithmetic",
        syntax: ["expm1(x)"],
        description: "Calculate the value of subtracting 1 from the exponential value.",
        examples: ["expm1(2)", "pow(e, 2) - 1", "log(expm1(2) + 1)"],
        seealso: ["exp", "pow", "log"]
      };
    }
  });

  // node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/expression/embeddedDocs/function/arithmetic/fix.js
  var require_fix2 = __commonJS({
    "node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/expression/embeddedDocs/function/arithmetic/fix.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.fixDocs = void 0;
      var fixDocs = exports.fixDocs = {
        name: "fix",
        category: "Arithmetic",
        syntax: ["fix(x)"],
        description: "Round a value towards zero. If x is complex, both real and imaginary part are rounded towards zero.",
        examples: ["fix(3.2)", "fix(3.8)", "fix(-4.2)", "fix(-4.8)"],
        seealso: ["ceil", "floor", "round"]
      };
    }
  });

  // node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/expression/embeddedDocs/function/arithmetic/floor.js
  var require_floor2 = __commonJS({
    "node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/expression/embeddedDocs/function/arithmetic/floor.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.floorDocs = void 0;
      var floorDocs = exports.floorDocs = {
        name: "floor",
        category: "Arithmetic",
        syntax: ["floor(x)"],
        description: "Round a value towards minus infinity.If x is complex, both real and imaginary part are rounded towards minus infinity.",
        examples: ["floor(3.2)", "floor(3.8)", "floor(-4.2)"],
        seealso: ["ceil", "fix", "round"]
      };
    }
  });

  // node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/expression/embeddedDocs/function/arithmetic/gcd.js
  var require_gcd2 = __commonJS({
    "node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/expression/embeddedDocs/function/arithmetic/gcd.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.gcdDocs = void 0;
      var gcdDocs = exports.gcdDocs = {
        name: "gcd",
        category: "Arithmetic",
        syntax: ["gcd(a, b)", "gcd(a, b, c, ...)"],
        description: "Compute the greatest common divisor.",
        examples: ["gcd(8, 12)", "gcd(-4, 6)", "gcd(25, 15, -10)"],
        seealso: ["lcm", "xgcd"]
      };
    }
  });

  // node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/expression/embeddedDocs/function/arithmetic/hypot.js
  var require_hypot2 = __commonJS({
    "node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/expression/embeddedDocs/function/arithmetic/hypot.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.hypotDocs = void 0;
      var hypotDocs = exports.hypotDocs = {
        name: "hypot",
        category: "Arithmetic",
        syntax: ["hypot(a, b, c, ...)", "hypot([a, b, c, ...])"],
        description: "Calculate the hypotenusa of a list with values. ",
        examples: ["hypot(3, 4)", "sqrt(3^2 + 4^2)", "hypot(-2)", "hypot([3, 4, 5])"],
        seealso: ["abs", "norm"]
      };
    }
  });

  // node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/expression/embeddedDocs/function/arithmetic/invmod.js
  var require_invmod2 = __commonJS({
    "node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/expression/embeddedDocs/function/arithmetic/invmod.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.invmodDocs = void 0;
      var invmodDocs = exports.invmodDocs = {
        name: "invmod",
        category: "Arithmetic",
        syntax: ["invmod(a, b)"],
        description: "Calculate the (modular) multiplicative inverse of a modulo b. Solution to the equation ax \u2263 1 (mod b)",
        examples: ["invmod(8, 12)", "invmod(7, 13)", "invmod(15151, 15122)"],
        seealso: ["gcd", "xgcd"]
      };
    }
  });

  // node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/expression/embeddedDocs/function/arithmetic/lcm.js
  var require_lcm2 = __commonJS({
    "node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/expression/embeddedDocs/function/arithmetic/lcm.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.lcmDocs = void 0;
      var lcmDocs = exports.lcmDocs = {
        name: "lcm",
        category: "Arithmetic",
        syntax: ["lcm(x, y)"],
        description: "Compute the least common multiple.",
        examples: ["lcm(4, 6)", "lcm(6, 21)", "lcm(6, 21, 5)"],
        seealso: ["gcd"]
      };
    }
  });

  // node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/expression/embeddedDocs/function/arithmetic/log.js
  var require_log3 = __commonJS({
    "node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/expression/embeddedDocs/function/arithmetic/log.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.logDocs = void 0;
      var logDocs = exports.logDocs = {
        name: "log",
        category: "Arithmetic",
        syntax: ["log(x)", "log(x, base)"],
        description: "Compute the logarithm of a value. If no base is provided, the natural logarithm of x is calculated. If base if provided, the logarithm is calculated for the specified base. log(x, base) is defined as log(x) / log(base).",
        examples: ["log(3.5)", "a = log(2.4)", "exp(a)", "10 ^ 4", "log(10000, 10)", "log(10000) / log(10)", "b = log(1024, 2)", "2 ^ b"],
        seealso: ["exp", "log1p", "log2", "log10"]
      };
    }
  });

  // node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/expression/embeddedDocs/function/arithmetic/log10.js
  var require_log102 = __commonJS({
    "node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/expression/embeddedDocs/function/arithmetic/log10.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.log10Docs = void 0;
      var log10Docs = exports.log10Docs = {
        name: "log10",
        category: "Arithmetic",
        syntax: ["log10(x)"],
        description: "Compute the 10-base logarithm of a value.",
        examples: ["log10(0.00001)", "log10(10000)", "10 ^ 4", "log(10000) / log(10)", "log(10000, 10)"],
        seealso: ["exp", "log"]
      };
    }
  });

  // node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/expression/embeddedDocs/function/arithmetic/log1p.js
  var require_log1p2 = __commonJS({
    "node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/expression/embeddedDocs/function/arithmetic/log1p.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.log1pDocs = void 0;
      var log1pDocs = exports.log1pDocs = {
        name: "log1p",
        category: "Arithmetic",
        syntax: ["log1p(x)", "log1p(x, base)"],
        description: "Calculate the logarithm of a `value+1`",
        examples: ["log1p(2.5)", "exp(log1p(1.4))", "pow(10, 4)", "log1p(9999, 10)", "log1p(9999) / log(10)"],
        seealso: ["exp", "log", "log2", "log10"]
      };
    }
  });

  // node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/expression/embeddedDocs/function/arithmetic/log2.js
  var require_log22 = __commonJS({
    "node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/expression/embeddedDocs/function/arithmetic/log2.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.log2Docs = void 0;
      var log2Docs = exports.log2Docs = {
        name: "log2",
        category: "Arithmetic",
        syntax: ["log2(x)"],
        description: "Calculate the 2-base of a value. This is the same as calculating `log(x, 2)`.",
        examples: ["log2(0.03125)", "log2(16)", "log2(16) / log2(2)", "pow(2, 4)"],
        seealso: ["exp", "log1p", "log", "log10"]
      };
    }
  });

  // node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/expression/embeddedDocs/function/arithmetic/mod.js
  var require_mod2 = __commonJS({
    "node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/expression/embeddedDocs/function/arithmetic/mod.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.modDocs = void 0;
      var modDocs = exports.modDocs = {
        name: "mod",
        category: "Operators",
        syntax: ["x % y", "x mod y", "mod(x, y)"],
        description: "Calculates the modulus, the remainder of an integer division.",
        examples: ["7 % 3", "11 % 2", "10 mod 4", "isOdd(x) = x % 2", "isOdd(2)", "isOdd(3)"],
        seealso: ["divide"]
      };
    }
  });

  // node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/expression/embeddedDocs/function/arithmetic/multiply.js
  var require_multiply2 = __commonJS({
    "node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/expression/embeddedDocs/function/arithmetic/multiply.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.multiplyDocs = void 0;
      var multiplyDocs = exports.multiplyDocs = {
        name: "multiply",
        category: "Operators",
        syntax: ["x * y", "multiply(x, y)"],
        description: "multiply two values.",
        examples: ["a = 2.1 * 3.4", "a / 3.4", "2 * 3 + 4", "2 * (3 + 4)", "3 * 2.1 km"],
        seealso: ["divide"]
      };
    }
  });

  // node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/expression/embeddedDocs/function/arithmetic/norm.js
  var require_norm2 = __commonJS({
    "node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/expression/embeddedDocs/function/arithmetic/norm.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.normDocs = void 0;
      var normDocs = exports.normDocs = {
        name: "norm",
        category: "Arithmetic",
        syntax: ["norm(x)", "norm(x, p)"],
        description: "Calculate the norm of a number, vector or matrix.",
        examples: ["abs(-3.5)", "norm(-3.5)", "norm(3 - 4i)", "norm([1, 2, -3], Infinity)", "norm([1, 2, -3], -Infinity)", "norm([3, 4], 2)", "norm([[1, 2], [3, 4]], 1)", 'norm([[1, 2], [3, 4]], "inf")', 'norm([[1, 2], [3, 4]], "fro")']
      };
    }
  });

  // node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/expression/embeddedDocs/function/arithmetic/nthRoot.js
  var require_nthRoot2 = __commonJS({
    "node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/expression/embeddedDocs/function/arithmetic/nthRoot.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.nthRootDocs = void 0;
      var nthRootDocs = exports.nthRootDocs = {
        name: "nthRoot",
        category: "Arithmetic",
        syntax: ["nthRoot(a)", "nthRoot(a, root)"],
        description: 'Calculate the nth root of a value. The principal nth root of a positive real number A, is the positive real solution of the equation "x^root = A".',
        examples: ["4 ^ 3", "nthRoot(64, 3)", "nthRoot(9, 2)", "sqrt(9)"],
        seealso: ["nthRoots", "pow", "sqrt"]
      };
    }
  });

  // node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/expression/embeddedDocs/function/arithmetic/nthRoots.js
  var require_nthRoots2 = __commonJS({
    "node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/expression/embeddedDocs/function/arithmetic/nthRoots.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.nthRootsDocs = void 0;
      var nthRootsDocs = exports.nthRootsDocs = {
        name: "nthRoots",
        category: "Arithmetic",
        syntax: ["nthRoots(A)", "nthRoots(A, root)"],
        description: 'Calculate the nth roots of a value. An nth root of a positive real number A, is a positive real solution of the equation "x^root = A". This function returns an array of complex values.',
        examples: ["nthRoots(1)", "nthRoots(1, 3)"],
        seealso: ["sqrt", "pow", "nthRoot"]
      };
    }
  });

  // node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/expression/embeddedDocs/function/arithmetic/pow.js
  var require_pow2 = __commonJS({
    "node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/expression/embeddedDocs/function/arithmetic/pow.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.powDocs = void 0;
      var powDocs = exports.powDocs = {
        name: "pow",
        category: "Operators",
        syntax: ["x ^ y", "pow(x, y)"],
        description: "Calculates the power of x to y, x^y.",
        examples: ["2^3", "2*2*2", "1 + e ^ (pi * i)", "pow([[1, 2], [4, 3]], 2)", "pow([[1, 2], [4, 3]], -1)"],
        seealso: ["multiply", "nthRoot", "nthRoots", "sqrt"]
      };
    }
  });

  // node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/expression/embeddedDocs/function/arithmetic/round.js
  var require_round2 = __commonJS({
    "node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/expression/embeddedDocs/function/arithmetic/round.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.roundDocs = void 0;
      var roundDocs = exports.roundDocs = {
        name: "round",
        category: "Arithmetic",
        syntax: ["round(x)", "round(x, n)", "round(unit, valuelessUnit)", "round(unit, n, valuelessUnit)"],
        description: "round a value towards the nearest integer.If x is complex, both real and imaginary part are rounded towards the nearest integer. When n is specified, the value is rounded to n decimals.",
        examples: ["round(3.2)", "round(3.8)", "round(-4.2)", "round(-4.8)", "round(pi, 3)", "round(123.45678, 2)", "round(3.241cm, 2, cm)", "round([3.2, 3.8, -4.7])"],
        seealso: ["ceil", "floor", "fix"]
      };
    }
  });

  // node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/expression/embeddedDocs/function/arithmetic/sign.js
  var require_sign2 = __commonJS({
    "node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/expression/embeddedDocs/function/arithmetic/sign.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.signDocs = void 0;
      var signDocs = exports.signDocs = {
        name: "sign",
        category: "Arithmetic",
        syntax: ["sign(x)"],
        description: "Compute the sign of a value. The sign of a value x is 1 when x>1, -1 when x<0, and 0 when x=0.",
        examples: ["sign(3.5)", "sign(-4.2)", "sign(0)"],
        seealso: ["abs"]
      };
    }
  });

  // node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/expression/embeddedDocs/function/arithmetic/sqrt.js
  var require_sqrt2 = __commonJS({
    "node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/expression/embeddedDocs/function/arithmetic/sqrt.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.sqrtDocs = void 0;
      var sqrtDocs = exports.sqrtDocs = {
        name: "sqrt",
        category: "Arithmetic",
        syntax: ["sqrt(x)"],
        description: "Compute the square root value. If x = y * y, then y is the square root of x.",
        examples: ["sqrt(25)", "5 * 5", "sqrt(-1)"],
        seealso: ["square", "sqrtm", "multiply", "nthRoot", "nthRoots", "pow"]
      };
    }
  });

  // node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/expression/embeddedDocs/function/arithmetic/sqrtm.js
  var require_sqrtm = __commonJS({
    "node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/expression/embeddedDocs/function/arithmetic/sqrtm.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.sqrtmDocs = void 0;
      var sqrtmDocs = exports.sqrtmDocs = {
        name: "sqrtm",
        category: "Arithmetic",
        syntax: ["sqrtm(x)"],
        description: "Calculate the principal square root of a square matrix. The principal square root matrix `X` of another matrix `A` is such that `X * X = A`.",
        examples: ["sqrtm([[33, 24], [48, 57]])"],
        seealso: ["sqrt", "abs", "square", "multiply"]
      };
    }
  });

  // node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/expression/embeddedDocs/function/algebra/sylvester.js
  var require_sylvester = __commonJS({
    "node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/expression/embeddedDocs/function/algebra/sylvester.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.sylvesterDocs = void 0;
      var sylvesterDocs = exports.sylvesterDocs = {
        name: "sylvester",
        category: "Algebra",
        syntax: ["sylvester(A,B,C)"],
        description: "Solves the real-valued Sylvester equation AX+XB=C for X",
        examples: ["sylvester([[-1, -2], [1, 1]], [[-2, 1], [-1, 2]], [[-3, 2], [3, 0]])", "A = [[-1, -2], [1, 1]]; B = [[2, -1], [1, -2]]; C = [[-3, 2], [3, 0]]", "sylvester(A, B, C)"],
        seealso: ["schur", "lyap"]
      };
    }
  });

  // node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/expression/embeddedDocs/function/algebra/schur.js
  var require_schur = __commonJS({
    "node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/expression/embeddedDocs/function/algebra/schur.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.schurDocs = void 0;
      var schurDocs = exports.schurDocs = {
        name: "schur",
        category: "Algebra",
        syntax: ["schur(A)"],
        description: "Performs a real Schur decomposition of the real matrix A = UTU'",
        examples: ["schur([[1, 0], [-4, 3]])", "A = [[1, 0], [-4, 3]]", "schur(A)"],
        seealso: ["lyap", "sylvester"]
      };
    }
  });

  // node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/expression/embeddedDocs/function/algebra/lyap.js
  var require_lyap = __commonJS({
    "node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/expression/embeddedDocs/function/algebra/lyap.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.lyapDocs = void 0;
      var lyapDocs = exports.lyapDocs = {
        name: "lyap",
        category: "Algebra",
        syntax: ["lyap(A,Q)"],
        description: "Solves the Continuous-time Lyapunov equation AP+PA'+Q=0 for P",
        examples: ["lyap([[-2, 0], [1, -4]], [[3, 1], [1, 3]])", "A = [[-2, 0], [1, -4]]", "Q = [[3, 1], [1, 3]]", "lyap(A,Q)"],
        seealso: ["schur", "sylvester"]
      };
    }
  });

  // node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/expression/embeddedDocs/function/arithmetic/square.js
  var require_square2 = __commonJS({
    "node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/expression/embeddedDocs/function/arithmetic/square.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.squareDocs = void 0;
      var squareDocs = exports.squareDocs = {
        name: "square",
        category: "Arithmetic",
        syntax: ["square(x)"],
        description: "Compute the square of a value. The square of x is x * x.",
        examples: ["square(3)", "sqrt(9)", "3^2", "3 * 3"],
        seealso: ["multiply", "pow", "sqrt", "cube"]
      };
    }
  });

  // node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/expression/embeddedDocs/function/arithmetic/subtract.js
  var require_subtract2 = __commonJS({
    "node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/expression/embeddedDocs/function/arithmetic/subtract.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.subtractDocs = void 0;
      var subtractDocs = exports.subtractDocs = {
        name: "subtract",
        category: "Operators",
        syntax: ["x - y", "subtract(x, y)"],
        description: "subtract two values.",
        examples: ["a = 5.3 - 2", "a + 2", "2/3 - 1/6", "2 * 3 - 3", "2.1 km - 500m"],
        seealso: ["add"]
      };
    }
  });

  // node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/expression/embeddedDocs/function/arithmetic/unaryMinus.js
  var require_unaryMinus2 = __commonJS({
    "node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/expression/embeddedDocs/function/arithmetic/unaryMinus.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.unaryMinusDocs = void 0;
      var unaryMinusDocs = exports.unaryMinusDocs = {
        name: "unaryMinus",
        category: "Operators",
        syntax: ["-x", "unaryMinus(x)"],
        description: "Inverse the sign of a value. Converts booleans and strings to numbers.",
        examples: ["-4.5", "-(-5.6)", '-"22"'],
        seealso: ["add", "subtract", "unaryPlus"]
      };
    }
  });

  // node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/expression/embeddedDocs/function/arithmetic/unaryPlus.js
  var require_unaryPlus2 = __commonJS({
    "node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/expression/embeddedDocs/function/arithmetic/unaryPlus.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.unaryPlusDocs = void 0;
      var unaryPlusDocs = exports.unaryPlusDocs = {
        name: "unaryPlus",
        category: "Operators",
        syntax: ["+x", "unaryPlus(x)"],
        description: "Converts booleans and strings to numbers.",
        examples: ["+true", '+"2"'],
        seealso: ["add", "subtract", "unaryMinus"]
      };
    }
  });

  // node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/expression/embeddedDocs/function/arithmetic/xgcd.js
  var require_xgcd2 = __commonJS({
    "node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/expression/embeddedDocs/function/arithmetic/xgcd.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.xgcdDocs = void 0;
      var xgcdDocs = exports.xgcdDocs = {
        name: "xgcd",
        category: "Arithmetic",
        syntax: ["xgcd(a, b)"],
        description: "Calculate the extended greatest common divisor for two values. The result is an array [d, x, y] with 3 entries, where d is the greatest common divisor, and d = x * a + y * b.",
        examples: ["xgcd(8, 12)", "gcd(8, 12)", "xgcd(36163, 21199)"],
        seealso: ["gcd", "lcm"]
      };
    }
  });

  // node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/expression/embeddedDocs/function/bitwise/bitAnd.js
  var require_bitAnd2 = __commonJS({
    "node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/expression/embeddedDocs/function/bitwise/bitAnd.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.bitAndDocs = void 0;
      var bitAndDocs = exports.bitAndDocs = {
        name: "bitAnd",
        category: "Bitwise",
        syntax: ["x & y", "bitAnd(x, y)"],
        description: "Bitwise AND operation. Performs the logical AND operation on each pair of the corresponding bits of the two given values by multiplying them. If both bits in the compared position are 1, the bit in the resulting binary representation is 1, otherwise, the result is 0",
        examples: ["5 & 3", "bitAnd(53, 131)", "[1, 12, 31] & 42"],
        seealso: ["bitNot", "bitOr", "bitXor", "leftShift", "rightArithShift", "rightLogShift"]
      };
    }
  });

  // node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/expression/embeddedDocs/function/bitwise/bitNot.js
  var require_bitNot2 = __commonJS({
    "node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/expression/embeddedDocs/function/bitwise/bitNot.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.bitNotDocs = void 0;
      var bitNotDocs = exports.bitNotDocs = {
        name: "bitNot",
        category: "Bitwise",
        syntax: ["~x", "bitNot(x)"],
        description: "Bitwise NOT operation. Performs a logical negation on each bit of the given value. Bits that are 0 become 1, and those that are 1 become 0.",
        examples: ["~1", "~2", "bitNot([2, -3, 4])"],
        seealso: ["bitAnd", "bitOr", "bitXor", "leftShift", "rightArithShift", "rightLogShift"]
      };
    }
  });

  // node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/expression/embeddedDocs/function/bitwise/bitOr.js
  var require_bitOr2 = __commonJS({
    "node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/expression/embeddedDocs/function/bitwise/bitOr.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.bitOrDocs = void 0;
      var bitOrDocs = exports.bitOrDocs = {
        name: "bitOr",
        category: "Bitwise",
        syntax: ["x | y", "bitOr(x, y)"],
        description: "Bitwise OR operation. Performs the logical inclusive OR operation on each pair of corresponding bits of the two given values. The result in each position is 1 if the first bit is 1 or the second bit is 1 or both bits are 1, otherwise, the result is 0.",
        examples: ["5 | 3", "bitOr([1, 2, 3], 4)"],
        seealso: ["bitAnd", "bitNot", "bitXor", "leftShift", "rightArithShift", "rightLogShift"]
      };
    }
  });

  // node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/expression/embeddedDocs/function/bitwise/bitXor.js
  var require_bitXor2 = __commonJS({
    "node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/expression/embeddedDocs/function/bitwise/bitXor.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.bitXorDocs = void 0;
      var bitXorDocs = exports.bitXorDocs = {
        name: "bitXor",
        category: "Bitwise",
        syntax: ["bitXor(x, y)"],
        description: "Bitwise XOR operation, exclusive OR. Performs the logical exclusive OR operation on each pair of corresponding bits of the two given values. The result in each position is 1 if only the first bit is 1 or only the second bit is 1, but will be 0 if both are 0 or both are 1.",
        examples: ["bitOr(1, 2)", "bitXor([2, 3, 4], 4)"],
        seealso: ["bitAnd", "bitNot", "bitOr", "leftShift", "rightArithShift", "rightLogShift"]
      };
    }
  });

  // node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/expression/embeddedDocs/function/bitwise/leftShift.js
  var require_leftShift2 = __commonJS({
    "node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/expression/embeddedDocs/function/bitwise/leftShift.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.leftShiftDocs = void 0;
      var leftShiftDocs = exports.leftShiftDocs = {
        name: "leftShift",
        category: "Bitwise",
        syntax: ["x << y", "leftShift(x, y)"],
        description: "Bitwise left logical shift of a value x by y number of bits.",
        examples: ["4 << 1", "8 >> 1"],
        seealso: ["bitAnd", "bitNot", "bitOr", "bitXor", "rightArithShift", "rightLogShift"]
      };
    }
  });

  // node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/expression/embeddedDocs/function/bitwise/rightArithShift.js
  var require_rightArithShift2 = __commonJS({
    "node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/expression/embeddedDocs/function/bitwise/rightArithShift.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.rightArithShiftDocs = void 0;
      var rightArithShiftDocs = exports.rightArithShiftDocs = {
        name: "rightArithShift",
        category: "Bitwise",
        syntax: ["x >> y", "rightArithShift(x, y)"],
        description: "Bitwise right arithmetic shift of a value x by y number of bits.",
        examples: ["8 >> 1", "4 << 1", "-12 >> 2"],
        seealso: ["bitAnd", "bitNot", "bitOr", "bitXor", "leftShift", "rightLogShift"]
      };
    }
  });

  // node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/expression/embeddedDocs/function/bitwise/rightLogShift.js
  var require_rightLogShift2 = __commonJS({
    "node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/expression/embeddedDocs/function/bitwise/rightLogShift.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.rightLogShiftDocs = void 0;
      var rightLogShiftDocs = exports.rightLogShiftDocs = {
        name: "rightLogShift",
        category: "Bitwise",
        syntax: ["x >>> y", "rightLogShift(x, y)"],
        description: "Bitwise right logical shift of a value x by y number of bits.",
        examples: ["8 >>> 1", "4 << 1", "-12 >>> 2"],
        seealso: ["bitAnd", "bitNot", "bitOr", "bitXor", "leftShift", "rightArithShift"]
      };
    }
  });

  // node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/expression/embeddedDocs/function/combinatorics/bellNumbers.js
  var require_bellNumbers = __commonJS({
    "node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/expression/embeddedDocs/function/combinatorics/bellNumbers.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.bellNumbersDocs = void 0;
      var bellNumbersDocs = exports.bellNumbersDocs = {
        name: "bellNumbers",
        category: "Combinatorics",
        syntax: ["bellNumbers(n)"],
        description: "The Bell Numbers count the number of partitions of a set. A partition is a pairwise disjoint subset of S whose union is S. `bellNumbers` only takes integer arguments. The following condition must be enforced: n >= 0.",
        examples: ["bellNumbers(3)", "bellNumbers(8)"],
        seealso: ["stirlingS2"]
      };
    }
  });

  // node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/expression/embeddedDocs/function/combinatorics/catalan.js
  var require_catalan = __commonJS({
    "node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/expression/embeddedDocs/function/combinatorics/catalan.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.catalanDocs = void 0;
      var catalanDocs = exports.catalanDocs = {
        name: "catalan",
        category: "Combinatorics",
        syntax: ["catalan(n)"],
        description: "The Catalan Numbers enumerate combinatorial structures of many different types. catalan only takes integer arguments. The following condition must be enforced: n >= 0.",
        examples: ["catalan(3)", "catalan(8)"],
        seealso: ["bellNumbers"]
      };
    }
  });

  // node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/expression/embeddedDocs/function/combinatorics/composition.js
  var require_composition = __commonJS({
    "node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/expression/embeddedDocs/function/combinatorics/composition.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.compositionDocs = void 0;
      var compositionDocs = exports.compositionDocs = {
        name: "composition",
        category: "Combinatorics",
        syntax: ["composition(n, k)"],
        description: "The composition counts of n into k parts. composition only takes integer arguments. The following condition must be enforced: k <= n.",
        examples: ["composition(5, 3)"],
        seealso: ["combinations"]
      };
    }
  });

  // node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/expression/embeddedDocs/function/combinatorics/stirlingS2.js
  var require_stirlingS2 = __commonJS({
    "node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/expression/embeddedDocs/function/combinatorics/stirlingS2.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.stirlingS2Docs = void 0;
      var stirlingS2Docs = exports.stirlingS2Docs = {
        name: "stirlingS2",
        category: "Combinatorics",
        syntax: ["stirlingS2(n, k)"],
        description: "he Stirling numbers of the second kind, counts the number of ways to partition a set of n labelled objects into k nonempty unlabelled subsets. `stirlingS2` only takes integer arguments. The following condition must be enforced: k <= n. If n = k or k = 1, then s(n,k) = 1.",
        examples: ["stirlingS2(5, 3)"],
        seealso: ["bellNumbers"]
      };
    }
  });

  // node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/expression/embeddedDocs/function/complex/arg.js
  var require_arg2 = __commonJS({
    "node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/expression/embeddedDocs/function/complex/arg.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.argDocs = void 0;
      var argDocs = exports.argDocs = {
        name: "arg",
        category: "Complex",
        syntax: ["arg(x)"],
        description: "Compute the argument of a complex value. If x = a+bi, the argument is computed as atan2(b, a).",
        examples: ["arg(2 + 2i)", "atan2(3, 2)", "arg(2 + 3i)"],
        seealso: ["re", "im", "conj", "abs"]
      };
    }
  });

  // node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/expression/embeddedDocs/function/complex/conj.js
  var require_conj2 = __commonJS({
    "node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/expression/embeddedDocs/function/complex/conj.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.conjDocs = void 0;
      var conjDocs = exports.conjDocs = {
        name: "conj",
        category: "Complex",
        syntax: ["conj(x)"],
        description: "Compute the complex conjugate of a complex value. If x = a+bi, the complex conjugate is a-bi.",
        examples: ["conj(2 + 3i)", "conj(2 - 3i)", "conj(-5.2i)"],
        seealso: ["re", "im", "abs", "arg"]
      };
    }
  });

  // node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/expression/embeddedDocs/function/complex/im.js
  var require_im2 = __commonJS({
    "node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/expression/embeddedDocs/function/complex/im.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.imDocs = void 0;
      var imDocs = exports.imDocs = {
        name: "im",
        category: "Complex",
        syntax: ["im(x)"],
        description: "Get the imaginary part of a complex number.",
        examples: ["im(2 + 3i)", "re(2 + 3i)", "im(-5.2i)", "im(2.4)"],
        seealso: ["re", "conj", "abs", "arg"]
      };
    }
  });

  // node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/expression/embeddedDocs/function/complex/re.js
  var require_re2 = __commonJS({
    "node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/expression/embeddedDocs/function/complex/re.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.reDocs = void 0;
      var reDocs = exports.reDocs = {
        name: "re",
        category: "Complex",
        syntax: ["re(x)"],
        description: "Get the real part of a complex number.",
        examples: ["re(2 + 3i)", "im(2 + 3i)", "re(-5.2i)", "re(2.4)"],
        seealso: ["im", "conj", "abs", "arg"]
      };
    }
  });

  // node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/expression/embeddedDocs/function/expression/evaluate.js
  var require_evaluate2 = __commonJS({
    "node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/expression/embeddedDocs/function/expression/evaluate.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.evaluateDocs = void 0;
      var evaluateDocs = exports.evaluateDocs = {
        name: "evaluate",
        category: "Expression",
        syntax: ["evaluate(expression)", "evaluate(expression, scope)", "evaluate([expr1, expr2, expr3, ...])", "evaluate([expr1, expr2, expr3, ...], scope)"],
        description: "Evaluate an expression or an array with expressions.",
        examples: ['evaluate("2 + 3")', 'evaluate("sqrt(16)")', 'evaluate("2 inch to cm")', 'evaluate("sin(x * pi)", { "x": 1/2 })', 'evaluate(["width=2", "height=4","width*height"])'],
        seealso: []
      };
    }
  });

  // node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/expression/embeddedDocs/function/expression/help.js
  var require_help = __commonJS({
    "node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/expression/embeddedDocs/function/expression/help.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.helpDocs = void 0;
      var helpDocs = exports.helpDocs = {
        name: "help",
        category: "Expression",
        syntax: ["help(object)", "help(string)"],
        description: "Display documentation on a function or data type.",
        examples: ["help(sqrt)", 'help("complex")'],
        seealso: []
      };
    }
  });

  // node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/expression/embeddedDocs/function/geometry/distance.js
  var require_distance = __commonJS({
    "node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/expression/embeddedDocs/function/geometry/distance.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.distanceDocs = void 0;
      var distanceDocs = exports.distanceDocs = {
        name: "distance",
        category: "Geometry",
        syntax: ["distance([x1, y1], [x2, y2])", "distance([[x1, y1], [x2, y2]])"],
        description: "Calculates the Euclidean distance between two points.",
        examples: ["distance([0,0], [4,4])", "distance([[0,0], [4,4]])"],
        seealso: []
      };
    }
  });

  // node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/expression/embeddedDocs/function/geometry/intersect.js
  var require_intersect = __commonJS({
    "node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/expression/embeddedDocs/function/geometry/intersect.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.intersectDocs = void 0;
      var intersectDocs = exports.intersectDocs = {
        name: "intersect",
        category: "Geometry",
        syntax: ["intersect(expr1, expr2, expr3, expr4)", "intersect(expr1, expr2, expr3)"],
        description: "Computes the intersection point of lines and/or planes.",
        examples: ["intersect([0, 0], [10, 10], [10, 0], [0, 10])", "intersect([1, 0, 1],  [4, -2, 2], [1, 1, 1, 6])"],
        seealso: []
      };
    }
  });

  // node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/expression/embeddedDocs/function/logical/and.js
  var require_and2 = __commonJS({
    "node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/expression/embeddedDocs/function/logical/and.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.andDocs = void 0;
      var andDocs = exports.andDocs = {
        name: "and",
        category: "Logical",
        syntax: ["x and y", "and(x, y)"],
        description: "Logical and. Test whether two values are both defined with a nonzero/nonempty value.",
        examples: ["true and false", "true and true", "2 and 4"],
        seealso: ["not", "or", "xor"]
      };
    }
  });

  // node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/expression/embeddedDocs/function/logical/not.js
  var require_not2 = __commonJS({
    "node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/expression/embeddedDocs/function/logical/not.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.notDocs = void 0;
      var notDocs = exports.notDocs = {
        name: "not",
        category: "Logical",
        syntax: ["not x", "not(x)"],
        description: "Logical not. Flips the boolean value of given argument.",
        examples: ["not true", "not false", "not 2", "not 0"],
        seealso: ["and", "or", "xor"]
      };
    }
  });

  // node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/expression/embeddedDocs/function/logical/or.js
  var require_or2 = __commonJS({
    "node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/expression/embeddedDocs/function/logical/or.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.orDocs = void 0;
      var orDocs = exports.orDocs = {
        name: "or",
        category: "Logical",
        syntax: ["x or y", "or(x, y)"],
        description: "Logical or. Test if at least one value is defined with a nonzero/nonempty value.",
        examples: ["true or false", "false or false", "0 or 4"],
        seealso: ["not", "and", "xor"]
      };
    }
  });

  // node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/expression/embeddedDocs/function/logical/xor.js
  var require_xor2 = __commonJS({
    "node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/expression/embeddedDocs/function/logical/xor.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.xorDocs = void 0;
      var xorDocs = exports.xorDocs = {
        name: "xor",
        category: "Logical",
        syntax: ["x xor y", "xor(x, y)"],
        description: "Logical exclusive or, xor. Test whether one and only one value is defined with a nonzero/nonempty value.",
        examples: ["true xor false", "false xor false", "true xor true", "0 xor 4"],
        seealso: ["not", "and", "or"]
      };
    }
  });

  // node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/expression/embeddedDocs/function/matrix/column.js
  var require_column2 = __commonJS({
    "node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/expression/embeddedDocs/function/matrix/column.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.columnDocs = void 0;
      var columnDocs = exports.columnDocs = {
        name: "column",
        category: "Matrix",
        syntax: ["column(x, index)"],
        description: "Return a column from a matrix or array.",
        examples: ["A = [[1, 2], [3, 4]]", "column(A, 1)", "column(A, 2)"],
        seealso: ["row", "matrixFromColumns"]
      };
    }
  });

  // node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/expression/embeddedDocs/function/matrix/concat.js
  var require_concat2 = __commonJS({
    "node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/expression/embeddedDocs/function/matrix/concat.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.concatDocs = void 0;
      var concatDocs = exports.concatDocs = {
        name: "concat",
        category: "Matrix",
        syntax: ["concat(A, B, C, ...)", "concat(A, B, C, ..., dim)"],
        description: "Concatenate matrices. By default, the matrices are concatenated by the last dimension. The dimension on which to concatenate can be provided as last argument.",
        examples: ["A = [1, 2; 5, 6]", "B = [3, 4; 7, 8]", "concat(A, B)", "concat(A, B, 1)", "concat(A, B, 2)"],
        seealso: ["det", "diag", "identity", "inv", "ones", "range", "size", "squeeze", "subset", "trace", "transpose", "zeros"]
      };
    }
  });

  // node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/expression/embeddedDocs/function/matrix/count.js
  var require_count2 = __commonJS({
    "node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/expression/embeddedDocs/function/matrix/count.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.countDocs = void 0;
      var countDocs = exports.countDocs = {
        name: "count",
        category: "Matrix",
        syntax: ["count(x)"],
        description: "Count the number of elements of a matrix, array or string.",
        examples: ["a = [1, 2; 3, 4; 5, 6]", "count(a)", "size(a)", 'count("hello world")'],
        seealso: ["size"]
      };
    }
  });

  // node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/expression/embeddedDocs/function/matrix/cross.js
  var require_cross2 = __commonJS({
    "node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/expression/embeddedDocs/function/matrix/cross.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.crossDocs = void 0;
      var crossDocs = exports.crossDocs = {
        name: "cross",
        category: "Matrix",
        syntax: ["cross(A, B)"],
        description: "Calculate the cross product for two vectors in three dimensional space.",
        examples: ["cross([1, 1, 0],  [0, 1, 1])", "cross([3, -3, 1], [4, 9, 2])", "cross([2, 3, 4],  [5, 6, 7])"],
        seealso: ["multiply", "dot"]
      };
    }
  });

  // node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/expression/embeddedDocs/function/matrix/ctranspose.js
  var require_ctranspose2 = __commonJS({
    "node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/expression/embeddedDocs/function/matrix/ctranspose.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.ctransposeDocs = void 0;
      var ctransposeDocs = exports.ctransposeDocs = {
        name: "ctranspose",
        category: "Matrix",
        syntax: ["x'", "ctranspose(x)"],
        description: "Complex Conjugate and Transpose a matrix",
        examples: ["a = [1, 2, 3; 4, 5, 6]", "a'", "ctranspose(a)"],
        seealso: ["concat", "det", "diag", "identity", "inv", "ones", "range", "size", "squeeze", "subset", "trace", "zeros"]
      };
    }
  });

  // node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/expression/embeddedDocs/function/matrix/det.js
  var require_det = __commonJS({
    "node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/expression/embeddedDocs/function/matrix/det.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.detDocs = void 0;
      var detDocs = exports.detDocs = {
        name: "det",
        category: "Matrix",
        syntax: ["det(x)"],
        description: "Calculate the determinant of a matrix",
        examples: ["det([1, 2; 3, 4])", "det([-2, 2, 3; -1, 1, 3; 2, 0, -1])"],
        seealso: ["concat", "diag", "identity", "inv", "ones", "range", "size", "squeeze", "subset", "trace", "transpose", "zeros"]
      };
    }
  });

  // node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/expression/embeddedDocs/function/matrix/diag.js
  var require_diag2 = __commonJS({
    "node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/expression/embeddedDocs/function/matrix/diag.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.diagDocs = void 0;
      var diagDocs = exports.diagDocs = {
        name: "diag",
        category: "Matrix",
        syntax: ["diag(x)", "diag(x, k)"],
        description: "Create a diagonal matrix or retrieve the diagonal of a matrix. When x is a vector, a matrix with the vector values on the diagonal will be returned. When x is a matrix, a vector with the diagonal values of the matrix is returned. When k is provided, the k-th diagonal will be filled in or retrieved, if k is positive, the values are placed on the super diagonal. When k is negative, the values are placed on the sub diagonal.",
        examples: ["diag(1:3)", "diag(1:3, 1)", "a = [1, 2, 3; 4, 5, 6; 7, 8, 9]", "diag(a)"],
        seealso: ["concat", "det", "identity", "inv", "ones", "range", "size", "squeeze", "subset", "trace", "transpose", "zeros"]
      };
    }
  });

  // node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/expression/embeddedDocs/function/matrix/diff.js
  var require_diff2 = __commonJS({
    "node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/expression/embeddedDocs/function/matrix/diff.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.diffDocs = void 0;
      var diffDocs = exports.diffDocs = {
        name: "diff",
        category: "Matrix",
        syntax: ["diff(arr)", "diff(arr, dim)"],
        description: ["Create a new matrix or array with the difference of the passed matrix or array.", "Dim parameter is optional and used to indicant the dimension of the array/matrix to apply the difference", "If no dimension parameter is passed it is assumed as dimension 0", "Dimension is zero-based in javascript and one-based in the parser", "Arrays must be 'rectangular' meaning arrays like [1, 2]", "If something is passed as a matrix it will be returned as a matrix but other than that all matrices are converted to arrays"],
        examples: ["A = [1, 2, 4, 7, 0]", "diff(A)", "diff(A, 1)", "B = [[1, 2], [3, 4]]", "diff(B)", "diff(B, 1)", "diff(B, 2)", "diff(B, bignumber(2))", "diff([[1, 2], matrix([3, 4])], 2)"],
        seealso: ["subtract", "partitionSelect"]
      };
    }
  });

  // node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/expression/embeddedDocs/function/matrix/dot.js
  var require_dot2 = __commonJS({
    "node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/expression/embeddedDocs/function/matrix/dot.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.dotDocs = void 0;
      var dotDocs = exports.dotDocs = {
        name: "dot",
        category: "Matrix",
        syntax: ["dot(A, B)", "A * B"],
        description: "Calculate the dot product of two vectors. The dot product of A = [a1, a2, a3, ..., an] and B = [b1, b2, b3, ..., bn] is defined as dot(A, B) = a1 * b1 + a2 * b2 + a3 * b3 + ... + an * bn",
        examples: ["dot([2, 4, 1], [2, 2, 3])", "[2, 4, 1] * [2, 2, 3]"],
        seealso: ["multiply", "cross"]
      };
    }
  });

  // node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/expression/embeddedDocs/function/matrix/eigs.js
  var require_eigs = __commonJS({
    "node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/expression/embeddedDocs/function/matrix/eigs.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.eigsDocs = void 0;
      var eigsDocs = exports.eigsDocs = {
        name: "eigs",
        category: "Matrix",
        syntax: ["eigs(x)"],
        description: "Calculate the eigenvalues and optionally eigenvectors of a square matrix",
        examples: ["eigs([[5, 2.3], [2.3, 1]])", "eigs([[1, 2, 3], [4, 5, 6], [7, 8, 9]], { precision: 1e-6, eigenvectors: false })"],
        seealso: ["inv"]
      };
    }
  });

  // node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/expression/embeddedDocs/function/matrix/filter.js
  var require_filter2 = __commonJS({
    "node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/expression/embeddedDocs/function/matrix/filter.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.filterDocs = void 0;
      var filterDocs = exports.filterDocs = {
        name: "filter",
        category: "Matrix",
        syntax: ["filter(x, test)"],
        description: "Filter items in a matrix.",
        examples: ["isPositive(x) = x > 0", "filter([6, -2, -1, 4, 3], isPositive)", "filter([6, -2, 0, 1, 0], x != 0)"],
        seealso: ["sort", "map", "forEach"]
      };
    }
  });

  // node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/expression/embeddedDocs/function/matrix/flatten.js
  var require_flatten2 = __commonJS({
    "node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/expression/embeddedDocs/function/matrix/flatten.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.flattenDocs = void 0;
      var flattenDocs = exports.flattenDocs = {
        name: "flatten",
        category: "Matrix",
        syntax: ["flatten(x)"],
        description: "Flatten a multi dimensional matrix into a single dimensional matrix.",
        examples: ["a = [1, 2, 3; 4, 5, 6]", "size(a)", "b = flatten(a)", "size(b)"],
        seealso: ["concat", "resize", "size", "squeeze"]
      };
    }
  });

  // node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/expression/embeddedDocs/function/matrix/forEach.js
  var require_forEach2 = __commonJS({
    "node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/expression/embeddedDocs/function/matrix/forEach.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.forEachDocs = void 0;
      var forEachDocs = exports.forEachDocs = {
        name: "forEach",
        category: "Matrix",
        syntax: ["forEach(x, callback)"],
        description: "Iterates over all elements of a matrix/array, and executes the given callback function.",
        examples: ["numberOfPets = {}", "addPet(n) = numberOfPets[n] = (numberOfPets[n] ? numberOfPets[n]:0 ) + 1;", 'forEach(["Dog","Cat","Cat"], addPet)', "numberOfPets"],
        seealso: ["map", "sort", "filter"]
      };
    }
  });

  // node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/expression/embeddedDocs/function/matrix/getMatrixDataType.js
  var require_getMatrixDataType2 = __commonJS({
    "node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/expression/embeddedDocs/function/matrix/getMatrixDataType.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.getMatrixDataTypeDocs = void 0;
      var getMatrixDataTypeDocs = exports.getMatrixDataTypeDocs = {
        name: "getMatrixDataType",
        category: "Matrix",
        syntax: ["getMatrixDataType(x)"],
        description: 'Find the data type of all elements in a matrix or array, for example "number" if all items are a number and "Complex" if all values are complex numbers. If a matrix contains more than one data type, it will return "mixed".',
        examples: ["getMatrixDataType([1, 2, 3])", "getMatrixDataType([[5 cm], [2 inch]])", 'getMatrixDataType([1, "text"])', "getMatrixDataType([1, bignumber(4)])"],
        seealso: ["matrix", "sparse", "typeOf"]
      };
    }
  });

  // node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/expression/embeddedDocs/function/matrix/identity.js
  var require_identity2 = __commonJS({
    "node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/expression/embeddedDocs/function/matrix/identity.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.identityDocs = void 0;
      var identityDocs = exports.identityDocs = {
        name: "identity",
        category: "Matrix",
        syntax: ["identity(n)", "identity(m, n)", "identity([m, n])"],
        description: "Returns the identity matrix with size m-by-n. The matrix has ones on the diagonal and zeros elsewhere.",
        examples: ["identity(3)", "identity(3, 5)", "a = [1, 2, 3; 4, 5, 6]", "identity(size(a))"],
        seealso: ["concat", "det", "diag", "inv", "ones", "range", "size", "squeeze", "subset", "trace", "transpose", "zeros"]
      };
    }
  });

  // node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/expression/embeddedDocs/function/matrix/inv.js
  var require_inv = __commonJS({
    "node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/expression/embeddedDocs/function/matrix/inv.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.invDocs = void 0;
      var invDocs = exports.invDocs = {
        name: "inv",
        category: "Matrix",
        syntax: ["inv(x)"],
        description: "Calculate the inverse of a matrix",
        examples: ["inv([1, 2; 3, 4])", "inv(4)", "1 / 4"],
        seealso: ["concat", "det", "diag", "identity", "ones", "range", "size", "squeeze", "subset", "trace", "transpose", "zeros"]
      };
    }
  });

  // node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/expression/embeddedDocs/function/matrix/pinv.js
  var require_pinv = __commonJS({
    "node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/expression/embeddedDocs/function/matrix/pinv.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.pinvDocs = void 0;
      var pinvDocs = exports.pinvDocs = {
        name: "pinv",
        category: "Matrix",
        syntax: ["pinv(x)"],
        description: "Calculate the Moore\u2013Penrose inverse of a matrix",
        examples: ["pinv([1, 2; 3, 4])", "pinv([[1, 0], [0, 1], [0, 1]])", "pinv(4)"],
        seealso: ["inv"]
      };
    }
  });

  // node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/expression/embeddedDocs/function/matrix/kron.js
  var require_kron2 = __commonJS({
    "node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/expression/embeddedDocs/function/matrix/kron.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.kronDocs = void 0;
      var kronDocs = exports.kronDocs = {
        name: "kron",
        category: "Matrix",
        syntax: ["kron(x, y)"],
        description: "Calculates the kronecker product of 2 matrices or vectors.",
        examples: ["kron([[1, 0], [0, 1]], [[1, 2], [3, 4]])", "kron([1,1], [2,3,4])"],
        seealso: ["multiply", "dot", "cross"]
      };
    }
  });

  // node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/expression/embeddedDocs/function/matrix/map.js
  var require_map3 = __commonJS({
    "node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/expression/embeddedDocs/function/matrix/map.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.mapDocs = void 0;
      var mapDocs = exports.mapDocs = {
        name: "map",
        category: "Matrix",
        syntax: ["map(x, callback)"],
        description: "Create a new matrix or array with the results of the callback function executed on each entry of the matrix/array.",
        examples: ["map([1, 2, 3], square)"],
        seealso: ["filter", "forEach"]
      };
    }
  });

  // node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/expression/embeddedDocs/function/matrix/matrixFromColumns.js
  var require_matrixFromColumns2 = __commonJS({
    "node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/expression/embeddedDocs/function/matrix/matrixFromColumns.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.matrixFromColumnsDocs = void 0;
      var matrixFromColumnsDocs = exports.matrixFromColumnsDocs = {
        name: "matrixFromColumns",
        category: "Matrix",
        syntax: ["matrixFromColumns(...arr)", "matrixFromColumns(row1, row2)", "matrixFromColumns(row1, row2, row3)"],
        description: "Create a dense matrix from vectors as individual columns.",
        examples: ["matrixFromColumns([1, 2, 3], [[4],[5],[6]])"],
        seealso: ["matrix", "matrixFromRows", "matrixFromFunction", "zeros"]
      };
    }
  });

  // node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/expression/embeddedDocs/function/matrix/matrixFromFunction.js
  var require_matrixFromFunction2 = __commonJS({
    "node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/expression/embeddedDocs/function/matrix/matrixFromFunction.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.matrixFromFunctionDocs = void 0;
      var matrixFromFunctionDocs = exports.matrixFromFunctionDocs = {
        name: "matrixFromFunction",
        category: "Matrix",
        syntax: ["matrixFromFunction(size, fn)", "matrixFromFunction(size, fn, format)", "matrixFromFunction(size, fn, format, datatype)", "matrixFromFunction(size, format, fn)", "matrixFromFunction(size, format, datatype, fn)"],
        description: "Create a matrix by evaluating a generating function at each index.",
        examples: ["f(I) = I[1] - I[2]", "matrixFromFunction([3,3], f)", "g(I) = I[1] - I[2] == 1 ? 4 : 0", 'matrixFromFunction([100, 100], "sparse", g)', "matrixFromFunction([5], random)"],
        seealso: ["matrix", "matrixFromRows", "matrixFromColumns", "zeros"]
      };
    }
  });

  // node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/expression/embeddedDocs/function/matrix/matrixFromRows.js
  var require_matrixFromRows2 = __commonJS({
    "node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/expression/embeddedDocs/function/matrix/matrixFromRows.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.matrixFromRowsDocs = void 0;
      var matrixFromRowsDocs = exports.matrixFromRowsDocs = {
        name: "matrixFromRows",
        category: "Matrix",
        syntax: ["matrixFromRows(...arr)", "matrixFromRows(row1, row2)", "matrixFromRows(row1, row2, row3)"],
        description: "Create a dense matrix from vectors as individual rows.",
        examples: ["matrixFromRows([1, 2, 3], [[4],[5],[6]])"],
        seealso: ["matrix", "matrixFromColumns", "matrixFromFunction", "zeros"]
      };
    }
  });

  // node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/expression/embeddedDocs/function/matrix/ones.js
  var require_ones2 = __commonJS({
    "node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/expression/embeddedDocs/function/matrix/ones.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.onesDocs = void 0;
      var onesDocs = exports.onesDocs = {
        name: "ones",
        category: "Matrix",
        syntax: ["ones(m)", "ones(m, n)", "ones(m, n, p, ...)", "ones([m])", "ones([m, n])", "ones([m, n, p, ...])"],
        description: "Create a matrix containing ones.",
        examples: ["ones(3)", "ones(3, 5)", "ones([2,3]) * 4.5", "a = [1, 2, 3; 4, 5, 6]", "ones(size(a))"],
        seealso: ["concat", "det", "diag", "identity", "inv", "range", "size", "squeeze", "subset", "trace", "transpose", "zeros"]
      };
    }
  });

  // node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/expression/embeddedDocs/function/matrix/partitionSelect.js
  var require_partitionSelect2 = __commonJS({
    "node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/expression/embeddedDocs/function/matrix/partitionSelect.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.partitionSelectDocs = void 0;
      var partitionSelectDocs = exports.partitionSelectDocs = {
        name: "partitionSelect",
        category: "Matrix",
        syntax: ["partitionSelect(x, k)", "partitionSelect(x, k, compare)"],
        description: "Partition-based selection of an array or 1D matrix. Will find the kth smallest value, and mutates the input array. Uses Quickselect.",
        examples: ["partitionSelect([5, 10, 1], 2)", 'partitionSelect(["C", "B", "A", "D"], 1, compareText)', "arr = [5, 2, 1]", "partitionSelect(arr, 0) # returns 1, arr is now: [1, 2, 5]", "arr", "partitionSelect(arr, 1, 'desc') # returns 2, arr is now: [5, 2, 1]", "arr"],
        seealso: ["sort"]
      };
    }
  });

  // node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/expression/embeddedDocs/function/matrix/range.js
  var require_range2 = __commonJS({
    "node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/expression/embeddedDocs/function/matrix/range.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.rangeDocs = void 0;
      var rangeDocs = exports.rangeDocs = {
        name: "range",
        category: "Type",
        syntax: ["start:end", "start:step:end", "range(start, end)", "range(start, end, step)", "range(string)"],
        description: "Create a range. Lower bound of the range is included, upper bound is excluded.",
        examples: ["1:5", "3:-1:-3", "range(3, 7)", "range(0, 12, 2)", 'range("4:10")', "range(1m, 1m, 3m)", "a = [1, 2, 3, 4; 5, 6, 7, 8]", "a[1:2, 1:2]"],
        seealso: ["concat", "det", "diag", "identity", "inv", "ones", "size", "squeeze", "subset", "trace", "transpose", "zeros"]
      };
    }
  });

  // node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/expression/embeddedDocs/function/matrix/reshape.js
  var require_reshape2 = __commonJS({
    "node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/expression/embeddedDocs/function/matrix/reshape.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.reshapeDocs = void 0;
      var reshapeDocs = exports.reshapeDocs = {
        name: "reshape",
        category: "Matrix",
        syntax: ["reshape(x, sizes)"],
        description: "Reshape a multi dimensional array to fit the specified dimensions.",
        examples: ["reshape([1, 2, 3, 4, 5, 6], [2, 3])", "reshape([[1, 2], [3, 4]], [1, 4])", "reshape([[1, 2], [3, 4]], [4])", "reshape([1, 2, 3, 4], [-1, 2])"],
        seealso: ["size", "squeeze", "resize"]
      };
    }
  });

  // node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/expression/embeddedDocs/function/matrix/resize.js
  var require_resize2 = __commonJS({
    "node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/expression/embeddedDocs/function/matrix/resize.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.resizeDocs = void 0;
      var resizeDocs = exports.resizeDocs = {
        name: "resize",
        category: "Matrix",
        syntax: ["resize(x, size)", "resize(x, size, defaultValue)"],
        description: "Resize a matrix.",
        examples: ["resize([1,2,3,4,5], [3])", "resize([1,2,3], [5])", "resize([1,2,3], [5], -1)", "resize(2, [2, 3])", 'resize("hello", [8], "!")'],
        seealso: ["size", "subset", "squeeze", "reshape"]
      };
    }
  });

  // node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/expression/embeddedDocs/function/matrix/rotate.js
  var require_rotate2 = __commonJS({
    "node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/expression/embeddedDocs/function/matrix/rotate.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.rotateDocs = void 0;
      var rotateDocs = exports.rotateDocs = {
        name: "rotate",
        category: "Matrix",
        syntax: ["rotate(w, theta)", "rotate(w, theta, v)"],
        description: "Returns a 2-D rotation matrix (2x2) for a given angle (in radians). Returns a 2-D rotation matrix (3x3) of a given angle (in radians) around given axis.",
        examples: ["rotate([1, 0], pi / 2)", 'rotate(matrix([1, 0]), unit("35deg"))', 'rotate([1, 0, 0], unit("90deg"), [0, 0, 1])', 'rotate(matrix([1, 0, 0]), unit("90deg"), matrix([0, 0, 1]))'],
        seealso: ["matrix", "rotationMatrix"]
      };
    }
  });

  // node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/expression/embeddedDocs/function/matrix/rotationMatrix.js
  var require_rotationMatrix2 = __commonJS({
    "node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/expression/embeddedDocs/function/matrix/rotationMatrix.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.rotationMatrixDocs = void 0;
      var rotationMatrixDocs = exports.rotationMatrixDocs = {
        name: "rotationMatrix",
        category: "Matrix",
        syntax: ["rotationMatrix(theta)", "rotationMatrix(theta, v)", "rotationMatrix(theta, v, format)"],
        description: "Returns a 2-D rotation matrix (2x2) for a given angle (in radians). Returns a 2-D rotation matrix (3x3) of a given angle (in radians) around given axis.",
        examples: ["rotationMatrix(pi / 2)", 'rotationMatrix(unit("45deg"), [0, 0, 1])', 'rotationMatrix(1, matrix([0, 0, 1]), "sparse")'],
        seealso: ["cos", "sin"]
      };
    }
  });

  // node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/expression/embeddedDocs/function/matrix/row.js
  var require_row2 = __commonJS({
    "node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/expression/embeddedDocs/function/matrix/row.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.rowDocs = void 0;
      var rowDocs = exports.rowDocs = {
        name: "row",
        category: "Matrix",
        syntax: ["row(x, index)"],
        description: "Return a row from a matrix or array.",
        examples: ["A = [[1, 2], [3, 4]]", "row(A, 1)", "row(A, 2)"],
        seealso: ["column", "matrixFromRows"]
      };
    }
  });

  // node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/expression/embeddedDocs/function/matrix/size.js
  var require_size2 = __commonJS({
    "node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/expression/embeddedDocs/function/matrix/size.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.sizeDocs = void 0;
      var sizeDocs = exports.sizeDocs = {
        name: "size",
        category: "Matrix",
        syntax: ["size(x)"],
        description: "Calculate the size of a matrix.",
        examples: ["size(2.3)", 'size("hello world")', "a = [1, 2; 3, 4; 5, 6]", "size(a)", "size(1:6)"],
        seealso: ["concat", "count", "det", "diag", "identity", "inv", "ones", "range", "squeeze", "subset", "trace", "transpose", "zeros"]
      };
    }
  });

  // node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/expression/embeddedDocs/function/matrix/sort.js
  var require_sort2 = __commonJS({
    "node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/expression/embeddedDocs/function/matrix/sort.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.sortDocs = void 0;
      var sortDocs = exports.sortDocs = {
        name: "sort",
        category: "Matrix",
        syntax: ["sort(x)", "sort(x, compare)"],
        description: 'Sort the items in a matrix. Compare can be a string "asc", "desc", "natural", or a custom sort function.',
        examples: ["sort([5, 10, 1])", 'sort(["C", "B", "A", "D"], "natural")', "sortByLength(a, b) = size(a)[1] - size(b)[1]", 'sort(["Langdon", "Tom", "Sara"], sortByLength)', 'sort(["10", "1", "2"], "natural")'],
        seealso: ["map", "filter", "forEach"]
      };
    }
  });

  // node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/expression/embeddedDocs/function/matrix/squeeze.js
  var require_squeeze2 = __commonJS({
    "node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/expression/embeddedDocs/function/matrix/squeeze.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.squeezeDocs = void 0;
      var squeezeDocs = exports.squeezeDocs = {
        name: "squeeze",
        category: "Matrix",
        syntax: ["squeeze(x)"],
        description: "Remove inner and outer singleton dimensions from a matrix.",
        examples: ["a = zeros(3,2,1)", "size(squeeze(a))", "b = zeros(1,1,3)", "size(squeeze(b))"],
        seealso: ["concat", "det", "diag", "identity", "inv", "ones", "range", "size", "subset", "trace", "transpose", "zeros"]
      };
    }
  });

  // node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/expression/embeddedDocs/function/matrix/subset.js
  var require_subset2 = __commonJS({
    "node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/expression/embeddedDocs/function/matrix/subset.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.subsetDocs = void 0;
      var subsetDocs = exports.subsetDocs = {
        name: "subset",
        category: "Matrix",
        syntax: ["value(index)", "value(index) = replacement", "subset(value, [index])", "subset(value, [index], replacement)"],
        description: "Get or set a subset of the entries of a matrix or characters of a string. Indexes are one-based. There should be one index specification for each dimension of the target. Each specification can be a single index, a list of indices, or a range in colon notation `l:u`. In a range, both the lower bound l and upper bound u are included; and if a bound is omitted it defaults to the most extreme valid value. The cartesian product of the indices specified in each dimension determines the target of the operation.",
        examples: ["d = [1, 2; 3, 4]", "e = []", "e[1, 1:2] = [5, 6]", "e[2, :] = [7, 8]", "f = d * e", "f[2, 1]", "f[:, 1]", "f[[1,2], [1,3]] = [9, 10; 11, 12]", "f"],
        seealso: ["concat", "det", "diag", "identity", "inv", "ones", "range", "size", "squeeze", "trace", "transpose", "zeros"]
      };
    }
  });

  // node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/expression/embeddedDocs/function/matrix/trace.js
  var require_trace2 = __commonJS({
    "node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/expression/embeddedDocs/function/matrix/trace.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.traceDocs = void 0;
      var traceDocs = exports.traceDocs = {
        name: "trace",
        category: "Matrix",
        syntax: ["trace(A)"],
        description: "Calculate the trace of a matrix: the sum of the elements on the main diagonal of a square matrix.",
        examples: ["A = [1, 2, 3; -1, 2, 3; 2, 0, 3]", "trace(A)"],
        seealso: ["concat", "det", "diag", "identity", "inv", "ones", "range", "size", "squeeze", "subset", "transpose", "zeros"]
      };
    }
  });

  // node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/expression/embeddedDocs/function/matrix/transpose.js
  var require_transpose2 = __commonJS({
    "node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/expression/embeddedDocs/function/matrix/transpose.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.transposeDocs = void 0;
      var transposeDocs = exports.transposeDocs = {
        name: "transpose",
        category: "Matrix",
        syntax: ["x'", "transpose(x)"],
        description: "Transpose a matrix",
        examples: ["a = [1, 2, 3; 4, 5, 6]", "a'", "transpose(a)"],
        seealso: ["concat", "det", "diag", "identity", "inv", "ones", "range", "size", "squeeze", "subset", "trace", "zeros"]
      };
    }
  });

  // node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/expression/embeddedDocs/function/matrix/zeros.js
  var require_zeros2 = __commonJS({
    "node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/expression/embeddedDocs/function/matrix/zeros.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.zerosDocs = void 0;
      var zerosDocs = exports.zerosDocs = {
        name: "zeros",
        category: "Matrix",
        syntax: ["zeros(m)", "zeros(m, n)", "zeros(m, n, p, ...)", "zeros([m])", "zeros([m, n])", "zeros([m, n, p, ...])"],
        description: "Create a matrix containing zeros.",
        examples: ["zeros(3)", "zeros(3, 5)", "a = [1, 2, 3; 4, 5, 6]", "zeros(size(a))"],
        seealso: ["concat", "det", "diag", "identity", "inv", "ones", "range", "size", "squeeze", "subset", "trace", "transpose"]
      };
    }
  });

  // node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/expression/embeddedDocs/function/matrix/fft.js
  var require_fft2 = __commonJS({
    "node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/expression/embeddedDocs/function/matrix/fft.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.fftDocs = void 0;
      var fftDocs = exports.fftDocs = {
        name: "fft",
        category: "Matrix",
        syntax: ["fft(x)"],
        description: "Calculate N-dimensional fourier transform",
        examples: ["fft([[1, 0], [1, 0]])"],
        seealso: ["ifft"]
      };
    }
  });

  // node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/expression/embeddedDocs/function/matrix/ifft.js
  var require_ifft2 = __commonJS({
    "node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/expression/embeddedDocs/function/matrix/ifft.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.ifftDocs = void 0;
      var ifftDocs = exports.ifftDocs = {
        name: "ifft",
        category: "Matrix",
        syntax: ["ifft(x)"],
        description: "Calculate N-dimensional inverse fourier transform",
        examples: ["ifft([[2, 2], [0, 0]])"],
        seealso: ["fft"]
      };
    }
  });

  // node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/expression/embeddedDocs/function/probability/combinations.js
  var require_combinations2 = __commonJS({
    "node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/expression/embeddedDocs/function/probability/combinations.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.combinationsDocs = void 0;
      var combinationsDocs = exports.combinationsDocs = {
        name: "combinations",
        category: "Probability",
        syntax: ["combinations(n, k)"],
        description: "Compute the number of combinations of n items taken k at a time",
        examples: ["combinations(7, 5)"],
        seealso: ["combinationsWithRep", "permutations", "factorial"]
      };
    }
  });

  // node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/expression/embeddedDocs/function/probability/combinationsWithRep.js
  var require_combinationsWithRep = __commonJS({
    "node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/expression/embeddedDocs/function/probability/combinationsWithRep.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.combinationsWithRepDocs = void 0;
      var combinationsWithRepDocs = exports.combinationsWithRepDocs = {
        name: "combinationsWithRep",
        category: "Probability",
        syntax: ["combinationsWithRep(n, k)"],
        description: "Compute the number of combinations of n items taken k at a time with replacements.",
        examples: ["combinationsWithRep(7, 5)"],
        seealso: ["combinations", "permutations", "factorial"]
      };
    }
  });

  // node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/expression/embeddedDocs/function/probability/factorial.js
  var require_factorial = __commonJS({
    "node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/expression/embeddedDocs/function/probability/factorial.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.factorialDocs = void 0;
      var factorialDocs = exports.factorialDocs = {
        name: "factorial",
        category: "Probability",
        syntax: ["n!", "factorial(n)"],
        description: "Compute the factorial of a value",
        examples: ["5!", "5 * 4 * 3 * 2 * 1", "3!"],
        seealso: ["combinations", "combinationsWithRep", "permutations", "gamma"]
      };
    }
  });

  // node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/expression/embeddedDocs/function/probability/gamma.js
  var require_gamma = __commonJS({
    "node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/expression/embeddedDocs/function/probability/gamma.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.gammaDocs = void 0;
      var gammaDocs = exports.gammaDocs = {
        name: "gamma",
        category: "Probability",
        syntax: ["gamma(n)"],
        description: "Compute the gamma function. For small values, the Lanczos approximation is used, and for large values the extended Stirling approximation.",
        examples: ["gamma(4)", "3!", "gamma(1/2)", "sqrt(pi)"],
        seealso: ["factorial"]
      };
    }
  });

  // node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/expression/embeddedDocs/function/probability/lgamma.js
  var require_lgamma = __commonJS({
    "node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/expression/embeddedDocs/function/probability/lgamma.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.lgammaDocs = void 0;
      var lgammaDocs = exports.lgammaDocs = {
        name: "lgamma",
        category: "Probability",
        syntax: ["lgamma(n)"],
        description: "Logarithm of the gamma function for real, positive numbers and complex numbers, using Lanczos approximation for numbers and Stirling series for complex numbers.",
        examples: ["lgamma(4)", "lgamma(1/2)", "lgamma(i)", "lgamma(complex(1.1, 2))"],
        seealso: ["gamma"]
      };
    }
  });

  // node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/expression/embeddedDocs/function/probability/kldivergence.js
  var require_kldivergence = __commonJS({
    "node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/expression/embeddedDocs/function/probability/kldivergence.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.kldivergenceDocs = void 0;
      var kldivergenceDocs = exports.kldivergenceDocs = {
        name: "kldivergence",
        category: "Probability",
        syntax: ["kldivergence(x, y)"],
        description: "Calculate the Kullback-Leibler (KL) divergence  between two distributions.",
        examples: ["kldivergence([0.7,0.5,0.4], [0.2,0.9,0.5])"],
        seealso: []
      };
    }
  });

  // node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/expression/embeddedDocs/function/probability/multinomial.js
  var require_multinomial = __commonJS({
    "node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/expression/embeddedDocs/function/probability/multinomial.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.multinomialDocs = void 0;
      var multinomialDocs = exports.multinomialDocs = {
        name: "multinomial",
        category: "Probability",
        syntax: ["multinomial(A)"],
        description: "Multinomial Coefficients compute the number of ways of picking a1, a2, ..., ai unordered outcomes from `n` possibilities. multinomial takes one array of integers as an argument. The following condition must be enforced: every ai > 0.",
        examples: ["multinomial([1, 2, 1])"],
        seealso: ["combinations", "factorial"]
      };
    }
  });

  // node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/expression/embeddedDocs/function/probability/permutations.js
  var require_permutations = __commonJS({
    "node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/expression/embeddedDocs/function/probability/permutations.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.permutationsDocs = void 0;
      var permutationsDocs = exports.permutationsDocs = {
        name: "permutations",
        category: "Probability",
        syntax: ["permutations(n)", "permutations(n, k)"],
        description: "Compute the number of permutations of n items taken k at a time",
        examples: ["permutations(5)", "permutations(5, 3)"],
        seealso: ["combinations", "combinationsWithRep", "factorial"]
      };
    }
  });

  // node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/expression/embeddedDocs/function/probability/pickRandom.js
  var require_pickRandom = __commonJS({
    "node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/expression/embeddedDocs/function/probability/pickRandom.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.pickRandomDocs = void 0;
      var pickRandomDocs = exports.pickRandomDocs = {
        name: "pickRandom",
        category: "Probability",
        syntax: ["pickRandom(array)", "pickRandom(array, number)", "pickRandom(array, weights)", "pickRandom(array, number, weights)", "pickRandom(array, weights, number)"],
        description: "Pick a random entry from a given array.",
        examples: ["pickRandom(0:10)", "pickRandom([1, 3, 1, 6])", "pickRandom([1, 3, 1, 6], 2)", "pickRandom([1, 3, 1, 6], [2, 3, 2, 1])", "pickRandom([1, 3, 1, 6], 2, [2, 3, 2, 1])", "pickRandom([1, 3, 1, 6], [2, 3, 2, 1], 2)"],
        seealso: ["random", "randomInt"]
      };
    }
  });

  // node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/expression/embeddedDocs/function/probability/random.js
  var require_random = __commonJS({
    "node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/expression/embeddedDocs/function/probability/random.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.randomDocs = void 0;
      var randomDocs = exports.randomDocs = {
        name: "random",
        category: "Probability",
        syntax: ["random()", "random(max)", "random(min, max)", "random(size)", "random(size, max)", "random(size, min, max)"],
        description: "Return a random number.",
        examples: ["random()", "random(10, 20)", "random([2, 3])"],
        seealso: ["pickRandom", "randomInt"]
      };
    }
  });

  // node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/expression/embeddedDocs/function/probability/randomInt.js
  var require_randomInt = __commonJS({
    "node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/expression/embeddedDocs/function/probability/randomInt.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.randomIntDocs = void 0;
      var randomIntDocs = exports.randomIntDocs = {
        name: "randomInt",
        category: "Probability",
        syntax: ["randomInt(max)", "randomInt(min, max)", "randomInt(size)", "randomInt(size, max)", "randomInt(size, min, max)"],
        description: "Return a random integer number",
        examples: ["randomInt(10, 20)", "randomInt([2, 3], 10)"],
        seealso: ["pickRandom", "random"]
      };
    }
  });

  // node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/expression/embeddedDocs/function/relational/compare.js
  var require_compare2 = __commonJS({
    "node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/expression/embeddedDocs/function/relational/compare.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.compareDocs = void 0;
      var compareDocs = exports.compareDocs = {
        name: "compare",
        category: "Relational",
        syntax: ["compare(x, y)"],
        description: "Compare two values. Returns 1 when x > y, -1 when x < y, and 0 when x == y.",
        examples: ["compare(2, 3)", "compare(3, 2)", "compare(2, 2)", "compare(5cm, 40mm)", "compare(2, [1, 2, 3])"],
        seealso: ["equal", "unequal", "smaller", "smallerEq", "largerEq", "compareNatural", "compareText"]
      };
    }
  });

  // node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/expression/embeddedDocs/function/relational/compareNatural.js
  var require_compareNatural2 = __commonJS({
    "node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/expression/embeddedDocs/function/relational/compareNatural.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.compareNaturalDocs = void 0;
      var compareNaturalDocs = exports.compareNaturalDocs = {
        name: "compareNatural",
        category: "Relational",
        syntax: ["compareNatural(x, y)"],
        description: "Compare two values of any type in a deterministic, natural way. Returns 1 when x > y, -1 when x < y, and 0 when x == y.",
        examples: ["compareNatural(2, 3)", "compareNatural(3, 2)", "compareNatural(2, 2)", "compareNatural(5cm, 40mm)", 'compareNatural("2", "10")', "compareNatural(2 + 3i, 2 + 4i)", "compareNatural([1, 2, 4], [1, 2, 3])", "compareNatural([1, 5], [1, 2, 3])", "compareNatural([1, 2], [1, 2])", "compareNatural({a: 2}, {a: 4})"],
        seealso: ["equal", "unequal", "smaller", "smallerEq", "largerEq", "compare", "compareText"]
      };
    }
  });

  // node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/expression/embeddedDocs/function/relational/compareText.js
  var require_compareText2 = __commonJS({
    "node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/expression/embeddedDocs/function/relational/compareText.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.compareTextDocs = void 0;
      var compareTextDocs = exports.compareTextDocs = {
        name: "compareText",
        category: "Relational",
        syntax: ["compareText(x, y)"],
        description: "Compare two strings lexically. Comparison is case sensitive. Returns 1 when x > y, -1 when x < y, and 0 when x == y.",
        examples: ['compareText("B", "A")', 'compareText("A", "B")', 'compareText("A", "A")', 'compareText("2", "10")', 'compare("2", "10")', "compare(2, 10)", 'compareNatural("2", "10")', 'compareText("B", ["A", "B", "C"])'],
        seealso: ["compare", "compareNatural"]
      };
    }
  });

  // node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/expression/embeddedDocs/function/relational/deepEqual.js
  var require_deepEqual2 = __commonJS({
    "node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/expression/embeddedDocs/function/relational/deepEqual.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.deepEqualDocs = void 0;
      var deepEqualDocs = exports.deepEqualDocs = {
        name: "deepEqual",
        category: "Relational",
        syntax: ["deepEqual(x, y)"],
        description: "Check equality of two matrices element wise. Returns true if the size of both matrices is equal and when and each of the elements are equal.",
        examples: ["deepEqual([1,3,4], [1,3,4])", "deepEqual([1,3,4], [1,3])"],
        seealso: ["equal", "unequal", "smaller", "larger", "smallerEq", "largerEq", "compare"]
      };
    }
  });

  // node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/expression/embeddedDocs/function/relational/equal.js
  var require_equal2 = __commonJS({
    "node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/expression/embeddedDocs/function/relational/equal.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.equalDocs = void 0;
      var equalDocs = exports.equalDocs = {
        name: "equal",
        category: "Relational",
        syntax: ["x == y", "equal(x, y)"],
        description: "Check equality of two values. Returns true if the values are equal, and false if not.",
        examples: ["2+2 == 3", "2+2 == 4", "a = 3.2", "b = 6-2.8", "a == b", "50cm == 0.5m"],
        seealso: ["unequal", "smaller", "larger", "smallerEq", "largerEq", "compare", "deepEqual", "equalText"]
      };
    }
  });

  // node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/expression/embeddedDocs/function/relational/equalText.js
  var require_equalText2 = __commonJS({
    "node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/expression/embeddedDocs/function/relational/equalText.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.equalTextDocs = void 0;
      var equalTextDocs = exports.equalTextDocs = {
        name: "equalText",
        category: "Relational",
        syntax: ["equalText(x, y)"],
        description: "Check equality of two strings. Comparison is case sensitive. Returns true if the values are equal, and false if not.",
        examples: ['equalText("Hello", "Hello")', 'equalText("a", "A")', 'equal("2e3", "2000")', 'equalText("2e3", "2000")', 'equalText("B", ["A", "B", "C"])'],
        seealso: ["compare", "compareNatural", "compareText", "equal"]
      };
    }
  });

  // node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/expression/embeddedDocs/function/relational/larger.js
  var require_larger2 = __commonJS({
    "node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/expression/embeddedDocs/function/relational/larger.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.largerDocs = void 0;
      var largerDocs = exports.largerDocs = {
        name: "larger",
        category: "Relational",
        syntax: ["x > y", "larger(x, y)"],
        description: "Check if value x is larger than y. Returns true if x is larger than y, and false if not.",
        examples: ["2 > 3", "5 > 2*2", "a = 3.3", "b = 6-2.8", "(a > b)", "(b < a)", "5 cm > 2 inch"],
        seealso: ["equal", "unequal", "smaller", "smallerEq", "largerEq", "compare"]
      };
    }
  });

  // node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/expression/embeddedDocs/function/relational/largerEq.js
  var require_largerEq2 = __commonJS({
    "node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/expression/embeddedDocs/function/relational/largerEq.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.largerEqDocs = void 0;
      var largerEqDocs = exports.largerEqDocs = {
        name: "largerEq",
        category: "Relational",
        syntax: ["x >= y", "largerEq(x, y)"],
        description: "Check if value x is larger or equal to y. Returns true if x is larger or equal to y, and false if not.",
        examples: ["2 >= 1+1", "2 > 1+1", "a = 3.2", "b = 6-2.8", "(a >= b)"],
        seealso: ["equal", "unequal", "smallerEq", "smaller", "compare"]
      };
    }
  });

  // node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/expression/embeddedDocs/function/relational/smaller.js
  var require_smaller2 = __commonJS({
    "node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/expression/embeddedDocs/function/relational/smaller.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.smallerDocs = void 0;
      var smallerDocs = exports.smallerDocs = {
        name: "smaller",
        category: "Relational",
        syntax: ["x < y", "smaller(x, y)"],
        description: "Check if value x is smaller than value y. Returns true if x is smaller than y, and false if not.",
        examples: ["2 < 3", "5 < 2*2", "a = 3.3", "b = 6-2.8", "(a < b)", "5 cm < 2 inch"],
        seealso: ["equal", "unequal", "larger", "smallerEq", "largerEq", "compare"]
      };
    }
  });

  // node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/expression/embeddedDocs/function/relational/smallerEq.js
  var require_smallerEq2 = __commonJS({
    "node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/expression/embeddedDocs/function/relational/smallerEq.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.smallerEqDocs = void 0;
      var smallerEqDocs = exports.smallerEqDocs = {
        name: "smallerEq",
        category: "Relational",
        syntax: ["x <= y", "smallerEq(x, y)"],
        description: "Check if value x is smaller or equal to value y. Returns true if x is smaller than y, and false if not.",
        examples: ["2 <= 1+1", "2 < 1+1", "a = 3.2", "b = 6-2.8", "(a <= b)"],
        seealso: ["equal", "unequal", "larger", "smaller", "largerEq", "compare"]
      };
    }
  });

  // node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/expression/embeddedDocs/function/relational/unequal.js
  var require_unequal2 = __commonJS({
    "node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/expression/embeddedDocs/function/relational/unequal.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.unequalDocs = void 0;
      var unequalDocs = exports.unequalDocs = {
        name: "unequal",
        category: "Relational",
        syntax: ["x != y", "unequal(x, y)"],
        description: "Check unequality of two values. Returns true if the values are unequal, and false if they are equal.",
        examples: ["2+2 != 3", "2+2 != 4", "a = 3.2", "b = 6-2.8", "a != b", "50cm != 0.5m", "5 cm != 2 inch"],
        seealso: ["equal", "smaller", "larger", "smallerEq", "largerEq", "compare", "deepEqual"]
      };
    }
  });

  // node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/expression/embeddedDocs/function/set/setCartesian.js
  var require_setCartesian2 = __commonJS({
    "node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/expression/embeddedDocs/function/set/setCartesian.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.setCartesianDocs = void 0;
      var setCartesianDocs = exports.setCartesianDocs = {
        name: "setCartesian",
        category: "Set",
        syntax: ["setCartesian(set1, set2)"],
        description: "Create the cartesian product of two (multi)sets. Multi-dimension arrays will be converted to single-dimension arrays and the values will be sorted in ascending order before the operation.",
        examples: ["setCartesian([1, 2], [3, 4])"],
        seealso: ["setUnion", "setIntersect", "setDifference", "setPowerset"]
      };
    }
  });

  // node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/expression/embeddedDocs/function/set/setDifference.js
  var require_setDifference2 = __commonJS({
    "node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/expression/embeddedDocs/function/set/setDifference.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.setDifferenceDocs = void 0;
      var setDifferenceDocs = exports.setDifferenceDocs = {
        name: "setDifference",
        category: "Set",
        syntax: ["setDifference(set1, set2)"],
        description: "Create the difference of two (multi)sets: every element of set1, that is not the element of set2. Multi-dimension arrays will be converted to single-dimension arrays before the operation.",
        examples: ["setDifference([1, 2, 3, 4], [3, 4, 5, 6])", "setDifference([[1, 2], [3, 4]], [[3, 4], [5, 6]])"],
        seealso: ["setUnion", "setIntersect", "setSymDifference"]
      };
    }
  });

  // node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/expression/embeddedDocs/function/set/setDistinct.js
  var require_setDistinct2 = __commonJS({
    "node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/expression/embeddedDocs/function/set/setDistinct.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.setDistinctDocs = void 0;
      var setDistinctDocs = exports.setDistinctDocs = {
        name: "setDistinct",
        category: "Set",
        syntax: ["setDistinct(set)"],
        description: "Collect the distinct elements of a multiset. A multi-dimension array will be converted to a single-dimension array before the operation.",
        examples: ["setDistinct([1, 1, 1, 2, 2, 3])"],
        seealso: ["setMultiplicity"]
      };
    }
  });

  // node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/expression/embeddedDocs/function/set/setIntersect.js
  var require_setIntersect2 = __commonJS({
    "node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/expression/embeddedDocs/function/set/setIntersect.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.setIntersectDocs = void 0;
      var setIntersectDocs = exports.setIntersectDocs = {
        name: "setIntersect",
        category: "Set",
        syntax: ["setIntersect(set1, set2)"],
        description: "Create the intersection of two (multi)sets. Multi-dimension arrays will be converted to single-dimension arrays before the operation.",
        examples: ["setIntersect([1, 2, 3, 4], [3, 4, 5, 6])", "setIntersect([[1, 2], [3, 4]], [[3, 4], [5, 6]])"],
        seealso: ["setUnion", "setDifference"]
      };
    }
  });

  // node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/expression/embeddedDocs/function/set/setIsSubset.js
  var require_setIsSubset2 = __commonJS({
    "node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/expression/embeddedDocs/function/set/setIsSubset.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.setIsSubsetDocs = void 0;
      var setIsSubsetDocs = exports.setIsSubsetDocs = {
        name: "setIsSubset",
        category: "Set",
        syntax: ["setIsSubset(set1, set2)"],
        description: "Check whether a (multi)set is a subset of another (multi)set: every element of set1 is the element of set2. Multi-dimension arrays will be converted to single-dimension arrays before the operation.",
        examples: ["setIsSubset([1, 2], [3, 4, 5, 6])", "setIsSubset([3, 4], [3, 4, 5, 6])"],
        seealso: ["setUnion", "setIntersect", "setDifference"]
      };
    }
  });

  // node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/expression/embeddedDocs/function/set/setMultiplicity.js
  var require_setMultiplicity2 = __commonJS({
    "node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/expression/embeddedDocs/function/set/setMultiplicity.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.setMultiplicityDocs = void 0;
      var setMultiplicityDocs = exports.setMultiplicityDocs = {
        name: "setMultiplicity",
        category: "Set",
        syntax: ["setMultiplicity(element, set)"],
        description: "Count the multiplicity of an element in a multiset. A multi-dimension array will be converted to a single-dimension array before the operation.",
        examples: ["setMultiplicity(1, [1, 2, 2, 4])", "setMultiplicity(2, [1, 2, 2, 4])"],
        seealso: ["setDistinct", "setSize"]
      };
    }
  });

  // node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/expression/embeddedDocs/function/set/setPowerset.js
  var require_setPowerset2 = __commonJS({
    "node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/expression/embeddedDocs/function/set/setPowerset.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.setPowersetDocs = void 0;
      var setPowersetDocs = exports.setPowersetDocs = {
        name: "setPowerset",
        category: "Set",
        syntax: ["setPowerset(set)"],
        description: "Create the powerset of a (multi)set: the powerset contains very possible subsets of a (multi)set. A multi-dimension array will be converted to a single-dimension array before the operation.",
        examples: ["setPowerset([1, 2, 3])"],
        seealso: ["setCartesian"]
      };
    }
  });

  // node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/expression/embeddedDocs/function/set/setSize.js
  var require_setSize2 = __commonJS({
    "node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/expression/embeddedDocs/function/set/setSize.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.setSizeDocs = void 0;
      var setSizeDocs = exports.setSizeDocs = {
        name: "setSize",
        category: "Set",
        syntax: ["setSize(set)", "setSize(set, unique)"],
        description: 'Count the number of elements of a (multi)set. When the second parameter "unique" is true, count only the unique values. A multi-dimension array will be converted to a single-dimension array before the operation.',
        examples: ["setSize([1, 2, 2, 4])", "setSize([1, 2, 2, 4], true)"],
        seealso: ["setUnion", "setIntersect", "setDifference"]
      };
    }
  });

  // node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/expression/embeddedDocs/function/set/setSymDifference.js
  var require_setSymDifference2 = __commonJS({
    "node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/expression/embeddedDocs/function/set/setSymDifference.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.setSymDifferenceDocs = void 0;
      var setSymDifferenceDocs = exports.setSymDifferenceDocs = {
        name: "setSymDifference",
        category: "Set",
        syntax: ["setSymDifference(set1, set2)"],
        description: "Create the symmetric difference of two (multi)sets. Multi-dimension arrays will be converted to single-dimension arrays before the operation.",
        examples: ["setSymDifference([1, 2, 3, 4], [3, 4, 5, 6])", "setSymDifference([[1, 2], [3, 4]], [[3, 4], [5, 6]])"],
        seealso: ["setUnion", "setIntersect", "setDifference"]
      };
    }
  });

  // node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/expression/embeddedDocs/function/set/setUnion.js
  var require_setUnion2 = __commonJS({
    "node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/expression/embeddedDocs/function/set/setUnion.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.setUnionDocs = void 0;
      var setUnionDocs = exports.setUnionDocs = {
        name: "setUnion",
        category: "Set",
        syntax: ["setUnion(set1, set2)"],
        description: "Create the union of two (multi)sets. Multi-dimension arrays will be converted to single-dimension arrays before the operation.",
        examples: ["setUnion([1, 2, 3, 4], [3, 4, 5, 6])", "setUnion([[1, 2], [3, 4]], [[3, 4], [5, 6]])"],
        seealso: ["setIntersect", "setDifference"]
      };
    }
  });

  // node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/expression/embeddedDocs/function/signal/zpk2tf.js
  var require_zpk2tf = __commonJS({
    "node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/expression/embeddedDocs/function/signal/zpk2tf.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.zpk2tfDocs = void 0;
      var zpk2tfDocs = exports.zpk2tfDocs = {
        name: "zpk2tf",
        category: "Signal",
        syntax: ["zpk2tf(z, p, k)"],
        description: "Compute the transfer function of a zero-pole-gain model.",
        examples: ["zpk2tf([1, 2], [-1, -2], 1)", "zpk2tf([1, 2], [-1, -2])", "zpk2tf([1 - 3i, 2 + 2i], [-1, -2])"],
        seealso: []
      };
    }
  });

  // node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/expression/embeddedDocs/function/signal/freqz.js
  var require_freqz = __commonJS({
    "node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/expression/embeddedDocs/function/signal/freqz.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.freqzDocs = void 0;
      var freqzDocs = exports.freqzDocs = {
        name: "freqz",
        category: "Signal",
        syntax: ["freqz(b, a)", "freqz(b, a, w)"],
        description: "Calculates the frequency response of a filter given its numerator and denominator coefficients.",
        examples: ["freqz([1, 2], [1, 2, 3])", "freqz([1, 2], [1, 2, 3], [0, 1])", "freqz([1, 2], [1, 2, 3], 512)"],
        seealso: []
      };
    }
  });

  // node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/expression/embeddedDocs/function/special/erf.js
  var require_erf2 = __commonJS({
    "node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/expression/embeddedDocs/function/special/erf.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.erfDocs = void 0;
      var erfDocs = exports.erfDocs = {
        name: "erf",
        category: "Special",
        syntax: ["erf(x)"],
        description: "Compute the erf function of a value using a rational Chebyshev approximations for different intervals of x",
        examples: ["erf(0.2)", "erf(-0.5)", "erf(4)"],
        seealso: []
      };
    }
  });

  // node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/expression/embeddedDocs/function/special/zeta.js
  var require_zeta2 = __commonJS({
    "node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/expression/embeddedDocs/function/special/zeta.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.zetaDocs = void 0;
      var zetaDocs = exports.zetaDocs = {
        name: "zeta",
        category: "Special",
        syntax: ["zeta(s)"],
        description: "Compute the Riemann Zeta Function using an infinite series and Riemanns Functional Equation for the entire complex plane",
        examples: ["zeta(0.2)", "zeta(-0.5)", "zeta(4)"],
        seealso: []
      };
    }
  });

  // node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/expression/embeddedDocs/function/statistics/mad.js
  var require_mad = __commonJS({
    "node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/expression/embeddedDocs/function/statistics/mad.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.madDocs = void 0;
      var madDocs = exports.madDocs = {
        name: "mad",
        category: "Statistics",
        syntax: ["mad(a, b, c, ...)", "mad(A)"],
        description: "Compute the median absolute deviation of a matrix or a list with values. The median absolute deviation is defined as the median of the absolute deviations from the median.",
        examples: ["mad(10, 20, 30)", "mad([1, 2, 3])"],
        seealso: ["mean", "median", "std", "abs"]
      };
    }
  });

  // node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/expression/embeddedDocs/function/statistics/max.js
  var require_max2 = __commonJS({
    "node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/expression/embeddedDocs/function/statistics/max.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.maxDocs = void 0;
      var maxDocs = exports.maxDocs = {
        name: "max",
        category: "Statistics",
        syntax: ["max(a, b, c, ...)", "max(A)", "max(A, dimension)"],
        description: "Compute the maximum value of a list of values.",
        examples: ["max(2, 3, 4, 1)", "max([2, 3, 4, 1])", "max([2, 5; 4, 3])", "max([2, 5; 4, 3], 1)", "max([2, 5; 4, 3], 2)", "max(2.7, 7.1, -4.5, 2.0, 4.1)", "min(2.7, 7.1, -4.5, 2.0, 4.1)"],
        seealso: ["mean", "median", "min", "prod", "std", "sum", "variance"]
      };
    }
  });

  // node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/expression/embeddedDocs/function/statistics/mean.js
  var require_mean = __commonJS({
    "node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/expression/embeddedDocs/function/statistics/mean.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.meanDocs = void 0;
      var meanDocs = exports.meanDocs = {
        name: "mean",
        category: "Statistics",
        syntax: ["mean(a, b, c, ...)", "mean(A)", "mean(A, dimension)"],
        description: "Compute the arithmetic mean of a list of values.",
        examples: ["mean(2, 3, 4, 1)", "mean([2, 3, 4, 1])", "mean([2, 5; 4, 3])", "mean([2, 5; 4, 3], 1)", "mean([2, 5; 4, 3], 2)", "mean([1.0, 2.7, 3.2, 4.0])"],
        seealso: ["max", "median", "min", "prod", "std", "sum", "variance"]
      };
    }
  });

  // node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/expression/embeddedDocs/function/statistics/median.js
  var require_median = __commonJS({
    "node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/expression/embeddedDocs/function/statistics/median.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.medianDocs = void 0;
      var medianDocs = exports.medianDocs = {
        name: "median",
        category: "Statistics",
        syntax: ["median(a, b, c, ...)", "median(A)"],
        description: "Compute the median of all values. The values are sorted and the middle value is returned. In case of an even number of values, the average of the two middle values is returned.",
        examples: ["median(5, 2, 7)", "median([3, -1, 5, 7])"],
        seealso: ["max", "mean", "min", "prod", "std", "sum", "variance", "quantileSeq"]
      };
    }
  });

  // node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/expression/embeddedDocs/function/statistics/min.js
  var require_min2 = __commonJS({
    "node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/expression/embeddedDocs/function/statistics/min.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.minDocs = void 0;
      var minDocs = exports.minDocs = {
        name: "min",
        category: "Statistics",
        syntax: ["min(a, b, c, ...)", "min(A)", "min(A, dimension)"],
        description: "Compute the minimum value of a list of values.",
        examples: ["min(2, 3, 4, 1)", "min([2, 3, 4, 1])", "min([2, 5; 4, 3])", "min([2, 5; 4, 3], 1)", "min([2, 5; 4, 3], 2)", "min(2.7, 7.1, -4.5, 2.0, 4.1)", "max(2.7, 7.1, -4.5, 2.0, 4.1)"],
        seealso: ["max", "mean", "median", "prod", "std", "sum", "variance"]
      };
    }
  });

  // node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/expression/embeddedDocs/function/statistics/mode.js
  var require_mode2 = __commonJS({
    "node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/expression/embeddedDocs/function/statistics/mode.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.modeDocs = void 0;
      var modeDocs = exports.modeDocs = {
        name: "mode",
        category: "Statistics",
        syntax: ["mode(a, b, c, ...)", "mode(A)", "mode(A, a, b, B, c, ...)"],
        description: "Computes the mode of all values as an array. In case mode being more than one, multiple values are returned in an array.",
        examples: ["mode(2, 1, 4, 3, 1)", "mode([1, 2.7, 3.2, 4, 2.7])", "mode(1, 4, 6, 1, 6)"],
        seealso: ["max", "mean", "min", "median", "prod", "std", "sum", "variance"]
      };
    }
  });

  // node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/expression/embeddedDocs/function/statistics/prod.js
  var require_prod2 = __commonJS({
    "node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/expression/embeddedDocs/function/statistics/prod.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.prodDocs = void 0;
      var prodDocs = exports.prodDocs = {
        name: "prod",
        category: "Statistics",
        syntax: ["prod(a, b, c, ...)", "prod(A)"],
        description: "Compute the product of all values.",
        examples: ["prod(2, 3, 4)", "prod([2, 3, 4])", "prod([2, 5; 4, 3])"],
        seealso: ["max", "mean", "min", "median", "min", "std", "sum", "variance"]
      };
    }
  });

  // node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/expression/embeddedDocs/function/statistics/quantileSeq.js
  var require_quantileSeq = __commonJS({
    "node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/expression/embeddedDocs/function/statistics/quantileSeq.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.quantileSeqDocs = void 0;
      var quantileSeqDocs = exports.quantileSeqDocs = {
        name: "quantileSeq",
        category: "Statistics",
        syntax: ["quantileSeq(A, prob[, sorted])", "quantileSeq(A, [prob1, prob2, ...][, sorted])", "quantileSeq(A, N[, sorted])"],
        description: "Compute the prob order quantile of a matrix or a list with values. The sequence is sorted and the middle value is returned. Supported types of sequence values are: Number, BigNumber, Unit Supported types of probablity are: Number, BigNumber. \n\nIn case of a (multi dimensional) array or matrix, the prob order quantile of all elements will be calculated.",
        examples: ["quantileSeq([3, -1, 5, 7], 0.5)", "quantileSeq([3, -1, 5, 7], [1/3, 2/3])", "quantileSeq([3, -1, 5, 7], 2)", "quantileSeq([-1, 3, 5, 7], 0.5, true)"],
        seealso: ["mean", "median", "min", "max", "prod", "std", "sum", "variance"]
      };
    }
  });

  // node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/expression/embeddedDocs/function/statistics/std.js
  var require_std = __commonJS({
    "node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/expression/embeddedDocs/function/statistics/std.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.stdDocs = void 0;
      var stdDocs = exports.stdDocs = {
        name: "std",
        category: "Statistics",
        syntax: ["std(a, b, c, ...)", "std(A)", "std(A, dimension)", "std(A, normalization)", "std(A, dimension, normalization)"],
        description: 'Compute the standard deviation of all values, defined as std(A) = sqrt(variance(A)). Optional parameter normalization can be "unbiased" (default), "uncorrected", or "biased".',
        examples: ["std(2, 4, 6)", "std([2, 4, 6, 8])", 'std([2, 4, 6, 8], "uncorrected")', 'std([2, 4, 6, 8], "biased")', "std([1, 2, 3; 4, 5, 6])"],
        seealso: ["max", "mean", "min", "median", "prod", "sum", "variance"]
      };
    }
  });

  // node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/expression/embeddedDocs/function/statistics/cumsum.js
  var require_cumsum = __commonJS({
    "node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/expression/embeddedDocs/function/statistics/cumsum.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.cumSumDocs = void 0;
      var cumSumDocs = exports.cumSumDocs = {
        name: "cumsum",
        category: "Statistics",
        syntax: ["cumsum(a, b, c, ...)", "cumsum(A)"],
        description: "Compute the cumulative sum of all values.",
        examples: ["cumsum(2, 3, 4, 1)", "cumsum([2, 3, 4, 1])", "cumsum([1, 2; 3, 4])", "cumsum([1, 2; 3, 4], 1)", "cumsum([1, 2; 3, 4], 2)"],
        seealso: ["max", "mean", "median", "min", "prod", "std", "sum", "variance"]
      };
    }
  });

  // node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/expression/embeddedDocs/function/statistics/sum.js
  var require_sum = __commonJS({
    "node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/expression/embeddedDocs/function/statistics/sum.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.sumDocs = void 0;
      var sumDocs = exports.sumDocs = {
        name: "sum",
        category: "Statistics",
        syntax: ["sum(a, b, c, ...)", "sum(A)", "sum(A, dimension)"],
        description: "Compute the sum of all values.",
        examples: ["sum(2, 3, 4, 1)", "sum([2, 3, 4, 1])", "sum([2, 5; 4, 3])"],
        seealso: ["max", "mean", "median", "min", "prod", "std", "sum", "variance"]
      };
    }
  });

  // node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/expression/embeddedDocs/function/statistics/variance.js
  var require_variance = __commonJS({
    "node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/expression/embeddedDocs/function/statistics/variance.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.varianceDocs = void 0;
      var varianceDocs = exports.varianceDocs = {
        name: "variance",
        category: "Statistics",
        syntax: ["variance(a, b, c, ...)", "variance(A)", "variance(A, dimension)", "variance(A, normalization)", "variance(A, dimension, normalization)"],
        description: 'Compute the variance of all values. Optional parameter normalization can be "unbiased" (default), "uncorrected", or "biased".',
        examples: ["variance(2, 4, 6)", "variance([2, 4, 6, 8])", 'variance([2, 4, 6, 8], "uncorrected")', 'variance([2, 4, 6, 8], "biased")', "variance([1, 2, 3; 4, 5, 6])"],
        seealso: ["max", "mean", "min", "median", "min", "prod", "std", "sum"]
      };
    }
  });

  // node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/expression/embeddedDocs/function/statistics/corr.js
  var require_corr = __commonJS({
    "node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/expression/embeddedDocs/function/statistics/corr.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.corrDocs = void 0;
      var corrDocs = exports.corrDocs = {
        name: "corr",
        category: "Statistics",
        syntax: ["corr(A,B)"],
        description: "Compute the correlation coefficient of a two list with values, For matrices, the matrix correlation coefficient is calculated.",
        examples: ["corr([2, 4, 6, 8],[1, 2, 3, 6])", "corr(matrix([[1, 2.2, 3, 4.8, 5], [1, 2, 3, 4, 5]]), matrix([[4, 5.3, 6.6, 7, 8], [1, 2, 3, 4, 5]]))"],
        seealso: ["max", "mean", "min", "median", "min", "prod", "std", "sum"]
      };
    }
  });

  // node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/expression/embeddedDocs/function/trigonometry/acos.js
  var require_acos2 = __commonJS({
    "node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/expression/embeddedDocs/function/trigonometry/acos.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.acosDocs = void 0;
      var acosDocs = exports.acosDocs = {
        name: "acos",
        category: "Trigonometry",
        syntax: ["acos(x)"],
        description: "Compute the inverse cosine of a value in radians.",
        examples: ["acos(0.5)", "acos(cos(2.3))"],
        seealso: ["cos", "atan", "asin"]
      };
    }
  });

  // node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/expression/embeddedDocs/function/trigonometry/acosh.js
  var require_acosh2 = __commonJS({
    "node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/expression/embeddedDocs/function/trigonometry/acosh.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.acoshDocs = void 0;
      var acoshDocs = exports.acoshDocs = {
        name: "acosh",
        category: "Trigonometry",
        syntax: ["acosh(x)"],
        description: "Calculate the hyperbolic arccos of a value, defined as `acosh(x) = ln(sqrt(x^2 - 1) + x)`.",
        examples: ["acosh(1.5)"],
        seealso: ["cosh", "asinh", "atanh"]
      };
    }
  });

  // node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/expression/embeddedDocs/function/trigonometry/acot.js
  var require_acot2 = __commonJS({
    "node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/expression/embeddedDocs/function/trigonometry/acot.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.acotDocs = void 0;
      var acotDocs = exports.acotDocs = {
        name: "acot",
        category: "Trigonometry",
        syntax: ["acot(x)"],
        description: "Calculate the inverse cotangent of a value.",
        examples: ["acot(0.5)", "acot(cot(0.5))", "acot(2)"],
        seealso: ["cot", "atan"]
      };
    }
  });

  // node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/expression/embeddedDocs/function/trigonometry/acoth.js
  var require_acoth2 = __commonJS({
    "node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/expression/embeddedDocs/function/trigonometry/acoth.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.acothDocs = void 0;
      var acothDocs = exports.acothDocs = {
        name: "acoth",
        category: "Trigonometry",
        syntax: ["acoth(x)"],
        description: "Calculate the hyperbolic arccotangent of a value, defined as `acoth(x) = (ln((x+1)/x) + ln(x/(x-1))) / 2`.",
        examples: ["acoth(2)", "acoth(0.5)"],
        seealso: ["acsch", "asech"]
      };
    }
  });

  // node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/expression/embeddedDocs/function/trigonometry/acsc.js
  var require_acsc2 = __commonJS({
    "node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/expression/embeddedDocs/function/trigonometry/acsc.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.acscDocs = void 0;
      var acscDocs = exports.acscDocs = {
        name: "acsc",
        category: "Trigonometry",
        syntax: ["acsc(x)"],
        description: "Calculate the inverse cotangent of a value.",
        examples: ["acsc(2)", "acsc(csc(0.5))", "acsc(0.5)"],
        seealso: ["csc", "asin", "asec"]
      };
    }
  });

  // node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/expression/embeddedDocs/function/trigonometry/acsch.js
  var require_acsch2 = __commonJS({
    "node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/expression/embeddedDocs/function/trigonometry/acsch.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.acschDocs = void 0;
      var acschDocs = exports.acschDocs = {
        name: "acsch",
        category: "Trigonometry",
        syntax: ["acsch(x)"],
        description: "Calculate the hyperbolic arccosecant of a value, defined as `acsch(x) = ln(1/x + sqrt(1/x^2 + 1))`.",
        examples: ["acsch(0.5)"],
        seealso: ["asech", "acoth"]
      };
    }
  });

  // node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/expression/embeddedDocs/function/trigonometry/asec.js
  var require_asec2 = __commonJS({
    "node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/expression/embeddedDocs/function/trigonometry/asec.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.asecDocs = void 0;
      var asecDocs = exports.asecDocs = {
        name: "asec",
        category: "Trigonometry",
        syntax: ["asec(x)"],
        description: "Calculate the inverse secant of a value.",
        examples: ["asec(0.5)", "asec(sec(0.5))", "asec(2)"],
        seealso: ["acos", "acot", "acsc"]
      };
    }
  });

  // node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/expression/embeddedDocs/function/trigonometry/asech.js
  var require_asech2 = __commonJS({
    "node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/expression/embeddedDocs/function/trigonometry/asech.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.asechDocs = void 0;
      var asechDocs = exports.asechDocs = {
        name: "asech",
        category: "Trigonometry",
        syntax: ["asech(x)"],
        description: "Calculate the inverse secant of a value.",
        examples: ["asech(0.5)"],
        seealso: ["acsch", "acoth"]
      };
    }
  });

  // node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/expression/embeddedDocs/function/trigonometry/asin.js
  var require_asin2 = __commonJS({
    "node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/expression/embeddedDocs/function/trigonometry/asin.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.asinDocs = void 0;
      var asinDocs = exports.asinDocs = {
        name: "asin",
        category: "Trigonometry",
        syntax: ["asin(x)"],
        description: "Compute the inverse sine of a value in radians.",
        examples: ["asin(0.5)", "asin(sin(0.5))"],
        seealso: ["sin", "acos", "atan"]
      };
    }
  });

  // node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/expression/embeddedDocs/function/trigonometry/asinh.js
  var require_asinh2 = __commonJS({
    "node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/expression/embeddedDocs/function/trigonometry/asinh.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.asinhDocs = void 0;
      var asinhDocs = exports.asinhDocs = {
        name: "asinh",
        category: "Trigonometry",
        syntax: ["asinh(x)"],
        description: "Calculate the hyperbolic arcsine of a value, defined as `asinh(x) = ln(x + sqrt(x^2 + 1))`.",
        examples: ["asinh(0.5)"],
        seealso: ["acosh", "atanh"]
      };
    }
  });

  // node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/expression/embeddedDocs/function/trigonometry/atan.js
  var require_atan3 = __commonJS({
    "node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/expression/embeddedDocs/function/trigonometry/atan.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.atanDocs = void 0;
      var atanDocs = exports.atanDocs = {
        name: "atan",
        category: "Trigonometry",
        syntax: ["atan(x)"],
        description: "Compute the inverse tangent of a value in radians.",
        examples: ["atan(0.5)", "atan(tan(0.5))"],
        seealso: ["tan", "acos", "asin"]
      };
    }
  });

  // node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/expression/embeddedDocs/function/trigonometry/atan2.js
  var require_atan22 = __commonJS({
    "node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/expression/embeddedDocs/function/trigonometry/atan2.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.atan2Docs = void 0;
      var atan2Docs = exports.atan2Docs = {
        name: "atan2",
        category: "Trigonometry",
        syntax: ["atan2(y, x)"],
        description: "Computes the principal value of the arc tangent of y/x in radians.",
        examples: ["atan2(2, 2) / pi", "angle = 60 deg in rad", "x = cos(angle)", "y = sin(angle)", "atan2(y, x)"],
        seealso: ["sin", "cos", "tan"]
      };
    }
  });

  // node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/expression/embeddedDocs/function/trigonometry/atanh.js
  var require_atanh2 = __commonJS({
    "node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/expression/embeddedDocs/function/trigonometry/atanh.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.atanhDocs = void 0;
      var atanhDocs = exports.atanhDocs = {
        name: "atanh",
        category: "Trigonometry",
        syntax: ["atanh(x)"],
        description: "Calculate the hyperbolic arctangent of a value, defined as `atanh(x) = ln((1 + x)/(1 - x)) / 2`.",
        examples: ["atanh(0.5)"],
        seealso: ["acosh", "asinh"]
      };
    }
  });

  // node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/expression/embeddedDocs/function/trigonometry/cos.js
  var require_cos2 = __commonJS({
    "node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/expression/embeddedDocs/function/trigonometry/cos.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.cosDocs = void 0;
      var cosDocs = exports.cosDocs = {
        name: "cos",
        category: "Trigonometry",
        syntax: ["cos(x)"],
        description: "Compute the cosine of x in radians.",
        examples: ["cos(2)", "cos(pi / 4) ^ 2", "cos(180 deg)", "cos(60 deg)", "sin(0.2)^2 + cos(0.2)^2"],
        seealso: ["acos", "sin", "tan"]
      };
    }
  });

  // node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/expression/embeddedDocs/function/trigonometry/cosh.js
  var require_cosh2 = __commonJS({
    "node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/expression/embeddedDocs/function/trigonometry/cosh.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.coshDocs = void 0;
      var coshDocs = exports.coshDocs = {
        name: "cosh",
        category: "Trigonometry",
        syntax: ["cosh(x)"],
        description: "Compute the hyperbolic cosine of x in radians.",
        examples: ["cosh(0.5)"],
        seealso: ["sinh", "tanh", "coth"]
      };
    }
  });

  // node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/expression/embeddedDocs/function/trigonometry/cot.js
  var require_cot2 = __commonJS({
    "node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/expression/embeddedDocs/function/trigonometry/cot.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.cotDocs = void 0;
      var cotDocs = exports.cotDocs = {
        name: "cot",
        category: "Trigonometry",
        syntax: ["cot(x)"],
        description: "Compute the cotangent of x in radians. Defined as 1/tan(x)",
        examples: ["cot(2)", "1 / tan(2)"],
        seealso: ["sec", "csc", "tan"]
      };
    }
  });

  // node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/expression/embeddedDocs/function/trigonometry/coth.js
  var require_coth2 = __commonJS({
    "node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/expression/embeddedDocs/function/trigonometry/coth.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.cothDocs = void 0;
      var cothDocs = exports.cothDocs = {
        name: "coth",
        category: "Trigonometry",
        syntax: ["coth(x)"],
        description: "Compute the hyperbolic cotangent of x in radians.",
        examples: ["coth(2)", "1 / tanh(2)"],
        seealso: ["sech", "csch", "tanh"]
      };
    }
  });

  // node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/expression/embeddedDocs/function/trigonometry/csc.js
  var require_csc2 = __commonJS({
    "node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/expression/embeddedDocs/function/trigonometry/csc.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.cscDocs = void 0;
      var cscDocs = exports.cscDocs = {
        name: "csc",
        category: "Trigonometry",
        syntax: ["csc(x)"],
        description: "Compute the cosecant of x in radians. Defined as 1/sin(x)",
        examples: ["csc(2)", "1 / sin(2)"],
        seealso: ["sec", "cot", "sin"]
      };
    }
  });

  // node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/expression/embeddedDocs/function/trigonometry/csch.js
  var require_csch2 = __commonJS({
    "node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/expression/embeddedDocs/function/trigonometry/csch.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.cschDocs = void 0;
      var cschDocs = exports.cschDocs = {
        name: "csch",
        category: "Trigonometry",
        syntax: ["csch(x)"],
        description: "Compute the hyperbolic cosecant of x in radians. Defined as 1/sinh(x)",
        examples: ["csch(2)", "1 / sinh(2)"],
        seealso: ["sech", "coth", "sinh"]
      };
    }
  });

  // node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/expression/embeddedDocs/function/trigonometry/sec.js
  var require_sec2 = __commonJS({
    "node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/expression/embeddedDocs/function/trigonometry/sec.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.secDocs = void 0;
      var secDocs = exports.secDocs = {
        name: "sec",
        category: "Trigonometry",
        syntax: ["sec(x)"],
        description: "Compute the secant of x in radians. Defined as 1/cos(x)",
        examples: ["sec(2)", "1 / cos(2)"],
        seealso: ["cot", "csc", "cos"]
      };
    }
  });

  // node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/expression/embeddedDocs/function/trigonometry/sech.js
  var require_sech2 = __commonJS({
    "node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/expression/embeddedDocs/function/trigonometry/sech.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.sechDocs = void 0;
      var sechDocs = exports.sechDocs = {
        name: "sech",
        category: "Trigonometry",
        syntax: ["sech(x)"],
        description: "Compute the hyperbolic secant of x in radians. Defined as 1/cosh(x)",
        examples: ["sech(2)", "1 / cosh(2)"],
        seealso: ["coth", "csch", "cosh"]
      };
    }
  });

  // node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/expression/embeddedDocs/function/trigonometry/sin.js
  var require_sin2 = __commonJS({
    "node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/expression/embeddedDocs/function/trigonometry/sin.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.sinDocs = void 0;
      var sinDocs = exports.sinDocs = {
        name: "sin",
        category: "Trigonometry",
        syntax: ["sin(x)"],
        description: "Compute the sine of x in radians.",
        examples: ["sin(2)", "sin(pi / 4) ^ 2", "sin(90 deg)", "sin(30 deg)", "sin(0.2)^2 + cos(0.2)^2"],
        seealso: ["asin", "cos", "tan"]
      };
    }
  });

  // node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/expression/embeddedDocs/function/trigonometry/sinh.js
  var require_sinh2 = __commonJS({
    "node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/expression/embeddedDocs/function/trigonometry/sinh.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.sinhDocs = void 0;
      var sinhDocs = exports.sinhDocs = {
        name: "sinh",
        category: "Trigonometry",
        syntax: ["sinh(x)"],
        description: "Compute the hyperbolic sine of x in radians.",
        examples: ["sinh(0.5)"],
        seealso: ["cosh", "tanh"]
      };
    }
  });

  // node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/expression/embeddedDocs/function/trigonometry/tan.js
  var require_tan2 = __commonJS({
    "node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/expression/embeddedDocs/function/trigonometry/tan.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.tanDocs = void 0;
      var tanDocs = exports.tanDocs = {
        name: "tan",
        category: "Trigonometry",
        syntax: ["tan(x)"],
        description: "Compute the tangent of x in radians.",
        examples: ["tan(0.5)", "sin(0.5) / cos(0.5)", "tan(pi / 4)", "tan(45 deg)"],
        seealso: ["atan", "sin", "cos"]
      };
    }
  });

  // node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/expression/embeddedDocs/function/trigonometry/tanh.js
  var require_tanh2 = __commonJS({
    "node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/expression/embeddedDocs/function/trigonometry/tanh.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.tanhDocs = void 0;
      var tanhDocs = exports.tanhDocs = {
        name: "tanh",
        category: "Trigonometry",
        syntax: ["tanh(x)"],
        description: "Compute the hyperbolic tangent of x in radians.",
        examples: ["tanh(0.5)", "sinh(0.5) / cosh(0.5)"],
        seealso: ["sinh", "cosh"]
      };
    }
  });

  // node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/expression/embeddedDocs/function/units/to.js
  var require_to2 = __commonJS({
    "node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/expression/embeddedDocs/function/units/to.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.toDocs = void 0;
      var toDocs = exports.toDocs = {
        name: "to",
        category: "Units",
        syntax: ["x to unit", "to(x, unit)"],
        description: "Change the unit of a value.",
        examples: ["5 inch to cm", "3.2kg to g", "16 bytes in bits"],
        seealso: []
      };
    }
  });

  // node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/expression/embeddedDocs/function/utils/bin.js
  var require_bin2 = __commonJS({
    "node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/expression/embeddedDocs/function/utils/bin.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.binDocs = void 0;
      var binDocs = exports.binDocs = {
        name: "bin",
        category: "Utils",
        syntax: ["bin(value)"],
        description: "Format a number as binary",
        examples: ["bin(2)"],
        seealso: ["oct", "hex"]
      };
    }
  });

  // node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/expression/embeddedDocs/function/utils/clone.js
  var require_clone2 = __commonJS({
    "node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/expression/embeddedDocs/function/utils/clone.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.cloneDocs = void 0;
      var cloneDocs = exports.cloneDocs = {
        name: "clone",
        category: "Utils",
        syntax: ["clone(x)"],
        description: "Clone a variable. Creates a copy of primitive variables,and a deep copy of matrices",
        examples: ["clone(3.5)", "clone(2 - 4i)", "clone(45 deg)", "clone([1, 2; 3, 4])", 'clone("hello world")'],
        seealso: []
      };
    }
  });

  // node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/expression/embeddedDocs/function/utils/format.js
  var require_format2 = __commonJS({
    "node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/expression/embeddedDocs/function/utils/format.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.formatDocs = void 0;
      var formatDocs = exports.formatDocs = {
        name: "format",
        category: "Utils",
        syntax: ["format(value)", "format(value, precision)"],
        description: "Format a value of any type as string.",
        examples: ["format(2.3)", "format(3 - 4i)", "format([])", "format(pi, 3)"],
        seealso: ["print"]
      };
    }
  });

  // node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/expression/embeddedDocs/function/utils/hasNumericValue.js
  var require_hasNumericValue2 = __commonJS({
    "node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/expression/embeddedDocs/function/utils/hasNumericValue.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.hasNumericValueDocs = void 0;
      var hasNumericValueDocs = exports.hasNumericValueDocs = {
        name: "hasNumericValue",
        category: "Utils",
        syntax: ["hasNumericValue(x)"],
        description: "Test whether a value is an numeric value. In case of a string, true is returned if the string contains a numeric value.",
        examples: ["hasNumericValue(2)", 'hasNumericValue("2")', 'isNumeric("2")', "hasNumericValue(0)", "hasNumericValue(bignumber(500))", "hasNumericValue(fraction(0.125))", "hasNumericValue(2 + 3i)", 'hasNumericValue([2.3, "foo", false])'],
        seealso: ["isInteger", "isZero", "isNegative", "isPositive", "isNaN", "isNumeric"]
      };
    }
  });

  // node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/expression/embeddedDocs/function/utils/hex.js
  var require_hex2 = __commonJS({
    "node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/expression/embeddedDocs/function/utils/hex.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.hexDocs = void 0;
      var hexDocs = exports.hexDocs = {
        name: "hex",
        category: "Utils",
        syntax: ["hex(value)"],
        description: "Format a number as hexadecimal",
        examples: ["hex(240)"],
        seealso: ["bin", "oct"]
      };
    }
  });

  // node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/expression/embeddedDocs/function/utils/isInteger.js
  var require_isInteger2 = __commonJS({
    "node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/expression/embeddedDocs/function/utils/isInteger.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.isIntegerDocs = void 0;
      var isIntegerDocs = exports.isIntegerDocs = {
        name: "isInteger",
        category: "Utils",
        syntax: ["isInteger(x)"],
        description: "Test whether a value is an integer number.",
        examples: ["isInteger(2)", "isInteger(3.5)", "isInteger([3, 0.5, -2])"],
        seealso: ["isNegative", "isNumeric", "isPositive", "isZero"]
      };
    }
  });

  // node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/expression/embeddedDocs/function/utils/isNaN.js
  var require_isNaN2 = __commonJS({
    "node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/expression/embeddedDocs/function/utils/isNaN.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.isNaNDocs = void 0;
      var isNaNDocs = exports.isNaNDocs = {
        name: "isNaN",
        category: "Utils",
        syntax: ["isNaN(x)"],
        description: "Test whether a value is NaN (not a number)",
        examples: ["isNaN(2)", "isNaN(0 / 0)", "isNaN(NaN)", "isNaN(Infinity)"],
        seealso: ["isNegative", "isNumeric", "isPositive", "isZero"]
      };
    }
  });

  // node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/expression/embeddedDocs/function/utils/isNegative.js
  var require_isNegative2 = __commonJS({
    "node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/expression/embeddedDocs/function/utils/isNegative.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.isNegativeDocs = void 0;
      var isNegativeDocs = exports.isNegativeDocs = {
        name: "isNegative",
        category: "Utils",
        syntax: ["isNegative(x)"],
        description: "Test whether a value is negative: smaller than zero.",
        examples: ["isNegative(2)", "isNegative(0)", "isNegative(-4)", "isNegative([3, 0.5, -2])"],
        seealso: ["isInteger", "isNumeric", "isPositive", "isZero"]
      };
    }
  });

  // node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/expression/embeddedDocs/function/utils/isNumeric.js
  var require_isNumeric2 = __commonJS({
    "node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/expression/embeddedDocs/function/utils/isNumeric.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.isNumericDocs = void 0;
      var isNumericDocs = exports.isNumericDocs = {
        name: "isNumeric",
        category: "Utils",
        syntax: ["isNumeric(x)"],
        description: "Test whether a value is a numeric value. Returns true when the input is a number, BigNumber, Fraction, or boolean.",
        examples: ["isNumeric(2)", 'isNumeric("2")', 'hasNumericValue("2")', "isNumeric(0)", "isNumeric(bignumber(500))", "isNumeric(fraction(0.125))", "isNumeric(2 + 3i)", 'isNumeric([2.3, "foo", false])'],
        seealso: ["isInteger", "isZero", "isNegative", "isPositive", "isNaN", "hasNumericValue"]
      };
    }
  });

  // node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/expression/embeddedDocs/function/utils/isPositive.js
  var require_isPositive2 = __commonJS({
    "node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/expression/embeddedDocs/function/utils/isPositive.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.isPositiveDocs = void 0;
      var isPositiveDocs = exports.isPositiveDocs = {
        name: "isPositive",
        category: "Utils",
        syntax: ["isPositive(x)"],
        description: "Test whether a value is positive: larger than zero.",
        examples: ["isPositive(2)", "isPositive(0)", "isPositive(-4)", "isPositive([3, 0.5, -2])"],
        seealso: ["isInteger", "isNumeric", "isNegative", "isZero"]
      };
    }
  });

  // node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/expression/embeddedDocs/function/utils/isPrime.js
  var require_isPrime2 = __commonJS({
    "node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/expression/embeddedDocs/function/utils/isPrime.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.isPrimeDocs = void 0;
      var isPrimeDocs = exports.isPrimeDocs = {
        name: "isPrime",
        category: "Utils",
        syntax: ["isPrime(x)"],
        description: "Test whether a value is prime: has no divisors other than itself and one.",
        examples: ["isPrime(3)", "isPrime(-2)", "isPrime([2, 17, 100])"],
        seealso: ["isInteger", "isNumeric", "isNegative", "isZero"]
      };
    }
  });

  // node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/expression/embeddedDocs/function/utils/isZero.js
  var require_isZero2 = __commonJS({
    "node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/expression/embeddedDocs/function/utils/isZero.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.isZeroDocs = void 0;
      var isZeroDocs = exports.isZeroDocs = {
        name: "isZero",
        category: "Utils",
        syntax: ["isZero(x)"],
        description: "Test whether a value is zero.",
        examples: ["isZero(2)", "isZero(0)", "isZero(-4)", "isZero([3, 0, -2, 0])"],
        seealso: ["isInteger", "isNumeric", "isNegative", "isPositive"]
      };
    }
  });

  // node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/expression/embeddedDocs/function/utils/numeric.js
  var require_numeric2 = __commonJS({
    "node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/expression/embeddedDocs/function/utils/numeric.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.numericDocs = void 0;
      var numericDocs = exports.numericDocs = {
        name: "numeric",
        category: "Utils",
        syntax: ["numeric(x)"],
        description: "Convert a numeric input to a specific numeric type: number, BigNumber, or Fraction.",
        examples: ['numeric("4")', 'numeric("4", "number")', 'numeric("4", "BigNumber")', 'numeric("4", "Fraction")', 'numeric(4, "Fraction")', 'numeric(fraction(2, 5), "number")'],
        seealso: ["number", "fraction", "bignumber", "string", "format"]
      };
    }
  });

  // node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/expression/embeddedDocs/function/utils/oct.js
  var require_oct2 = __commonJS({
    "node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/expression/embeddedDocs/function/utils/oct.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.octDocs = void 0;
      var octDocs = exports.octDocs = {
        name: "oct",
        category: "Utils",
        syntax: ["oct(value)"],
        description: "Format a number as octal",
        examples: ["oct(56)"],
        seealso: ["bin", "hex"]
      };
    }
  });

  // node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/expression/embeddedDocs/function/utils/print.js
  var require_print3 = __commonJS({
    "node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/expression/embeddedDocs/function/utils/print.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.printDocs = void 0;
      var printDocs = exports.printDocs = {
        name: "print",
        category: "Utils",
        syntax: ["print(template, values)", "print(template, values, precision)"],
        description: "Interpolate values into a string template.",
        examples: ['print("Lucy is $age years old", {age: 5})', 'print("The value of pi is $pi", {pi: pi}, 3)', 'print("Hello, $user.name!", {user: {name: "John"}})', 'print("Values: $1, $2, $3", [6, 9, 4])'],
        seealso: ["format"]
      };
    }
  });

  // node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/expression/embeddedDocs/function/utils/typeOf.js
  var require_typeOf2 = __commonJS({
    "node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/expression/embeddedDocs/function/utils/typeOf.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.typeOfDocs = void 0;
      var typeOfDocs = exports.typeOfDocs = {
        name: "typeOf",
        category: "Utils",
        syntax: ["typeOf(x)"],
        description: "Get the type of a variable.",
        examples: ["typeOf(3.5)", "typeOf(2 - 4i)", "typeOf(45 deg)", 'typeOf("hello world")'],
        seealso: ["getMatrixDataType"]
      };
    }
  });

  // node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/expression/embeddedDocs/function/numeric/solveODE.js
  var require_solveODE2 = __commonJS({
    "node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/expression/embeddedDocs/function/numeric/solveODE.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.solveODEDocs = void 0;
      var solveODEDocs = exports.solveODEDocs = {
        name: "solveODE",
        category: "Numeric",
        syntax: ["solveODE(func, tspan, y0)", "solveODE(func, tspan, y0, options)"],
        description: "Numerical Integration of Ordinary Differential Equations.",
        examples: ["f(t,y) = y", "tspan = [0, 4]", "solveODE(f, tspan, 1)", "solveODE(f, tspan, [1, 2])", 'solveODE(f, tspan, 1, { method:"RK23", maxStep:0.1 })'],
        seealso: ["derivative", "simplifyCore"]
      };
    }
  });

  // node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/expression/embeddedDocs/embeddedDocs.js
  var require_embeddedDocs = __commonJS({
    "node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/expression/embeddedDocs/embeddedDocs.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.embeddedDocs = void 0;
      var _e = require_e();
      var _false = require_false();
      var _i = require_i();
      var _Infinity = require_Infinity();
      var _LN = require_LN10();
      var _LN2 = require_LN2();
      var _LOG10E = require_LOG10E();
      var _LOG2E = require_LOG2E();
      var _NaN = require_NaN();
      var _null = require_null();
      var _phi = require_phi();
      var _pi = require_pi();
      var _SQRT1_ = require_SQRT1_2();
      var _SQRT = require_SQRT2();
      var _tau = require_tau();
      var _true = require_true();
      var _version = require_version();
      var _bignumber = require_bignumber2();
      var _boolean = require_boolean2();
      var _complex = require_complex4();
      var _createUnit = require_createUnit2();
      var _fraction = require_fraction3();
      var _index = require_construction();
      var _matrix = require_matrix2();
      var _number = require_number4();
      var _sparse = require_sparse2();
      var _splitUnit = require_splitUnit2();
      var _string = require_string3();
      var _unit = require_unit2();
      var _config = require_config3();
      var _import = require_import();
      var _typed = require_typed2();
      var _derivative = require_derivative();
      var _leafCount = require_leafCount();
      var _lsolve = require_lsolve2();
      var _lsolveAll = require_lsolveAll2();
      var _lup = require_lup2();
      var _lusolve = require_lusolve2();
      var _polynomialRoot = require_polynomialRoot2();
      var _qr = require_qr2();
      var _rationalize = require_rationalize();
      var _resolve = require_resolve();
      var _simplify = require_simplify();
      var _simplifyConstant = require_simplifyConstant();
      var _simplifyCore = require_simplifyCore();
      var _slu = require_slu2();
      var _symbolicEqual = require_symbolicEqual();
      var _usolve = require_usolve2();
      var _usolveAll = require_usolveAll2();
      var _abs = require_abs2();
      var _add = require_add2();
      var _cbrt = require_cbrt2();
      var _ceil = require_ceil2();
      var _cube = require_cube2();
      var _divide = require_divide();
      var _dotDivide = require_dotDivide2();
      var _dotMultiply = require_dotMultiply2();
      var _dotPow = require_dotPow2();
      var _exp = require_exp2();
      var _expm = require_expm();
      var _expm2 = require_expm12();
      var _fix = require_fix2();
      var _floor = require_floor2();
      var _gcd = require_gcd2();
      var _hypot = require_hypot2();
      var _invmod = require_invmod2();
      var _lcm = require_lcm2();
      var _log = require_log3();
      var _log2 = require_log102();
      var _log1p = require_log1p2();
      var _log3 = require_log22();
      var _mod = require_mod2();
      var _multiply = require_multiply2();
      var _norm = require_norm2();
      var _nthRoot = require_nthRoot2();
      var _nthRoots = require_nthRoots2();
      var _pow = require_pow2();
      var _round = require_round2();
      var _sign = require_sign2();
      var _sqrt = require_sqrt2();
      var _sqrtm = require_sqrtm();
      var _sylvester = require_sylvester();
      var _schur = require_schur();
      var _lyap = require_lyap();
      var _square = require_square2();
      var _subtract = require_subtract2();
      var _unaryMinus = require_unaryMinus2();
      var _unaryPlus = require_unaryPlus2();
      var _xgcd = require_xgcd2();
      var _bitAnd = require_bitAnd2();
      var _bitNot = require_bitNot2();
      var _bitOr = require_bitOr2();
      var _bitXor = require_bitXor2();
      var _leftShift = require_leftShift2();
      var _rightArithShift = require_rightArithShift2();
      var _rightLogShift = require_rightLogShift2();
      var _bellNumbers = require_bellNumbers();
      var _catalan = require_catalan();
      var _composition = require_composition();
      var _stirlingS = require_stirlingS2();
      var _arg = require_arg2();
      var _conj = require_conj2();
      var _im = require_im2();
      var _re = require_re2();
      var _evaluate = require_evaluate2();
      var _help = require_help();
      var _distance = require_distance();
      var _intersect = require_intersect();
      var _and = require_and2();
      var _not = require_not2();
      var _or = require_or2();
      var _xor = require_xor2();
      var _column = require_column2();
      var _concat = require_concat2();
      var _count = require_count2();
      var _cross = require_cross2();
      var _ctranspose = require_ctranspose2();
      var _det = require_det();
      var _diag = require_diag2();
      var _diff = require_diff2();
      var _dot = require_dot2();
      var _eigs = require_eigs();
      var _filter = require_filter2();
      var _flatten = require_flatten2();
      var _forEach = require_forEach2();
      var _getMatrixDataType = require_getMatrixDataType2();
      var _identity = require_identity2();
      var _inv = require_inv();
      var _pinv = require_pinv();
      var _kron = require_kron2();
      var _map = require_map3();
      var _matrixFromColumns = require_matrixFromColumns2();
      var _matrixFromFunction = require_matrixFromFunction2();
      var _matrixFromRows = require_matrixFromRows2();
      var _ones = require_ones2();
      var _partitionSelect = require_partitionSelect2();
      var _range = require_range2();
      var _reshape2 = require_reshape2();
      var _resize2 = require_resize2();
      var _rotate = require_rotate2();
      var _rotationMatrix = require_rotationMatrix2();
      var _row = require_row2();
      var _size = require_size2();
      var _sort = require_sort2();
      var _squeeze = require_squeeze2();
      var _subset = require_subset2();
      var _trace = require_trace2();
      var _transpose = require_transpose2();
      var _zeros = require_zeros2();
      var _fft = require_fft2();
      var _ifft = require_ifft2();
      var _combinations = require_combinations2();
      var _combinationsWithRep = require_combinationsWithRep();
      var _factorial = require_factorial();
      var _gamma = require_gamma();
      var _lgamma = require_lgamma();
      var _kldivergence = require_kldivergence();
      var _multinomial = require_multinomial();
      var _permutations = require_permutations();
      var _pickRandom = require_pickRandom();
      var _random = require_random();
      var _randomInt = require_randomInt();
      var _compare = require_compare2();
      var _compareNatural = require_compareNatural2();
      var _compareText = require_compareText2();
      var _deepEqual = require_deepEqual2();
      var _equal = require_equal2();
      var _equalText = require_equalText2();
      var _larger = require_larger2();
      var _largerEq = require_largerEq2();
      var _smaller = require_smaller2();
      var _smallerEq = require_smallerEq2();
      var _unequal = require_unequal2();
      var _setCartesian = require_setCartesian2();
      var _setDifference = require_setDifference2();
      var _setDistinct = require_setDistinct2();
      var _setIntersect = require_setIntersect2();
      var _setIsSubset = require_setIsSubset2();
      var _setMultiplicity = require_setMultiplicity2();
      var _setPowerset = require_setPowerset2();
      var _setSize = require_setSize2();
      var _setSymDifference = require_setSymDifference2();
      var _setUnion = require_setUnion2();
      var _zpk2tf = require_zpk2tf();
      var _freqz = require_freqz();
      var _erf = require_erf2();
      var _zeta = require_zeta2();
      var _mad = require_mad();
      var _max = require_max2();
      var _mean = require_mean();
      var _median = require_median();
      var _min = require_min2();
      var _mode = require_mode2();
      var _prod = require_prod2();
      var _quantileSeq = require_quantileSeq();
      var _std = require_std();
      var _cumsum = require_cumsum();
      var _sum = require_sum();
      var _variance = require_variance();
      var _corr = require_corr();
      var _acos = require_acos2();
      var _acosh = require_acosh2();
      var _acot = require_acot2();
      var _acoth = require_acoth2();
      var _acsc = require_acsc2();
      var _acsch = require_acsch2();
      var _asec = require_asec2();
      var _asech = require_asech2();
      var _asin = require_asin2();
      var _asinh = require_asinh2();
      var _atan = require_atan3();
      var _atan2 = require_atan22();
      var _atanh = require_atanh2();
      var _cos = require_cos2();
      var _cosh = require_cosh2();
      var _cot = require_cot2();
      var _coth = require_coth2();
      var _csc = require_csc2();
      var _csch = require_csch2();
      var _sec = require_sec2();
      var _sech = require_sech2();
      var _sin = require_sin2();
      var _sinh = require_sinh2();
      var _tan = require_tan2();
      var _tanh = require_tanh2();
      var _to = require_to2();
      var _bin = require_bin2();
      var _clone = require_clone2();
      var _format2 = require_format2();
      var _hasNumericValue = require_hasNumericValue2();
      var _hex = require_hex2();
      var _isInteger = require_isInteger2();
      var _isNaN = require_isNaN2();
      var _isNegative = require_isNegative2();
      var _isNumeric = require_isNumeric2();
      var _isPositive = require_isPositive2();
      var _isPrime = require_isPrime2();
      var _isZero = require_isZero2();
      var _numeric = require_numeric2();
      var _oct = require_oct2();
      var _print = require_print3();
      var _typeOf = require_typeOf2();
      var _solveODE = require_solveODE2();
      var embeddedDocs = exports.embeddedDocs = {
        // construction functions
        bignumber: _bignumber.bignumberDocs,
        "boolean": _boolean.booleanDocs,
        complex: _complex.complexDocs,
        createUnit: _createUnit.createUnitDocs,
        fraction: _fraction.fractionDocs,
        index: _index.indexDocs,
        matrix: _matrix.matrixDocs,
        number: _number.numberDocs,
        sparse: _sparse.sparseDocs,
        splitUnit: _splitUnit.splitUnitDocs,
        string: _string.stringDocs,
        unit: _unit.unitDocs,
        // constants
        e: _e.eDocs,
        E: _e.eDocs,
        "false": _false.falseDocs,
        i: _i.iDocs,
        Infinity: _Infinity.InfinityDocs,
        LN2: _LN2.LN2Docs,
        LN10: _LN.LN10Docs,
        LOG2E: _LOG2E.LOG2EDocs,
        LOG10E: _LOG10E.LOG10EDocs,
        NaN: _NaN.NaNDocs,
        "null": _null.nullDocs,
        pi: _pi.piDocs,
        PI: _pi.piDocs,
        phi: _phi.phiDocs,
        SQRT1_2: _SQRT1_.SQRT12Docs,
        SQRT2: _SQRT.SQRT2Docs,
        tau: _tau.tauDocs,
        "true": _true.trueDocs,
        version: _version.versionDocs,
        // physical constants
        // TODO: more detailed docs for physical constants
        speedOfLight: {
          description: "Speed of light in vacuum",
          examples: ["speedOfLight"]
        },
        gravitationConstant: {
          description: "Newtonian constant of gravitation",
          examples: ["gravitationConstant"]
        },
        planckConstant: {
          description: "Planck constant",
          examples: ["planckConstant"]
        },
        reducedPlanckConstant: {
          description: "Reduced Planck constant",
          examples: ["reducedPlanckConstant"]
        },
        magneticConstant: {
          description: "Magnetic constant (vacuum permeability)",
          examples: ["magneticConstant"]
        },
        electricConstant: {
          description: "Electric constant (vacuum permeability)",
          examples: ["electricConstant"]
        },
        vacuumImpedance: {
          description: "Characteristic impedance of vacuum",
          examples: ["vacuumImpedance"]
        },
        coulomb: {
          description: "Coulomb's constant",
          examples: ["coulomb"]
        },
        elementaryCharge: {
          description: "Elementary charge",
          examples: ["elementaryCharge"]
        },
        bohrMagneton: {
          description: "Borh magneton",
          examples: ["bohrMagneton"]
        },
        conductanceQuantum: {
          description: "Conductance quantum",
          examples: ["conductanceQuantum"]
        },
        inverseConductanceQuantum: {
          description: "Inverse conductance quantum",
          examples: ["inverseConductanceQuantum"]
        },
        // josephson: {description: 'Josephson constant', examples: ['josephson']},
        magneticFluxQuantum: {
          description: "Magnetic flux quantum",
          examples: ["magneticFluxQuantum"]
        },
        nuclearMagneton: {
          description: "Nuclear magneton",
          examples: ["nuclearMagneton"]
        },
        klitzing: {
          description: "Von Klitzing constant",
          examples: ["klitzing"]
        },
        bohrRadius: {
          description: "Borh radius",
          examples: ["bohrRadius"]
        },
        classicalElectronRadius: {
          description: "Classical electron radius",
          examples: ["classicalElectronRadius"]
        },
        electronMass: {
          description: "Electron mass",
          examples: ["electronMass"]
        },
        fermiCoupling: {
          description: "Fermi coupling constant",
          examples: ["fermiCoupling"]
        },
        fineStructure: {
          description: "Fine-structure constant",
          examples: ["fineStructure"]
        },
        hartreeEnergy: {
          description: "Hartree energy",
          examples: ["hartreeEnergy"]
        },
        protonMass: {
          description: "Proton mass",
          examples: ["protonMass"]
        },
        deuteronMass: {
          description: "Deuteron Mass",
          examples: ["deuteronMass"]
        },
        neutronMass: {
          description: "Neutron mass",
          examples: ["neutronMass"]
        },
        quantumOfCirculation: {
          description: "Quantum of circulation",
          examples: ["quantumOfCirculation"]
        },
        rydberg: {
          description: "Rydberg constant",
          examples: ["rydberg"]
        },
        thomsonCrossSection: {
          description: "Thomson cross section",
          examples: ["thomsonCrossSection"]
        },
        weakMixingAngle: {
          description: "Weak mixing angle",
          examples: ["weakMixingAngle"]
        },
        efimovFactor: {
          description: "Efimov factor",
          examples: ["efimovFactor"]
        },
        atomicMass: {
          description: "Atomic mass constant",
          examples: ["atomicMass"]
        },
        avogadro: {
          description: "Avogadro's number",
          examples: ["avogadro"]
        },
        boltzmann: {
          description: "Boltzmann constant",
          examples: ["boltzmann"]
        },
        faraday: {
          description: "Faraday constant",
          examples: ["faraday"]
        },
        firstRadiation: {
          description: "First radiation constant",
          examples: ["firstRadiation"]
        },
        loschmidt: {
          description: "Loschmidt constant at T=273.15 K and p=101.325 kPa",
          examples: ["loschmidt"]
        },
        gasConstant: {
          description: "Gas constant",
          examples: ["gasConstant"]
        },
        molarPlanckConstant: {
          description: "Molar Planck constant",
          examples: ["molarPlanckConstant"]
        },
        molarVolume: {
          description: "Molar volume of an ideal gas at T=273.15 K and p=101.325 kPa",
          examples: ["molarVolume"]
        },
        sackurTetrode: {
          description: "Sackur-Tetrode constant at T=1 K and p=101.325 kPa",
          examples: ["sackurTetrode"]
        },
        secondRadiation: {
          description: "Second radiation constant",
          examples: ["secondRadiation"]
        },
        stefanBoltzmann: {
          description: "Stefan-Boltzmann constant",
          examples: ["stefanBoltzmann"]
        },
        wienDisplacement: {
          description: "Wien displacement law constant",
          examples: ["wienDisplacement"]
        },
        // spectralRadiance: {description: 'First radiation constant for spectral radiance', examples: ['spectralRadiance']},
        molarMass: {
          description: "Molar mass constant",
          examples: ["molarMass"]
        },
        molarMassC12: {
          description: "Molar mass constant of carbon-12",
          examples: ["molarMassC12"]
        },
        gravity: {
          description: "Standard acceleration of gravity (standard acceleration of free-fall on Earth)",
          examples: ["gravity"]
        },
        planckLength: {
          description: "Planck length",
          examples: ["planckLength"]
        },
        planckMass: {
          description: "Planck mass",
          examples: ["planckMass"]
        },
        planckTime: {
          description: "Planck time",
          examples: ["planckTime"]
        },
        planckCharge: {
          description: "Planck charge",
          examples: ["planckCharge"]
        },
        planckTemperature: {
          description: "Planck temperature",
          examples: ["planckTemperature"]
        },
        // functions - algebra
        derivative: _derivative.derivativeDocs,
        lsolve: _lsolve.lsolveDocs,
        lsolveAll: _lsolveAll.lsolveAllDocs,
        lup: _lup.lupDocs,
        lusolve: _lusolve.lusolveDocs,
        leafCount: _leafCount.leafCountDocs,
        polynomialRoot: _polynomialRoot.polynomialRootDocs,
        resolve: _resolve.resolveDocs,
        simplify: _simplify.simplifyDocs,
        simplifyConstant: _simplifyConstant.simplifyConstantDocs,
        simplifyCore: _simplifyCore.simplifyCoreDocs,
        symbolicEqual: _symbolicEqual.symbolicEqualDocs,
        rationalize: _rationalize.rationalizeDocs,
        slu: _slu.sluDocs,
        usolve: _usolve.usolveDocs,
        usolveAll: _usolveAll.usolveAllDocs,
        qr: _qr.qrDocs,
        // functions - arithmetic
        abs: _abs.absDocs,
        add: _add.addDocs,
        cbrt: _cbrt.cbrtDocs,
        ceil: _ceil.ceilDocs,
        cube: _cube.cubeDocs,
        divide: _divide.divideDocs,
        dotDivide: _dotDivide.dotDivideDocs,
        dotMultiply: _dotMultiply.dotMultiplyDocs,
        dotPow: _dotPow.dotPowDocs,
        exp: _exp.expDocs,
        expm: _expm.expmDocs,
        expm1: _expm2.expm1Docs,
        fix: _fix.fixDocs,
        floor: _floor.floorDocs,
        gcd: _gcd.gcdDocs,
        hypot: _hypot.hypotDocs,
        lcm: _lcm.lcmDocs,
        log: _log.logDocs,
        log2: _log3.log2Docs,
        log1p: _log1p.log1pDocs,
        log10: _log2.log10Docs,
        mod: _mod.modDocs,
        multiply: _multiply.multiplyDocs,
        norm: _norm.normDocs,
        nthRoot: _nthRoot.nthRootDocs,
        nthRoots: _nthRoots.nthRootsDocs,
        pow: _pow.powDocs,
        round: _round.roundDocs,
        sign: _sign.signDocs,
        sqrt: _sqrt.sqrtDocs,
        sqrtm: _sqrtm.sqrtmDocs,
        square: _square.squareDocs,
        subtract: _subtract.subtractDocs,
        unaryMinus: _unaryMinus.unaryMinusDocs,
        unaryPlus: _unaryPlus.unaryPlusDocs,
        xgcd: _xgcd.xgcdDocs,
        invmod: _invmod.invmodDocs,
        // functions - bitwise
        bitAnd: _bitAnd.bitAndDocs,
        bitNot: _bitNot.bitNotDocs,
        bitOr: _bitOr.bitOrDocs,
        bitXor: _bitXor.bitXorDocs,
        leftShift: _leftShift.leftShiftDocs,
        rightArithShift: _rightArithShift.rightArithShiftDocs,
        rightLogShift: _rightLogShift.rightLogShiftDocs,
        // functions - combinatorics
        bellNumbers: _bellNumbers.bellNumbersDocs,
        catalan: _catalan.catalanDocs,
        composition: _composition.compositionDocs,
        stirlingS2: _stirlingS.stirlingS2Docs,
        // functions - core
        config: _config.configDocs,
        "import": _import.importDocs,
        typed: _typed.typedDocs,
        // functions - complex
        arg: _arg.argDocs,
        conj: _conj.conjDocs,
        re: _re.reDocs,
        im: _im.imDocs,
        // functions - expression
        evaluate: _evaluate.evaluateDocs,
        help: _help.helpDocs,
        // functions - geometry
        distance: _distance.distanceDocs,
        intersect: _intersect.intersectDocs,
        // functions - logical
        and: _and.andDocs,
        not: _not.notDocs,
        or: _or.orDocs,
        xor: _xor.xorDocs,
        // functions - matrix
        concat: _concat.concatDocs,
        count: _count.countDocs,
        cross: _cross.crossDocs,
        column: _column.columnDocs,
        ctranspose: _ctranspose.ctransposeDocs,
        det: _det.detDocs,
        diag: _diag.diagDocs,
        diff: _diff.diffDocs,
        dot: _dot.dotDocs,
        getMatrixDataType: _getMatrixDataType.getMatrixDataTypeDocs,
        identity: _identity.identityDocs,
        filter: _filter.filterDocs,
        flatten: _flatten.flattenDocs,
        forEach: _forEach.forEachDocs,
        inv: _inv.invDocs,
        pinv: _pinv.pinvDocs,
        eigs: _eigs.eigsDocs,
        kron: _kron.kronDocs,
        matrixFromFunction: _matrixFromFunction.matrixFromFunctionDocs,
        matrixFromRows: _matrixFromRows.matrixFromRowsDocs,
        matrixFromColumns: _matrixFromColumns.matrixFromColumnsDocs,
        map: _map.mapDocs,
        ones: _ones.onesDocs,
        partitionSelect: _partitionSelect.partitionSelectDocs,
        range: _range.rangeDocs,
        resize: _resize2.resizeDocs,
        reshape: _reshape2.reshapeDocs,
        rotate: _rotate.rotateDocs,
        rotationMatrix: _rotationMatrix.rotationMatrixDocs,
        row: _row.rowDocs,
        size: _size.sizeDocs,
        sort: _sort.sortDocs,
        squeeze: _squeeze.squeezeDocs,
        subset: _subset.subsetDocs,
        trace: _trace.traceDocs,
        transpose: _transpose.transposeDocs,
        zeros: _zeros.zerosDocs,
        fft: _fft.fftDocs,
        ifft: _ifft.ifftDocs,
        sylvester: _sylvester.sylvesterDocs,
        schur: _schur.schurDocs,
        lyap: _lyap.lyapDocs,
        // functions - numeric
        solveODE: _solveODE.solveODEDocs,
        // functions - probability
        combinations: _combinations.combinationsDocs,
        combinationsWithRep: _combinationsWithRep.combinationsWithRepDocs,
        // distribution: distributionDocs,
        factorial: _factorial.factorialDocs,
        gamma: _gamma.gammaDocs,
        kldivergence: _kldivergence.kldivergenceDocs,
        lgamma: _lgamma.lgammaDocs,
        multinomial: _multinomial.multinomialDocs,
        permutations: _permutations.permutationsDocs,
        pickRandom: _pickRandom.pickRandomDocs,
        random: _random.randomDocs,
        randomInt: _randomInt.randomIntDocs,
        // functions - relational
        compare: _compare.compareDocs,
        compareNatural: _compareNatural.compareNaturalDocs,
        compareText: _compareText.compareTextDocs,
        deepEqual: _deepEqual.deepEqualDocs,
        equal: _equal.equalDocs,
        equalText: _equalText.equalTextDocs,
        larger: _larger.largerDocs,
        largerEq: _largerEq.largerEqDocs,
        smaller: _smaller.smallerDocs,
        smallerEq: _smallerEq.smallerEqDocs,
        unequal: _unequal.unequalDocs,
        // functions - set
        setCartesian: _setCartesian.setCartesianDocs,
        setDifference: _setDifference.setDifferenceDocs,
        setDistinct: _setDistinct.setDistinctDocs,
        setIntersect: _setIntersect.setIntersectDocs,
        setIsSubset: _setIsSubset.setIsSubsetDocs,
        setMultiplicity: _setMultiplicity.setMultiplicityDocs,
        setPowerset: _setPowerset.setPowersetDocs,
        setSize: _setSize.setSizeDocs,
        setSymDifference: _setSymDifference.setSymDifferenceDocs,
        setUnion: _setUnion.setUnionDocs,
        // functions - signal
        zpk2tf: _zpk2tf.zpk2tfDocs,
        freqz: _freqz.freqzDocs,
        // functions - special
        erf: _erf.erfDocs,
        zeta: _zeta.zetaDocs,
        // functions - statistics
        cumsum: _cumsum.cumSumDocs,
        mad: _mad.madDocs,
        max: _max.maxDocs,
        mean: _mean.meanDocs,
        median: _median.medianDocs,
        min: _min.minDocs,
        mode: _mode.modeDocs,
        prod: _prod.prodDocs,
        quantileSeq: _quantileSeq.quantileSeqDocs,
        std: _std.stdDocs,
        sum: _sum.sumDocs,
        variance: _variance.varianceDocs,
        corr: _corr.corrDocs,
        // functions - trigonometry
        acos: _acos.acosDocs,
        acosh: _acosh.acoshDocs,
        acot: _acot.acotDocs,
        acoth: _acoth.acothDocs,
        acsc: _acsc.acscDocs,
        acsch: _acsch.acschDocs,
        asec: _asec.asecDocs,
        asech: _asech.asechDocs,
        asin: _asin.asinDocs,
        asinh: _asinh.asinhDocs,
        atan: _atan.atanDocs,
        atanh: _atanh.atanhDocs,
        atan2: _atan2.atan2Docs,
        cos: _cos.cosDocs,
        cosh: _cosh.coshDocs,
        cot: _cot.cotDocs,
        coth: _coth.cothDocs,
        csc: _csc.cscDocs,
        csch: _csch.cschDocs,
        sec: _sec.secDocs,
        sech: _sech.sechDocs,
        sin: _sin.sinDocs,
        sinh: _sinh.sinhDocs,
        tan: _tan.tanDocs,
        tanh: _tanh.tanhDocs,
        // functions - units
        to: _to.toDocs,
        // functions - utils
        clone: _clone.cloneDocs,
        format: _format2.formatDocs,
        bin: _bin.binDocs,
        oct: _oct.octDocs,
        hex: _hex.hexDocs,
        isNaN: _isNaN.isNaNDocs,
        isInteger: _isInteger.isIntegerDocs,
        isNegative: _isNegative.isNegativeDocs,
        isNumeric: _isNumeric.isNumericDocs,
        hasNumericValue: _hasNumericValue.hasNumericValueDocs,
        isPositive: _isPositive.isPositiveDocs,
        isPrime: _isPrime.isPrimeDocs,
        isZero: _isZero.isZeroDocs,
        print: _print.printDocs,
        typeOf: _typeOf.typeOfDocs,
        numeric: _numeric.numericDocs
      };
    }
  });

  // node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/expression/function/help.js
  var require_help2 = __commonJS({
    "node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/expression/function/help.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.createHelp = void 0;
      var _factory = require_factory();
      var _customs = require_customs();
      var _embeddedDocs = require_embeddedDocs();
      var _object = require_object();
      var name18 = "help";
      var dependencies19 = ["typed", "mathWithTransform", "Help"];
      var createHelp = exports.createHelp = /* @__PURE__ */ (0, _factory.factory)(name18, dependencies19, function(_ref) {
        var typed2 = _ref.typed, mathWithTransform = _ref.mathWithTransform, Help = _ref.Help;
        return typed2(name18, {
          any: function any(search) {
            var prop;
            var searchName = search;
            if (typeof search !== "string") {
              for (prop in mathWithTransform) {
                if ((0, _object.hasOwnProperty)(mathWithTransform, prop) && search === mathWithTransform[prop]) {
                  searchName = prop;
                  break;
                }
              }
            }
            var doc = (0, _customs.getSafeProperty)(_embeddedDocs.embeddedDocs, searchName);
            if (!doc) {
              var searchText = typeof searchName === "function" ? searchName.name : searchName;
              throw new Error('No documentation found on "' + searchText + '"');
            }
            return new Help(doc);
          }
        });
      });
    }
  });

  // node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/type/chain/function/chain.js
  var require_chain = __commonJS({
    "node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/type/chain/function/chain.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.createChain = void 0;
      var _factory = require_factory();
      var name18 = "chain";
      var dependencies19 = ["typed", "Chain"];
      var createChain = exports.createChain = /* @__PURE__ */ (0, _factory.factory)(name18, dependencies19, function(_ref) {
        var typed2 = _ref.typed, Chain = _ref.Chain;
        return typed2(name18, {
          "": function _() {
            return new Chain();
          },
          any: function any(value) {
            return new Chain(value);
          }
        });
      });
    }
  });

  // node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/function/matrix/det.js
  var require_det2 = __commonJS({
    "node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/function/matrix/det.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.createDet = void 0;
      var _is = require_is();
      var _object = require_object();
      var _string = require_string();
      var _factory = require_factory();
      var name18 = "det";
      var dependencies19 = ["typed", "matrix", "subtractScalar", "multiply", "divideScalar", "isZero", "unaryMinus"];
      var createDet2 = exports.createDet = /* @__PURE__ */ (0, _factory.factory)(name18, dependencies19, function(_ref) {
        var typed2 = _ref.typed, matrix2 = _ref.matrix, subtractScalar = _ref.subtractScalar, multiply2 = _ref.multiply, divideScalar = _ref.divideScalar, isZero = _ref.isZero, unaryMinus = _ref.unaryMinus;
        return typed2(name18, {
          any: function any(x) {
            return (0, _object.clone)(x);
          },
          "Array | Matrix": function det(x) {
            var size2;
            if ((0, _is.isMatrix)(x)) {
              size2 = x.size();
            } else if (Array.isArray(x)) {
              x = matrix2(x);
              size2 = x.size();
            } else {
              size2 = [];
            }
            switch (size2.length) {
              case 0:
                return (0, _object.clone)(x);
              case 1:
                if (size2[0] === 1) {
                  return (0, _object.clone)(x.valueOf()[0]);
                }
                if (size2[0] === 0) {
                  return 1;
                } else {
                  throw new RangeError("Matrix must be square (size: " + (0, _string.format)(size2) + ")");
                }
              case 2: {
                var rows = size2[0];
                var cols = size2[1];
                if (rows === cols) {
                  return _det(x.clone().valueOf(), rows, cols);
                }
                if (cols === 0) {
                  return 1;
                } else {
                  throw new RangeError("Matrix must be square (size: " + (0, _string.format)(size2) + ")");
                }
              }
              default:
                throw new RangeError("Matrix must be two dimensional (size: " + (0, _string.format)(size2) + ")");
            }
          }
        });
        function _det(matrix3, rows, cols) {
          if (rows === 1) {
            return (0, _object.clone)(matrix3[0][0]);
          } else if (rows === 2) {
            return subtractScalar(multiply2(matrix3[0][0], matrix3[1][1]), multiply2(matrix3[1][0], matrix3[0][1]));
          } else {
            var negated = false;
            var rowIndices = new Array(rows).fill(0).map(function(_, i2) {
              return i2;
            });
            for (var k = 0; k < rows; k++) {
              var k_ = rowIndices[k];
              if (isZero(matrix3[k_][k])) {
                var _k = void 0;
                for (_k = k + 1; _k < rows; _k++) {
                  if (!isZero(matrix3[rowIndices[_k]][k])) {
                    k_ = rowIndices[_k];
                    rowIndices[_k] = rowIndices[k];
                    rowIndices[k] = k_;
                    negated = !negated;
                    break;
                  }
                }
                if (_k === rows) return matrix3[k_][k];
              }
              var piv = matrix3[k_][k];
              var piv_ = k === 0 ? 1 : matrix3[rowIndices[k - 1]][k - 1];
              for (var i = k + 1; i < rows; i++) {
                var i_ = rowIndices[i];
                for (var j = k + 1; j < rows; j++) {
                  matrix3[i_][j] = divideScalar(subtractScalar(multiply2(matrix3[i_][j], piv), multiply2(matrix3[i_][k], matrix3[k_][j])), piv_);
                }
              }
            }
            var det = matrix3[rowIndices[rows - 1]][rows - 1];
            return negated ? unaryMinus(det) : det;
          }
        }
      });
    }
  });

  // node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/function/matrix/inv.js
  var require_inv2 = __commonJS({
    "node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/function/matrix/inv.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.createInv = void 0;
      var _is = require_is();
      var _array = require_array();
      var _factory = require_factory();
      var _string = require_string();
      var name18 = "inv";
      var dependencies19 = ["typed", "matrix", "divideScalar", "addScalar", "multiply", "unaryMinus", "det", "identity", "abs"];
      var createInv2 = exports.createInv = /* @__PURE__ */ (0, _factory.factory)(name18, dependencies19, function(_ref) {
        var typed2 = _ref.typed, matrix2 = _ref.matrix, divideScalar = _ref.divideScalar, addScalar2 = _ref.addScalar, multiply2 = _ref.multiply, unaryMinus = _ref.unaryMinus, det = _ref.det, identity = _ref.identity, abs2 = _ref.abs;
        return typed2(name18, {
          "Array | Matrix": function ArrayMatrix(x) {
            var size2 = (0, _is.isMatrix)(x) ? x.size() : (0, _array.arraySize)(x);
            switch (size2.length) {
              case 1:
                if (size2[0] === 1) {
                  if ((0, _is.isMatrix)(x)) {
                    return matrix2([divideScalar(1, x.valueOf()[0])]);
                  } else {
                    return [divideScalar(1, x[0])];
                  }
                } else {
                  throw new RangeError("Matrix must be square (size: " + (0, _string.format)(size2) + ")");
                }
              case 2: {
                var rows = size2[0];
                var cols = size2[1];
                if (rows === cols) {
                  if ((0, _is.isMatrix)(x)) {
                    return matrix2(_inv(x.valueOf(), rows, cols), x.storage());
                  } else {
                    return _inv(x, rows, cols);
                  }
                } else {
                  throw new RangeError("Matrix must be square (size: " + (0, _string.format)(size2) + ")");
                }
              }
              default:
                throw new RangeError("Matrix must be two dimensional (size: " + (0, _string.format)(size2) + ")");
            }
          },
          any: function any(x) {
            return divideScalar(1, x);
          }
        });
        function _inv(mat, rows, cols) {
          var r, s, f, value, temp;
          if (rows === 1) {
            value = mat[0][0];
            if (value === 0) {
              throw Error("Cannot calculate inverse, determinant is zero");
            }
            return [[divideScalar(1, value)]];
          } else if (rows === 2) {
            var d = det(mat);
            if (d === 0) {
              throw Error("Cannot calculate inverse, determinant is zero");
            }
            return [[divideScalar(mat[1][1], d), divideScalar(unaryMinus(mat[0][1]), d)], [divideScalar(unaryMinus(mat[1][0]), d), divideScalar(mat[0][0], d)]];
          } else {
            var A = mat.concat();
            for (r = 0; r < rows; r++) {
              A[r] = A[r].concat();
            }
            var B = identity(rows).valueOf();
            for (var c = 0; c < cols; c++) {
              var ABig = abs2(A[c][c]);
              var rBig = c;
              r = c + 1;
              while (r < rows) {
                if (abs2(A[r][c]) > ABig) {
                  ABig = abs2(A[r][c]);
                  rBig = r;
                }
                r++;
              }
              if (ABig === 0) {
                throw Error("Cannot calculate inverse, determinant is zero");
              }
              r = rBig;
              if (r !== c) {
                temp = A[c];
                A[c] = A[r];
                A[r] = temp;
                temp = B[c];
                B[c] = B[r];
                B[r] = temp;
              }
              var Ac = A[c];
              var Bc = B[c];
              for (r = 0; r < rows; r++) {
                var Ar = A[r];
                var Br = B[r];
                if (r !== c) {
                  if (Ar[c] !== 0) {
                    f = divideScalar(unaryMinus(Ar[c]), Ac[c]);
                    for (s = c; s < cols; s++) {
                      Ar[s] = addScalar2(Ar[s], multiply2(f, Ac[s]));
                    }
                    for (s = 0; s < cols; s++) {
                      Br[s] = addScalar2(Br[s], multiply2(f, Bc[s]));
                    }
                  }
                } else {
                  f = Ac[c];
                  for (s = c; s < cols; s++) {
                    Ar[s] = divideScalar(Ar[s], f);
                  }
                  for (s = 0; s < cols; s++) {
                    Br[s] = divideScalar(Br[s], f);
                  }
                }
              }
            }
            return B;
          }
        }
      });
    }
  });

  // node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/function/matrix/pinv.js
  var require_pinv2 = __commonJS({
    "node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/function/matrix/pinv.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.createPinv = void 0;
      var _is = require_is();
      var _array = require_array();
      var _factory = require_factory();
      var _string = require_string();
      var _object = require_object();
      var name18 = "pinv";
      var dependencies19 = ["typed", "matrix", "inv", "deepEqual", "equal", "dotDivide", "dot", "ctranspose", "divideScalar", "multiply", "add", "Complex"];
      var createPinv2 = exports.createPinv = /* @__PURE__ */ (0, _factory.factory)(name18, dependencies19, function(_ref) {
        var typed2 = _ref.typed, matrix2 = _ref.matrix, inv = _ref.inv, deepEqual = _ref.deepEqual, equal = _ref.equal, dotDivide = _ref.dotDivide, dot2 = _ref.dot, ctranspose = _ref.ctranspose, divideScalar = _ref.divideScalar, multiply2 = _ref.multiply, add2 = _ref.add, Complex3 = _ref.Complex;
        return typed2(name18, {
          "Array | Matrix": function ArrayMatrix(x) {
            var size2 = (0, _is.isMatrix)(x) ? x.size() : (0, _array.arraySize)(x);
            switch (size2.length) {
              case 1:
                if (_isZeros(x)) return ctranspose(x);
                if (size2[0] === 1) {
                  return inv(x);
                } else {
                  return dotDivide(ctranspose(x), dot2(x, x));
                }
              case 2: {
                if (_isZeros(x)) return ctranspose(x);
                var rows = size2[0];
                var cols = size2[1];
                if (rows === cols) {
                  try {
                    return inv(x);
                  } catch (err) {
                    if (err instanceof Error && err.message.match(/Cannot calculate inverse, determinant is zero/)) {
                    } else {
                      throw err;
                    }
                  }
                }
                if ((0, _is.isMatrix)(x)) {
                  return matrix2(_pinv(x.valueOf(), rows, cols), x.storage());
                } else {
                  return _pinv(x, rows, cols);
                }
              }
              default:
                throw new RangeError("Matrix must be two dimensional (size: " + (0, _string.format)(size2) + ")");
            }
          },
          any: function any(x) {
            if (equal(x, 0)) return (0, _object.clone)(x);
            return divideScalar(1, x);
          }
        });
        function _pinv(mat, rows, cols) {
          var _rankFact2 = _rankFact(mat, rows, cols), C = _rankFact2.C, F = _rankFact2.F;
          var Cpinv = multiply2(inv(multiply2(ctranspose(C), C)), ctranspose(C));
          var Fpinv = multiply2(ctranspose(F), inv(multiply2(F, ctranspose(F))));
          return multiply2(Fpinv, Cpinv);
        }
        function _rref(mat, rows, cols) {
          var M = (0, _object.clone)(mat);
          var lead = 0;
          for (var r = 0; r < rows; r++) {
            if (cols <= lead) {
              return M;
            }
            var i = r;
            while (_isZero(M[i][lead])) {
              i++;
              if (rows === i) {
                i = r;
                lead++;
                if (cols === lead) {
                  return M;
                }
              }
            }
            var _ref2 = [M[r], M[i]];
            M[i] = _ref2[0];
            M[r] = _ref2[1];
            var val = M[r][lead];
            for (var j = 0; j < cols; j++) {
              M[r][j] = dotDivide(M[r][j], val);
            }
            for (var _i = 0; _i < rows; _i++) {
              if (_i === r) continue;
              val = M[_i][lead];
              for (var _j = 0; _j < cols; _j++) {
                M[_i][_j] = add2(M[_i][_j], multiply2(-1, multiply2(val, M[r][_j])));
              }
            }
            lead++;
          }
          return M;
        }
        function _rankFact(mat, rows, cols) {
          var rref = _rref(mat, rows, cols);
          var C = mat.map(function(_, i) {
            return _.filter(function(_2, j) {
              return j < rows && !_isZero(dot2(rref[j], rref[j]));
            });
          });
          var F = rref.filter(function(_, i) {
            return !_isZero(dot2(rref[i], rref[i]));
          });
          return {
            C,
            F
          };
        }
        function _isZero(x) {
          return equal(add2(x, Complex3(1, 1)), add2(0, Complex3(1, 1)));
        }
        function _isZeros(arr) {
          return deepEqual(add2(arr, Complex3(1, 1)), add2(multiply2(arr, 0), Complex3(1, 1)));
        }
      });
    }
  });

  // node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/function/matrix/eigs/complexEigs.js
  var require_complexEigs = __commonJS({
    "node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/function/matrix/eigs/complexEigs.js"(exports) {
      "use strict";
      var _interopRequireDefault = require_interopRequireDefault();
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.createComplexEigs = createComplexEigs;
      var _toConsumableArray2 = _interopRequireDefault(require_toConsumableArray());
      var _object = require_object();
      function _createForOfIteratorHelper(o, allowArrayLike) {
        var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"];
        if (!it) {
          if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") {
            if (it) o = it;
            var i = 0;
            var F = function F2() {
            };
            return { s: F, n: function n() {
              if (i >= o.length) return { done: true };
              return { done: false, value: o[i++] };
            }, e: function e(_e) {
              throw _e;
            }, f: F };
          }
          throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
        }
        var normalCompletion = true, didErr = false, err;
        return { s: function s() {
          it = it.call(o);
        }, n: function n() {
          var step = it.next();
          normalCompletion = step.done;
          return step;
        }, e: function e(_e2) {
          didErr = true;
          err = _e2;
        }, f: function f() {
          try {
            if (!normalCompletion && it["return"] != null) it["return"]();
          } finally {
            if (didErr) throw err;
          }
        } };
      }
      function _unsupportedIterableToArray(o, minLen) {
        if (!o) return;
        if (typeof o === "string") return _arrayLikeToArray(o, minLen);
        var n = Object.prototype.toString.call(o).slice(8, -1);
        if (n === "Object" && o.constructor) n = o.constructor.name;
        if (n === "Map" || n === "Set") return Array.from(o);
        if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);
      }
      function _arrayLikeToArray(arr, len) {
        if (len == null || len > arr.length) len = arr.length;
        for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];
        return arr2;
      }
      function createComplexEigs(_ref) {
        var addScalar2 = _ref.addScalar, subtract = _ref.subtract, flatten2 = _ref.flatten, multiply2 = _ref.multiply, multiplyScalar2 = _ref.multiplyScalar, divideScalar = _ref.divideScalar, sqrt2 = _ref.sqrt, abs2 = _ref.abs, bignumber = _ref.bignumber, diag = _ref.diag, size2 = _ref.size, reshape2 = _ref.reshape, inv = _ref.inv, qr = _ref.qr, usolve = _ref.usolve, usolveAll = _ref.usolveAll, equal = _ref.equal, complex2 = _ref.complex, larger = _ref.larger, smaller = _ref.smaller, matrixFromColumns = _ref.matrixFromColumns, dot2 = _ref.dot;
        function complexEigs(arr, N, prec, type) {
          var findVectors = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : true;
          var R = balance(arr, N, prec, type, findVectors);
          reduceToHessenberg(arr, N, prec, type, findVectors, R);
          var _iterateUntilTriangul = iterateUntilTriangular(arr, N, prec, type, findVectors), values = _iterateUntilTriangul.values, C = _iterateUntilTriangul.C;
          if (findVectors) {
            var eigenvectors = findEigenvectors(arr, N, C, R, values, prec, type);
            return {
              values,
              eigenvectors
            };
          }
          return {
            values
          };
        }
        function balance(arr, N, prec, type, findVectors) {
          var big = type === "BigNumber";
          var cplx = type === "Complex";
          var realzero = big ? bignumber(0) : 0;
          var one = big ? bignumber(1) : cplx ? complex2(1) : 1;
          var realone = big ? bignumber(1) : 1;
          var radix = big ? bignumber(10) : 2;
          var radixSq = multiplyScalar2(radix, radix);
          var Rdiag;
          if (findVectors) {
            Rdiag = Array(N).fill(one);
          }
          var last = false;
          while (!last) {
            last = true;
            for (var i = 0; i < N; i++) {
              var colNorm = realzero;
              var rowNorm = realzero;
              for (var j = 0; j < N; j++) {
                if (i === j) continue;
                colNorm = addScalar2(colNorm, abs2(arr[j][i]));
                rowNorm = addScalar2(rowNorm, abs2(arr[i][j]));
              }
              if (!equal(colNorm, 0) && !equal(rowNorm, 0)) {
                var f = realone;
                var c = colNorm;
                var rowDivRadix = divideScalar(rowNorm, radix);
                var rowMulRadix = multiplyScalar2(rowNorm, radix);
                while (smaller(c, rowDivRadix)) {
                  c = multiplyScalar2(c, radixSq);
                  f = multiplyScalar2(f, radix);
                }
                while (larger(c, rowMulRadix)) {
                  c = divideScalar(c, radixSq);
                  f = divideScalar(f, radix);
                }
                var condition = smaller(divideScalar(addScalar2(c, rowNorm), f), multiplyScalar2(addScalar2(colNorm, rowNorm), 0.95));
                if (condition) {
                  last = false;
                  var g = divideScalar(1, f);
                  for (var _j = 0; _j < N; _j++) {
                    if (i === _j) {
                      continue;
                    }
                    arr[i][_j] = multiplyScalar2(arr[i][_j], g);
                    arr[_j][i] = multiplyScalar2(arr[_j][i], f);
                  }
                  if (findVectors) {
                    Rdiag[i] = multiplyScalar2(Rdiag[i], g);
                  }
                }
              }
            }
          }
          return findVectors ? diag(Rdiag) : null;
        }
        function reduceToHessenberg(arr, N, prec, type, findVectors, R) {
          var big = type === "BigNumber";
          var cplx = type === "Complex";
          var zero = big ? bignumber(0) : cplx ? complex2(0) : 0;
          if (big) {
            prec = bignumber(prec);
          }
          for (var i = 0; i < N - 2; i++) {
            var maxIndex = 0;
            var max2 = zero;
            for (var j = i + 1; j < N; j++) {
              var el = arr[j][i];
              if (smaller(abs2(max2), abs2(el))) {
                max2 = el;
                maxIndex = j;
              }
            }
            if (smaller(abs2(max2), prec)) {
              continue;
            }
            if (maxIndex !== i + 1) {
              var tmp1 = arr[maxIndex];
              arr[maxIndex] = arr[i + 1];
              arr[i + 1] = tmp1;
              for (var _j2 = 0; _j2 < N; _j2++) {
                var tmp2 = arr[_j2][maxIndex];
                arr[_j2][maxIndex] = arr[_j2][i + 1];
                arr[_j2][i + 1] = tmp2;
              }
              if (findVectors) {
                var tmp3 = R[maxIndex];
                R[maxIndex] = R[i + 1];
                R[i + 1] = tmp3;
              }
            }
            for (var _j3 = i + 2; _j3 < N; _j3++) {
              var n = divideScalar(arr[_j3][i], max2);
              if (n === 0) {
                continue;
              }
              for (var k = 0; k < N; k++) {
                arr[_j3][k] = subtract(arr[_j3][k], multiplyScalar2(n, arr[i + 1][k]));
              }
              for (var _k = 0; _k < N; _k++) {
                arr[_k][i + 1] = addScalar2(arr[_k][i + 1], multiplyScalar2(n, arr[_k][_j3]));
              }
              if (findVectors) {
                for (var _k2 = 0; _k2 < N; _k2++) {
                  R[_j3][_k2] = subtract(R[_j3][_k2], multiplyScalar2(n, R[i + 1][_k2]));
                }
              }
            }
          }
          return R;
        }
        function iterateUntilTriangular(A, N, prec, type, findVectors) {
          var big = type === "BigNumber";
          var cplx = type === "Complex";
          var one = big ? bignumber(1) : cplx ? complex2(1) : 1;
          if (big) {
            prec = bignumber(prec);
          }
          var arr = (0, _object.clone)(A);
          var lambdas = [];
          var n = N;
          var Sdiag = [];
          var Qtotal = findVectors ? diag(Array(N).fill(one)) : void 0;
          var Qpartial = findVectors ? diag(Array(n).fill(one)) : void 0;
          var lastConvergenceBefore = 0;
          while (lastConvergenceBefore <= 100) {
            lastConvergenceBefore += 1;
            var k = arr[n - 1][n - 1];
            for (var i = 0; i < n; i++) {
              arr[i][i] = subtract(arr[i][i], k);
            }
            var _qr = qr(arr), Q = _qr.Q, R = _qr.R;
            arr = multiply2(R, Q);
            for (var _i = 0; _i < n; _i++) {
              arr[_i][_i] = addScalar2(arr[_i][_i], k);
            }
            if (findVectors) {
              Qpartial = multiply2(Qpartial, Q);
            }
            if (n === 1 || smaller(abs2(arr[n - 1][n - 2]), prec)) {
              lastConvergenceBefore = 0;
              lambdas.push(arr[n - 1][n - 1]);
              if (findVectors) {
                Sdiag.unshift([[1]]);
                inflateMatrix(Qpartial, N);
                Qtotal = multiply2(Qtotal, Qpartial);
                if (n > 1) {
                  Qpartial = diag(Array(n - 1).fill(one));
                }
              }
              n -= 1;
              arr.pop();
              for (var _i2 = 0; _i2 < n; _i2++) {
                arr[_i2].pop();
              }
            } else if (n === 2 || smaller(abs2(arr[n - 2][n - 3]), prec)) {
              lastConvergenceBefore = 0;
              var ll = eigenvalues2x2(arr[n - 2][n - 2], arr[n - 2][n - 1], arr[n - 1][n - 2], arr[n - 1][n - 1]);
              lambdas.push.apply(lambdas, (0, _toConsumableArray2["default"])(ll));
              if (findVectors) {
                Sdiag.unshift(jordanBase2x2(arr[n - 2][n - 2], arr[n - 2][n - 1], arr[n - 1][n - 2], arr[n - 1][n - 1], ll[0], ll[1], prec, type));
                inflateMatrix(Qpartial, N);
                Qtotal = multiply2(Qtotal, Qpartial);
                if (n > 2) {
                  Qpartial = diag(Array(n - 2).fill(one));
                }
              }
              n -= 2;
              arr.pop();
              arr.pop();
              for (var _i3 = 0; _i3 < n; _i3++) {
                arr[_i3].pop();
                arr[_i3].pop();
              }
            }
            if (n === 0) {
              break;
            }
          }
          lambdas.sort(function(a, b) {
            return +subtract(abs2(a), abs2(b));
          });
          if (lastConvergenceBefore > 100) {
            var err = Error("The eigenvalues failed to converge. Only found these eigenvalues: " + lambdas.join(", "));
            err.values = lambdas;
            err.vectors = [];
            throw err;
          }
          var C = findVectors ? multiply2(Qtotal, blockDiag(Sdiag, N)) : void 0;
          return {
            values: lambdas,
            C
          };
        }
        function findEigenvectors(A, N, C, R, values, prec, type) {
          var Cinv = inv(C);
          var U = multiply2(Cinv, A, C);
          var big = type === "BigNumber";
          var cplx = type === "Complex";
          var zero = big ? bignumber(0) : cplx ? complex2(0) : 0;
          var one = big ? bignumber(1) : cplx ? complex2(1) : 1;
          var uniqueValues = [];
          var multiplicities = [];
          var _iterator = _createForOfIteratorHelper(values), _step;
          try {
            for (_iterator.s(); !(_step = _iterator.n()).done; ) {
              var lambda = _step.value;
              var _i4 = indexOf(uniqueValues, lambda, equal);
              if (_i4 === -1) {
                uniqueValues.push(lambda);
                multiplicities.push(1);
              } else {
                multiplicities[_i4] += 1;
              }
            }
          } catch (err) {
            _iterator.e(err);
          } finally {
            _iterator.f();
          }
          var vectors = [];
          var len = uniqueValues.length;
          var b = Array(N).fill(zero);
          var E = diag(Array(N).fill(one));
          var _loop = function _loop2() {
            var lambda2 = uniqueValues[i];
            var S = subtract(U, multiply2(lambda2, E));
            var solutions = usolveAll(S, b);
            solutions.shift();
            while (solutions.length < multiplicities[i]) {
              var approxVec = inverseIterate(S, N, solutions, prec, type);
              if (approxVec === null) {
                break;
              }
              solutions.push(approxVec);
            }
            var correction = multiply2(inv(R), C);
            solutions = solutions.map(function(v) {
              return multiply2(correction, v);
            });
            vectors.push.apply(vectors, (0, _toConsumableArray2["default"])(solutions.map(function(v) {
              return {
                value: lambda2,
                vector: flatten2(v)
              };
            })));
          };
          for (var i = 0; i < len; i++) {
            _loop();
          }
          return vectors;
        }
        function eigenvalues2x2(a, b, c, d) {
          var trA = addScalar2(a, d);
          var detA = subtract(multiplyScalar2(a, d), multiplyScalar2(b, c));
          var x = multiplyScalar2(trA, 0.5);
          var y = multiplyScalar2(sqrt2(subtract(multiplyScalar2(trA, trA), multiplyScalar2(4, detA))), 0.5);
          return [addScalar2(x, y), subtract(x, y)];
        }
        function jordanBase2x2(a, b, c, d, l1, l2, prec, type) {
          var big = type === "BigNumber";
          var cplx = type === "Complex";
          var zero = big ? bignumber(0) : cplx ? complex2(0) : 0;
          var one = big ? bignumber(1) : cplx ? complex2(1) : 1;
          if (smaller(abs2(c), prec)) {
            return [[one, zero], [zero, one]];
          }
          if (larger(abs2(subtract(l1, l2)), prec)) {
            return [[subtract(l1, d), subtract(l2, d)], [c, c]];
          }
          var na = subtract(a, l1);
          var nd = subtract(d, l1);
          if (smaller(abs2(b), prec) && smaller(abs2(nd), prec)) {
            return [[na, one], [c, zero]];
          } else {
            return [[b, zero], [nd, one]];
          }
        }
        function inflateMatrix(arr, N) {
          for (var i = 0; i < arr.length; i++) {
            var _arr$i;
            (_arr$i = arr[i]).push.apply(_arr$i, (0, _toConsumableArray2["default"])(Array(N - arr[i].length).fill(0)));
          }
          for (var _i5 = arr.length; _i5 < N; _i5++) {
            arr.push(Array(N).fill(0));
            arr[_i5][_i5] = 1;
          }
          return arr;
        }
        function blockDiag(arr, N) {
          var M = [];
          for (var i = 0; i < N; i++) {
            M[i] = Array(N).fill(0);
          }
          var I = 0;
          var _iterator2 = _createForOfIteratorHelper(arr), _step2;
          try {
            for (_iterator2.s(); !(_step2 = _iterator2.n()).done; ) {
              var sub2 = _step2.value;
              var n = sub2.length;
              for (var _i6 = 0; _i6 < n; _i6++) {
                for (var j = 0; j < n; j++) {
                  M[I + _i6][I + j] = sub2[_i6][j];
                }
              }
              I += n;
            }
          } catch (err) {
            _iterator2.e(err);
          } finally {
            _iterator2.f();
          }
          return M;
        }
        function indexOf(arr, el, fn) {
          for (var i = 0; i < arr.length; i++) {
            if (fn(arr[i], el)) {
              return i;
            }
          }
          return -1;
        }
        function inverseIterate(A, N, orthog, prec, type) {
          var largeNum = type === "BigNumber" ? bignumber(1e3) : 1e3;
          var b;
          var i = 0;
          for (; i < 5; ++i) {
            b = randomOrthogonalVector(N, orthog, type);
            try {
              b = usolve(A, b);
            } catch (_unused) {
              continue;
            }
            if (larger(norm(b), largeNum)) {
              break;
            }
          }
          if (i >= 5) {
            return null;
          }
          i = 0;
          while (true) {
            var c = usolve(A, b);
            if (smaller(norm(orthogonalComplement(b, [c])), prec)) {
              break;
            }
            if (++i >= 10) {
              return null;
            }
            b = normalize(c);
          }
          return b;
        }
        function randomOrthogonalVector(N, orthog, type) {
          var big = type === "BigNumber";
          var cplx = type === "Complex";
          var v = Array(N).fill(0).map(function(_) {
            return 2 * Math.random() - 1;
          });
          if (big) {
            v = v.map(function(n) {
              return bignumber(n);
            });
          }
          if (cplx) {
            v = v.map(function(n) {
              return complex2(n);
            });
          }
          v = orthogonalComplement(v, orthog);
          return normalize(v, type);
        }
        function orthogonalComplement(v, orthog) {
          var vectorShape = size2(v);
          var _iterator3 = _createForOfIteratorHelper(orthog), _step3;
          try {
            for (_iterator3.s(); !(_step3 = _iterator3.n()).done; ) {
              var w = _step3.value;
              w = reshape2(w, vectorShape);
              v = subtract(v, multiply2(divideScalar(dot2(w, v), dot2(w, w)), w));
            }
          } catch (err) {
            _iterator3.e(err);
          } finally {
            _iterator3.f();
          }
          return v;
        }
        function norm(v) {
          return abs2(sqrt2(dot2(v, v)));
        }
        function normalize(v, type) {
          var big = type === "BigNumber";
          var cplx = type === "Complex";
          var one = big ? bignumber(1) : cplx ? complex2(1) : 1;
          return multiply2(divideScalar(one, norm(v)), v);
        }
        return complexEigs;
      }
    }
  });

  // node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/function/matrix/eigs/realSymmetric.js
  var require_realSymmetric = __commonJS({
    "node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/function/matrix/eigs/realSymmetric.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.createRealSymmetric = createRealSymmetric;
      var _object = require_object();
      function createRealSymmetric(_ref) {
        var config4 = _ref.config, addScalar2 = _ref.addScalar, subtract = _ref.subtract, abs2 = _ref.abs, atan3 = _ref.atan, cos2 = _ref.cos, sin2 = _ref.sin, multiplyScalar2 = _ref.multiplyScalar, inv = _ref.inv, bignumber = _ref.bignumber, multiply2 = _ref.multiply, add2 = _ref.add;
        function main(arr, N) {
          var prec = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : config4.epsilon;
          var type = arguments.length > 3 ? arguments[3] : void 0;
          var computeVectors = arguments.length > 4 ? arguments[4] : void 0;
          if (type === "number") {
            return diag(arr, prec, computeVectors);
          }
          if (type === "BigNumber") {
            return diagBig(arr, prec, computeVectors);
          }
          throw TypeError("Unsupported data type: " + type);
        }
        function diag(x, precision, computeVectors) {
          var N = x.length;
          var e0 = Math.abs(precision / N);
          var psi;
          var Sij;
          if (computeVectors) {
            Sij = new Array(N);
            for (var i = 0; i < N; i++) {
              Sij[i] = Array(N).fill(0);
              Sij[i][i] = 1;
            }
          }
          var Vab = getAij(x);
          while (Math.abs(Vab[1]) >= Math.abs(e0)) {
            var _i = Vab[0][0];
            var j = Vab[0][1];
            psi = getTheta(x[_i][_i], x[j][j], x[_i][j]);
            x = x1(x, psi, _i, j);
            if (computeVectors) Sij = Sij1(Sij, psi, _i, j);
            Vab = getAij(x);
          }
          var Ei = Array(N).fill(0);
          for (var _i2 = 0; _i2 < N; _i2++) {
            Ei[_i2] = x[_i2][_i2];
          }
          return sorting((0, _object.clone)(Ei), Sij, computeVectors);
        }
        function diagBig(x, precision, computeVectors) {
          var N = x.length;
          var e0 = abs2(precision / N);
          var psi;
          var Sij;
          if (computeVectors) {
            Sij = new Array(N);
            for (var i = 0; i < N; i++) {
              Sij[i] = Array(N).fill(0);
              Sij[i][i] = 1;
            }
          }
          var Vab = getAijBig(x);
          while (abs2(Vab[1]) >= abs2(e0)) {
            var _i3 = Vab[0][0];
            var j = Vab[0][1];
            psi = getThetaBig(x[_i3][_i3], x[j][j], x[_i3][j]);
            x = x1Big(x, psi, _i3, j);
            if (computeVectors) Sij = Sij1Big(Sij, psi, _i3, j);
            Vab = getAijBig(x);
          }
          var Ei = Array(N).fill(0);
          for (var _i4 = 0; _i4 < N; _i4++) {
            Ei[_i4] = x[_i4][_i4];
          }
          return sorting((0, _object.clone)(Ei), Sij, computeVectors);
        }
        function getTheta(aii, ajj, aij) {
          var denom = ajj - aii;
          if (Math.abs(denom) <= config4.epsilon) {
            return Math.PI / 4;
          } else {
            return 0.5 * Math.atan(2 * aij / (ajj - aii));
          }
        }
        function getThetaBig(aii, ajj, aij) {
          var denom = subtract(ajj, aii);
          if (abs2(denom) <= config4.epsilon) {
            return bignumber(-1).acos().div(4);
          } else {
            return multiplyScalar2(0.5, atan3(multiply2(2, aij, inv(denom))));
          }
        }
        function Sij1(Sij, theta, i, j) {
          var N = Sij.length;
          var c = Math.cos(theta);
          var s = Math.sin(theta);
          var Ski = Array(N).fill(0);
          var Skj = Array(N).fill(0);
          for (var k = 0; k < N; k++) {
            Ski[k] = c * Sij[k][i] - s * Sij[k][j];
            Skj[k] = s * Sij[k][i] + c * Sij[k][j];
          }
          for (var _k = 0; _k < N; _k++) {
            Sij[_k][i] = Ski[_k];
            Sij[_k][j] = Skj[_k];
          }
          return Sij;
        }
        function Sij1Big(Sij, theta, i, j) {
          var N = Sij.length;
          var c = cos2(theta);
          var s = sin2(theta);
          var Ski = Array(N).fill(bignumber(0));
          var Skj = Array(N).fill(bignumber(0));
          for (var k = 0; k < N; k++) {
            Ski[k] = subtract(multiplyScalar2(c, Sij[k][i]), multiplyScalar2(s, Sij[k][j]));
            Skj[k] = addScalar2(multiplyScalar2(s, Sij[k][i]), multiplyScalar2(c, Sij[k][j]));
          }
          for (var _k2 = 0; _k2 < N; _k2++) {
            Sij[_k2][i] = Ski[_k2];
            Sij[_k2][j] = Skj[_k2];
          }
          return Sij;
        }
        function x1Big(Hij, theta, i, j) {
          var N = Hij.length;
          var c = bignumber(cos2(theta));
          var s = bignumber(sin2(theta));
          var c2 = multiplyScalar2(c, c);
          var s2 = multiplyScalar2(s, s);
          var Aki = Array(N).fill(bignumber(0));
          var Akj = Array(N).fill(bignumber(0));
          var csHij = multiply2(bignumber(2), c, s, Hij[i][j]);
          var Aii = addScalar2(subtract(multiplyScalar2(c2, Hij[i][i]), csHij), multiplyScalar2(s2, Hij[j][j]));
          var Ajj = add2(multiplyScalar2(s2, Hij[i][i]), csHij, multiplyScalar2(c2, Hij[j][j]));
          for (var k = 0; k < N; k++) {
            Aki[k] = subtract(multiplyScalar2(c, Hij[i][k]), multiplyScalar2(s, Hij[j][k]));
            Akj[k] = addScalar2(multiplyScalar2(s, Hij[i][k]), multiplyScalar2(c, Hij[j][k]));
          }
          Hij[i][i] = Aii;
          Hij[j][j] = Ajj;
          Hij[i][j] = bignumber(0);
          Hij[j][i] = bignumber(0);
          for (var _k3 = 0; _k3 < N; _k3++) {
            if (_k3 !== i && _k3 !== j) {
              Hij[i][_k3] = Aki[_k3];
              Hij[_k3][i] = Aki[_k3];
              Hij[j][_k3] = Akj[_k3];
              Hij[_k3][j] = Akj[_k3];
            }
          }
          return Hij;
        }
        function x1(Hij, theta, i, j) {
          var N = Hij.length;
          var c = Math.cos(theta);
          var s = Math.sin(theta);
          var c2 = c * c;
          var s2 = s * s;
          var Aki = Array(N).fill(0);
          var Akj = Array(N).fill(0);
          var Aii = c2 * Hij[i][i] - 2 * c * s * Hij[i][j] + s2 * Hij[j][j];
          var Ajj = s2 * Hij[i][i] + 2 * c * s * Hij[i][j] + c2 * Hij[j][j];
          for (var k = 0; k < N; k++) {
            Aki[k] = c * Hij[i][k] - s * Hij[j][k];
            Akj[k] = s * Hij[i][k] + c * Hij[j][k];
          }
          Hij[i][i] = Aii;
          Hij[j][j] = Ajj;
          Hij[i][j] = 0;
          Hij[j][i] = 0;
          for (var _k4 = 0; _k4 < N; _k4++) {
            if (_k4 !== i && _k4 !== j) {
              Hij[i][_k4] = Aki[_k4];
              Hij[_k4][i] = Aki[_k4];
              Hij[j][_k4] = Akj[_k4];
              Hij[_k4][j] = Akj[_k4];
            }
          }
          return Hij;
        }
        function getAij(Mij) {
          var N = Mij.length;
          var maxMij = 0;
          var maxIJ = [0, 1];
          for (var i = 0; i < N; i++) {
            for (var j = i + 1; j < N; j++) {
              if (Math.abs(maxMij) < Math.abs(Mij[i][j])) {
                maxMij = Math.abs(Mij[i][j]);
                maxIJ = [i, j];
              }
            }
          }
          return [maxIJ, maxMij];
        }
        function getAijBig(Mij) {
          var N = Mij.length;
          var maxMij = 0;
          var maxIJ = [0, 1];
          for (var i = 0; i < N; i++) {
            for (var j = i + 1; j < N; j++) {
              if (abs2(maxMij) < abs2(Mij[i][j])) {
                maxMij = abs2(Mij[i][j]);
                maxIJ = [i, j];
              }
            }
          }
          return [maxIJ, maxMij];
        }
        function sorting(E, S, computeVectors) {
          var N = E.length;
          var values = Array(N);
          var vecs;
          if (computeVectors) {
            vecs = Array(N);
            for (var k = 0; k < N; k++) {
              vecs[k] = Array(N);
            }
          }
          for (var i = 0; i < N; i++) {
            var minID = 0;
            var minE = E[0];
            for (var j = 0; j < E.length; j++) {
              if (abs2(E[j]) < abs2(minE)) {
                minID = j;
                minE = E[minID];
              }
            }
            values[i] = E.splice(minID, 1)[0];
            if (computeVectors) {
              for (var _k5 = 0; _k5 < N; _k5++) {
                vecs[i][_k5] = S[_k5][minID];
                S[_k5].splice(minID, 1);
              }
            }
          }
          if (!computeVectors) return {
            values
          };
          var eigenvectors = vecs.map(function(vector, i2) {
            return {
              value: values[i2],
              vector
            };
          });
          return {
            values,
            eigenvectors
          };
        }
        return main;
      }
    }
  });

  // node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/function/matrix/eigs.js
  var require_eigs2 = __commonJS({
    "node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/function/matrix/eigs.js"(exports) {
      "use strict";
      var _interopRequireDefault = require_interopRequireDefault();
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.createEigs = void 0;
      var _extends2 = _interopRequireDefault(require_extends());
      var _factory = require_factory();
      var _string = require_string();
      var _complexEigs = require_complexEigs();
      var _realSymmetric = require_realSymmetric();
      var _is = require_is();
      var name18 = "eigs";
      var dependencies19 = ["config", "typed", "matrix", "addScalar", "equal", "subtract", "abs", "atan", "cos", "sin", "multiplyScalar", "divideScalar", "inv", "bignumber", "multiply", "add", "larger", "column", "flatten", "number", "complex", "sqrt", "diag", "size", "reshape", "qr", "usolve", "usolveAll", "im", "re", "smaller", "matrixFromColumns", "dot"];
      var createEigs2 = exports.createEigs = /* @__PURE__ */ (0, _factory.factory)(name18, dependencies19, function(_ref) {
        var config4 = _ref.config, typed2 = _ref.typed, matrix2 = _ref.matrix, addScalar2 = _ref.addScalar, subtract = _ref.subtract, equal = _ref.equal, abs2 = _ref.abs, atan3 = _ref.atan, cos2 = _ref.cos, sin2 = _ref.sin, multiplyScalar2 = _ref.multiplyScalar, divideScalar = _ref.divideScalar, inv = _ref.inv, bignumber = _ref.bignumber, multiply2 = _ref.multiply, add2 = _ref.add, larger = _ref.larger, column = _ref.column, flatten2 = _ref.flatten, number = _ref.number, complex2 = _ref.complex, sqrt2 = _ref.sqrt, diag = _ref.diag, size2 = _ref.size, reshape2 = _ref.reshape, qr = _ref.qr, usolve = _ref.usolve, usolveAll = _ref.usolveAll, im = _ref.im, re = _ref.re, smaller = _ref.smaller, matrixFromColumns = _ref.matrixFromColumns, dot2 = _ref.dot;
        var doRealSymmetric = (0, _realSymmetric.createRealSymmetric)({
          config: config4,
          addScalar: addScalar2,
          subtract,
          column,
          flatten: flatten2,
          equal,
          abs: abs2,
          atan: atan3,
          cos: cos2,
          sin: sin2,
          multiplyScalar: multiplyScalar2,
          inv,
          bignumber,
          complex: complex2,
          multiply: multiply2,
          add: add2
        });
        var doComplexEigs = (0, _complexEigs.createComplexEigs)({
          config: config4,
          addScalar: addScalar2,
          subtract,
          multiply: multiply2,
          multiplyScalar: multiplyScalar2,
          flatten: flatten2,
          divideScalar,
          sqrt: sqrt2,
          abs: abs2,
          bignumber,
          diag,
          size: size2,
          reshape: reshape2,
          qr,
          inv,
          usolve,
          usolveAll,
          equal,
          complex: complex2,
          larger,
          smaller,
          matrixFromColumns,
          dot: dot2
        });
        return typed2("eigs", {
          // The conversion to matrix in the first two implementations,
          // just to convert back to an array right away in
          // computeValuesAndVectors, is unfortunate, and should perhaps be
          // streamlined. It is done because the Matrix object carries some
          // type information about its entries, and so constructing the matrix
          // is a roundabout way of doing type detection.
          Array: function Array2(x) {
            return doEigs(matrix2(x));
          },
          "Array, number|BigNumber": function ArrayNumberBigNumber(x, prec) {
            return doEigs(matrix2(x), {
              precision: prec
            });
          },
          "Array, Object": function ArrayObject(x, opts) {
            return doEigs(matrix2(x), opts);
          },
          Matrix: function Matrix2(mat) {
            return doEigs(mat, {
              matricize: true
            });
          },
          "Matrix, number|BigNumber": function MatrixNumberBigNumber(mat, prec) {
            return doEigs(mat, {
              precision: prec,
              matricize: true
            });
          },
          "Matrix, Object": function MatrixObject(mat, opts) {
            var useOpts = {
              matricize: true
            };
            (0, _extends2["default"])(useOpts, opts);
            return doEigs(mat, useOpts);
          }
        });
        function doEigs(mat) {
          var _opts$precision;
          var opts = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
          var computeVectors = "eigenvectors" in opts ? opts.eigenvectors : true;
          var prec = (_opts$precision = opts.precision) !== null && _opts$precision !== void 0 ? _opts$precision : config4.epsilon;
          var result = computeValuesAndVectors(mat, prec, computeVectors);
          if (opts.matricize) {
            result.values = matrix2(result.values);
            if (computeVectors) {
              result.eigenvectors = result.eigenvectors.map(function(_ref2) {
                var value = _ref2.value, vector = _ref2.vector;
                return {
                  value,
                  vector: matrix2(vector)
                };
              });
            }
          }
          if (computeVectors) {
            Object.defineProperty(result, "vectors", {
              enumerable: false,
              // to make sure that the eigenvectors can still be
              // converted to string.
              get: function get() {
                throw new Error("eigs(M).vectors replaced with eigs(M).eigenvectors");
              }
            });
          }
          return result;
        }
        function computeValuesAndVectors(mat, prec, computeVectors) {
          var arr = mat.toArray();
          var asize = mat.size();
          if (asize.length !== 2 || asize[0] !== asize[1]) {
            throw new RangeError("Matrix must be square (size: ".concat((0, _string.format)(asize), ")"));
          }
          var N = asize[0];
          if (isReal(arr, N, prec)) {
            coerceReal(arr, N);
            if (isSymmetric(arr, N, prec)) {
              var _type = coerceTypes(mat, arr, N);
              return doRealSymmetric(arr, N, prec, _type, computeVectors);
            }
          }
          var type = coerceTypes(mat, arr, N);
          return doComplexEigs(arr, N, prec, type, computeVectors);
        }
        function isSymmetric(arr, N, prec) {
          for (var i = 0; i < N; i++) {
            for (var j = i; j < N; j++) {
              if (larger(bignumber(abs2(subtract(arr[i][j], arr[j][i]))), prec)) {
                return false;
              }
            }
          }
          return true;
        }
        function isReal(arr, N, prec) {
          for (var i = 0; i < N; i++) {
            for (var j = 0; j < N; j++) {
              if (larger(bignumber(abs2(im(arr[i][j]))), prec)) {
                return false;
              }
            }
          }
          return true;
        }
        function coerceReal(arr, N) {
          for (var i = 0; i < N; i++) {
            for (var j = 0; j < N; j++) {
              arr[i][j] = re(arr[i][j]);
            }
          }
        }
        function coerceTypes(mat, arr, N) {
          var type = mat.datatype();
          if (type === "number" || type === "BigNumber" || type === "Complex") {
            return type;
          }
          var hasNumber = false;
          var hasBig = false;
          var hasComplex = false;
          for (var i = 0; i < N; i++) {
            for (var j = 0; j < N; j++) {
              var el = arr[i][j];
              if ((0, _is.isNumber)(el) || (0, _is.isFraction)(el)) {
                hasNumber = true;
              } else if ((0, _is.isBigNumber)(el)) {
                hasBig = true;
              } else if ((0, _is.isComplex)(el)) {
                hasComplex = true;
              } else {
                throw TypeError("Unsupported type in Matrix: " + (0, _is.typeOf)(el));
              }
            }
          }
          if (hasBig && hasComplex) {
            console.warn("Complex BigNumbers not supported, this operation will lose precission.");
          }
          if (hasComplex) {
            for (var _i = 0; _i < N; _i++) {
              for (var _j = 0; _j < N; _j++) {
                arr[_i][_j] = complex2(arr[_i][_j]);
              }
            }
            return "Complex";
          }
          if (hasBig) {
            for (var _i2 = 0; _i2 < N; _i2++) {
              for (var _j2 = 0; _j2 < N; _j2++) {
                arr[_i2][_j2] = bignumber(arr[_i2][_j2]);
              }
            }
            return "BigNumber";
          }
          if (hasNumber) {
            for (var _i3 = 0; _i3 < N; _i3++) {
              for (var _j3 = 0; _j3 < N; _j3++) {
                arr[_i3][_j3] = number(arr[_i3][_j3]);
              }
            }
            return "number";
          } else {
            throw TypeError("Matrix contains unsupported types only.");
          }
        }
      });
    }
  });

  // node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/function/matrix/expm.js
  var require_expm2 = __commonJS({
    "node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/function/matrix/expm.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.createExpm = void 0;
      var _is = require_is();
      var _string = require_string();
      var _factory = require_factory();
      var name18 = "expm";
      var dependencies19 = ["typed", "abs", "add", "identity", "inv", "multiply"];
      var createExpm2 = exports.createExpm = /* @__PURE__ */ (0, _factory.factory)(name18, dependencies19, function(_ref) {
        var typed2 = _ref.typed, abs2 = _ref.abs, add2 = _ref.add, identity = _ref.identity, inv = _ref.inv, multiply2 = _ref.multiply;
        return typed2(name18, {
          Matrix: function Matrix2(A) {
            var size2 = A.size();
            if (size2.length !== 2 || size2[0] !== size2[1]) {
              throw new RangeError("Matrix must be square (size: " + (0, _string.format)(size2) + ")");
            }
            var n = size2[0];
            var eps = 1e-15;
            var infNorm = infinityNorm(A);
            var params = findParams(infNorm, eps);
            var q = params.q;
            var j = params.j;
            var Apos = multiply2(A, Math.pow(2, -j));
            var N = identity(n);
            var D = identity(n);
            var factor = 1;
            var AposToI = Apos;
            var alternate = -1;
            for (var i = 1; i <= q; i++) {
              if (i > 1) {
                AposToI = multiply2(AposToI, Apos);
                alternate = -alternate;
              }
              factor = factor * (q - i + 1) / ((2 * q - i + 1) * i);
              N = add2(N, multiply2(factor, AposToI));
              D = add2(D, multiply2(factor * alternate, AposToI));
            }
            var R = multiply2(inv(D), N);
            for (var _i = 0; _i < j; _i++) {
              R = multiply2(R, R);
            }
            return (0, _is.isSparseMatrix)(A) ? A.createSparseMatrix(R) : R;
          }
        });
        function infinityNorm(A) {
          var n = A.size()[0];
          var infNorm = 0;
          for (var i = 0; i < n; i++) {
            var rowSum = 0;
            for (var j = 0; j < n; j++) {
              rowSum += abs2(A.get([i, j]));
            }
            infNorm = Math.max(rowSum, infNorm);
          }
          return infNorm;
        }
        function findParams(infNorm, eps) {
          var maxSearchSize = 30;
          for (var k = 0; k < maxSearchSize; k++) {
            for (var q = 0; q <= k; q++) {
              var j = k - q;
              if (errorEstimate(infNorm, q, j) < eps) {
                return {
                  q,
                  j
                };
              }
            }
          }
          throw new Error("Could not find acceptable parameters to compute the matrix exponential (try increasing maxSearchSize in expm.js)");
        }
        function errorEstimate(infNorm, q, j) {
          var qfac = 1;
          for (var i = 2; i <= q; i++) {
            qfac *= i;
          }
          var twoqfac = qfac;
          for (var _i2 = q + 1; _i2 <= 2 * q; _i2++) {
            twoqfac *= _i2;
          }
          var twoqp1fac = twoqfac * (2 * q + 1);
          return 8 * Math.pow(infNorm / Math.pow(2, j), 2 * q) * qfac * qfac / (twoqfac * twoqp1fac);
        }
      });
    }
  });

  // node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/function/matrix/sqrtm.js
  var require_sqrtm2 = __commonJS({
    "node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/function/matrix/sqrtm.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.createSqrtm = void 0;
      var _is = require_is();
      var _string = require_string();
      var _array = require_array();
      var _factory = require_factory();
      var name18 = "sqrtm";
      var dependencies19 = ["typed", "abs", "add", "multiply", "map", "sqrt", "subtract", "inv", "size", "max", "identity"];
      var createSqrtm2 = exports.createSqrtm = /* @__PURE__ */ (0, _factory.factory)(name18, dependencies19, function(_ref) {
        var typed2 = _ref.typed, abs2 = _ref.abs, add2 = _ref.add, multiply2 = _ref.multiply, map = _ref.map, sqrt2 = _ref.sqrt, subtract = _ref.subtract, inv = _ref.inv, size2 = _ref.size, max2 = _ref.max, identity = _ref.identity;
        var _maxIterations = 1e3;
        var _tolerance = 1e-6;
        function _denmanBeavers(A) {
          var error;
          var iterations = 0;
          var Y = A;
          var Z = identity(size2(A));
          do {
            var Yk = Y;
            Y = multiply2(0.5, add2(Yk, inv(Z)));
            Z = multiply2(0.5, add2(Z, inv(Yk)));
            error = max2(abs2(subtract(Y, Yk)));
            if (error > _tolerance && ++iterations > _maxIterations) {
              throw new Error("computing square root of matrix: iterative method could not converge");
            }
          } while (error > _tolerance);
          return Y;
        }
        return typed2(name18, {
          "Array | Matrix": function ArrayMatrix(A) {
            var size3 = (0, _is.isMatrix)(A) ? A.size() : (0, _array.arraySize)(A);
            switch (size3.length) {
              case 1:
                if (size3[0] === 1) {
                  return map(A, sqrt2);
                } else {
                  throw new RangeError("Matrix must be square (size: " + (0, _string.format)(size3) + ")");
                }
              case 2: {
                var rows = size3[0];
                var cols = size3[1];
                if (rows === cols) {
                  return _denmanBeavers(A);
                } else {
                  throw new RangeError("Matrix must be square (size: " + (0, _string.format)(size3) + ")");
                }
              }
              default:
                throw new RangeError("Matrix must be at most two dimensional (size: " + (0, _string.format)(size3) + ")");
            }
          }
        });
      });
    }
  });

  // node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/function/algebra/sylvester.js
  var require_sylvester2 = __commonJS({
    "node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/function/algebra/sylvester.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.createSylvester = void 0;
      var _factory = require_factory();
      var name18 = "sylvester";
      var dependencies19 = ["typed", "schur", "matrixFromColumns", "matrix", "multiply", "range", "concat", "transpose", "index", "subset", "add", "subtract", "identity", "lusolve", "abs"];
      var createSylvester2 = exports.createSylvester = /* @__PURE__ */ (0, _factory.factory)(name18, dependencies19, function(_ref) {
        var typed2 = _ref.typed, schur = _ref.schur, matrixFromColumns = _ref.matrixFromColumns, matrix2 = _ref.matrix, multiply2 = _ref.multiply, range = _ref.range, concat2 = _ref.concat, transpose = _ref.transpose, index = _ref.index, subset = _ref.subset, add2 = _ref.add, subtract = _ref.subtract, identity = _ref.identity, lusolve = _ref.lusolve, abs2 = _ref.abs;
        return typed2(name18, {
          "Matrix, Matrix, Matrix": _sylvester,
          "Array, Matrix, Matrix": function ArrayMatrixMatrix(A, B, C) {
            return _sylvester(matrix2(A), B, C);
          },
          "Array, Array, Matrix": function ArrayArrayMatrix(A, B, C) {
            return _sylvester(matrix2(A), matrix2(B), C);
          },
          "Array, Matrix, Array": function ArrayMatrixArray(A, B, C) {
            return _sylvester(matrix2(A), B, matrix2(C));
          },
          "Matrix, Array, Matrix": function MatrixArrayMatrix(A, B, C) {
            return _sylvester(A, matrix2(B), C);
          },
          "Matrix, Array, Array": function MatrixArrayArray(A, B, C) {
            return _sylvester(A, matrix2(B), matrix2(C));
          },
          "Matrix, Matrix, Array": function MatrixMatrixArray(A, B, C) {
            return _sylvester(A, B, matrix2(C));
          },
          "Array, Array, Array": function ArrayArrayArray(A, B, C) {
            return _sylvester(matrix2(A), matrix2(B), matrix2(C)).toArray();
          }
        });
        function _sylvester(A, B, C) {
          var n = B.size()[0];
          var m = A.size()[0];
          var sA = schur(A);
          var F = sA.T;
          var U = sA.U;
          var sB = schur(multiply2(-1, B));
          var G = sB.T;
          var V = sB.U;
          var D = multiply2(multiply2(transpose(U), C), V);
          var all = range(0, m);
          var y = [];
          var hc = function hc2(a, b) {
            return concat2(a, b, 1);
          };
          var vc = function vc2(a, b) {
            return concat2(a, b, 0);
          };
          for (var k = 0; k < n; k++) {
            if (k < n - 1 && abs2(subset(G, index(k + 1, k))) > 1e-5) {
              var RHS = vc(subset(D, index(all, k)), subset(D, index(all, k + 1)));
              for (var j = 0; j < k; j++) {
                RHS = add2(RHS, vc(multiply2(y[j], subset(G, index(j, k))), multiply2(y[j], subset(G, index(j, k + 1)))));
              }
              var gkk = multiply2(identity(m), multiply2(-1, subset(G, index(k, k))));
              var gmk = multiply2(identity(m), multiply2(-1, subset(G, index(k + 1, k))));
              var gkm = multiply2(identity(m), multiply2(-1, subset(G, index(k, k + 1))));
              var gmm = multiply2(identity(m), multiply2(-1, subset(G, index(k + 1, k + 1))));
              var LHS = vc(hc(add2(F, gkk), gmk), hc(gkm, add2(F, gmm)));
              var yAux = lusolve(LHS, RHS);
              y[k] = yAux.subset(index(range(0, m), 0));
              y[k + 1] = yAux.subset(index(range(m, 2 * m), 0));
              k++;
            } else {
              var _RHS = subset(D, index(all, k));
              for (var _j = 0; _j < k; _j++) {
                _RHS = add2(_RHS, multiply2(y[_j], subset(G, index(_j, k))));
              }
              var _gkk = subset(G, index(k, k));
              var _LHS = subtract(F, multiply2(_gkk, identity(m)));
              y[k] = lusolve(_LHS, _RHS);
            }
          }
          var Y = matrix2(matrixFromColumns.apply(void 0, y));
          var X = multiply2(U, multiply2(Y, transpose(V)));
          return X;
        }
      });
    }
  });

  // node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/function/algebra/decomposition/schur.js
  var require_schur2 = __commonJS({
    "node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/function/algebra/decomposition/schur.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.createSchur = void 0;
      var _factory = require_factory();
      var name18 = "schur";
      var dependencies19 = ["typed", "matrix", "identity", "multiply", "qr", "norm", "subtract"];
      var createSchur2 = exports.createSchur = /* @__PURE__ */ (0, _factory.factory)(name18, dependencies19, function(_ref) {
        var typed2 = _ref.typed, matrix2 = _ref.matrix, identity = _ref.identity, multiply2 = _ref.multiply, qr = _ref.qr, norm = _ref.norm, subtract = _ref.subtract;
        return typed2(name18, {
          Array: function Array2(X) {
            var r = _schur(matrix2(X));
            return {
              U: r.U.valueOf(),
              T: r.T.valueOf()
            };
          },
          Matrix: function Matrix2(X) {
            return _schur(X);
          }
        });
        function _schur(X) {
          var n = X.size()[0];
          var A = X;
          var U = identity(n);
          var k = 0;
          var A0;
          do {
            A0 = A;
            var QR = qr(A);
            var Q = QR.Q;
            var R = QR.R;
            A = multiply2(R, Q);
            U = multiply2(U, Q);
            if (k++ > 100) {
              break;
            }
          } while (norm(subtract(A, A0)) > 1e-4);
          return {
            U,
            T: A
          };
        }
      });
    }
  });

  // node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/function/algebra/lyap.js
  var require_lyap2 = __commonJS({
    "node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/function/algebra/lyap.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.createLyap = void 0;
      var _factory = require_factory();
      var name18 = "lyap";
      var dependencies19 = ["typed", "matrix", "sylvester", "multiply", "transpose"];
      var createLyap2 = exports.createLyap = /* @__PURE__ */ (0, _factory.factory)(name18, dependencies19, function(_ref) {
        var typed2 = _ref.typed, matrix2 = _ref.matrix, sylvester = _ref.sylvester, multiply2 = _ref.multiply, transpose = _ref.transpose;
        return typed2(name18, {
          "Matrix, Matrix": function MatrixMatrix(A, Q) {
            return sylvester(A, transpose(A), multiply2(-1, Q));
          },
          "Array, Matrix": function ArrayMatrix(A, Q) {
            return sylvester(matrix2(A), transpose(matrix2(A)), multiply2(-1, Q));
          },
          "Matrix, Array": function MatrixArray(A, Q) {
            return sylvester(A, transpose(matrix2(A)), matrix2(multiply2(-1, Q)));
          },
          "Array, Array": function ArrayArray(A, Q) {
            return sylvester(matrix2(A), transpose(matrix2(A)), matrix2(multiply2(-1, Q))).toArray();
          }
        });
      });
    }
  });

  // node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/function/arithmetic/divide.js
  var require_divide2 = __commonJS({
    "node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/function/arithmetic/divide.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.createDivide = void 0;
      var _factory = require_factory();
      var _object = require_object();
      var _matAlgo11xS0s = require_matAlgo11xS0s();
      var _matAlgo14xDs = require_matAlgo14xDs();
      var name18 = "divide";
      var dependencies19 = ["typed", "matrix", "multiply", "equalScalar", "divideScalar", "inv"];
      var createDivide2 = exports.createDivide = /* @__PURE__ */ (0, _factory.factory)(name18, dependencies19, function(_ref) {
        var typed2 = _ref.typed, matrix2 = _ref.matrix, multiply2 = _ref.multiply, equalScalar2 = _ref.equalScalar, divideScalar = _ref.divideScalar, inv = _ref.inv;
        var matAlgo11xS0s = (0, _matAlgo11xS0s.createMatAlgo11xS0s)({
          typed: typed2,
          equalScalar: equalScalar2
        });
        var matAlgo14xDs = (0, _matAlgo14xDs.createMatAlgo14xDs)({
          typed: typed2
        });
        return typed2("divide", (0, _object.extend)({
          // we extend the signatures of divideScalar with signatures dealing with matrices
          "Array | Matrix, Array | Matrix": function ArrayMatrixArrayMatrix(x, y) {
            return multiply2(x, inv(y));
          },
          "DenseMatrix, any": function DenseMatrixAny(x, y) {
            return matAlgo14xDs(x, y, divideScalar, false);
          },
          "SparseMatrix, any": function SparseMatrixAny(x, y) {
            return matAlgo11xS0s(x, y, divideScalar, false);
          },
          "Array, any": function ArrayAny(x, y) {
            return matAlgo14xDs(matrix2(x), y, divideScalar, false).valueOf();
          },
          "any, Array | Matrix": function anyArrayMatrix(x, y) {
            return multiply2(x, inv(y));
          }
        }, divideScalar.signatures));
      });
    }
  });

  // node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/function/geometry/distance.js
  var require_distance2 = __commonJS({
    "node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/function/geometry/distance.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.createDistance = void 0;
      var _is = require_is();
      var _factory = require_factory();
      var name18 = "distance";
      var dependencies19 = ["typed", "addScalar", "subtractScalar", "divideScalar", "multiplyScalar", "deepEqual", "sqrt", "abs"];
      var createDistance2 = exports.createDistance = /* @__PURE__ */ (0, _factory.factory)(name18, dependencies19, function(_ref) {
        var typed2 = _ref.typed, addScalar2 = _ref.addScalar, subtractScalar = _ref.subtractScalar, multiplyScalar2 = _ref.multiplyScalar, divideScalar = _ref.divideScalar, deepEqual = _ref.deepEqual, sqrt2 = _ref.sqrt, abs2 = _ref.abs;
        return typed2(name18, {
          "Array, Array, Array": function ArrayArrayArray(x, y, z) {
            if (x.length === 2 && y.length === 2 && z.length === 2) {
              if (!_2d(x)) {
                throw new TypeError("Array with 2 numbers or BigNumbers expected for first argument");
              }
              if (!_2d(y)) {
                throw new TypeError("Array with 2 numbers or BigNumbers expected for second argument");
              }
              if (!_2d(z)) {
                throw new TypeError("Array with 2 numbers or BigNumbers expected for third argument");
              }
              if (deepEqual(y, z)) {
                throw new TypeError("LinePoint1 should not be same with LinePoint2");
              }
              var xCoeff = subtractScalar(z[1], y[1]);
              var yCoeff = subtractScalar(y[0], z[0]);
              var constant = subtractScalar(multiplyScalar2(z[0], y[1]), multiplyScalar2(y[0], z[1]));
              return _distancePointLine2D(x[0], x[1], xCoeff, yCoeff, constant);
            } else {
              throw new TypeError("Invalid Arguments: Try again");
            }
          },
          "Object, Object, Object": function ObjectObjectObject(x, y, z) {
            if (Object.keys(x).length === 2 && Object.keys(y).length === 2 && Object.keys(z).length === 2) {
              if (!_2d(x)) {
                throw new TypeError("Values of pointX and pointY should be numbers or BigNumbers");
              }
              if (!_2d(y)) {
                throw new TypeError("Values of lineOnePtX and lineOnePtY should be numbers or BigNumbers");
              }
              if (!_2d(z)) {
                throw new TypeError("Values of lineTwoPtX and lineTwoPtY should be numbers or BigNumbers");
              }
              if (deepEqual(_objectToArray(y), _objectToArray(z))) {
                throw new TypeError("LinePoint1 should not be same with LinePoint2");
              }
              if ("pointX" in x && "pointY" in x && "lineOnePtX" in y && "lineOnePtY" in y && "lineTwoPtX" in z && "lineTwoPtY" in z) {
                var xCoeff = subtractScalar(z.lineTwoPtY, y.lineOnePtY);
                var yCoeff = subtractScalar(y.lineOnePtX, z.lineTwoPtX);
                var constant = subtractScalar(multiplyScalar2(z.lineTwoPtX, y.lineOnePtY), multiplyScalar2(y.lineOnePtX, z.lineTwoPtY));
                return _distancePointLine2D(x.pointX, x.pointY, xCoeff, yCoeff, constant);
              } else {
                throw new TypeError("Key names do not match");
              }
            } else {
              throw new TypeError("Invalid Arguments: Try again");
            }
          },
          "Array, Array": function ArrayArray(x, y) {
            if (x.length === 2 && y.length === 3) {
              if (!_2d(x)) {
                throw new TypeError("Array with 2 numbers or BigNumbers expected for first argument");
              }
              if (!_3d(y)) {
                throw new TypeError("Array with 3 numbers or BigNumbers expected for second argument");
              }
              return _distancePointLine2D(x[0], x[1], y[0], y[1], y[2]);
            } else if (x.length === 3 && y.length === 6) {
              if (!_3d(x)) {
                throw new TypeError("Array with 3 numbers or BigNumbers expected for first argument");
              }
              if (!_parametricLine(y)) {
                throw new TypeError("Array with 6 numbers or BigNumbers expected for second argument");
              }
              return _distancePointLine3D(x[0], x[1], x[2], y[0], y[1], y[2], y[3], y[4], y[5]);
            } else if (x.length === y.length && x.length > 0) {
              if (!_containsOnlyNumbers(x)) {
                throw new TypeError("All values of an array should be numbers or BigNumbers");
              }
              if (!_containsOnlyNumbers(y)) {
                throw new TypeError("All values of an array should be numbers or BigNumbers");
              }
              return _euclideanDistance(x, y);
            } else {
              throw new TypeError("Invalid Arguments: Try again");
            }
          },
          "Object, Object": function ObjectObject(x, y) {
            if (Object.keys(x).length === 2 && Object.keys(y).length === 3) {
              if (!_2d(x)) {
                throw new TypeError("Values of pointX and pointY should be numbers or BigNumbers");
              }
              if (!_3d(y)) {
                throw new TypeError("Values of xCoeffLine, yCoeffLine and constant should be numbers or BigNumbers");
              }
              if ("pointX" in x && "pointY" in x && "xCoeffLine" in y && "yCoeffLine" in y && "constant" in y) {
                return _distancePointLine2D(x.pointX, x.pointY, y.xCoeffLine, y.yCoeffLine, y.constant);
              } else {
                throw new TypeError("Key names do not match");
              }
            } else if (Object.keys(x).length === 3 && Object.keys(y).length === 6) {
              if (!_3d(x)) {
                throw new TypeError("Values of pointX, pointY and pointZ should be numbers or BigNumbers");
              }
              if (!_parametricLine(y)) {
                throw new TypeError("Values of x0, y0, z0, a, b and c should be numbers or BigNumbers");
              }
              if ("pointX" in x && "pointY" in x && "x0" in y && "y0" in y && "z0" in y && "a" in y && "b" in y && "c" in y) {
                return _distancePointLine3D(x.pointX, x.pointY, x.pointZ, y.x0, y.y0, y.z0, y.a, y.b, y.c);
              } else {
                throw new TypeError("Key names do not match");
              }
            } else if (Object.keys(x).length === 2 && Object.keys(y).length === 2) {
              if (!_2d(x)) {
                throw new TypeError("Values of pointOneX and pointOneY should be numbers or BigNumbers");
              }
              if (!_2d(y)) {
                throw new TypeError("Values of pointTwoX and pointTwoY should be numbers or BigNumbers");
              }
              if ("pointOneX" in x && "pointOneY" in x && "pointTwoX" in y && "pointTwoY" in y) {
                return _euclideanDistance([x.pointOneX, x.pointOneY], [y.pointTwoX, y.pointTwoY]);
              } else {
                throw new TypeError("Key names do not match");
              }
            } else if (Object.keys(x).length === 3 && Object.keys(y).length === 3) {
              if (!_3d(x)) {
                throw new TypeError("Values of pointOneX, pointOneY and pointOneZ should be numbers or BigNumbers");
              }
              if (!_3d(y)) {
                throw new TypeError("Values of pointTwoX, pointTwoY and pointTwoZ should be numbers or BigNumbers");
              }
              if ("pointOneX" in x && "pointOneY" in x && "pointOneZ" in x && "pointTwoX" in y && "pointTwoY" in y && "pointTwoZ" in y) {
                return _euclideanDistance([x.pointOneX, x.pointOneY, x.pointOneZ], [y.pointTwoX, y.pointTwoY, y.pointTwoZ]);
              } else {
                throw new TypeError("Key names do not match");
              }
            } else {
              throw new TypeError("Invalid Arguments: Try again");
            }
          },
          Array: function Array2(arr) {
            if (!_pairwise(arr)) {
              throw new TypeError("Incorrect array format entered for pairwise distance calculation");
            }
            return _distancePairwise(arr);
          }
        });
        function _isNumber(a) {
          return typeof a === "number" || (0, _is.isBigNumber)(a);
        }
        function _2d(a) {
          if (a.constructor !== Array) {
            a = _objectToArray(a);
          }
          return _isNumber(a[0]) && _isNumber(a[1]);
        }
        function _3d(a) {
          if (a.constructor !== Array) {
            a = _objectToArray(a);
          }
          return _isNumber(a[0]) && _isNumber(a[1]) && _isNumber(a[2]);
        }
        function _containsOnlyNumbers(a) {
          if (!Array.isArray(a)) {
            a = _objectToArray(a);
          }
          return a.every(_isNumber);
        }
        function _parametricLine(a) {
          if (a.constructor !== Array) {
            a = _objectToArray(a);
          }
          return _isNumber(a[0]) && _isNumber(a[1]) && _isNumber(a[2]) && _isNumber(a[3]) && _isNumber(a[4]) && _isNumber(a[5]);
        }
        function _objectToArray(o) {
          var keys = Object.keys(o);
          var a = [];
          for (var i = 0; i < keys.length; i++) {
            a.push(o[keys[i]]);
          }
          return a;
        }
        function _pairwise(a) {
          if (a[0].length === 2 && _isNumber(a[0][0]) && _isNumber(a[0][1])) {
            if (a.some(function(aI) {
              return aI.length !== 2 || !_isNumber(aI[0]) || !_isNumber(aI[1]);
            })) {
              return false;
            }
          } else if (a[0].length === 3 && _isNumber(a[0][0]) && _isNumber(a[0][1]) && _isNumber(a[0][2])) {
            if (a.some(function(aI) {
              return aI.length !== 3 || !_isNumber(aI[0]) || !_isNumber(aI[1]) || !_isNumber(aI[2]);
            })) {
              return false;
            }
          } else {
            return false;
          }
          return true;
        }
        function _distancePointLine2D(x, y, a, b, c) {
          var num = abs2(addScalar2(addScalar2(multiplyScalar2(a, x), multiplyScalar2(b, y)), c));
          var den = sqrt2(addScalar2(multiplyScalar2(a, a), multiplyScalar2(b, b)));
          return divideScalar(num, den);
        }
        function _distancePointLine3D(x, y, z, x0, y0, z0, a, b, c) {
          var num = [subtractScalar(multiplyScalar2(subtractScalar(y0, y), c), multiplyScalar2(subtractScalar(z0, z), b)), subtractScalar(multiplyScalar2(subtractScalar(z0, z), a), multiplyScalar2(subtractScalar(x0, x), c)), subtractScalar(multiplyScalar2(subtractScalar(x0, x), b), multiplyScalar2(subtractScalar(y0, y), a))];
          num = sqrt2(addScalar2(addScalar2(multiplyScalar2(num[0], num[0]), multiplyScalar2(num[1], num[1])), multiplyScalar2(num[2], num[2])));
          var den = sqrt2(addScalar2(addScalar2(multiplyScalar2(a, a), multiplyScalar2(b, b)), multiplyScalar2(c, c)));
          return divideScalar(num, den);
        }
        function _euclideanDistance(x, y) {
          var vectorSize = x.length;
          var result = 0;
          var diff = 0;
          for (var i = 0; i < vectorSize; i++) {
            diff = subtractScalar(x[i], y[i]);
            result = addScalar2(multiplyScalar2(diff, diff), result);
          }
          return sqrt2(result);
        }
        function _distancePairwise(a) {
          var result = [];
          var pointA = [];
          var pointB = [];
          for (var i = 0; i < a.length - 1; i++) {
            for (var j = i + 1; j < a.length; j++) {
              if (a[0].length === 2) {
                pointA = [a[i][0], a[i][1]];
                pointB = [a[j][0], a[j][1]];
              } else if (a[0].length === 3) {
                pointA = [a[i][0], a[i][1], a[i][2]];
                pointB = [a[j][0], a[j][1], a[j][2]];
              }
              result.push(_euclideanDistance(pointA, pointB));
            }
          }
          return result;
        }
      });
    }
  });

  // node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/function/geometry/intersect.js
  var require_intersect2 = __commonJS({
    "node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/function/geometry/intersect.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.createIntersect = void 0;
      var _factory = require_factory();
      var name18 = "intersect";
      var dependencies19 = ["typed", "config", "abs", "add", "addScalar", "matrix", "multiply", "multiplyScalar", "divideScalar", "subtract", "smaller", "equalScalar", "flatten", "isZero", "isNumeric"];
      var createIntersect2 = exports.createIntersect = /* @__PURE__ */ (0, _factory.factory)(name18, dependencies19, function(_ref) {
        var typed2 = _ref.typed, config4 = _ref.config, abs2 = _ref.abs, add2 = _ref.add, addScalar2 = _ref.addScalar, matrix2 = _ref.matrix, multiply2 = _ref.multiply, multiplyScalar2 = _ref.multiplyScalar, divideScalar = _ref.divideScalar, subtract = _ref.subtract, smaller = _ref.smaller, equalScalar2 = _ref.equalScalar, flatten2 = _ref.flatten, isZero = _ref.isZero, isNumeric = _ref.isNumeric;
        return typed2("intersect", {
          "Array, Array, Array": _AAA,
          "Array, Array, Array, Array": _AAAA,
          "Matrix, Matrix, Matrix": function MatrixMatrixMatrix(x, y, plane) {
            var arr = _AAA(x.valueOf(), y.valueOf(), plane.valueOf());
            return arr === null ? null : matrix2(arr);
          },
          "Matrix, Matrix, Matrix, Matrix": function MatrixMatrixMatrixMatrix(w, x, y, z) {
            var arr = _AAAA(w.valueOf(), x.valueOf(), y.valueOf(), z.valueOf());
            return arr === null ? null : matrix2(arr);
          }
        });
        function _AAA(x, y, plane) {
          x = _coerceArr(x);
          y = _coerceArr(y);
          plane = _coerceArr(plane);
          if (!_3d(x)) {
            throw new TypeError("Array with 3 numbers or BigNumbers expected for first argument");
          }
          if (!_3d(y)) {
            throw new TypeError("Array with 3 numbers or BigNumbers expected for second argument");
          }
          if (!_4d(plane)) {
            throw new TypeError("Array with 4 numbers expected as third argument");
          }
          return _intersectLinePlane(x[0], x[1], x[2], y[0], y[1], y[2], plane[0], plane[1], plane[2], plane[3]);
        }
        function _AAAA(w, x, y, z) {
          w = _coerceArr(w);
          x = _coerceArr(x);
          y = _coerceArr(y);
          z = _coerceArr(z);
          if (w.length === 2) {
            if (!_2d(w)) {
              throw new TypeError("Array with 2 numbers or BigNumbers expected for first argument");
            }
            if (!_2d(x)) {
              throw new TypeError("Array with 2 numbers or BigNumbers expected for second argument");
            }
            if (!_2d(y)) {
              throw new TypeError("Array with 2 numbers or BigNumbers expected for third argument");
            }
            if (!_2d(z)) {
              throw new TypeError("Array with 2 numbers or BigNumbers expected for fourth argument");
            }
            return _intersect2d(w, x, y, z);
          } else if (w.length === 3) {
            if (!_3d(w)) {
              throw new TypeError("Array with 3 numbers or BigNumbers expected for first argument");
            }
            if (!_3d(x)) {
              throw new TypeError("Array with 3 numbers or BigNumbers expected for second argument");
            }
            if (!_3d(y)) {
              throw new TypeError("Array with 3 numbers or BigNumbers expected for third argument");
            }
            if (!_3d(z)) {
              throw new TypeError("Array with 3 numbers or BigNumbers expected for fourth argument");
            }
            return _intersect3d(w[0], w[1], w[2], x[0], x[1], x[2], y[0], y[1], y[2], z[0], z[1], z[2]);
          } else {
            throw new TypeError("Arrays with two or thee dimensional points expected");
          }
        }
        function _coerceArr(arr) {
          if (arr.length === 1) return arr[0];
          if (arr.length > 1 && Array.isArray(arr[0])) {
            if (arr.every(function(el) {
              return Array.isArray(el) && el.length === 1;
            })) return flatten2(arr);
          }
          return arr;
        }
        function _2d(x) {
          return x.length === 2 && isNumeric(x[0]) && isNumeric(x[1]);
        }
        function _3d(x) {
          return x.length === 3 && isNumeric(x[0]) && isNumeric(x[1]) && isNumeric(x[2]);
        }
        function _4d(x) {
          return x.length === 4 && isNumeric(x[0]) && isNumeric(x[1]) && isNumeric(x[2]) && isNumeric(x[3]);
        }
        function _intersect2d(p1a, p1b, p2a, p2b) {
          var o1 = p1a;
          var o2 = p2a;
          var d1 = subtract(o1, p1b);
          var d2 = subtract(o2, p2b);
          var det = subtract(multiplyScalar2(d1[0], d2[1]), multiplyScalar2(d2[0], d1[1]));
          if (isZero(det)) return null;
          if (smaller(abs2(det), config4.epsilon)) {
            return null;
          }
          var d20o11 = multiplyScalar2(d2[0], o1[1]);
          var d21o10 = multiplyScalar2(d2[1], o1[0]);
          var d20o21 = multiplyScalar2(d2[0], o2[1]);
          var d21o20 = multiplyScalar2(d2[1], o2[0]);
          var t = divideScalar(addScalar2(subtract(subtract(d20o11, d21o10), d20o21), d21o20), det);
          return add2(multiply2(d1, t), o1);
        }
        function _intersect3dHelper(a, b, c, d, e, f, g, h, i, j, k, l) {
          var add1 = multiplyScalar2(subtract(a, b), subtract(c, d));
          var add22 = multiplyScalar2(subtract(e, f), subtract(g, h));
          var add3 = multiplyScalar2(subtract(i, j), subtract(k, l));
          return addScalar2(addScalar2(add1, add22), add3);
        }
        function _intersect3d(x1, y1, z1, x2, y2, z2, x3, y3, z3, x4, y4, z4) {
          var d1343 = _intersect3dHelper(x1, x3, x4, x3, y1, y3, y4, y3, z1, z3, z4, z3);
          var d4321 = _intersect3dHelper(x4, x3, x2, x1, y4, y3, y2, y1, z4, z3, z2, z1);
          var d1321 = _intersect3dHelper(x1, x3, x2, x1, y1, y3, y2, y1, z1, z3, z2, z1);
          var d4343 = _intersect3dHelper(x4, x3, x4, x3, y4, y3, y4, y3, z4, z3, z4, z3);
          var d2121 = _intersect3dHelper(x2, x1, x2, x1, y2, y1, y2, y1, z2, z1, z2, z1);
          var numerator = subtract(multiplyScalar2(d1343, d4321), multiplyScalar2(d1321, d4343));
          var denominator = subtract(multiplyScalar2(d2121, d4343), multiplyScalar2(d4321, d4321));
          if (isZero(denominator)) return null;
          var ta = divideScalar(numerator, denominator);
          var tb = divideScalar(addScalar2(d1343, multiplyScalar2(ta, d4321)), d4343);
          var pax = addScalar2(x1, multiplyScalar2(ta, subtract(x2, x1)));
          var pay = addScalar2(y1, multiplyScalar2(ta, subtract(y2, y1)));
          var paz = addScalar2(z1, multiplyScalar2(ta, subtract(z2, z1)));
          var pbx = addScalar2(x3, multiplyScalar2(tb, subtract(x4, x3)));
          var pby = addScalar2(y3, multiplyScalar2(tb, subtract(y4, y3)));
          var pbz = addScalar2(z3, multiplyScalar2(tb, subtract(z4, z3)));
          if (equalScalar2(pax, pbx) && equalScalar2(pay, pby) && equalScalar2(paz, pbz)) {
            return [pax, pay, paz];
          } else {
            return null;
          }
        }
        function _intersectLinePlane(x1, y1, z1, x2, y2, z2, x, y, z, c) {
          var x1x = multiplyScalar2(x1, x);
          var x2x = multiplyScalar2(x2, x);
          var y1y = multiplyScalar2(y1, y);
          var y2y = multiplyScalar2(y2, y);
          var z1z = multiplyScalar2(z1, z);
          var z2z = multiplyScalar2(z2, z);
          var numerator = subtract(subtract(subtract(c, x1x), y1y), z1z);
          var denominator = subtract(subtract(subtract(addScalar2(addScalar2(x2x, y2y), z2z), x1x), y1y), z1z);
          var t = divideScalar(numerator, denominator);
          var px = addScalar2(x1, multiplyScalar2(t, subtract(x2, x1)));
          var py = addScalar2(y1, multiplyScalar2(t, subtract(y2, y1)));
          var pz = addScalar2(z1, multiplyScalar2(t, subtract(z2, z1)));
          return [px, py, pz];
        }
      });
    }
  });

  // node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/function/statistics/sum.js
  var require_sum2 = __commonJS({
    "node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/function/statistics/sum.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.createSum = void 0;
      var _collection = require_collection();
      var _factory = require_factory();
      var _improveErrorMessage = require_improveErrorMessage();
      var name18 = "sum";
      var dependencies19 = ["typed", "config", "add", "numeric"];
      var createSum2 = exports.createSum = /* @__PURE__ */ (0, _factory.factory)(name18, dependencies19, function(_ref) {
        var typed2 = _ref.typed, config4 = _ref.config, add2 = _ref.add, numeric = _ref.numeric;
        return typed2(name18, {
          // sum([a, b, c, d, ...])
          "Array | Matrix": _sum,
          // sum([a, b, c, d, ...], dim)
          "Array | Matrix, number | BigNumber": _nsumDim,
          // sum(a, b, c, d, ...)
          "...": function _(args) {
            if ((0, _collection.containsCollections)(args)) {
              throw new TypeError("Scalar values expected in function sum");
            }
            return _sum(args);
          }
        });
        function _sum(array) {
          var sum2;
          (0, _collection.deepForEach)(array, function(value) {
            try {
              sum2 = sum2 === void 0 ? value : add2(sum2, value);
            } catch (err) {
              throw (0, _improveErrorMessage.improveErrorMessage)(err, "sum", value);
            }
          });
          if (sum2 === void 0) {
            sum2 = numeric(0, config4.number);
          }
          if (typeof sum2 === "string") {
            sum2 = numeric(sum2, config4.number);
          }
          return sum2;
        }
        function _nsumDim(array, dim) {
          try {
            var sum2 = (0, _collection.reduce)(array, dim, add2);
            return sum2;
          } catch (err) {
            throw (0, _improveErrorMessage.improveErrorMessage)(err, "sum");
          }
        }
      });
    }
  });

  // node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/function/statistics/cumsum.js
  var require_cumsum2 = __commonJS({
    "node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/function/statistics/cumsum.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.createCumSum = void 0;
      var _collection = require_collection();
      var _factory = require_factory();
      var _switch2 = require_switch();
      var _improveErrorMessage = require_improveErrorMessage();
      var _array = require_array();
      var _IndexError = require_IndexError();
      var name18 = "cumsum";
      var dependencies19 = ["typed", "add", "unaryPlus"];
      var createCumSum2 = exports.createCumSum = /* @__PURE__ */ (0, _factory.factory)(name18, dependencies19, function(_ref) {
        var typed2 = _ref.typed, add2 = _ref.add, unaryPlus = _ref.unaryPlus;
        return typed2(name18, {
          // sum([a, b, c, d, ...])
          Array: _cumsum,
          Matrix: function Matrix2(matrix2) {
            return matrix2.create(_cumsum(matrix2.valueOf()));
          },
          // sum([a, b, c, d, ...], dim)
          "Array, number | BigNumber": _ncumSumDim,
          "Matrix, number | BigNumber": function MatrixNumberBigNumber(matrix2, dim) {
            return matrix2.create(_ncumSumDim(matrix2.valueOf(), dim));
          },
          // cumsum(a, b, c, d, ...)
          "...": function _(args) {
            if ((0, _collection.containsCollections)(args)) {
              throw new TypeError("All values expected to be scalar in function cumsum");
            }
            return _cumsum(args);
          }
        });
        function _cumsum(array) {
          try {
            return _cumsummap(array);
          } catch (err) {
            throw (0, _improveErrorMessage.improveErrorMessage)(err, name18);
          }
        }
        function _cumsummap(array) {
          if (array.length === 0) {
            return [];
          }
          var sums = [unaryPlus(array[0])];
          for (var i = 1; i < array.length; ++i) {
            sums.push(add2(sums[i - 1], array[i]));
          }
          return sums;
        }
        function _ncumSumDim(array, dim) {
          var size2 = (0, _array.arraySize)(array);
          if (dim < 0 || dim >= size2.length) {
            throw new _IndexError.IndexError(dim, size2.length);
          }
          try {
            return _cumsumDimensional(array, dim);
          } catch (err) {
            throw (0, _improveErrorMessage.improveErrorMessage)(err, name18);
          }
        }
        function _cumsumDimensional(mat, dim) {
          var i, ret, tran;
          if (dim <= 0) {
            var initialValue = mat[0][0];
            if (!Array.isArray(initialValue)) {
              return _cumsummap(mat);
            } else {
              tran = (0, _switch2._switch)(mat);
              ret = [];
              for (i = 0; i < tran.length; i++) {
                ret[i] = _cumsumDimensional(tran[i], dim - 1);
              }
              return ret;
            }
          } else {
            ret = [];
            for (i = 0; i < mat.length; i++) {
              ret[i] = _cumsumDimensional(mat[i], dim - 1);
            }
            return ret;
          }
        }
      });
    }
  });

  // node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/function/statistics/mean.js
  var require_mean2 = __commonJS({
    "node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/function/statistics/mean.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.createMean = void 0;
      var _collection = require_collection();
      var _array = require_array();
      var _factory = require_factory();
      var _improveErrorMessage = require_improveErrorMessage();
      var name18 = "mean";
      var dependencies19 = ["typed", "add", "divide"];
      var createMean2 = exports.createMean = /* @__PURE__ */ (0, _factory.factory)(name18, dependencies19, function(_ref) {
        var typed2 = _ref.typed, add2 = _ref.add, divide2 = _ref.divide;
        return typed2(name18, {
          // mean([a, b, c, d, ...])
          "Array | Matrix": _mean,
          // mean([a, b, c, d, ...], dim)
          "Array | Matrix, number | BigNumber": _nmeanDim,
          // mean(a, b, c, d, ...)
          "...": function _(args) {
            if ((0, _collection.containsCollections)(args)) {
              throw new TypeError("Scalar values expected in function mean");
            }
            return _mean(args);
          }
        });
        function _nmeanDim(array, dim) {
          try {
            var sum2 = (0, _collection.reduce)(array, dim, add2);
            var s = Array.isArray(array) ? (0, _array.arraySize)(array) : array.size();
            return divide2(sum2, s[dim]);
          } catch (err) {
            throw (0, _improveErrorMessage.improveErrorMessage)(err, "mean");
          }
        }
        function _mean(array) {
          var sum2;
          var num = 0;
          (0, _collection.deepForEach)(array, function(value) {
            try {
              sum2 = sum2 === void 0 ? value : add2(sum2, value);
              num++;
            } catch (err) {
              throw (0, _improveErrorMessage.improveErrorMessage)(err, "mean", value);
            }
          });
          if (num === 0) {
            throw new Error("Cannot calculate the mean of an empty array");
          }
          return divide2(sum2, num);
        }
      });
    }
  });

  // node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/function/statistics/median.js
  var require_median2 = __commonJS({
    "node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/function/statistics/median.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.createMedian = void 0;
      var _collection = require_collection();
      var _array = require_array();
      var _factory = require_factory();
      var _improveErrorMessage = require_improveErrorMessage();
      var name18 = "median";
      var dependencies19 = ["typed", "add", "divide", "compare", "partitionSelect"];
      var createMedian2 = exports.createMedian = /* @__PURE__ */ (0, _factory.factory)(name18, dependencies19, function(_ref) {
        var typed2 = _ref.typed, add2 = _ref.add, divide2 = _ref.divide, compare = _ref.compare, partitionSelect = _ref.partitionSelect;
        function _median(array) {
          try {
            array = (0, _array.flatten)(array.valueOf());
            var num = array.length;
            if (num === 0) {
              throw new Error("Cannot calculate median of an empty array");
            }
            if (num % 2 === 0) {
              var mid = num / 2 - 1;
              var right = partitionSelect(array, mid + 1);
              var left = array[mid];
              for (var i = 0; i < mid; ++i) {
                if (compare(array[i], left) > 0) {
                  left = array[i];
                }
              }
              return middle2(left, right);
            } else {
              var m = partitionSelect(array, (num - 1) / 2);
              return middle(m);
            }
          } catch (err) {
            throw (0, _improveErrorMessage.improveErrorMessage)(err, "median");
          }
        }
        var middle = typed2({
          "number | BigNumber | Complex | Unit": function numberBigNumberComplexUnit(value) {
            return value;
          }
        });
        var middle2 = typed2({
          "number | BigNumber | Complex | Unit, number | BigNumber | Complex | Unit": function numberBigNumberComplexUnitNumberBigNumberComplexUnit(left, right) {
            return divide2(add2(left, right), 2);
          }
        });
        return typed2(name18, {
          // median([a, b, c, d, ...])
          "Array | Matrix": _median,
          // median([a, b, c, d, ...], dim)
          "Array | Matrix, number | BigNumber": function ArrayMatrixNumberBigNumber(array, dim) {
            throw new Error("median(A, dim) is not yet supported");
          },
          // median(a, b, c, d, ...)
          "...": function _(args) {
            if ((0, _collection.containsCollections)(args)) {
              throw new TypeError("Scalar values expected in function median");
            }
            return _median(args);
          }
        });
      });
    }
  });

  // node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/function/statistics/mad.js
  var require_mad2 = __commonJS({
    "node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/function/statistics/mad.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.createMad = void 0;
      var _array = require_array();
      var _factory = require_factory();
      var _improveErrorMessage = require_improveErrorMessage();
      var name18 = "mad";
      var dependencies19 = ["typed", "abs", "map", "median", "subtract"];
      var createMad2 = exports.createMad = /* @__PURE__ */ (0, _factory.factory)(name18, dependencies19, function(_ref) {
        var typed2 = _ref.typed, abs2 = _ref.abs, map = _ref.map, median = _ref.median, subtract = _ref.subtract;
        return typed2(name18, {
          // mad([a, b, c, d, ...])
          "Array | Matrix": _mad,
          // mad(a, b, c, d, ...)
          "...": function _(args) {
            return _mad(args);
          }
        });
        function _mad(array) {
          array = (0, _array.flatten)(array.valueOf());
          if (array.length === 0) {
            throw new Error("Cannot calculate median absolute deviation (mad) of an empty array");
          }
          try {
            var med = median(array);
            return median(map(array, function(value) {
              return abs2(subtract(value, med));
            }));
          } catch (err) {
            if (err instanceof TypeError && err.message.includes("median")) {
              throw new TypeError(err.message.replace("median", "mad"));
            } else {
              throw (0, _improveErrorMessage.improveErrorMessage)(err, "mad");
            }
          }
        }
      });
    }
  });

  // node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/function/statistics/variance.js
  var require_variance2 = __commonJS({
    "node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/function/statistics/variance.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.createVariance = void 0;
      var _collection = require_collection();
      var _is = require_is();
      var _factory = require_factory();
      var _improveErrorMessage = require_improveErrorMessage();
      var DEFAULT_NORMALIZATION = "unbiased";
      var name18 = "variance";
      var dependencies19 = ["typed", "add", "subtract", "multiply", "divide", "apply", "isNaN"];
      var createVariance2 = exports.createVariance = /* @__PURE__ */ (0, _factory.factory)(name18, dependencies19, function(_ref) {
        var typed2 = _ref.typed, add2 = _ref.add, subtract = _ref.subtract, multiply2 = _ref.multiply, divide2 = _ref.divide, apply = _ref.apply, isNaN2 = _ref.isNaN;
        return typed2(name18, {
          // variance([a, b, c, d, ...])
          "Array | Matrix": function ArrayMatrix(array) {
            return _var(array, DEFAULT_NORMALIZATION);
          },
          // variance([a, b, c, d, ...], normalization)
          "Array | Matrix, string": _var,
          // variance([a, b, c, c, ...], dim)
          "Array | Matrix, number | BigNumber": function ArrayMatrixNumberBigNumber(array, dim) {
            return _varDim(array, dim, DEFAULT_NORMALIZATION);
          },
          // variance([a, b, c, c, ...], dim, normalization)
          "Array | Matrix, number | BigNumber, string": _varDim,
          // variance(a, b, c, d, ...)
          "...": function _(args) {
            return _var(args, DEFAULT_NORMALIZATION);
          }
        });
        function _var(array, normalization) {
          var sum2;
          var num = 0;
          if (array.length === 0) {
            throw new SyntaxError("Function variance requires one or more parameters (0 provided)");
          }
          (0, _collection.deepForEach)(array, function(value) {
            try {
              sum2 = sum2 === void 0 ? value : add2(sum2, value);
              num++;
            } catch (err) {
              throw (0, _improveErrorMessage.improveErrorMessage)(err, "variance", value);
            }
          });
          if (num === 0) throw new Error("Cannot calculate variance of an empty array");
          var mean = divide2(sum2, num);
          sum2 = void 0;
          (0, _collection.deepForEach)(array, function(value) {
            var diff = subtract(value, mean);
            sum2 = sum2 === void 0 ? multiply2(diff, diff) : add2(sum2, multiply2(diff, diff));
          });
          if (isNaN2(sum2)) {
            return sum2;
          }
          switch (normalization) {
            case "uncorrected":
              return divide2(sum2, num);
            case "biased":
              return divide2(sum2, num + 1);
            case "unbiased": {
              var zero = (0, _is.isBigNumber)(sum2) ? sum2.mul(0) : 0;
              return num === 1 ? zero : divide2(sum2, num - 1);
            }
            default:
              throw new Error('Unknown normalization "' + normalization + '". Choose "unbiased" (default), "uncorrected", or "biased".');
          }
        }
        function _varDim(array, dim, normalization) {
          try {
            if (array.length === 0) {
              throw new SyntaxError("Function variance requires one or more parameters (0 provided)");
            }
            return apply(array, dim, function(x) {
              return _var(x, normalization);
            });
          } catch (err) {
            throw (0, _improveErrorMessage.improveErrorMessage)(err, "variance");
          }
        }
      });
    }
  });

  // node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/function/statistics/quantileSeq.js
  var require_quantileSeq2 = __commonJS({
    "node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/function/statistics/quantileSeq.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.createQuantileSeq = void 0;
      var _is = require_is();
      var _array = require_array();
      var _factory = require_factory();
      var _apply = require_apply();
      var name18 = "quantileSeq";
      var dependencies19 = ["typed", "?bignumber", "add", "subtract", "divide", "multiply", "partitionSelect", "compare", "isInteger", "smaller", "smallerEq", "larger"];
      var createQuantileSeq2 = exports.createQuantileSeq = /* @__PURE__ */ (0, _factory.factory)(name18, dependencies19, function(_ref) {
        var typed2 = _ref.typed, bignumber = _ref.bignumber, add2 = _ref.add, subtract = _ref.subtract, divide2 = _ref.divide, multiply2 = _ref.multiply, partitionSelect = _ref.partitionSelect, compare = _ref.compare, isInteger2 = _ref.isInteger, smaller = _ref.smaller, smallerEq = _ref.smallerEq, larger = _ref.larger;
        var apply = (0, _apply.createApply)({
          typed: typed2,
          isInteger: isInteger2
        });
        return typed2(name18, {
          "Array | Matrix, number | BigNumber": function ArrayMatrixNumberBigNumber(data, p) {
            return _quantileSeqProbNumber(data, p, false);
          },
          "Array | Matrix, number | BigNumber, number": function ArrayMatrixNumberBigNumberNumber(data, prob, dim) {
            return _quantileSeqDim(data, prob, false, dim, _quantileSeqProbNumber);
          },
          "Array | Matrix, number | BigNumber, boolean": _quantileSeqProbNumber,
          "Array | Matrix, number | BigNumber, boolean, number": function ArrayMatrixNumberBigNumberBooleanNumber(data, prob, sorted, dim) {
            return _quantileSeqDim(data, prob, sorted, dim, _quantileSeqProbNumber);
          },
          "Array | Matrix, Array | Matrix": function ArrayMatrixArrayMatrix(data, p) {
            return _quantileSeqProbCollection(data, p, false);
          },
          "Array | Matrix, Array | Matrix, number": function ArrayMatrixArrayMatrixNumber(data, prob, dim) {
            return _quantileSeqDim(data, prob, false, dim, _quantileSeqProbCollection);
          },
          "Array | Matrix, Array | Matrix, boolean": _quantileSeqProbCollection,
          "Array | Matrix, Array | Matrix, boolean, number": function ArrayMatrixArrayMatrixBooleanNumber(data, prob, sorted, dim) {
            return _quantileSeqDim(data, prob, sorted, dim, _quantileSeqProbCollection);
          }
        });
        function _quantileSeqDim(data, prob, sorted, dim, fn) {
          return apply(data, dim, function(x) {
            return fn(x, prob, sorted);
          });
        }
        function _quantileSeqProbNumber(data, probOrN, sorted) {
          var probArr;
          var dataArr = data.valueOf();
          if (smaller(probOrN, 0)) {
            throw new Error("N/prob must be non-negative");
          }
          if (smallerEq(probOrN, 1)) {
            return (0, _is.isNumber)(probOrN) ? _quantileSeq(dataArr, probOrN, sorted) : bignumber(_quantileSeq(dataArr, probOrN, sorted));
          }
          if (larger(probOrN, 1)) {
            if (!isInteger2(probOrN)) {
              throw new Error("N must be a positive integer");
            }
            if (larger(probOrN, 4294967295)) {
              throw new Error("N must be less than or equal to 2^32-1, as that is the maximum length of an Array");
            }
            var nPlusOne = add2(probOrN, 1);
            probArr = [];
            for (var i = 0; smaller(i, probOrN); i++) {
              var prob = divide2(i + 1, nPlusOne);
              probArr.push(_quantileSeq(dataArr, prob, sorted));
            }
            return (0, _is.isNumber)(probOrN) ? probArr : bignumber(probArr);
          }
        }
        function _quantileSeqProbCollection(data, probOrN, sorted) {
          var dataArr = data.valueOf();
          var probOrNArr = probOrN.valueOf();
          var probArr = [];
          for (var i = 0; i < probOrNArr.length; ++i) {
            probArr.push(_quantileSeq(dataArr, probOrNArr[i], sorted));
          }
          return probArr;
        }
        function _quantileSeq(array, prob, sorted) {
          var flat = (0, _array.flatten)(array);
          var len = flat.length;
          if (len === 0) {
            throw new Error("Cannot calculate quantile of an empty sequence");
          }
          var index = (0, _is.isNumber)(prob) ? prob * (len - 1) : prob.times(len - 1);
          var integerPart = (0, _is.isNumber)(prob) ? Math.floor(index) : index.floor().toNumber();
          var fracPart = (0, _is.isNumber)(prob) ? index % 1 : index.minus(integerPart);
          if (isInteger2(index)) {
            return sorted ? flat[index] : partitionSelect(flat, (0, _is.isNumber)(prob) ? index : index.valueOf());
          }
          var left;
          var right;
          if (sorted) {
            left = flat[integerPart];
            right = flat[integerPart + 1];
          } else {
            right = partitionSelect(flat, integerPart + 1);
            left = flat[integerPart];
            for (var i = 0; i < integerPart; ++i) {
              if (compare(flat[i], left) > 0) {
                left = flat[i];
              }
            }
          }
          return add2(multiply2(left, subtract(1, fracPart)), multiply2(right, fracPart));
        }
      });
    }
  });

  // node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/function/statistics/std.js
  var require_std2 = __commonJS({
    "node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/function/statistics/std.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.createStd = void 0;
      var _factory = require_factory();
      var _is = require_is();
      var name18 = "std";
      var dependencies19 = ["typed", "map", "sqrt", "variance"];
      var createStd2 = exports.createStd = /* @__PURE__ */ (0, _factory.factory)(name18, dependencies19, function(_ref) {
        var typed2 = _ref.typed, map = _ref.map, sqrt2 = _ref.sqrt, variance = _ref.variance;
        return typed2(name18, {
          // std([a, b, c, d, ...])
          "Array | Matrix": _std,
          // std([a, b, c, d, ...], normalization)
          "Array | Matrix, string": _std,
          // std([a, b, c, c, ...], dim)
          "Array | Matrix, number | BigNumber": _std,
          // std([a, b, c, c, ...], dim, normalization)
          "Array | Matrix, number | BigNumber, string": _std,
          // std(a, b, c, d, ...)
          "...": function _(args) {
            return _std(args);
          }
        });
        function _std(array, normalization) {
          if (array.length === 0) {
            throw new SyntaxError("Function std requires one or more parameters (0 provided)");
          }
          try {
            var v = variance.apply(null, arguments);
            if ((0, _is.isCollection)(v)) {
              return map(v, sqrt2);
            } else {
              return sqrt2(v);
            }
          } catch (err) {
            if (err instanceof TypeError && err.message.includes(" variance")) {
              throw new TypeError(err.message.replace(" variance", " std"));
            } else {
              throw err;
            }
          }
        }
      });
    }
  });

  // node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/function/statistics/corr.js
  var require_corr2 = __commonJS({
    "node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/function/statistics/corr.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.createCorr = void 0;
      var _factory = require_factory();
      var name18 = "corr";
      var dependencies19 = ["typed", "matrix", "mean", "sqrt", "sum", "add", "subtract", "multiply", "pow", "divide"];
      var createCorr2 = exports.createCorr = /* @__PURE__ */ (0, _factory.factory)(name18, dependencies19, function(_ref) {
        var typed2 = _ref.typed, matrix2 = _ref.matrix, sqrt2 = _ref.sqrt, sum2 = _ref.sum, add2 = _ref.add, subtract = _ref.subtract, multiply2 = _ref.multiply, pow2 = _ref.pow, divide2 = _ref.divide;
        return typed2(name18, {
          "Array, Array": function ArrayArray(A, B) {
            return _corr(A, B);
          },
          "Matrix, Matrix": function MatrixMatrix(A, B) {
            var res = _corr(A.toArray(), B.toArray());
            return Array.isArray(res) ? matrix2(res) : res;
          }
        });
        function _corr(A, B) {
          var correlations = [];
          if (Array.isArray(A[0]) && Array.isArray(B[0])) {
            if (A.length !== B.length) {
              throw new SyntaxError("Dimension mismatch. Array A and B must have the same length.");
            }
            for (var i = 0; i < A.length; i++) {
              if (A[i].length !== B[i].length) {
                throw new SyntaxError("Dimension mismatch. Array A and B must have the same number of elements.");
              }
              correlations.push(correlation(A[i], B[i]));
            }
            return correlations;
          } else {
            if (A.length !== B.length) {
              throw new SyntaxError("Dimension mismatch. Array A and B must have the same number of elements.");
            }
            return correlation(A, B);
          }
        }
        function correlation(A, B) {
          var n = A.length;
          var sumX = sum2(A);
          var sumY = sum2(B);
          var sumXY = A.reduce(function(acc, x, index) {
            return add2(acc, multiply2(x, B[index]));
          }, 0);
          var sumXSquare = sum2(A.map(function(x) {
            return pow2(x, 2);
          }));
          var sumYSquare = sum2(B.map(function(y) {
            return pow2(y, 2);
          }));
          var numerator = subtract(multiply2(n, sumXY), multiply2(sumX, sumY));
          var denominator = sqrt2(multiply2(subtract(multiply2(n, sumXSquare), pow2(sumX, 2)), subtract(multiply2(n, sumYSquare), pow2(sumY, 2))));
          return divide2(numerator, denominator);
        }
      });
    }
  });

  // node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/function/probability/combinations.js
  var require_combinations3 = __commonJS({
    "node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/function/probability/combinations.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.createCombinations = void 0;
      var _factory = require_factory();
      var _combinations = require_combinations();
      var name18 = "combinations";
      var dependencies19 = ["typed"];
      var createCombinations2 = exports.createCombinations = /* @__PURE__ */ (0, _factory.factory)(name18, dependencies19, function(_ref) {
        var typed2 = _ref.typed;
        return typed2(name18, {
          "number, number": _combinations.combinationsNumber,
          "BigNumber, BigNumber": function BigNumberBigNumber(n, k) {
            var BigNumber2 = n.constructor;
            var result, i;
            var nMinusk = n.minus(k);
            var one = new BigNumber2(1);
            if (!isPositiveInteger(n) || !isPositiveInteger(k)) {
              throw new TypeError("Positive integer value expected in function combinations");
            }
            if (k.gt(n)) {
              throw new TypeError("k must be less than n in function combinations");
            }
            result = one;
            if (k.lt(nMinusk)) {
              for (i = one; i.lte(nMinusk); i = i.plus(one)) {
                result = result.times(k.plus(i)).dividedBy(i);
              }
            } else {
              for (i = one; i.lte(k); i = i.plus(one)) {
                result = result.times(nMinusk.plus(i)).dividedBy(i);
              }
            }
            return result;
          }
          // TODO: implement support for collection in combinations
        });
      });
      function isPositiveInteger(n) {
        return n.isInteger() && n.gte(0);
      }
    }
  });

  // node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/function/probability/combinationsWithRep.js
  var require_combinationsWithRep2 = __commonJS({
    "node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/function/probability/combinationsWithRep.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.createCombinationsWithRep = void 0;
      var _factory = require_factory();
      var _number = require_number();
      var _product = require_product();
      var name18 = "combinationsWithRep";
      var dependencies19 = ["typed"];
      var createCombinationsWithRep2 = exports.createCombinationsWithRep = /* @__PURE__ */ (0, _factory.factory)(name18, dependencies19, function(_ref) {
        var typed2 = _ref.typed;
        return typed2(name18, {
          "number, number": function numberNumber(n, k) {
            if (!(0, _number.isInteger)(n) || n < 0) {
              throw new TypeError("Positive integer value expected in function combinationsWithRep");
            }
            if (!(0, _number.isInteger)(k) || k < 0) {
              throw new TypeError("Positive integer value expected in function combinationsWithRep");
            }
            if (n < 1) {
              throw new TypeError("k must be less than or equal to n + k - 1");
            }
            if (k < n - 1) {
              var _prodrange = (0, _product.product)(n, n + k - 1);
              return _prodrange / (0, _product.product)(1, k);
            }
            var prodrange = (0, _product.product)(k + 1, n + k - 1);
            return prodrange / (0, _product.product)(1, n - 1);
          },
          "BigNumber, BigNumber": function BigNumberBigNumber(n, k) {
            var BigNumber2 = n.constructor;
            var result, i;
            var one = new BigNumber2(1);
            var nMinusOne = n.minus(one);
            if (!isPositiveInteger(n) || !isPositiveInteger(k)) {
              throw new TypeError("Positive integer value expected in function combinationsWithRep");
            }
            if (n.lt(one)) {
              throw new TypeError("k must be less than or equal to n + k - 1 in function combinationsWithRep");
            }
            result = one;
            if (k.lt(nMinusOne)) {
              for (i = one; i.lte(nMinusOne); i = i.plus(one)) {
                result = result.times(k.plus(i)).dividedBy(i);
              }
            } else {
              for (i = one; i.lte(k); i = i.plus(one)) {
                result = result.times(nMinusOne.plus(i)).dividedBy(i);
              }
            }
            return result;
          }
        });
      });
      function isPositiveInteger(n) {
        return n.isInteger() && n.gte(0);
      }
    }
  });

  // node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/function/probability/gamma.js
  var require_gamma2 = __commonJS({
    "node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/function/probability/gamma.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.createGamma = void 0;
      var _factory = require_factory();
      var _index = require_number2();
      var name18 = "gamma";
      var dependencies19 = ["typed", "config", "multiplyScalar", "pow", "BigNumber", "Complex"];
      var createGamma2 = exports.createGamma = /* @__PURE__ */ (0, _factory.factory)(name18, dependencies19, function(_ref) {
        var typed2 = _ref.typed, config4 = _ref.config, multiplyScalar2 = _ref.multiplyScalar, pow2 = _ref.pow, _BigNumber = _ref.BigNumber, Complex3 = _ref.Complex;
        function gammaComplex(n) {
          if (n.im === 0) {
            return (0, _index.gammaNumber)(n.re);
          }
          if (n.re < 0.5) {
            var _t = new Complex3(1 - n.re, -n.im);
            var r = new Complex3(Math.PI * n.re, Math.PI * n.im);
            return new Complex3(Math.PI).div(r.sin()).div(gammaComplex(_t));
          }
          n = new Complex3(n.re - 1, n.im);
          var x = new Complex3(_index.gammaP[0], 0);
          for (var i = 1; i < _index.gammaP.length; ++i) {
            var gammaPval = new Complex3(_index.gammaP[i], 0);
            x = x.add(gammaPval.div(n.add(i)));
          }
          var t = new Complex3(n.re + _index.gammaG + 0.5, n.im);
          var twoPiSqrt = Math.sqrt(2 * Math.PI);
          var tpow = t.pow(n.add(0.5));
          var expt = t.neg().exp();
          return x.mul(twoPiSqrt).mul(tpow).mul(expt);
        }
        return typed2(name18, {
          number: _index.gammaNumber,
          Complex: gammaComplex,
          BigNumber: function BigNumber2(n) {
            if (n.isInteger()) {
              return n.isNegative() || n.isZero() ? new _BigNumber(Infinity) : bigFactorial(n.minus(1));
            }
            if (!n.isFinite()) {
              return new _BigNumber(n.isNegative() ? NaN : Infinity);
            }
            throw new Error("Integer BigNumber expected");
          }
        });
        function bigFactorial(n) {
          if (n < 8) {
            return new _BigNumber([1, 1, 2, 6, 24, 120, 720, 5040][n]);
          }
          var precision = config4.precision + (Math.log(n.toNumber()) | 0);
          var Big = _BigNumber.clone({
            precision
          });
          if (n % 2 === 1) {
            return n.times(bigFactorial(new _BigNumber(n - 1)));
          }
          var p = n;
          var prod = new Big(n);
          var sum2 = n.toNumber();
          while (p > 2) {
            p -= 2;
            sum2 += p;
            prod = prod.times(sum2);
          }
          return new _BigNumber(prod.toPrecision(_BigNumber.precision));
        }
      });
    }
  });

  // node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/function/probability/lgamma.js
  var require_lgamma2 = __commonJS({
    "node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/function/probability/lgamma.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.createLgamma = void 0;
      var _index = require_number2();
      var _factory = require_factory();
      var _number = require_number();
      var name18 = "lgamma";
      var dependencies19 = ["Complex", "typed"];
      var createLgamma2 = exports.createLgamma = /* @__PURE__ */ (0, _factory.factory)(name18, dependencies19, function(_ref) {
        var Complex3 = _ref.Complex, typed2 = _ref.typed;
        var SMALL_RE = 7;
        var SMALL_IM = 7;
        var coeffs = [-0.029550653594771242, 0.00641025641025641, -0.0019175269175269176, 8417508417508417e-19, -5952380952380953e-19, 7936507936507937e-19, -0.002777777777777778, 0.08333333333333333];
        return typed2(name18, {
          number: _index.lgammaNumber,
          Complex: lgammaComplex,
          BigNumber: function BigNumber2() {
            throw new Error("mathjs doesn't yet provide an implementation of the algorithm lgamma for BigNumber");
          }
        });
        function lgammaComplex(n) {
          var TWOPI = 6.283185307179586;
          var LOGPI = 1.1447298858494002;
          var REFLECTION = 0.1;
          if (n.isNaN()) {
            return new Complex3(NaN, NaN);
          } else if (n.im === 0) {
            return new Complex3((0, _index.lgammaNumber)(n.re), 0);
          } else if (n.re >= SMALL_RE || Math.abs(n.im) >= SMALL_IM) {
            return lgammaStirling(n);
          } else if (n.re <= REFLECTION) {
            var tmp = (0, _number.copysign)(TWOPI, n.im) * Math.floor(0.5 * n.re + 0.25);
            var a = n.mul(Math.PI).sin().log();
            var b = lgammaComplex(new Complex3(1 - n.re, -n.im));
            return new Complex3(LOGPI, tmp).sub(a).sub(b);
          } else if (n.im >= 0) {
            return lgammaRecurrence(n);
          } else {
            return lgammaRecurrence(n.conjugate()).conjugate();
          }
        }
        function lgammaStirling(z) {
          var leftPart = z.sub(0.5).mul(z.log()).sub(z).add(_index.lnSqrt2PI);
          var rz = new Complex3(1, 0).div(z);
          var rzz = rz.div(z);
          var a = coeffs[0];
          var b = coeffs[1];
          var r = 2 * rzz.re;
          var s = rzz.re * rzz.re + rzz.im * rzz.im;
          for (var i = 2; i < 8; i++) {
            var tmp = b;
            b = -s * a + coeffs[i];
            a = r * a + tmp;
          }
          var rightPart = rz.mul(rzz.mul(a).add(b));
          return leftPart.add(rightPart);
        }
        function lgammaRecurrence(z) {
          var signflips = 0;
          var sb = 0;
          var shiftprod = z;
          z = z.add(1);
          while (z.re <= SMALL_RE) {
            shiftprod = shiftprod.mul(z);
            var nsb = shiftprod.im < 0 ? 1 : 0;
            if (nsb !== 0 && sb === 0) signflips++;
            sb = nsb;
            z = z.add(1);
          }
          return lgammaStirling(z).sub(shiftprod.log()).sub(new Complex3(0, signflips * 2 * Math.PI * 1));
        }
      });
    }
  });

  // node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/function/probability/factorial.js
  var require_factorial2 = __commonJS({
    "node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/function/probability/factorial.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.createFactorial = void 0;
      var _collection = require_collection();
      var _factory = require_factory();
      var name18 = "factorial";
      var dependencies19 = ["typed", "gamma"];
      var createFactorial2 = exports.createFactorial = /* @__PURE__ */ (0, _factory.factory)(name18, dependencies19, function(_ref) {
        var typed2 = _ref.typed, gamma = _ref.gamma;
        return typed2(name18, {
          number: function number(n) {
            if (n < 0) {
              throw new Error("Value must be non-negative");
            }
            return gamma(n + 1);
          },
          BigNumber: function BigNumber2(n) {
            if (n.isNegative()) {
              throw new Error("Value must be non-negative");
            }
            return gamma(n.plus(1));
          },
          "Array | Matrix": typed2.referToSelf(function(self2) {
            return function(n) {
              return (0, _collection.deepMap)(n, self2);
            };
          })
        });
      });
    }
  });

  // node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/function/probability/kldivergence.js
  var require_kldivergence2 = __commonJS({
    "node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/function/probability/kldivergence.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.createKldivergence = void 0;
      var _factory = require_factory();
      var name18 = "kldivergence";
      var dependencies19 = ["typed", "matrix", "divide", "sum", "multiply", "map", "dotDivide", "log", "isNumeric"];
      var createKldivergence2 = exports.createKldivergence = /* @__PURE__ */ (0, _factory.factory)(name18, dependencies19, function(_ref) {
        var typed2 = _ref.typed, matrix2 = _ref.matrix, divide2 = _ref.divide, sum2 = _ref.sum, multiply2 = _ref.multiply, map = _ref.map, dotDivide = _ref.dotDivide, log3 = _ref.log, isNumeric = _ref.isNumeric;
        return typed2(name18, {
          "Array, Array": function ArrayArray(q, p) {
            return _kldiv(matrix2(q), matrix2(p));
          },
          "Matrix, Array": function MatrixArray(q, p) {
            return _kldiv(q, matrix2(p));
          },
          "Array, Matrix": function ArrayMatrix(q, p) {
            return _kldiv(matrix2(q), p);
          },
          "Matrix, Matrix": function MatrixMatrix(q, p) {
            return _kldiv(q, p);
          }
        });
        function _kldiv(q, p) {
          var plength = p.size().length;
          var qlength = q.size().length;
          if (plength > 1) {
            throw new Error("first object must be one dimensional");
          }
          if (qlength > 1) {
            throw new Error("second object must be one dimensional");
          }
          if (plength !== qlength) {
            throw new Error("Length of two vectors must be equal");
          }
          var sumq = sum2(q);
          if (sumq === 0) {
            throw new Error("Sum of elements in first object must be non zero");
          }
          var sump = sum2(p);
          if (sump === 0) {
            throw new Error("Sum of elements in second object must be non zero");
          }
          var qnorm = divide2(q, sum2(q));
          var pnorm = divide2(p, sum2(p));
          var result = sum2(multiply2(qnorm, map(dotDivide(qnorm, pnorm), function(x) {
            return log3(x);
          })));
          if (isNumeric(result)) {
            return result;
          } else {
            return Number.NaN;
          }
        }
      });
    }
  });

  // node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/function/probability/multinomial.js
  var require_multinomial2 = __commonJS({
    "node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/function/probability/multinomial.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.createMultinomial = void 0;
      var _collection = require_collection();
      var _factory = require_factory();
      var name18 = "multinomial";
      var dependencies19 = ["typed", "add", "divide", "multiply", "factorial", "isInteger", "isPositive"];
      var createMultinomial2 = exports.createMultinomial = /* @__PURE__ */ (0, _factory.factory)(name18, dependencies19, function(_ref) {
        var typed2 = _ref.typed, add2 = _ref.add, divide2 = _ref.divide, multiply2 = _ref.multiply, factorial = _ref.factorial, isInteger2 = _ref.isInteger, isPositive = _ref.isPositive;
        return typed2(name18, {
          "Array | Matrix": function ArrayMatrix(a) {
            var sum2 = 0;
            var denom = 1;
            (0, _collection.deepForEach)(a, function(ai) {
              if (!isInteger2(ai) || !isPositive(ai)) {
                throw new TypeError("Positive integer value expected in function multinomial");
              }
              sum2 = add2(sum2, ai);
              denom = multiply2(denom, factorial(ai));
            });
            return divide2(factorial(sum2), denom);
          }
        });
      });
    }
  });

  // node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/function/probability/permutations.js
  var require_permutations2 = __commonJS({
    "node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/function/probability/permutations.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.createPermutations = void 0;
      var _number = require_number();
      var _product = require_product();
      var _factory = require_factory();
      var name18 = "permutations";
      var dependencies19 = ["typed", "factorial"];
      var createPermutations2 = exports.createPermutations = /* @__PURE__ */ (0, _factory.factory)(name18, dependencies19, function(_ref) {
        var typed2 = _ref.typed, factorial = _ref.factorial;
        return typed2(name18, {
          "number | BigNumber": factorial,
          "number, number": function numberNumber(n, k) {
            if (!(0, _number.isInteger)(n) || n < 0) {
              throw new TypeError("Positive integer value expected in function permutations");
            }
            if (!(0, _number.isInteger)(k) || k < 0) {
              throw new TypeError("Positive integer value expected in function permutations");
            }
            if (k > n) {
              throw new TypeError("second argument k must be less than or equal to first argument n");
            }
            return (0, _product.product)(n - k + 1, n);
          },
          "BigNumber, BigNumber": function BigNumberBigNumber(n, k) {
            var result, i;
            if (!isPositiveInteger(n) || !isPositiveInteger(k)) {
              throw new TypeError("Positive integer value expected in function permutations");
            }
            if (k.gt(n)) {
              throw new TypeError("second argument k must be less than or equal to first argument n");
            }
            var one = n.mul(0).add(1);
            result = one;
            for (i = n.minus(k).plus(1); i.lte(n); i = i.plus(1)) {
              result = result.times(i);
            }
            return result;
          }
          // TODO: implement support for collection in permutations
        });
      });
      function isPositiveInteger(n) {
        return n.isInteger() && n.gte(0);
      }
    }
  });

  // node_modules/.pnpm/seedrandom@3.0.5/node_modules/seedrandom/lib/alea.js
  var require_alea = __commonJS({
    "node_modules/.pnpm/seedrandom@3.0.5/node_modules/seedrandom/lib/alea.js"(exports, module) {
      (function(global, module2, define2) {
        function Alea(seed) {
          var me = this, mash = Mash();
          me.next = function() {
            var t = 2091639 * me.s0 + me.c * 23283064365386963e-26;
            me.s0 = me.s1;
            me.s1 = me.s2;
            return me.s2 = t - (me.c = t | 0);
          };
          me.c = 1;
          me.s0 = mash(" ");
          me.s1 = mash(" ");
          me.s2 = mash(" ");
          me.s0 -= mash(seed);
          if (me.s0 < 0) {
            me.s0 += 1;
          }
          me.s1 -= mash(seed);
          if (me.s1 < 0) {
            me.s1 += 1;
          }
          me.s2 -= mash(seed);
          if (me.s2 < 0) {
            me.s2 += 1;
          }
          mash = null;
        }
        function copy(f, t) {
          t.c = f.c;
          t.s0 = f.s0;
          t.s1 = f.s1;
          t.s2 = f.s2;
          return t;
        }
        function impl(seed, opts) {
          var xg = new Alea(seed), state = opts && opts.state, prng = xg.next;
          prng.int32 = function() {
            return xg.next() * 4294967296 | 0;
          };
          prng.double = function() {
            return prng() + (prng() * 2097152 | 0) * 11102230246251565e-32;
          };
          prng.quick = prng;
          if (state) {
            if (typeof state == "object") copy(state, xg);
            prng.state = function() {
              return copy(xg, {});
            };
          }
          return prng;
        }
        function Mash() {
          var n = 4022871197;
          var mash = function(data) {
            data = String(data);
            for (var i = 0; i < data.length; i++) {
              n += data.charCodeAt(i);
              var h = 0.02519603282416938 * n;
              n = h >>> 0;
              h -= n;
              h *= n;
              n = h >>> 0;
              h -= n;
              n += h * 4294967296;
            }
            return (n >>> 0) * 23283064365386963e-26;
          };
          return mash;
        }
        if (module2 && module2.exports) {
          module2.exports = impl;
        } else if (define2 && define2.amd) {
          define2(function() {
            return impl;
          });
        } else {
          this.alea = impl;
        }
      })(
        exports,
        typeof module == "object" && module,
        // present in node.js
        typeof define == "function" && define
        // present with an AMD loader
      );
    }
  });

  // node_modules/.pnpm/seedrandom@3.0.5/node_modules/seedrandom/lib/xor128.js
  var require_xor128 = __commonJS({
    "node_modules/.pnpm/seedrandom@3.0.5/node_modules/seedrandom/lib/xor128.js"(exports, module) {
      (function(global, module2, define2) {
        function XorGen(seed) {
          var me = this, strseed = "";
          me.x = 0;
          me.y = 0;
          me.z = 0;
          me.w = 0;
          me.next = function() {
            var t = me.x ^ me.x << 11;
            me.x = me.y;
            me.y = me.z;
            me.z = me.w;
            return me.w ^= me.w >>> 19 ^ t ^ t >>> 8;
          };
          if (seed === (seed | 0)) {
            me.x = seed;
          } else {
            strseed += seed;
          }
          for (var k = 0; k < strseed.length + 64; k++) {
            me.x ^= strseed.charCodeAt(k) | 0;
            me.next();
          }
        }
        function copy(f, t) {
          t.x = f.x;
          t.y = f.y;
          t.z = f.z;
          t.w = f.w;
          return t;
        }
        function impl(seed, opts) {
          var xg = new XorGen(seed), state = opts && opts.state, prng = function() {
            return (xg.next() >>> 0) / 4294967296;
          };
          prng.double = function() {
            do {
              var top = xg.next() >>> 11, bot = (xg.next() >>> 0) / 4294967296, result = (top + bot) / (1 << 21);
            } while (result === 0);
            return result;
          };
          prng.int32 = xg.next;
          prng.quick = prng;
          if (state) {
            if (typeof state == "object") copy(state, xg);
            prng.state = function() {
              return copy(xg, {});
            };
          }
          return prng;
        }
        if (module2 && module2.exports) {
          module2.exports = impl;
        } else if (define2 && define2.amd) {
          define2(function() {
            return impl;
          });
        } else {
          this.xor128 = impl;
        }
      })(
        exports,
        typeof module == "object" && module,
        // present in node.js
        typeof define == "function" && define
        // present with an AMD loader
      );
    }
  });

  // node_modules/.pnpm/seedrandom@3.0.5/node_modules/seedrandom/lib/xorwow.js
  var require_xorwow = __commonJS({
    "node_modules/.pnpm/seedrandom@3.0.5/node_modules/seedrandom/lib/xorwow.js"(exports, module) {
      (function(global, module2, define2) {
        function XorGen(seed) {
          var me = this, strseed = "";
          me.next = function() {
            var t = me.x ^ me.x >>> 2;
            me.x = me.y;
            me.y = me.z;
            me.z = me.w;
            me.w = me.v;
            return (me.d = me.d + 362437 | 0) + (me.v = me.v ^ me.v << 4 ^ (t ^ t << 1)) | 0;
          };
          me.x = 0;
          me.y = 0;
          me.z = 0;
          me.w = 0;
          me.v = 0;
          if (seed === (seed | 0)) {
            me.x = seed;
          } else {
            strseed += seed;
          }
          for (var k = 0; k < strseed.length + 64; k++) {
            me.x ^= strseed.charCodeAt(k) | 0;
            if (k == strseed.length) {
              me.d = me.x << 10 ^ me.x >>> 4;
            }
            me.next();
          }
        }
        function copy(f, t) {
          t.x = f.x;
          t.y = f.y;
          t.z = f.z;
          t.w = f.w;
          t.v = f.v;
          t.d = f.d;
          return t;
        }
        function impl(seed, opts) {
          var xg = new XorGen(seed), state = opts && opts.state, prng = function() {
            return (xg.next() >>> 0) / 4294967296;
          };
          prng.double = function() {
            do {
              var top = xg.next() >>> 11, bot = (xg.next() >>> 0) / 4294967296, result = (top + bot) / (1 << 21);
            } while (result === 0);
            return result;
          };
          prng.int32 = xg.next;
          prng.quick = prng;
          if (state) {
            if (typeof state == "object") copy(state, xg);
            prng.state = function() {
              return copy(xg, {});
            };
          }
          return prng;
        }
        if (module2 && module2.exports) {
          module2.exports = impl;
        } else if (define2 && define2.amd) {
          define2(function() {
            return impl;
          });
        } else {
          this.xorwow = impl;
        }
      })(
        exports,
        typeof module == "object" && module,
        // present in node.js
        typeof define == "function" && define
        // present with an AMD loader
      );
    }
  });

  // node_modules/.pnpm/seedrandom@3.0.5/node_modules/seedrandom/lib/xorshift7.js
  var require_xorshift7 = __commonJS({
    "node_modules/.pnpm/seedrandom@3.0.5/node_modules/seedrandom/lib/xorshift7.js"(exports, module) {
      (function(global, module2, define2) {
        function XorGen(seed) {
          var me = this;
          me.next = function() {
            var X = me.x, i = me.i, t, v, w;
            t = X[i];
            t ^= t >>> 7;
            v = t ^ t << 24;
            t = X[i + 1 & 7];
            v ^= t ^ t >>> 10;
            t = X[i + 3 & 7];
            v ^= t ^ t >>> 3;
            t = X[i + 4 & 7];
            v ^= t ^ t << 7;
            t = X[i + 7 & 7];
            t = t ^ t << 13;
            v ^= t ^ t << 9;
            X[i] = v;
            me.i = i + 1 & 7;
            return v;
          };
          function init(me2, seed2) {
            var j, w, X = [];
            if (seed2 === (seed2 | 0)) {
              w = X[0] = seed2;
            } else {
              seed2 = "" + seed2;
              for (j = 0; j < seed2.length; ++j) {
                X[j & 7] = X[j & 7] << 15 ^ seed2.charCodeAt(j) + X[j + 1 & 7] << 13;
              }
            }
            while (X.length < 8) X.push(0);
            for (j = 0; j < 8 && X[j] === 0; ++j) ;
            if (j == 8) w = X[7] = -1;
            else w = X[j];
            me2.x = X;
            me2.i = 0;
            for (j = 256; j > 0; --j) {
              me2.next();
            }
          }
          init(me, seed);
        }
        function copy(f, t) {
          t.x = f.x.slice();
          t.i = f.i;
          return t;
        }
        function impl(seed, opts) {
          if (seed == null) seed = +/* @__PURE__ */ new Date();
          var xg = new XorGen(seed), state = opts && opts.state, prng = function() {
            return (xg.next() >>> 0) / 4294967296;
          };
          prng.double = function() {
            do {
              var top = xg.next() >>> 11, bot = (xg.next() >>> 0) / 4294967296, result = (top + bot) / (1 << 21);
            } while (result === 0);
            return result;
          };
          prng.int32 = xg.next;
          prng.quick = prng;
          if (state) {
            if (state.x) copy(state, xg);
            prng.state = function() {
              return copy(xg, {});
            };
          }
          return prng;
        }
        if (module2 && module2.exports) {
          module2.exports = impl;
        } else if (define2 && define2.amd) {
          define2(function() {
            return impl;
          });
        } else {
          this.xorshift7 = impl;
        }
      })(
        exports,
        typeof module == "object" && module,
        // present in node.js
        typeof define == "function" && define
        // present with an AMD loader
      );
    }
  });

  // node_modules/.pnpm/seedrandom@3.0.5/node_modules/seedrandom/lib/xor4096.js
  var require_xor4096 = __commonJS({
    "node_modules/.pnpm/seedrandom@3.0.5/node_modules/seedrandom/lib/xor4096.js"(exports, module) {
      (function(global, module2, define2) {
        function XorGen(seed) {
          var me = this;
          me.next = function() {
            var w = me.w, X = me.X, i = me.i, t, v;
            me.w = w = w + 1640531527 | 0;
            v = X[i + 34 & 127];
            t = X[i = i + 1 & 127];
            v ^= v << 13;
            t ^= t << 17;
            v ^= v >>> 15;
            t ^= t >>> 12;
            v = X[i] = v ^ t;
            me.i = i;
            return v + (w ^ w >>> 16) | 0;
          };
          function init(me2, seed2) {
            var t, v, i, j, w, X = [], limit = 128;
            if (seed2 === (seed2 | 0)) {
              v = seed2;
              seed2 = null;
            } else {
              seed2 = seed2 + "\0";
              v = 0;
              limit = Math.max(limit, seed2.length);
            }
            for (i = 0, j = -32; j < limit; ++j) {
              if (seed2) v ^= seed2.charCodeAt((j + 32) % seed2.length);
              if (j === 0) w = v;
              v ^= v << 10;
              v ^= v >>> 15;
              v ^= v << 4;
              v ^= v >>> 13;
              if (j >= 0) {
                w = w + 1640531527 | 0;
                t = X[j & 127] ^= v + w;
                i = 0 == t ? i + 1 : 0;
              }
            }
            if (i >= 128) {
              X[(seed2 && seed2.length || 0) & 127] = -1;
            }
            i = 127;
            for (j = 4 * 128; j > 0; --j) {
              v = X[i + 34 & 127];
              t = X[i = i + 1 & 127];
              v ^= v << 13;
              t ^= t << 17;
              v ^= v >>> 15;
              t ^= t >>> 12;
              X[i] = v ^ t;
            }
            me2.w = w;
            me2.X = X;
            me2.i = i;
          }
          init(me, seed);
        }
        function copy(f, t) {
          t.i = f.i;
          t.w = f.w;
          t.X = f.X.slice();
          return t;
        }
        ;
        function impl(seed, opts) {
          if (seed == null) seed = +/* @__PURE__ */ new Date();
          var xg = new XorGen(seed), state = opts && opts.state, prng = function() {
            return (xg.next() >>> 0) / 4294967296;
          };
          prng.double = function() {
            do {
              var top = xg.next() >>> 11, bot = (xg.next() >>> 0) / 4294967296, result = (top + bot) / (1 << 21);
            } while (result === 0);
            return result;
          };
          prng.int32 = xg.next;
          prng.quick = prng;
          if (state) {
            if (state.X) copy(state, xg);
            prng.state = function() {
              return copy(xg, {});
            };
          }
          return prng;
        }
        if (module2 && module2.exports) {
          module2.exports = impl;
        } else if (define2 && define2.amd) {
          define2(function() {
            return impl;
          });
        } else {
          this.xor4096 = impl;
        }
      })(
        exports,
        // window object or global
        typeof module == "object" && module,
        // present in node.js
        typeof define == "function" && define
        // present with an AMD loader
      );
    }
  });

  // node_modules/.pnpm/seedrandom@3.0.5/node_modules/seedrandom/lib/tychei.js
  var require_tychei = __commonJS({
    "node_modules/.pnpm/seedrandom@3.0.5/node_modules/seedrandom/lib/tychei.js"(exports, module) {
      (function(global, module2, define2) {
        function XorGen(seed) {
          var me = this, strseed = "";
          me.next = function() {
            var b = me.b, c = me.c, d = me.d, a = me.a;
            b = b << 25 ^ b >>> 7 ^ c;
            c = c - d | 0;
            d = d << 24 ^ d >>> 8 ^ a;
            a = a - b | 0;
            me.b = b = b << 20 ^ b >>> 12 ^ c;
            me.c = c = c - d | 0;
            me.d = d << 16 ^ c >>> 16 ^ a;
            return me.a = a - b | 0;
          };
          me.a = 0;
          me.b = 0;
          me.c = 2654435769 | 0;
          me.d = 1367130551;
          if (seed === Math.floor(seed)) {
            me.a = seed / 4294967296 | 0;
            me.b = seed | 0;
          } else {
            strseed += seed;
          }
          for (var k = 0; k < strseed.length + 20; k++) {
            me.b ^= strseed.charCodeAt(k) | 0;
            me.next();
          }
        }
        function copy(f, t) {
          t.a = f.a;
          t.b = f.b;
          t.c = f.c;
          t.d = f.d;
          return t;
        }
        ;
        function impl(seed, opts) {
          var xg = new XorGen(seed), state = opts && opts.state, prng = function() {
            return (xg.next() >>> 0) / 4294967296;
          };
          prng.double = function() {
            do {
              var top = xg.next() >>> 11, bot = (xg.next() >>> 0) / 4294967296, result = (top + bot) / (1 << 21);
            } while (result === 0);
            return result;
          };
          prng.int32 = xg.next;
          prng.quick = prng;
          if (state) {
            if (typeof state == "object") copy(state, xg);
            prng.state = function() {
              return copy(xg, {});
            };
          }
          return prng;
        }
        if (module2 && module2.exports) {
          module2.exports = impl;
        } else if (define2 && define2.amd) {
          define2(function() {
            return impl;
          });
        } else {
          this.tychei = impl;
        }
      })(
        exports,
        typeof module == "object" && module,
        // present in node.js
        typeof define == "function" && define
        // present with an AMD loader
      );
    }
  });

  // (disabled):crypto
  var require_crypto = __commonJS({
    "(disabled):crypto"() {
    }
  });

  // node_modules/.pnpm/seedrandom@3.0.5/node_modules/seedrandom/seedrandom.js
  var require_seedrandom = __commonJS({
    "node_modules/.pnpm/seedrandom@3.0.5/node_modules/seedrandom/seedrandom.js"(exports, module) {
      (function(global, pool, math) {
        var width = 256, chunks = 6, digits2 = 52, rngname = "random", startdenom = math.pow(width, chunks), significance = math.pow(2, digits2), overflow = significance * 2, mask = width - 1, nodecrypto;
        function seedrandom(seed, options, callback) {
          var key = [];
          options = options == true ? { entropy: true } : options || {};
          var shortseed = mixkey(flatten2(
            options.entropy ? [seed, tostring(pool)] : seed == null ? autoseed() : seed,
            3
          ), key);
          var arc4 = new ARC4(key);
          var prng = function() {
            var n = arc4.g(chunks), d = startdenom, x = 0;
            while (n < significance) {
              n = (n + x) * width;
              d *= width;
              x = arc4.g(1);
            }
            while (n >= overflow) {
              n /= 2;
              d /= 2;
              x >>>= 1;
            }
            return (n + x) / d;
          };
          prng.int32 = function() {
            return arc4.g(4) | 0;
          };
          prng.quick = function() {
            return arc4.g(4) / 4294967296;
          };
          prng.double = prng;
          mixkey(tostring(arc4.S), pool);
          return (options.pass || callback || function(prng2, seed2, is_math_call, state) {
            if (state) {
              if (state.S) {
                copy(state, arc4);
              }
              prng2.state = function() {
                return copy(arc4, {});
              };
            }
            if (is_math_call) {
              math[rngname] = prng2;
              return seed2;
            } else return prng2;
          })(
            prng,
            shortseed,
            "global" in options ? options.global : this == math,
            options.state
          );
        }
        function ARC4(key) {
          var t, keylen = key.length, me = this, i = 0, j = me.i = me.j = 0, s = me.S = [];
          if (!keylen) {
            key = [keylen++];
          }
          while (i < width) {
            s[i] = i++;
          }
          for (i = 0; i < width; i++) {
            s[i] = s[j = mask & j + key[i % keylen] + (t = s[i])];
            s[j] = t;
          }
          (me.g = function(count) {
            var t2, r = 0, i2 = me.i, j2 = me.j, s2 = me.S;
            while (count--) {
              t2 = s2[i2 = mask & i2 + 1];
              r = r * width + s2[mask & (s2[i2] = s2[j2 = mask & j2 + t2]) + (s2[j2] = t2)];
            }
            me.i = i2;
            me.j = j2;
            return r;
          })(width);
        }
        function copy(f, t) {
          t.i = f.i;
          t.j = f.j;
          t.S = f.S.slice();
          return t;
        }
        ;
        function flatten2(obj, depth) {
          var result = [], typ = typeof obj, prop;
          if (depth && typ == "object") {
            for (prop in obj) {
              try {
                result.push(flatten2(obj[prop], depth - 1));
              } catch (e) {
              }
            }
          }
          return result.length ? result : typ == "string" ? obj : obj + "\0";
        }
        function mixkey(seed, key) {
          var stringseed = seed + "", smear, j = 0;
          while (j < stringseed.length) {
            key[mask & j] = mask & (smear ^= key[mask & j] * 19) + stringseed.charCodeAt(j++);
          }
          return tostring(key);
        }
        function autoseed() {
          try {
            var out;
            if (nodecrypto && (out = nodecrypto.randomBytes)) {
              out = out(width);
            } else {
              out = new Uint8Array(width);
              (global.crypto || global.msCrypto).getRandomValues(out);
            }
            return tostring(out);
          } catch (e) {
            var browser = global.navigator, plugins = browser && browser.plugins;
            return [+/* @__PURE__ */ new Date(), global, plugins, global.screen, tostring(pool)];
          }
        }
        function tostring(a) {
          return String.fromCharCode.apply(0, a);
        }
        mixkey(math.random(), pool);
        if (typeof module == "object" && module.exports) {
          module.exports = seedrandom;
          try {
            nodecrypto = require_crypto();
          } catch (ex) {
          }
        } else if (typeof define == "function" && define.amd) {
          define(function() {
            return seedrandom;
          });
        } else {
          math["seed" + rngname] = seedrandom;
        }
      })(
        // global: `self` in browsers (including strict mode and web workers),
        // otherwise `this` in Node and other environments
        typeof self !== "undefined" ? self : exports,
        [],
        // pool: entropy pool starts empty
        Math
        // math: package containing random, pow, and seedrandom
      );
    }
  });

  // node_modules/.pnpm/seedrandom@3.0.5/node_modules/seedrandom/index.js
  var require_seedrandom2 = __commonJS({
    "node_modules/.pnpm/seedrandom@3.0.5/node_modules/seedrandom/index.js"(exports, module) {
      var alea = require_alea();
      var xor128 = require_xor128();
      var xorwow = require_xorwow();
      var xorshift7 = require_xorshift7();
      var xor4096 = require_xor4096();
      var tychei = require_tychei();
      var sr = require_seedrandom();
      sr.alea = alea;
      sr.xor128 = xor128;
      sr.xorwow = xorwow;
      sr.xorshift7 = xorshift7;
      sr.xor4096 = xor4096;
      sr.tychei = tychei;
      module.exports = sr;
    }
  });

  // node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/function/probability/util/seededRNG.js
  var require_seededRNG = __commonJS({
    "node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/function/probability/util/seededRNG.js"(exports) {
      "use strict";
      var _interopRequireDefault = require_interopRequireDefault();
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.createRng = createRng;
      var _seedrandom = _interopRequireDefault(require_seedrandom2());
      var singletonRandom = /* @__PURE__ */ (0, _seedrandom["default"])(Date.now());
      function createRng(randomSeed) {
        var random2;
        function setSeed(seed) {
          random2 = seed === null ? singletonRandom : (0, _seedrandom["default"])(String(seed));
        }
        setSeed(randomSeed);
        function rng() {
          return random2();
        }
        return rng;
      }
    }
  });

  // node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/function/probability/pickRandom.js
  var require_pickRandom2 = __commonJS({
    "node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/function/probability/pickRandom.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.createPickRandom = void 0;
      var _array = require_array();
      var _factory = require_factory();
      var _is = require_is();
      var _seededRNG = require_seededRNG();
      var name18 = "pickRandom";
      var dependencies19 = ["typed", "config", "?on"];
      var createPickRandom2 = exports.createPickRandom = /* @__PURE__ */ (0, _factory.factory)(name18, dependencies19, function(_ref) {
        var typed2 = _ref.typed, config4 = _ref.config, on = _ref.on;
        var rng = (0, _seededRNG.createRng)(config4.randomSeed);
        if (on) {
          on("config", function(curr, prev) {
            if (curr.randomSeed !== prev.randomSeed) {
              rng = (0, _seededRNG.createRng)(curr.randomSeed);
            }
          });
        }
        return typed2(name18, {
          "Array | Matrix": function ArrayMatrix(possibles) {
            return _pickRandom(possibles, {});
          },
          "Array | Matrix, Object": function ArrayMatrixObject(possibles, options) {
            return _pickRandom(possibles, options);
          },
          "Array | Matrix, number": function ArrayMatrixNumber(possibles, number) {
            return _pickRandom(possibles, {
              number
            });
          },
          "Array | Matrix, Array | Matrix": function ArrayMatrixArrayMatrix(possibles, weights) {
            return _pickRandom(possibles, {
              weights
            });
          },
          "Array | Matrix, Array | Matrix, number": function ArrayMatrixArrayMatrixNumber(possibles, weights, number) {
            return _pickRandom(possibles, {
              number,
              weights
            });
          },
          "Array | Matrix, number, Array | Matrix": function ArrayMatrixNumberArrayMatrix(possibles, number, weights) {
            return _pickRandom(possibles, {
              number,
              weights
            });
          }
        });
        function _pickRandom(possibles, _ref2) {
          var number = _ref2.number, weights = _ref2.weights, _ref2$elementWise = _ref2.elementWise, elementWise = _ref2$elementWise === void 0 ? true : _ref2$elementWise;
          var single = typeof number === "undefined";
          if (single) {
            number = 1;
          }
          var createMatrix2 = (0, _is.isMatrix)(possibles) ? possibles.create : (0, _is.isMatrix)(weights) ? weights.create : null;
          possibles = possibles.valueOf();
          if (weights) {
            weights = weights.valueOf();
          }
          if (elementWise === true) {
            possibles = (0, _array.flatten)(possibles);
            weights = (0, _array.flatten)(weights);
          }
          var totalWeights = 0;
          if (typeof weights !== "undefined") {
            if (weights.length !== possibles.length) {
              throw new Error("Weights must have the same length as possibles");
            }
            for (var i = 0, len = weights.length; i < len; i++) {
              if (!(0, _is.isNumber)(weights[i]) || weights[i] < 0) {
                throw new Error("Weights must be an array of positive numbers");
              }
              totalWeights += weights[i];
            }
          }
          var length = possibles.length;
          var result = [];
          var pick;
          while (result.length < number) {
            if (typeof weights === "undefined") {
              pick = possibles[Math.floor(rng() * length)];
            } else {
              var randKey = rng() * totalWeights;
              for (var _i = 0, _len = possibles.length; _i < _len; _i++) {
                randKey -= weights[_i];
                if (randKey < 0) {
                  pick = possibles[_i];
                  break;
                }
              }
            }
            result.push(pick);
          }
          return single ? result[0] : createMatrix2 ? createMatrix2(result) : result;
        }
      });
    }
  });

  // node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/function/probability/util/randomMatrix.js
  var require_randomMatrix = __commonJS({
    "node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/function/probability/util/randomMatrix.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.randomMatrix = randomMatrix;
      function randomMatrix(size2, random2) {
        var data = [];
        size2 = size2.slice(0);
        if (size2.length > 1) {
          for (var i = 0, length = size2.shift(); i < length; i++) {
            data.push(randomMatrix(size2, random2));
          }
        } else {
          for (var _i = 0, _length = size2.shift(); _i < _length; _i++) {
            data.push(random2());
          }
        }
        return data;
      }
    }
  });

  // node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/function/probability/random.js
  var require_random2 = __commonJS({
    "node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/function/probability/random.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.createRandomNumber = exports.createRandom = void 0;
      var _factory = require_factory();
      var _is = require_is();
      var _seededRNG = require_seededRNG();
      var _randomMatrix2 = require_randomMatrix();
      var name18 = "random";
      var dependencies19 = ["typed", "config", "?on"];
      var createRandom2 = exports.createRandom = /* @__PURE__ */ (0, _factory.factory)(name18, dependencies19, function(_ref) {
        var typed2 = _ref.typed, config4 = _ref.config, on = _ref.on;
        var rng = (0, _seededRNG.createRng)(config4.randomSeed);
        if (on) {
          on("config", function(curr, prev) {
            if (curr.randomSeed !== prev.randomSeed) {
              rng = (0, _seededRNG.createRng)(curr.randomSeed);
            }
          });
        }
        return typed2(name18, {
          "": function _() {
            return _random(0, 1);
          },
          number: function number(max2) {
            return _random(0, max2);
          },
          "number, number": function numberNumber(min2, max2) {
            return _random(min2, max2);
          },
          "Array | Matrix": function ArrayMatrix(size2) {
            return _randomMatrix(size2, 0, 1);
          },
          "Array | Matrix, number": function ArrayMatrixNumber(size2, max2) {
            return _randomMatrix(size2, 0, max2);
          },
          "Array | Matrix, number, number": function ArrayMatrixNumberNumber(size2, min2, max2) {
            return _randomMatrix(size2, min2, max2);
          }
        });
        function _randomMatrix(size2, min2, max2) {
          var res = (0, _randomMatrix2.randomMatrix)(size2.valueOf(), function() {
            return _random(min2, max2);
          });
          return (0, _is.isMatrix)(size2) ? size2.create(res) : res;
        }
        function _random(min2, max2) {
          return min2 + rng() * (max2 - min2);
        }
      });
      var createRandomNumber = exports.createRandomNumber = /* @__PURE__ */ (0, _factory.factory)(name18, ["typed", "config", "?on"], function(_ref2) {
        var typed2 = _ref2.typed, config4 = _ref2.config, on = _ref2.on, matrix2 = _ref2.matrix;
        var rng = (0, _seededRNG.createRng)(config4.randomSeed);
        if (on) {
          on("config", function(curr, prev) {
            if (curr.randomSeed !== prev.randomSeed) {
              rng = (0, _seededRNG.createRng)(curr.randomSeed);
            }
          });
        }
        return typed2(name18, {
          "": function _() {
            return _random(0, 1);
          },
          number: function number(max2) {
            return _random(0, max2);
          },
          "number, number": function numberNumber(min2, max2) {
            return _random(min2, max2);
          }
        });
        function _random(min2, max2) {
          return min2 + rng() * (max2 - min2);
        }
      });
    }
  });

  // node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/function/probability/randomInt.js
  var require_randomInt2 = __commonJS({
    "node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/function/probability/randomInt.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.createRandomInt = void 0;
      var _factory = require_factory();
      var _randomMatrix = require_randomMatrix();
      var _seededRNG = require_seededRNG();
      var _is = require_is();
      var name18 = "randomInt";
      var dependencies19 = ["typed", "config", "?on"];
      var createRandomInt2 = exports.createRandomInt = /* @__PURE__ */ (0, _factory.factory)(name18, dependencies19, function(_ref) {
        var typed2 = _ref.typed, config4 = _ref.config, on = _ref.on;
        var rng = (0, _seededRNG.createRng)(config4.randomSeed);
        if (on) {
          on("config", function(curr, prev) {
            if (curr.randomSeed !== prev.randomSeed) {
              rng = (0, _seededRNG.createRng)(curr.randomSeed);
            }
          });
        }
        return typed2(name18, {
          "": function _() {
            return _randomInt(0, 1);
          },
          number: function number(max2) {
            return _randomInt(0, max2);
          },
          "number, number": function numberNumber(min2, max2) {
            return _randomInt(min2, max2);
          },
          "Array | Matrix": function ArrayMatrix(size2) {
            return _randomIntMatrix(size2, 0, 1);
          },
          "Array | Matrix, number": function ArrayMatrixNumber(size2, max2) {
            return _randomIntMatrix(size2, 0, max2);
          },
          "Array | Matrix, number, number": function ArrayMatrixNumberNumber(size2, min2, max2) {
            return _randomIntMatrix(size2, min2, max2);
          }
        });
        function _randomIntMatrix(size2, min2, max2) {
          var res = (0, _randomMatrix.randomMatrix)(size2.valueOf(), function() {
            return _randomInt(min2, max2);
          });
          return (0, _is.isMatrix)(size2) ? size2.create(res) : res;
        }
        function _randomInt(min2, max2) {
          return Math.floor(min2 + rng() * (max2 - min2));
        }
      });
    }
  });

  // node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/function/combinatorics/stirlingS2.js
  var require_stirlingS22 = __commonJS({
    "node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/function/combinatorics/stirlingS2.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.createStirlingS2 = void 0;
      var _factory = require_factory();
      var _is = require_is();
      var name18 = "stirlingS2";
      var dependencies19 = ["typed", "addScalar", "subtractScalar", "multiplyScalar", "divideScalar", "pow", "factorial", "combinations", "isNegative", "isInteger", "number", "?bignumber", "larger"];
      var createStirlingS22 = exports.createStirlingS2 = /* @__PURE__ */ (0, _factory.factory)(name18, dependencies19, function(_ref) {
        var typed2 = _ref.typed, addScalar2 = _ref.addScalar, subtractScalar = _ref.subtractScalar, multiplyScalar2 = _ref.multiplyScalar, divideScalar = _ref.divideScalar, pow2 = _ref.pow, factorial = _ref.factorial, combinations = _ref.combinations, isNegative = _ref.isNegative, isInteger2 = _ref.isInteger, number = _ref.number, bignumber = _ref.bignumber, larger = _ref.larger;
        var smallCache = [];
        var bigCache = [];
        return typed2(name18, {
          "number | BigNumber, number | BigNumber": function numberBigNumberNumberBigNumber(n, k) {
            if (!isInteger2(n) || isNegative(n) || !isInteger2(k) || isNegative(k)) {
              throw new TypeError("Non-negative integer value expected in function stirlingS2");
            } else if (larger(k, n)) {
              throw new TypeError("k must be less than or equal to n in function stirlingS2");
            }
            var big = !((0, _is.isNumber)(n) && (0, _is.isNumber)(k));
            var cache = big ? bigCache : smallCache;
            var make = big ? bignumber : number;
            var nn = number(n);
            var nk = number(k);
            if (cache[nn] && cache[nn].length > nk) {
              return cache[nn][nk];
            }
            for (var m = 0; m <= nn; ++m) {
              if (!cache[m]) {
                cache[m] = [m === 0 ? make(1) : make(0)];
              }
              if (m === 0) continue;
              var row = cache[m];
              var prev = cache[m - 1];
              for (var i = row.length; i <= m && i <= nk; ++i) {
                if (i === m) {
                  row[i] = 1;
                } else {
                  row[i] = addScalar2(multiplyScalar2(make(i), prev[i]), prev[i - 1]);
                }
              }
            }
            return cache[nn][nk];
          }
        });
      });
    }
  });

  // node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/function/combinatorics/bellNumbers.js
  var require_bellNumbers2 = __commonJS({
    "node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/function/combinatorics/bellNumbers.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.createBellNumbers = void 0;
      var _factory = require_factory();
      var name18 = "bellNumbers";
      var dependencies19 = ["typed", "addScalar", "isNegative", "isInteger", "stirlingS2"];
      var createBellNumbers2 = exports.createBellNumbers = /* @__PURE__ */ (0, _factory.factory)(name18, dependencies19, function(_ref) {
        var typed2 = _ref.typed, addScalar2 = _ref.addScalar, isNegative = _ref.isNegative, isInteger2 = _ref.isInteger, stirlingS2 = _ref.stirlingS2;
        return typed2(name18, {
          "number | BigNumber": function numberBigNumber(n) {
            if (!isInteger2(n) || isNegative(n)) {
              throw new TypeError("Non-negative integer value expected in function bellNumbers");
            }
            var result = 0;
            for (var i = 0; i <= n; i++) {
              result = addScalar2(result, stirlingS2(n, i));
            }
            return result;
          }
        });
      });
    }
  });

  // node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/function/combinatorics/catalan.js
  var require_catalan2 = __commonJS({
    "node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/function/combinatorics/catalan.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.createCatalan = void 0;
      var _factory = require_factory();
      var name18 = "catalan";
      var dependencies19 = ["typed", "addScalar", "divideScalar", "multiplyScalar", "combinations", "isNegative", "isInteger"];
      var createCatalan2 = exports.createCatalan = /* @__PURE__ */ (0, _factory.factory)(name18, dependencies19, function(_ref) {
        var typed2 = _ref.typed, addScalar2 = _ref.addScalar, divideScalar = _ref.divideScalar, multiplyScalar2 = _ref.multiplyScalar, combinations = _ref.combinations, isNegative = _ref.isNegative, isInteger2 = _ref.isInteger;
        return typed2(name18, {
          "number | BigNumber": function numberBigNumber(n) {
            if (!isInteger2(n) || isNegative(n)) {
              throw new TypeError("Non-negative integer value expected in function catalan");
            }
            return divideScalar(combinations(multiplyScalar2(n, 2), n), addScalar2(n, 1));
          }
        });
      });
    }
  });

  // node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/function/combinatorics/composition.js
  var require_composition2 = __commonJS({
    "node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/function/combinatorics/composition.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.createComposition = void 0;
      var _factory = require_factory();
      var name18 = "composition";
      var dependencies19 = ["typed", "addScalar", "combinations", "isNegative", "isPositive", "isInteger", "larger"];
      var createComposition2 = exports.createComposition = /* @__PURE__ */ (0, _factory.factory)(name18, dependencies19, function(_ref) {
        var typed2 = _ref.typed, addScalar2 = _ref.addScalar, combinations = _ref.combinations, isPositive = _ref.isPositive, isNegative = _ref.isNegative, isInteger2 = _ref.isInteger, larger = _ref.larger;
        return typed2(name18, {
          "number | BigNumber, number | BigNumber": function numberBigNumberNumberBigNumber(n, k) {
            if (!isInteger2(n) || !isPositive(n) || !isInteger2(k) || !isPositive(k)) {
              throw new TypeError("Positive integer value expected in function composition");
            } else if (larger(k, n)) {
              throw new TypeError("k must be less than or equal to n in function composition");
            }
            return combinations(addScalar2(n, -1), addScalar2(k, -1));
          }
        });
      });
    }
  });

  // node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/function/algebra/leafCount.js
  var require_leafCount2 = __commonJS({
    "node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/function/algebra/leafCount.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.createLeafCount = void 0;
      var _factory = require_factory();
      var name18 = "leafCount";
      var dependencies19 = ["parse", "typed"];
      var createLeafCount = exports.createLeafCount = /* @__PURE__ */ (0, _factory.factory)(name18, dependencies19, function(_ref) {
        var parse2 = _ref.parse, typed2 = _ref.typed;
        function countLeaves(node) {
          var count = 0;
          node.forEach(function(n) {
            count += countLeaves(n);
          });
          return count || 1;
        }
        return typed2(name18, {
          Node: function Node(expr) {
            return countLeaves(expr);
          }
        });
      });
    }
  });

  // node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/function/algebra/simplify/wildcards.js
  var require_wildcards = __commonJS({
    "node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/function/algebra/simplify/wildcards.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.isConstantExpression = isConstantExpression;
      Object.defineProperty(exports, "isConstantNode", {
        enumerable: true,
        get: function get() {
          return _is.isConstantNode;
        }
      });
      exports.isNumericNode = isNumericNode;
      Object.defineProperty(exports, "isVariableNode", {
        enumerable: true,
        get: function get() {
          return _is.isSymbolNode;
        }
      });
      var _is = require_is();
      function isNumericNode(x) {
        return (0, _is.isConstantNode)(x) || (0, _is.isOperatorNode)(x) && x.isUnary() && (0, _is.isConstantNode)(x.args[0]);
      }
      function isConstantExpression(x) {
        if ((0, _is.isConstantNode)(x)) {
          return true;
        }
        if (((0, _is.isFunctionNode)(x) || (0, _is.isOperatorNode)(x)) && x.args.every(isConstantExpression)) {
          return true;
        }
        if ((0, _is.isParenthesisNode)(x) && isConstantExpression(x.content)) {
          return true;
        }
        return false;
      }
    }
  });

  // node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/function/algebra/simplify/util.js
  var require_util = __commonJS({
    "node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/function/algebra/simplify/util.js"(exports) {
      "use strict";
      var _interopRequireDefault = require_interopRequireDefault();
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.createUtil = void 0;
      var _defineProperty2 = _interopRequireDefault(require_defineProperty());
      var _is = require_is();
      var _factory = require_factory();
      var _object = require_object();
      function ownKeys(e, r) {
        var t = Object.keys(e);
        if (Object.getOwnPropertySymbols) {
          var o = Object.getOwnPropertySymbols(e);
          r && (o = o.filter(function(r2) {
            return Object.getOwnPropertyDescriptor(e, r2).enumerable;
          })), t.push.apply(t, o);
        }
        return t;
      }
      function _objectSpread(e) {
        for (var r = 1; r < arguments.length; r++) {
          var t = null != arguments[r] ? arguments[r] : {};
          r % 2 ? ownKeys(Object(t), true).forEach(function(r2) {
            (0, _defineProperty2["default"])(e, r2, t[r2]);
          }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function(r2) {
            Object.defineProperty(e, r2, Object.getOwnPropertyDescriptor(t, r2));
          });
        }
        return e;
      }
      var name18 = "simplifyUtil";
      var dependencies19 = ["FunctionNode", "OperatorNode", "SymbolNode"];
      var createUtil = exports.createUtil = /* @__PURE__ */ (0, _factory.factory)(name18, dependencies19, function(_ref) {
        var FunctionNode = _ref.FunctionNode, OperatorNode = _ref.OperatorNode, SymbolNode = _ref.SymbolNode;
        var T = true;
        var F = false;
        var defaultName = "defaultF";
        var defaultContext = {
          /*      */
          add: {
            trivial: T,
            total: T,
            commutative: T,
            associative: T
          },
          /**/
          unaryPlus: {
            trivial: T,
            total: T,
            commutative: T,
            associative: T
          },
          /* */
          subtract: {
            trivial: F,
            total: T,
            commutative: F,
            associative: F
          },
          /* */
          multiply: {
            trivial: T,
            total: T,
            commutative: T,
            associative: T
          },
          /*   */
          divide: {
            trivial: F,
            total: T,
            commutative: F,
            associative: F
          },
          /*    */
          paren: {
            trivial: T,
            total: T,
            commutative: T,
            associative: F
          },
          /* */
          defaultF: {
            trivial: F,
            total: T,
            commutative: F,
            associative: F
          }
        };
        var realContext = {
          divide: {
            total: F
          },
          log: {
            total: F
          }
        };
        var positiveContext = {
          subtract: {
            total: F
          },
          abs: {
            trivial: T
          },
          log: {
            total: T
          }
        };
        function hasProperty(nodeOrName, property) {
          var context = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : defaultContext;
          var name19 = defaultName;
          if (typeof nodeOrName === "string") {
            name19 = nodeOrName;
          } else if ((0, _is.isOperatorNode)(nodeOrName)) {
            name19 = nodeOrName.fn.toString();
          } else if ((0, _is.isFunctionNode)(nodeOrName)) {
            name19 = nodeOrName.name;
          } else if ((0, _is.isParenthesisNode)(nodeOrName)) {
            name19 = "paren";
          }
          if ((0, _object.hasOwnProperty)(context, name19)) {
            var properties = context[name19];
            if ((0, _object.hasOwnProperty)(properties, property)) {
              return properties[property];
            }
            if ((0, _object.hasOwnProperty)(defaultContext, name19)) {
              return defaultContext[name19][property];
            }
          }
          if ((0, _object.hasOwnProperty)(context, defaultName)) {
            var _properties = context[defaultName];
            if ((0, _object.hasOwnProperty)(_properties, property)) {
              return _properties[property];
            }
            return defaultContext[defaultName][property];
          }
          if ((0, _object.hasOwnProperty)(defaultContext, name19)) {
            var _properties2 = defaultContext[name19];
            if ((0, _object.hasOwnProperty)(_properties2, property)) {
              return _properties2[property];
            }
          }
          return defaultContext[defaultName][property];
        }
        function isCommutative(node) {
          var context = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : defaultContext;
          return hasProperty(node, "commutative", context);
        }
        function isAssociative(node) {
          var context = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : defaultContext;
          return hasProperty(node, "associative", context);
        }
        function mergeContext(primary, secondary) {
          var merged = _objectSpread({}, primary);
          for (var prop in secondary) {
            if ((0, _object.hasOwnProperty)(primary, prop)) {
              merged[prop] = _objectSpread(_objectSpread({}, secondary[prop]), primary[prop]);
            } else {
              merged[prop] = secondary[prop];
            }
          }
          return merged;
        }
        function flatten2(node, context) {
          if (!node.args || node.args.length === 0) {
            return node;
          }
          node.args = allChildren(node, context);
          for (var i = 0; i < node.args.length; i++) {
            flatten2(node.args[i], context);
          }
        }
        function allChildren(node, context) {
          var op;
          var children = [];
          var findChildren = function findChildren2(node2) {
            for (var i = 0; i < node2.args.length; i++) {
              var child = node2.args[i];
              if ((0, _is.isOperatorNode)(child) && op === child.op) {
                findChildren2(child);
              } else {
                children.push(child);
              }
            }
          };
          if (isAssociative(node, context)) {
            op = node.op;
            findChildren(node);
            return children;
          } else {
            return node.args;
          }
        }
        function unflattenr(node, context) {
          if (!node.args || node.args.length === 0) {
            return;
          }
          var makeNode = createMakeNodeFunction(node);
          var l = node.args.length;
          for (var i = 0; i < l; i++) {
            unflattenr(node.args[i], context);
          }
          if (l > 2 && isAssociative(node, context)) {
            var curnode = node.args.pop();
            while (node.args.length > 0) {
              curnode = makeNode([node.args.pop(), curnode]);
            }
            node.args = curnode.args;
          }
        }
        function unflattenl(node, context) {
          if (!node.args || node.args.length === 0) {
            return;
          }
          var makeNode = createMakeNodeFunction(node);
          var l = node.args.length;
          for (var i = 0; i < l; i++) {
            unflattenl(node.args[i], context);
          }
          if (l > 2 && isAssociative(node, context)) {
            var curnode = node.args.shift();
            while (node.args.length > 0) {
              curnode = makeNode([curnode, node.args.shift()]);
            }
            node.args = curnode.args;
          }
        }
        function createMakeNodeFunction(node) {
          if ((0, _is.isOperatorNode)(node)) {
            return function(args) {
              try {
                return new OperatorNode(node.op, node.fn, args, node.implicit);
              } catch (err) {
                console.error(err);
                return [];
              }
            };
          } else {
            return function(args) {
              return new FunctionNode(new SymbolNode(node.name), args);
            };
          }
        }
        return {
          createMakeNodeFunction,
          hasProperty,
          isCommutative,
          isAssociative,
          mergeContext,
          flatten: flatten2,
          allChildren,
          unflattenr,
          unflattenl,
          defaultContext,
          realContext,
          positiveContext
        };
      });
    }
  });

  // node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/function/algebra/simplify.js
  var require_simplify2 = __commonJS({
    "node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/function/algebra/simplify.js"(exports) {
      "use strict";
      var _interopRequireDefault = require_interopRequireDefault();
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.createSimplify = void 0;
      var _typeof2 = _interopRequireDefault(require_typeof());
      var _is = require_is();
      var _wildcards = require_wildcards();
      var _factory = require_factory();
      var _util = require_util();
      var _object = require_object();
      var _map = require_map();
      var name18 = "simplify";
      var dependencies19 = ["config", "typed", "parse", "add", "subtract", "multiply", "divide", "pow", "isZero", "equal", "resolve", "simplifyConstant", "simplifyCore", "?fraction", "?bignumber", "mathWithTransform", "matrix", "AccessorNode", "ArrayNode", "ConstantNode", "FunctionNode", "IndexNode", "ObjectNode", "OperatorNode", "ParenthesisNode", "SymbolNode"];
      var createSimplify = exports.createSimplify = /* @__PURE__ */ (0, _factory.factory)(name18, dependencies19, function(_ref) {
        var config4 = _ref.config, typed2 = _ref.typed, parse2 = _ref.parse, add2 = _ref.add, subtract = _ref.subtract, multiply2 = _ref.multiply, divide2 = _ref.divide, pow2 = _ref.pow, isZero = _ref.isZero, equal = _ref.equal, resolve = _ref.resolve, simplifyConstant = _ref.simplifyConstant, simplifyCore = _ref.simplifyCore, fraction = _ref.fraction, bignumber = _ref.bignumber, mathWithTransform = _ref.mathWithTransform, matrix2 = _ref.matrix, AccessorNode = _ref.AccessorNode, ArrayNode = _ref.ArrayNode, ConstantNode = _ref.ConstantNode, FunctionNode = _ref.FunctionNode, IndexNode = _ref.IndexNode, ObjectNode = _ref.ObjectNode, OperatorNode = _ref.OperatorNode, ParenthesisNode = _ref.ParenthesisNode, SymbolNode = _ref.SymbolNode;
        var _createUtil = (0, _util.createUtil)({
          FunctionNode,
          OperatorNode,
          SymbolNode
        }), hasProperty = _createUtil.hasProperty, isCommutative = _createUtil.isCommutative, isAssociative = _createUtil.isAssociative, mergeContext = _createUtil.mergeContext, flatten2 = _createUtil.flatten, unflattenr = _createUtil.unflattenr, unflattenl = _createUtil.unflattenl, createMakeNodeFunction = _createUtil.createMakeNodeFunction, defaultContext = _createUtil.defaultContext, realContext = _createUtil.realContext, positiveContext = _createUtil.positiveContext;
        typed2.addConversion({
          from: "Object",
          to: "Map",
          convert: _map.createMap
        });
        var simplify = typed2("simplify", {
          Node: _simplify,
          "Node, Map": function NodeMap(expr, scope) {
            return _simplify(expr, false, scope);
          },
          "Node, Map, Object": function NodeMapObject(expr, scope, options) {
            return _simplify(expr, false, scope, options);
          },
          "Node, Array": _simplify,
          "Node, Array, Map": _simplify,
          "Node, Array, Map, Object": _simplify
        });
        typed2.removeConversion({
          from: "Object",
          to: "Map",
          convert: _map.createMap
        });
        simplify.defaultContext = defaultContext;
        simplify.realContext = realContext;
        simplify.positiveContext = positiveContext;
        function removeParens(node) {
          return node.transform(function(node2, path, parent) {
            return (0, _is.isParenthesisNode)(node2) ? removeParens(node2.content) : node2;
          });
        }
        var SUPPORTED_CONSTANTS = {
          "true": true,
          "false": true,
          e: true,
          i: true,
          Infinity: true,
          LN2: true,
          LN10: true,
          LOG2E: true,
          LOG10E: true,
          NaN: true,
          phi: true,
          pi: true,
          SQRT1_2: true,
          SQRT2: true,
          tau: true
          // null: false,
          // undefined: false,
          // version: false,
        };
        simplify.rules = [
          simplifyCore,
          // { l: 'n+0', r: 'n' },     // simplifyCore
          // { l: 'n^0', r: '1' },     // simplifyCore
          // { l: '0*n', r: '0' },     // simplifyCore
          // { l: 'n/n', r: '1'},      // simplifyCore
          // { l: 'n^1', r: 'n' },     // simplifyCore
          // { l: '+n1', r:'n1' },     // simplifyCore
          // { l: 'n--n1', r:'n+n1' }, // simplifyCore
          {
            l: "log(e)",
            r: "1"
          },
          // temporary rules
          // Note initially we tend constants to the right because like-term
          // collection prefers the left, and we would rather collect nonconstants
          {
            s: "n-n1 -> n+-n1",
            // temporarily replace 'subtract' so we can further flatten the 'add' operator
            assuming: {
              subtract: {
                total: true
              }
            }
          },
          {
            s: "n-n -> 0",
            // partial alternative when we can't always subtract
            assuming: {
              subtract: {
                total: false
              }
            }
          },
          {
            s: "-(cl*v) -> v * (-cl)",
            // make non-constant terms positive
            assuming: {
              multiply: {
                commutative: true
              },
              subtract: {
                total: true
              }
            }
          },
          {
            s: "-(cl*v) -> (-cl) * v",
            // non-commutative version, part 1
            assuming: {
              multiply: {
                commutative: false
              },
              subtract: {
                total: true
              }
            }
          },
          {
            s: "-(v*cl) -> v * (-cl)",
            // non-commutative version, part 2
            assuming: {
              multiply: {
                commutative: false
              },
              subtract: {
                total: true
              }
            }
          },
          {
            l: "-(n1/n2)",
            r: "-n1/n2"
          },
          {
            l: "-v",
            r: "v * (-1)"
          },
          // finish making non-constant terms positive
          {
            l: "(n1 + n2)*(-1)",
            r: "n1*(-1) + n2*(-1)",
            repeat: true
          },
          // expand negations to achieve as much sign cancellation as possible
          {
            l: "n/n1^n2",
            r: "n*n1^-n2"
          },
          // temporarily replace 'divide' so we can further flatten the 'multiply' operator
          {
            l: "n/n1",
            r: "n*n1^-1"
          },
          {
            s: "(n1*n2)^n3 -> n1^n3 * n2^n3",
            assuming: {
              multiply: {
                commutative: true
              }
            }
          },
          {
            s: "(n1*n2)^(-1) -> n2^(-1) * n1^(-1)",
            assuming: {
              multiply: {
                commutative: false
              }
            }
          },
          // expand nested exponentiation
          {
            s: "(n ^ n1) ^ n2 -> n ^ (n1 * n2)",
            assuming: {
              divide: {
                total: true
              }
            }
            // 1/(1/n) = n needs 1/n to exist
          },
          // collect like factors; into a sum, only do this for nonconstants
          {
            l: " vd   * ( vd   * n1 + n2)",
            r: "vd^2       * n1 +  vd   * n2"
          },
          {
            s: " vd   * (vd^n4 * n1 + n2)   ->  vd^(1+n4)  * n1 +  vd   * n2",
            assuming: {
              divide: {
                total: true
              }
            }
            // v*1/v = v^(1+-1) needs 1/v
          },
          {
            s: "vd^n3 * ( vd   * n1 + n2)   ->  vd^(n3+1)  * n1 + vd^n3 * n2",
            assuming: {
              divide: {
                total: true
              }
            }
          },
          {
            s: "vd^n3 * (vd^n4 * n1 + n2)   ->  vd^(n3+n4) * n1 + vd^n3 * n2",
            assuming: {
              divide: {
                total: true
              }
            }
          },
          {
            l: "n*n",
            r: "n^2"
          },
          {
            s: "n * n^n1 -> n^(n1+1)",
            assuming: {
              divide: {
                total: true
              }
            }
            // n*1/n = n^(-1+1) needs 1/n
          },
          {
            s: "n^n1 * n^n2 -> n^(n1+n2)",
            assuming: {
              divide: {
                total: true
              }
            }
            // ditto for n^2*1/n^2
          },
          // Unfortunately, to deal with more complicated cancellations, it
          // becomes necessary to simplify constants twice per pass. It's not
          // terribly expensive compared to matching rules, so this should not
          // pose a performance problem.
          simplifyConstant,
          // First: before collecting like terms
          // collect like terms
          {
            s: "n+n -> 2*n",
            assuming: {
              add: {
                total: true
              }
            }
            // 2 = 1 + 1 needs to exist
          },
          {
            l: "n+-n",
            r: "0"
          },
          {
            l: "vd*n + vd",
            r: "vd*(n+1)"
          },
          // NOTE: leftmost position is special:
          {
            l: "n3*n1 + n3*n2",
            r: "n3*(n1+n2)"
          },
          // All sub-monomials tried there.
          {
            l: "n3^(-n4)*n1 +   n3  * n2",
            r: "n3^(-n4)*(n1 + n3^(n4+1) *n2)"
          },
          {
            l: "n3^(-n4)*n1 + n3^n5 * n2",
            r: "n3^(-n4)*(n1 + n3^(n4+n5)*n2)"
          },
          // noncommutative additional cases (term collection & factoring)
          {
            s: "n*vd + vd -> (n+1)*vd",
            assuming: {
              multiply: {
                commutative: false
              }
            }
          },
          {
            s: "vd + n*vd -> (1+n)*vd",
            assuming: {
              multiply: {
                commutative: false
              }
            }
          },
          {
            s: "n1*n3 + n2*n3 -> (n1+n2)*n3",
            assuming: {
              multiply: {
                commutative: false
              }
            }
          },
          {
            s: "n^n1 * n -> n^(n1+1)",
            assuming: {
              divide: {
                total: true
              },
              multiply: {
                commutative: false
              }
            }
          },
          {
            s: "n1*n3^(-n4) + n2 * n3    -> (n1 + n2*n3^(n4 +  1))*n3^(-n4)",
            assuming: {
              multiply: {
                commutative: false
              }
            }
          },
          {
            s: "n1*n3^(-n4) + n2 * n3^n5 -> (n1 + n2*n3^(n4 + n5))*n3^(-n4)",
            assuming: {
              multiply: {
                commutative: false
              }
            }
          },
          {
            l: "n*cd + cd",
            r: "(n+1)*cd"
          },
          {
            s: "cd*n + cd -> cd*(n+1)",
            assuming: {
              multiply: {
                commutative: false
              }
            }
          },
          {
            s: "cd + cd*n -> cd*(1+n)",
            assuming: {
              multiply: {
                commutative: false
              }
            }
          },
          simplifyConstant,
          // Second: before returning expressions to "standard form"
          // make factors positive (and undo 'make non-constant terms positive')
          {
            s: "(-n)*n1 -> -(n*n1)",
            assuming: {
              subtract: {
                total: true
              }
            }
          },
          {
            s: "n1*(-n) -> -(n1*n)",
            // in case * non-commutative
            assuming: {
              subtract: {
                total: true
              },
              multiply: {
                commutative: false
              }
            }
          },
          // final ordering of constants
          {
            s: "ce+ve -> ve+ce",
            assuming: {
              add: {
                commutative: true
              }
            },
            imposeContext: {
              add: {
                commutative: false
              }
            }
          },
          {
            s: "vd*cd -> cd*vd",
            assuming: {
              multiply: {
                commutative: true
              }
            },
            imposeContext: {
              multiply: {
                commutative: false
              }
            }
          },
          // undo temporary rules
          // { l: '(-1) * n', r: '-n' }, // #811 added test which proved this is redundant
          {
            l: "n+-n1",
            r: "n-n1"
          },
          // undo replace 'subtract'
          {
            l: "n+-(n1)",
            r: "n-(n1)"
          },
          {
            s: "n*(n1^-1) -> n/n1",
            // undo replace 'divide'; for * commutative
            assuming: {
              multiply: {
                commutative: true
              }
            }
            // o.w. / not conventional
          },
          {
            s: "n*n1^-n2 -> n/n1^n2",
            assuming: {
              multiply: {
                commutative: true
              }
            }
            // o.w. / not conventional
          },
          {
            s: "n^-1 -> 1/n",
            assuming: {
              multiply: {
                commutative: true
              }
            }
            // o.w. / not conventional
          },
          {
            l: "n^1",
            r: "n"
          },
          // can be produced by power cancellation
          {
            s: "n*(n1/n2) -> (n*n1)/n2",
            // '*' before '/'
            assuming: {
              multiply: {
                associative: true
              }
            }
          },
          {
            s: "n-(n1+n2) -> n-n1-n2",
            // '-' before '+'
            assuming: {
              addition: {
                associative: true,
                commutative: true
              }
            }
          },
          // { l: '(n1/n2)/n3', r: 'n1/(n2*n3)' },
          // { l: '(n*n1)/(n*n2)', r: 'n1/n2' },
          // simplifyConstant can leave an extra factor of 1, which can always
          // be eliminated, since the identity always commutes
          {
            l: "1*n",
            r: "n",
            imposeContext: {
              multiply: {
                commutative: true
              }
            }
          },
          {
            s: "n1/(n2/n3) -> (n1*n3)/n2",
            assuming: {
              multiply: {
                associative: true
              }
            }
          },
          {
            l: "n1/(-n2)",
            r: "-n1/n2"
          }
        ];
        function _canonicalizeRule(ruleObject, context) {
          var newRule = {};
          if (ruleObject.s) {
            var lr = ruleObject.s.split("->");
            if (lr.length === 2) {
              newRule.l = lr[0];
              newRule.r = lr[1];
            } else {
              throw SyntaxError("Could not parse rule: " + ruleObject.s);
            }
          } else {
            newRule.l = ruleObject.l;
            newRule.r = ruleObject.r;
          }
          newRule.l = removeParens(parse2(newRule.l));
          newRule.r = removeParens(parse2(newRule.r));
          for (var _i = 0, _arr = ["imposeContext", "repeat", "assuming"]; _i < _arr.length; _i++) {
            var prop = _arr[_i];
            if (prop in ruleObject) {
              newRule[prop] = ruleObject[prop];
            }
          }
          if (ruleObject.evaluate) {
            newRule.evaluate = parse2(ruleObject.evaluate);
          }
          if (isAssociative(newRule.l, context)) {
            var nonCommutative = !isCommutative(newRule.l, context);
            var leftExpandsym;
            if (nonCommutative) leftExpandsym = _getExpandPlaceholderSymbol();
            var makeNode = createMakeNodeFunction(newRule.l);
            var expandsym = _getExpandPlaceholderSymbol();
            newRule.expanded = {};
            newRule.expanded.l = makeNode([newRule.l, expandsym]);
            flatten2(newRule.expanded.l, context);
            unflattenr(newRule.expanded.l, context);
            newRule.expanded.r = makeNode([newRule.r, expandsym]);
            if (nonCommutative) {
              newRule.expandedNC1 = {};
              newRule.expandedNC1.l = makeNode([leftExpandsym, newRule.l]);
              newRule.expandedNC1.r = makeNode([leftExpandsym, newRule.r]);
              newRule.expandedNC2 = {};
              newRule.expandedNC2.l = makeNode([leftExpandsym, newRule.expanded.l]);
              newRule.expandedNC2.r = makeNode([leftExpandsym, newRule.expanded.r]);
            }
          }
          return newRule;
        }
        function _buildRules(rules, context) {
          var ruleSet = [];
          for (var i = 0; i < rules.length; i++) {
            var rule = rules[i];
            var newRule = void 0;
            var ruleType = (0, _typeof2["default"])(rule);
            switch (ruleType) {
              case "string":
                rule = {
                  s: rule
                };
              /* falls through */
              case "object":
                newRule = _canonicalizeRule(rule, context);
                break;
              case "function":
                newRule = rule;
                break;
              default:
                throw TypeError("Unsupported type of rule: " + ruleType);
            }
            ruleSet.push(newRule);
          }
          return ruleSet;
        }
        var _lastsym = 0;
        function _getExpandPlaceholderSymbol() {
          return new SymbolNode("_p" + _lastsym++);
        }
        function _simplify(expr, rules) {
          var scope = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : (0, _map.createEmptyMap)();
          var options = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : {};
          var debug = options.consoleDebug;
          rules = _buildRules(rules || simplify.rules, options.context);
          var res = resolve(expr, scope);
          res = removeParens(res);
          var visited = {};
          var str = res.toString({
            parenthesis: "all"
          });
          while (!visited[str]) {
            visited[str] = true;
            _lastsym = 0;
            var laststr = str;
            if (debug) console.log("Working on: ", str);
            for (var i = 0; i < rules.length; i++) {
              var rulestr = "";
              if (typeof rules[i] === "function") {
                res = rules[i](res, options);
                if (debug) rulestr = rules[i].name;
              } else {
                flatten2(res, options.context);
                res = applyRule(res, rules[i], options.context);
                if (debug) {
                  rulestr = "".concat(rules[i].l.toString(), " -> ").concat(rules[i].r.toString());
                }
              }
              if (debug) {
                var newstr = res.toString({
                  parenthesis: "all"
                });
                if (newstr !== laststr) {
                  console.log("Applying", rulestr, "produced", newstr);
                  laststr = newstr;
                }
              }
              unflattenl(res, options.context);
            }
            str = res.toString({
              parenthesis: "all"
            });
          }
          return res;
        }
        function mapRule(nodes, rule, context) {
          var resNodes = nodes;
          if (nodes) {
            for (var i = 0; i < nodes.length; ++i) {
              var newNode = applyRule(nodes[i], rule, context);
              if (newNode !== nodes[i]) {
                if (resNodes === nodes) {
                  resNodes = nodes.slice();
                }
                resNodes[i] = newNode;
              }
            }
          }
          return resNodes;
        }
        function applyRule(node, rule, context) {
          if (rule.assuming) {
            for (var symbol in rule.assuming) {
              for (var property in rule.assuming[symbol]) {
                if (hasProperty(symbol, property, context) !== rule.assuming[symbol][property]) {
                  return node;
                }
              }
            }
          }
          var mergedContext = mergeContext(rule.imposeContext, context);
          var res = node;
          if (res instanceof OperatorNode || res instanceof FunctionNode) {
            var newArgs = mapRule(res.args, rule, context);
            if (newArgs !== res.args) {
              res = res.clone();
              res.args = newArgs;
            }
          } else if (res instanceof ParenthesisNode) {
            if (res.content) {
              var newContent = applyRule(res.content, rule, context);
              if (newContent !== res.content) {
                res = new ParenthesisNode(newContent);
              }
            }
          } else if (res instanceof ArrayNode) {
            var newItems = mapRule(res.items, rule, context);
            if (newItems !== res.items) {
              res = new ArrayNode(newItems);
            }
          } else if (res instanceof AccessorNode) {
            var newObj = res.object;
            if (res.object) {
              newObj = applyRule(res.object, rule, context);
            }
            var newIndex = res.index;
            if (res.index) {
              newIndex = applyRule(res.index, rule, context);
            }
            if (newObj !== res.object || newIndex !== res.index) {
              res = new AccessorNode(newObj, newIndex);
            }
          } else if (res instanceof IndexNode) {
            var newDims = mapRule(res.dimensions, rule, context);
            if (newDims !== res.dimensions) {
              res = new IndexNode(newDims);
            }
          } else if (res instanceof ObjectNode) {
            var changed = false;
            var newProps = {};
            for (var prop in res.properties) {
              newProps[prop] = applyRule(res.properties[prop], rule, context);
              if (newProps[prop] !== res.properties[prop]) {
                changed = true;
              }
            }
            if (changed) {
              res = new ObjectNode(newProps);
            }
          }
          var repl = rule.r;
          var matches = _ruleMatch(rule.l, res, mergedContext)[0];
          if (!matches && rule.expanded) {
            repl = rule.expanded.r;
            matches = _ruleMatch(rule.expanded.l, res, mergedContext)[0];
          }
          if (!matches && rule.expandedNC1) {
            repl = rule.expandedNC1.r;
            matches = _ruleMatch(rule.expandedNC1.l, res, mergedContext)[0];
            if (!matches) {
              repl = rule.expandedNC2.r;
              matches = _ruleMatch(rule.expandedNC2.l, res, mergedContext)[0];
            }
          }
          if (matches) {
            var implicit = res.implicit;
            res = repl.clone();
            if (implicit && "implicit" in repl) {
              res.implicit = true;
            }
            res = res.transform(function(node2) {
              if (node2.isSymbolNode && (0, _object.hasOwnProperty)(matches.placeholders, node2.name)) {
                return matches.placeholders[node2.name].clone();
              } else {
                return node2;
              }
            });
          }
          if (rule.repeat && res !== node) {
            res = applyRule(res, rule, context);
          }
          return res;
        }
        function getSplits(node, context) {
          var res = [];
          var right, rightArgs;
          var makeNode = createMakeNodeFunction(node);
          if (isCommutative(node, context)) {
            for (var i = 0; i < node.args.length; i++) {
              rightArgs = node.args.slice(0);
              rightArgs.splice(i, 1);
              right = rightArgs.length === 1 ? rightArgs[0] : makeNode(rightArgs);
              res.push(makeNode([node.args[i], right]));
            }
          } else {
            for (var _i2 = 1; _i2 < node.args.length; _i2++) {
              var left = node.args[0];
              if (_i2 > 1) {
                left = makeNode(node.args.slice(0, _i2));
              }
              rightArgs = node.args.slice(_i2);
              right = rightArgs.length === 1 ? rightArgs[0] : makeNode(rightArgs);
              res.push(makeNode([left, right]));
            }
          }
          return res;
        }
        function mergeMatch(match1, match2) {
          var res = {
            placeholders: {}
          };
          if (!match1.placeholders && !match2.placeholders) {
            return res;
          } else if (!match1.placeholders) {
            return match2;
          } else if (!match2.placeholders) {
            return match1;
          }
          for (var key in match1.placeholders) {
            if ((0, _object.hasOwnProperty)(match1.placeholders, key)) {
              res.placeholders[key] = match1.placeholders[key];
              if ((0, _object.hasOwnProperty)(match2.placeholders, key)) {
                if (!_exactMatch(match1.placeholders[key], match2.placeholders[key])) {
                  return null;
                }
              }
            }
          }
          for (var _key in match2.placeholders) {
            if ((0, _object.hasOwnProperty)(match2.placeholders, _key)) {
              res.placeholders[_key] = match2.placeholders[_key];
            }
          }
          return res;
        }
        function combineChildMatches(list1, list2) {
          var res = [];
          if (list1.length === 0 || list2.length === 0) {
            return res;
          }
          var merged;
          for (var i1 = 0; i1 < list1.length; i1++) {
            for (var i2 = 0; i2 < list2.length; i2++) {
              merged = mergeMatch(list1[i1], list2[i2]);
              if (merged) {
                res.push(merged);
              }
            }
          }
          return res;
        }
        function mergeChildMatches(childMatches) {
          if (childMatches.length === 0) {
            return childMatches;
          }
          var sets = childMatches.reduce(combineChildMatches);
          var uniqueSets = [];
          var unique = {};
          for (var i = 0; i < sets.length; i++) {
            var s = JSON.stringify(sets[i]);
            if (!unique[s]) {
              unique[s] = true;
              uniqueSets.push(sets[i]);
            }
          }
          return uniqueSets;
        }
        function _ruleMatch(rule, node, context, isSplit) {
          var res = [{
            placeholders: {}
          }];
          if (rule instanceof OperatorNode && node instanceof OperatorNode || rule instanceof FunctionNode && node instanceof FunctionNode) {
            if (rule instanceof OperatorNode) {
              if (rule.op !== node.op || rule.fn !== node.fn) {
                return [];
              }
            } else if (rule instanceof FunctionNode) {
              if (rule.name !== node.name) {
                return [];
              }
            }
            if (node.args.length === 1 && rule.args.length === 1 || !isAssociative(node, context) && node.args.length === rule.args.length || isSplit) {
              var childMatches = [];
              for (var i = 0; i < rule.args.length; i++) {
                var childMatch = _ruleMatch(rule.args[i], node.args[i], context);
                if (childMatch.length === 0) {
                  break;
                }
                childMatches.push(childMatch);
              }
              if (childMatches.length !== rule.args.length) {
                if (!isCommutative(node, context) || // exact match in order needed
                rule.args.length === 1) {
                  return [];
                }
                if (rule.args.length > 2) {
                  throw new Error("permuting >2 commutative non-associative rule arguments not yet implemented");
                }
                var leftMatch = _ruleMatch(rule.args[0], node.args[1], context);
                if (leftMatch.length === 0) {
                  return [];
                }
                var rightMatch = _ruleMatch(rule.args[1], node.args[0], context);
                if (rightMatch.length === 0) {
                  return [];
                }
                childMatches = [leftMatch, rightMatch];
              }
              res = mergeChildMatches(childMatches);
            } else if (node.args.length >= 2 && rule.args.length === 2) {
              var splits = getSplits(node, context);
              var splitMatches = [];
              for (var _i3 = 0; _i3 < splits.length; _i3++) {
                var matchSet = _ruleMatch(rule, splits[_i3], context, true);
                splitMatches = splitMatches.concat(matchSet);
              }
              return splitMatches;
            } else if (rule.args.length > 2) {
              throw Error("Unexpected non-binary associative function: " + rule.toString());
            } else {
              return [];
            }
          } else if (rule instanceof SymbolNode) {
            if (rule.name.length === 0) {
              throw new Error("Symbol in rule has 0 length...!?");
            }
            if (SUPPORTED_CONSTANTS[rule.name]) {
              if (rule.name !== node.name) {
                return [];
              }
            } else {
              switch (rule.name[1] >= "a" && rule.name[1] <= "z" ? rule.name.substring(0, 2) : rule.name[0]) {
                case "n":
                case "_p":
                  res[0].placeholders[rule.name] = node;
                  break;
                case "c":
                case "cl":
                  if ((0, _wildcards.isConstantNode)(node)) {
                    res[0].placeholders[rule.name] = node;
                  } else {
                    return [];
                  }
                  break;
                case "v":
                  if (!(0, _wildcards.isConstantNode)(node)) {
                    res[0].placeholders[rule.name] = node;
                  } else {
                    return [];
                  }
                  break;
                case "vl":
                  if ((0, _wildcards.isVariableNode)(node)) {
                    res[0].placeholders[rule.name] = node;
                  } else {
                    return [];
                  }
                  break;
                case "cd":
                  if ((0, _wildcards.isNumericNode)(node)) {
                    res[0].placeholders[rule.name] = node;
                  } else {
                    return [];
                  }
                  break;
                case "vd":
                  if (!(0, _wildcards.isNumericNode)(node)) {
                    res[0].placeholders[rule.name] = node;
                  } else {
                    return [];
                  }
                  break;
                case "ce":
                  if ((0, _wildcards.isConstantExpression)(node)) {
                    res[0].placeholders[rule.name] = node;
                  } else {
                    return [];
                  }
                  break;
                case "ve":
                  if (!(0, _wildcards.isConstantExpression)(node)) {
                    res[0].placeholders[rule.name] = node;
                  } else {
                    return [];
                  }
                  break;
                default:
                  throw new Error("Invalid symbol in rule: " + rule.name);
              }
            }
          } else if (rule instanceof ConstantNode) {
            if (!equal(rule.value, node.value)) {
              return [];
            }
          } else {
            return [];
          }
          return res;
        }
        function _exactMatch(p, q) {
          if (p instanceof ConstantNode && q instanceof ConstantNode) {
            if (!equal(p.value, q.value)) {
              return false;
            }
          } else if (p instanceof SymbolNode && q instanceof SymbolNode) {
            if (p.name !== q.name) {
              return false;
            }
          } else if (p instanceof OperatorNode && q instanceof OperatorNode || p instanceof FunctionNode && q instanceof FunctionNode) {
            if (p instanceof OperatorNode) {
              if (p.op !== q.op || p.fn !== q.fn) {
                return false;
              }
            } else if (p instanceof FunctionNode) {
              if (p.name !== q.name) {
                return false;
              }
            }
            if (p.args.length !== q.args.length) {
              return false;
            }
            for (var i = 0; i < p.args.length; i++) {
              if (!_exactMatch(p.args[i], q.args[i])) {
                return false;
              }
            }
          } else {
            return false;
          }
          return true;
        }
        return simplify;
      });
    }
  });

  // node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/function/algebra/simplifyConstant.js
  var require_simplifyConstant2 = __commonJS({
    "node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/function/algebra/simplifyConstant.js"(exports) {
      "use strict";
      var _interopRequireDefault = require_interopRequireDefault();
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.createSimplifyConstant = void 0;
      var _typeof2 = _interopRequireDefault(require_typeof());
      var _is = require_is();
      var _factory = require_factory();
      var _util = require_util();
      var _noop = require_noop();
      function _createForOfIteratorHelper(o, allowArrayLike) {
        var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"];
        if (!it) {
          if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") {
            if (it) o = it;
            var i = 0;
            var F = function F2() {
            };
            return { s: F, n: function n() {
              if (i >= o.length) return { done: true };
              return { done: false, value: o[i++] };
            }, e: function e(_e) {
              throw _e;
            }, f: F };
          }
          throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
        }
        var normalCompletion = true, didErr = false, err;
        return { s: function s() {
          it = it.call(o);
        }, n: function n() {
          var step = it.next();
          normalCompletion = step.done;
          return step;
        }, e: function e(_e2) {
          didErr = true;
          err = _e2;
        }, f: function f() {
          try {
            if (!normalCompletion && it["return"] != null) it["return"]();
          } finally {
            if (didErr) throw err;
          }
        } };
      }
      function _unsupportedIterableToArray(o, minLen) {
        if (!o) return;
        if (typeof o === "string") return _arrayLikeToArray(o, minLen);
        var n = Object.prototype.toString.call(o).slice(8, -1);
        if (n === "Object" && o.constructor) n = o.constructor.name;
        if (n === "Map" || n === "Set") return Array.from(o);
        if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);
      }
      function _arrayLikeToArray(arr, len) {
        if (len == null || len > arr.length) len = arr.length;
        for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];
        return arr2;
      }
      var name18 = "simplifyConstant";
      var dependencies19 = ["typed", "config", "mathWithTransform", "matrix", "?fraction", "?bignumber", "AccessorNode", "ArrayNode", "ConstantNode", "FunctionNode", "IndexNode", "ObjectNode", "OperatorNode", "SymbolNode"];
      var createSimplifyConstant = exports.createSimplifyConstant = /* @__PURE__ */ (0, _factory.factory)(name18, dependencies19, function(_ref) {
        var typed2 = _ref.typed, config4 = _ref.config, mathWithTransform = _ref.mathWithTransform, matrix2 = _ref.matrix, fraction = _ref.fraction, bignumber = _ref.bignumber, AccessorNode = _ref.AccessorNode, ArrayNode = _ref.ArrayNode, ConstantNode = _ref.ConstantNode, FunctionNode = _ref.FunctionNode, IndexNode = _ref.IndexNode, ObjectNode = _ref.ObjectNode, OperatorNode = _ref.OperatorNode, SymbolNode = _ref.SymbolNode;
        var _createUtil = (0, _util.createUtil)({
          FunctionNode,
          OperatorNode,
          SymbolNode
        }), isCommutative = _createUtil.isCommutative, isAssociative = _createUtil.isAssociative, allChildren = _createUtil.allChildren, createMakeNodeFunction = _createUtil.createMakeNodeFunction;
        var simplifyConstant = typed2("simplifyConstant", {
          Node: function Node(node) {
            return _ensureNode(foldFraction(node, {}));
          },
          "Node, Object": function NodeObject(expr, options) {
            return _ensureNode(foldFraction(expr, options));
          }
        });
        function _removeFractions(thing) {
          if ((0, _is.isFraction)(thing)) {
            return thing.valueOf();
          }
          if (thing instanceof Array) {
            return thing.map(_removeFractions);
          }
          if ((0, _is.isMatrix)(thing)) {
            return matrix2(_removeFractions(thing.valueOf()));
          }
          return thing;
        }
        function _eval(fnname, args, options) {
          try {
            return mathWithTransform[fnname].apply(null, args);
          } catch (ignore) {
            args = args.map(_removeFractions);
            return _toNumber(mathWithTransform[fnname].apply(null, args), options);
          }
        }
        var _toNode = typed2({
          Fraction: _fractionToNode,
          number: function number(n) {
            if (n < 0) {
              return unaryMinusNode(new ConstantNode(-n));
            }
            return new ConstantNode(n);
          },
          BigNumber: function BigNumber2(n) {
            if (n < 0) {
              return unaryMinusNode(new ConstantNode(-n));
            }
            return new ConstantNode(n);
          },
          Complex: function Complex3(s) {
            throw new Error("Cannot convert Complex number to Node");
          },
          string: function string(s) {
            return new ConstantNode(s);
          },
          Matrix: function Matrix2(m) {
            return new ArrayNode(m.valueOf().map(function(e) {
              return _toNode(e);
            }));
          }
        });
        function _ensureNode(thing) {
          if ((0, _is.isNode)(thing)) {
            return thing;
          }
          return _toNode(thing);
        }
        function _exactFraction(n, options) {
          var exactFractions = options && options.exactFractions !== false;
          if (exactFractions && isFinite(n) && fraction) {
            var f = fraction(n);
            var fractionsLimit = options && typeof options.fractionsLimit === "number" ? options.fractionsLimit : Infinity;
            if (f.valueOf() === n && f.n < fractionsLimit && f.d < fractionsLimit) {
              return f;
            }
          }
          return n;
        }
        var _toNumber = typed2({
          "string, Object": function stringObject(s, options) {
            if (config4.number === "BigNumber") {
              if (bignumber === void 0) {
                (0, _noop.noBignumber)();
              }
              return bignumber(s);
            } else if (config4.number === "Fraction") {
              if (fraction === void 0) {
                (0, _noop.noFraction)();
              }
              return fraction(s);
            } else {
              var n = parseFloat(s);
              return _exactFraction(n, options);
            }
          },
          "Fraction, Object": function FractionObject(s, options) {
            return s;
          },
          // we don't need options here
          "BigNumber, Object": function BigNumberObject(s, options) {
            return s;
          },
          // we don't need options here
          "number, Object": function numberObject(s, options) {
            return _exactFraction(s, options);
          },
          "Complex, Object": function ComplexObject(s, options) {
            if (s.im !== 0) {
              return s;
            }
            return _exactFraction(s.re, options);
          },
          "Matrix, Object": function MatrixObject(s, options) {
            return matrix2(_exactFraction(s.valueOf()));
          },
          "Array, Object": function ArrayObject(s, options) {
            return s.map(_exactFraction);
          }
        });
        function unaryMinusNode(n) {
          return new OperatorNode("-", "unaryMinus", [n]);
        }
        function _fractionToNode(f) {
          var n;
          var vn = f.s * f.n;
          if (vn < 0) {
            n = new OperatorNode("-", "unaryMinus", [new ConstantNode(-vn)]);
          } else {
            n = new ConstantNode(vn);
          }
          if (f.d === 1) {
            return n;
          }
          return new OperatorNode("/", "divide", [n, new ConstantNode(f.d)]);
        }
        function _foldAccessor(obj, index, options) {
          if (!(0, _is.isIndexNode)(index)) {
            return new AccessorNode(_ensureNode(obj), _ensureNode(index));
          }
          if ((0, _is.isArrayNode)(obj) || (0, _is.isMatrix)(obj)) {
            var remainingDims = Array.from(index.dimensions);
            while (remainingDims.length > 0) {
              if ((0, _is.isConstantNode)(remainingDims[0]) && typeof remainingDims[0].value !== "string") {
                var first = _toNumber(remainingDims.shift().value, options);
                if ((0, _is.isArrayNode)(obj)) {
                  obj = obj.items[first - 1];
                } else {
                  obj = obj.valueOf()[first - 1];
                  if (obj instanceof Array) {
                    obj = matrix2(obj);
                  }
                }
              } else if (remainingDims.length > 1 && (0, _is.isConstantNode)(remainingDims[1]) && typeof remainingDims[1].value !== "string") {
                var second = _toNumber(remainingDims[1].value, options);
                var tryItems = [];
                var fromItems = (0, _is.isArrayNode)(obj) ? obj.items : obj.valueOf();
                var _iterator = _createForOfIteratorHelper(fromItems), _step;
                try {
                  for (_iterator.s(); !(_step = _iterator.n()).done; ) {
                    var item = _step.value;
                    if ((0, _is.isArrayNode)(item)) {
                      tryItems.push(item.items[second - 1]);
                    } else if ((0, _is.isMatrix)(obj)) {
                      tryItems.push(item[second - 1]);
                    } else {
                      break;
                    }
                  }
                } catch (err) {
                  _iterator.e(err);
                } finally {
                  _iterator.f();
                }
                if (tryItems.length === fromItems.length) {
                  if ((0, _is.isArrayNode)(obj)) {
                    obj = new ArrayNode(tryItems);
                  } else {
                    obj = matrix2(tryItems);
                  }
                  remainingDims.splice(1, 1);
                } else {
                  break;
                }
              } else {
                break;
              }
            }
            if (remainingDims.length === index.dimensions.length) {
              return new AccessorNode(_ensureNode(obj), index);
            }
            if (remainingDims.length > 0) {
              index = new IndexNode(remainingDims);
              return new AccessorNode(_ensureNode(obj), index);
            }
            return obj;
          }
          if ((0, _is.isObjectNode)(obj) && index.dimensions.length === 1 && (0, _is.isConstantNode)(index.dimensions[0])) {
            var key = index.dimensions[0].value;
            if (key in obj.properties) {
              return obj.properties[key];
            }
            return new ConstantNode();
          }
          return new AccessorNode(_ensureNode(obj), index);
        }
        function foldOp(fn, args, makeNode, options) {
          var first = args.shift();
          var reduction = args.reduce(function(sofar, next) {
            if (!(0, _is.isNode)(next)) {
              var last = sofar.pop();
              if ((0, _is.isNode)(last)) {
                return [last, next];
              }
              try {
                sofar.push(_eval(fn, [last, next], options));
                return sofar;
              } catch (ignoreandcontinue) {
                sofar.push(last);
              }
            }
            sofar.push(_ensureNode(sofar.pop()));
            var newtree = sofar.length === 1 ? sofar[0] : makeNode(sofar);
            return [makeNode([newtree, _ensureNode(next)])];
          }, [first]);
          if (reduction.length === 1) {
            return reduction[0];
          }
          return makeNode([reduction[0], _toNode(reduction[1])]);
        }
        function foldFraction(node, options) {
          switch (node.type) {
            case "SymbolNode":
              return node;
            case "ConstantNode":
              switch ((0, _typeof2["default"])(node.value)) {
                case "number":
                  return _toNumber(node.value, options);
                case "string":
                  return node.value;
                default:
                  if (!isNaN(node.value)) return _toNumber(node.value, options);
              }
              return node;
            case "FunctionNode":
              if (mathWithTransform[node.name] && mathWithTransform[node.name].rawArgs) {
                return node;
              }
              {
                var operatorFunctions = ["add", "multiply"];
                if (!operatorFunctions.includes(node.name)) {
                  var args = node.args.map(function(arg) {
                    return foldFraction(arg, options);
                  });
                  if (!args.some(_is.isNode)) {
                    try {
                      return _eval(node.name, args, options);
                    } catch (ignoreandcontinue) {
                    }
                  }
                  if (node.name === "size" && args.length === 1 && (0, _is.isArrayNode)(args[0])) {
                    var sz = [];
                    var section = args[0];
                    while ((0, _is.isArrayNode)(section)) {
                      sz.push(section.items.length);
                      section = section.items[0];
                    }
                    return matrix2(sz);
                  }
                  return new FunctionNode(node.name, args.map(_ensureNode));
                } else {
                }
              }
            /* falls through */
            case "OperatorNode": {
              var fn = node.fn.toString();
              var _args;
              var res;
              var makeNode = createMakeNodeFunction(node);
              if ((0, _is.isOperatorNode)(node) && node.isUnary()) {
                _args = [foldFraction(node.args[0], options)];
                if (!(0, _is.isNode)(_args[0])) {
                  res = _eval(fn, _args, options);
                } else {
                  res = makeNode(_args);
                }
              } else if (isAssociative(node, options.context)) {
                _args = allChildren(node, options.context);
                _args = _args.map(function(arg) {
                  return foldFraction(arg, options);
                });
                if (isCommutative(fn, options.context)) {
                  var consts = [];
                  var vars = [];
                  for (var i = 0; i < _args.length; i++) {
                    if (!(0, _is.isNode)(_args[i])) {
                      consts.push(_args[i]);
                    } else {
                      vars.push(_args[i]);
                    }
                  }
                  if (consts.length > 1) {
                    res = foldOp(fn, consts, makeNode, options);
                    vars.unshift(res);
                    res = foldOp(fn, vars, makeNode, options);
                  } else {
                    res = foldOp(fn, _args, makeNode, options);
                  }
                } else {
                  res = foldOp(fn, _args, makeNode, options);
                }
              } else {
                _args = node.args.map(function(arg) {
                  return foldFraction(arg, options);
                });
                res = foldOp(fn, _args, makeNode, options);
              }
              return res;
            }
            case "ParenthesisNode":
              return foldFraction(node.content, options);
            case "AccessorNode":
              return _foldAccessor(foldFraction(node.object, options), foldFraction(node.index, options), options);
            case "ArrayNode": {
              var foldItems = node.items.map(function(item) {
                return foldFraction(item, options);
              });
              if (foldItems.some(_is.isNode)) {
                return new ArrayNode(foldItems.map(_ensureNode));
              }
              return matrix2(foldItems);
            }
            case "IndexNode": {
              return new IndexNode(node.dimensions.map(function(n) {
                return simplifyConstant(n, options);
              }));
            }
            case "ObjectNode": {
              var foldProps = {};
              for (var prop in node.properties) {
                foldProps[prop] = simplifyConstant(node.properties[prop], options);
              }
              return new ObjectNode(foldProps);
            }
            case "AssignmentNode":
            /* falls through */
            case "BlockNode":
            /* falls through */
            case "FunctionAssignmentNode":
            /* falls through */
            case "RangeNode":
            /* falls through */
            case "ConditionalNode":
            /* falls through */
            default:
              throw new Error("Unimplemented node type in simplifyConstant: ".concat(node.type));
          }
        }
        return simplifyConstant;
      });
    }
  });

  // node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/function/algebra/simplifyCore.js
  var require_simplifyCore2 = __commonJS({
    "node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/function/algebra/simplifyCore.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.createSimplifyCore = void 0;
      var _is = require_is();
      var _operators = require_operators();
      var _util = require_util();
      var _factory = require_factory();
      var name18 = "simplifyCore";
      var dependencies19 = ["typed", "parse", "equal", "isZero", "add", "subtract", "multiply", "divide", "pow", "AccessorNode", "ArrayNode", "ConstantNode", "FunctionNode", "IndexNode", "ObjectNode", "OperatorNode", "ParenthesisNode", "SymbolNode"];
      var createSimplifyCore = exports.createSimplifyCore = /* @__PURE__ */ (0, _factory.factory)(name18, dependencies19, function(_ref) {
        var typed2 = _ref.typed, parse2 = _ref.parse, equal = _ref.equal, isZero = _ref.isZero, add2 = _ref.add, subtract = _ref.subtract, multiply2 = _ref.multiply, divide2 = _ref.divide, pow2 = _ref.pow, AccessorNode = _ref.AccessorNode, ArrayNode = _ref.ArrayNode, ConstantNode = _ref.ConstantNode, FunctionNode = _ref.FunctionNode, IndexNode = _ref.IndexNode, ObjectNode = _ref.ObjectNode, OperatorNode = _ref.OperatorNode, ParenthesisNode = _ref.ParenthesisNode, SymbolNode = _ref.SymbolNode;
        var node0 = new ConstantNode(0);
        var node1 = new ConstantNode(1);
        var nodeT = new ConstantNode(true);
        var nodeF = new ConstantNode(false);
        function isAlwaysBoolean(node) {
          return (0, _is.isOperatorNode)(node) && ["and", "not", "or"].includes(node.op);
        }
        var _createUtil = (0, _util.createUtil)({
          FunctionNode,
          OperatorNode,
          SymbolNode
        }), hasProperty = _createUtil.hasProperty, isCommutative = _createUtil.isCommutative;
        function _simplifyCore(nodeToSimplify) {
          var options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
          var context = options ? options.context : void 0;
          if (hasProperty(nodeToSimplify, "trivial", context)) {
            if ((0, _is.isFunctionNode)(nodeToSimplify) && nodeToSimplify.args.length === 1) {
              return _simplifyCore(nodeToSimplify.args[0], options);
            }
            var simpChild = false;
            var childCount = 0;
            nodeToSimplify.forEach(function(c) {
              ++childCount;
              if (childCount === 1) {
                simpChild = _simplifyCore(c, options);
              }
            });
            if (childCount === 1) {
              return simpChild;
            }
          }
          var node = nodeToSimplify;
          if ((0, _is.isFunctionNode)(node)) {
            var op = (0, _operators.getOperator)(node.name);
            if (op) {
              if (node.args.length > 2 && hasProperty(node, "associative", context)) {
                while (node.args.length > 2) {
                  var last = node.args.pop();
                  var seclast = node.args.pop();
                  node.args.push(new OperatorNode(op, node.name, [last, seclast]));
                }
              }
              node = new OperatorNode(op, node.name, node.args);
            } else {
              return new FunctionNode(_simplifyCore(node.fn), node.args.map(function(n) {
                return _simplifyCore(n, options);
              }));
            }
          }
          if ((0, _is.isOperatorNode)(node) && node.isUnary()) {
            var a0 = _simplifyCore(node.args[0], options);
            if (node.op === "~") {
              if ((0, _is.isOperatorNode)(a0) && a0.isUnary() && a0.op === "~") {
                return a0.args[0];
              }
            }
            if (node.op === "not") {
              if ((0, _is.isOperatorNode)(a0) && a0.isUnary() && a0.op === "not") {
                if (isAlwaysBoolean(a0.args[0])) {
                  return a0.args[0];
                }
              }
            }
            var finish = true;
            if (node.op === "-") {
              if ((0, _is.isOperatorNode)(a0)) {
                if (a0.isBinary() && a0.fn === "subtract") {
                  node = new OperatorNode("-", "subtract", [a0.args[1], a0.args[0]]);
                  finish = false;
                }
                if (a0.isUnary() && a0.op === "-") {
                  return a0.args[0];
                }
              }
            }
            if (finish) return new OperatorNode(node.op, node.fn, [a0]);
          }
          if ((0, _is.isOperatorNode)(node) && node.isBinary()) {
            var _a = _simplifyCore(node.args[0], options);
            var a1 = _simplifyCore(node.args[1], options);
            if (node.op === "+") {
              if ((0, _is.isConstantNode)(_a) && isZero(_a.value)) {
                return a1;
              }
              if ((0, _is.isConstantNode)(a1) && isZero(a1.value)) {
                return _a;
              }
              if ((0, _is.isOperatorNode)(a1) && a1.isUnary() && a1.op === "-") {
                a1 = a1.args[0];
                node = new OperatorNode("-", "subtract", [_a, a1]);
              }
            }
            if (node.op === "-") {
              if ((0, _is.isOperatorNode)(a1) && a1.isUnary() && a1.op === "-") {
                return _simplifyCore(new OperatorNode("+", "add", [_a, a1.args[0]]), options);
              }
              if ((0, _is.isConstantNode)(_a) && isZero(_a.value)) {
                return _simplifyCore(new OperatorNode("-", "unaryMinus", [a1]));
              }
              if ((0, _is.isConstantNode)(a1) && isZero(a1.value)) {
                return _a;
              }
              return new OperatorNode(node.op, node.fn, [_a, a1]);
            }
            if (node.op === "*") {
              if ((0, _is.isConstantNode)(_a)) {
                if (isZero(_a.value)) {
                  return node0;
                } else if (equal(_a.value, 1)) {
                  return a1;
                }
              }
              if ((0, _is.isConstantNode)(a1)) {
                if (isZero(a1.value)) {
                  return node0;
                } else if (equal(a1.value, 1)) {
                  return _a;
                }
                if (isCommutative(node, context)) {
                  return new OperatorNode(node.op, node.fn, [a1, _a], node.implicit);
                }
              }
              return new OperatorNode(node.op, node.fn, [_a, a1], node.implicit);
            }
            if (node.op === "/") {
              if ((0, _is.isConstantNode)(_a) && isZero(_a.value)) {
                return node0;
              }
              if ((0, _is.isConstantNode)(a1) && equal(a1.value, 1)) {
                return _a;
              }
              return new OperatorNode(node.op, node.fn, [_a, a1]);
            }
            if (node.op === "^") {
              if ((0, _is.isConstantNode)(a1)) {
                if (isZero(a1.value)) {
                  return node1;
                } else if (equal(a1.value, 1)) {
                  return _a;
                }
              }
            }
            if (node.op === "and") {
              if ((0, _is.isConstantNode)(_a)) {
                if (_a.value) {
                  if (isAlwaysBoolean(a1)) return a1;
                  if ((0, _is.isConstantNode)(a1)) {
                    return a1.value ? nodeT : nodeF;
                  }
                } else {
                  return nodeF;
                }
              }
              if ((0, _is.isConstantNode)(a1)) {
                if (a1.value) {
                  if (isAlwaysBoolean(_a)) return _a;
                } else {
                  return nodeF;
                }
              }
            }
            if (node.op === "or") {
              if ((0, _is.isConstantNode)(_a)) {
                if (_a.value) {
                  return nodeT;
                } else {
                  if (isAlwaysBoolean(a1)) return a1;
                }
              }
              if ((0, _is.isConstantNode)(a1)) {
                if (a1.value) {
                  return nodeT;
                } else {
                  if (isAlwaysBoolean(_a)) return _a;
                }
              }
            }
            return new OperatorNode(node.op, node.fn, [_a, a1]);
          }
          if ((0, _is.isOperatorNode)(node)) {
            return new OperatorNode(node.op, node.fn, node.args.map(function(a) {
              return _simplifyCore(a, options);
            }));
          }
          if ((0, _is.isArrayNode)(node)) {
            return new ArrayNode(node.items.map(function(n) {
              return _simplifyCore(n, options);
            }));
          }
          if ((0, _is.isAccessorNode)(node)) {
            return new AccessorNode(_simplifyCore(node.object, options), _simplifyCore(node.index, options));
          }
          if ((0, _is.isIndexNode)(node)) {
            return new IndexNode(node.dimensions.map(function(n) {
              return _simplifyCore(n, options);
            }));
          }
          if ((0, _is.isObjectNode)(node)) {
            var newProps = {};
            for (var prop in node.properties) {
              newProps[prop] = _simplifyCore(node.properties[prop], options);
            }
            return new ObjectNode(newProps);
          }
          return node;
        }
        return typed2(name18, {
          Node: _simplifyCore,
          "Node,Object": _simplifyCore
        });
      });
    }
  });

  // node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/function/algebra/resolve.js
  var require_resolve2 = __commonJS({
    "node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/function/algebra/resolve.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.createResolve = void 0;
      var _map = require_map();
      var _is = require_is();
      var _factory = require_factory();
      var name18 = "resolve";
      var dependencies19 = ["typed", "parse", "ConstantNode", "FunctionNode", "OperatorNode", "ParenthesisNode"];
      var createResolve = exports.createResolve = /* @__PURE__ */ (0, _factory.factory)(name18, dependencies19, function(_ref) {
        var typed2 = _ref.typed, parse2 = _ref.parse, ConstantNode = _ref.ConstantNode, FunctionNode = _ref.FunctionNode, OperatorNode = _ref.OperatorNode, ParenthesisNode = _ref.ParenthesisNode;
        function _resolve(node, scope) {
          var within = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : /* @__PURE__ */ new Set();
          if (!scope) {
            return node;
          }
          if ((0, _is.isSymbolNode)(node)) {
            if (within.has(node.name)) {
              var variables = Array.from(within).join(", ");
              throw new ReferenceError("recursive loop of variable definitions among {".concat(variables, "}"));
            }
            var value = scope.get(node.name);
            if ((0, _is.isNode)(value)) {
              var nextWithin = new Set(within);
              nextWithin.add(node.name);
              return _resolve(value, scope, nextWithin);
            } else if (typeof value === "number") {
              return parse2(String(value));
            } else if (value !== void 0) {
              return new ConstantNode(value);
            } else {
              return node;
            }
          } else if ((0, _is.isOperatorNode)(node)) {
            var args = node.args.map(function(arg) {
              return _resolve(arg, scope, within);
            });
            return new OperatorNode(node.op, node.fn, args, node.implicit);
          } else if ((0, _is.isParenthesisNode)(node)) {
            return new ParenthesisNode(_resolve(node.content, scope, within));
          } else if ((0, _is.isFunctionNode)(node)) {
            var _args = node.args.map(function(arg) {
              return _resolve(arg, scope, within);
            });
            return new FunctionNode(node.name, _args);
          }
          return node.map(function(child) {
            return _resolve(child, scope, within);
          });
        }
        return typed2("resolve", {
          Node: _resolve,
          "Node, Map | null | undefined": _resolve,
          "Node, Object": function NodeObject(n, scope) {
            return _resolve(n, (0, _map.createMap)(scope));
          },
          // For arrays and matrices, we map `self` rather than `_resolve`
          // because resolve is fairly expensive anyway, and this way
          // we get nice error messages if one entry in the array has wrong type.
          "Array | Matrix": typed2.referToSelf(function(self2) {
            return function(A) {
              return A.map(function(n) {
                return self2(n);
              });
            };
          }),
          "Array | Matrix, null | undefined": typed2.referToSelf(function(self2) {
            return function(A) {
              return A.map(function(n) {
                return self2(n);
              });
            };
          }),
          "Array, Object": typed2.referTo("Array,Map", function(selfAM) {
            return function(A, scope) {
              return selfAM(A, (0, _map.createMap)(scope));
            };
          }),
          "Matrix, Object": typed2.referTo("Matrix,Map", function(selfMM) {
            return function(A, scope) {
              return selfMM(A, (0, _map.createMap)(scope));
            };
          }),
          "Array | Matrix, Map": typed2.referToSelf(function(self2) {
            return function(A, scope) {
              return A.map(function(n) {
                return self2(n, scope);
              });
            };
          })
        });
      });
    }
  });

  // node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/function/algebra/symbolicEqual.js
  var require_symbolicEqual2 = __commonJS({
    "node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/function/algebra/symbolicEqual.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.createSymbolicEqual = void 0;
      var _is = require_is();
      var _factory = require_factory();
      var name18 = "symbolicEqual";
      var dependencies19 = ["parse", "simplify", "typed", "OperatorNode"];
      var createSymbolicEqual = exports.createSymbolicEqual = /* @__PURE__ */ (0, _factory.factory)(name18, dependencies19, function(_ref) {
        var parse2 = _ref.parse, simplify = _ref.simplify, typed2 = _ref.typed, OperatorNode = _ref.OperatorNode;
        function _symbolicEqual(e1, e2) {
          var options = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
          var diff = new OperatorNode("-", "subtract", [e1, e2]);
          var simplified = simplify(diff, {}, options);
          return (0, _is.isConstantNode)(simplified) && !simplified.value;
        }
        return typed2(name18, {
          "Node, Node": _symbolicEqual,
          "Node, Node, Object": _symbolicEqual
        });
      });
    }
  });

  // node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/function/algebra/derivative.js
  var require_derivative2 = __commonJS({
    "node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/function/algebra/derivative.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.createDerivative = void 0;
      var _is = require_is();
      var _factory = require_factory();
      var name18 = "derivative";
      var dependencies19 = ["typed", "config", "parse", "simplify", "equal", "isZero", "numeric", "ConstantNode", "FunctionNode", "OperatorNode", "ParenthesisNode", "SymbolNode"];
      var createDerivative = exports.createDerivative = /* @__PURE__ */ (0, _factory.factory)(name18, dependencies19, function(_ref) {
        var typed2 = _ref.typed, config4 = _ref.config, parse2 = _ref.parse, simplify = _ref.simplify, equal = _ref.equal, isZero = _ref.isZero, numeric = _ref.numeric, ConstantNode = _ref.ConstantNode, FunctionNode = _ref.FunctionNode, OperatorNode = _ref.OperatorNode, ParenthesisNode = _ref.ParenthesisNode, SymbolNode = _ref.SymbolNode;
        function plainDerivative(expr, variable) {
          var options = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {
            simplify: true
          };
          var constNodes = {};
          constTag(constNodes, expr, variable.name);
          var res = _derivative(expr, constNodes);
          return options.simplify ? simplify(res) : res;
        }
        typed2.addConversion({
          from: "identifier",
          to: "SymbolNode",
          convert: parse2
        });
        var derivative = typed2(name18, {
          "Node, SymbolNode": plainDerivative,
          "Node, SymbolNode, Object": plainDerivative
          /* TODO: implement and test syntax with order of derivatives -> implement as an option {order: number}
          'Node, SymbolNode, ConstantNode': function (expr, variable, {order}) {
            let res = expr
            for (let i = 0; i < order; i++) {
              let constNodes = {}
              constTag(constNodes, expr, variable.name)
              res = _derivative(res, constNodes)
            }
            return res
          }
          */
        });
        typed2.removeConversion({
          from: "identifier",
          to: "SymbolNode",
          convert: parse2
        });
        derivative._simplify = true;
        derivative.toTex = function(deriv) {
          return _derivTex.apply(null, deriv.args);
        };
        var _derivTex = typed2("_derivTex", {
          "Node, SymbolNode": function NodeSymbolNode(expr, x) {
            if ((0, _is.isConstantNode)(expr) && (0, _is.typeOf)(expr.value) === "string") {
              return _derivTex(parse2(expr.value).toString(), x.toString(), 1);
            } else {
              return _derivTex(expr.toTex(), x.toString(), 1);
            }
          },
          "Node, ConstantNode": function NodeConstantNode(expr, x) {
            if ((0, _is.typeOf)(x.value) === "string") {
              return _derivTex(expr, parse2(x.value));
            } else {
              throw new Error("The second parameter to 'derivative' is a non-string constant");
            }
          },
          "Node, SymbolNode, ConstantNode": function NodeSymbolNodeConstantNode(expr, x, order) {
            return _derivTex(expr.toString(), x.name, order.value);
          },
          "string, string, number": function stringStringNumber(expr, x, order) {
            var d;
            if (order === 1) {
              d = "{d\\over d" + x + "}";
            } else {
              d = "{d^{" + order + "}\\over d" + x + "^{" + order + "}}";
            }
            return d + "\\left[".concat(expr, "\\right]");
          }
        });
        var constTag = typed2("constTag", {
          "Object, ConstantNode, string": function ObjectConstantNodeString(constNodes, node) {
            constNodes[node] = true;
            return true;
          },
          "Object, SymbolNode, string": function ObjectSymbolNodeString(constNodes, node, varName) {
            if (node.name !== varName) {
              constNodes[node] = true;
              return true;
            }
            return false;
          },
          "Object, ParenthesisNode, string": function ObjectParenthesisNodeString(constNodes, node, varName) {
            return constTag(constNodes, node.content, varName);
          },
          "Object, FunctionAssignmentNode, string": function ObjectFunctionAssignmentNodeString(constNodes, node, varName) {
            if (!node.params.includes(varName)) {
              constNodes[node] = true;
              return true;
            }
            return constTag(constNodes, node.expr, varName);
          },
          "Object, FunctionNode | OperatorNode, string": function ObjectFunctionNodeOperatorNodeString(constNodes, node, varName) {
            if (node.args.length > 0) {
              var isConst = constTag(constNodes, node.args[0], varName);
              for (var i = 1; i < node.args.length; ++i) {
                isConst = constTag(constNodes, node.args[i], varName) && isConst;
              }
              if (isConst) {
                constNodes[node] = true;
                return true;
              }
            }
            return false;
          }
        });
        var _derivative = typed2("_derivative", {
          "ConstantNode, Object": function ConstantNodeObject(node) {
            return createConstantNode(0);
          },
          "SymbolNode, Object": function SymbolNodeObject(node, constNodes) {
            if (constNodes[node] !== void 0) {
              return createConstantNode(0);
            }
            return createConstantNode(1);
          },
          "ParenthesisNode, Object": function ParenthesisNodeObject(node, constNodes) {
            return new ParenthesisNode(_derivative(node.content, constNodes));
          },
          "FunctionAssignmentNode, Object": function FunctionAssignmentNodeObject(node, constNodes) {
            if (constNodes[node] !== void 0) {
              return createConstantNode(0);
            }
            return _derivative(node.expr, constNodes);
          },
          "FunctionNode, Object": function FunctionNodeObject(node, constNodes) {
            if (constNodes[node] !== void 0) {
              return createConstantNode(0);
            }
            var arg0 = node.args[0];
            var arg1;
            var div2 = false;
            var negative = false;
            var funcDerivative;
            switch (node.name) {
              case "cbrt":
                div2 = true;
                funcDerivative = new OperatorNode("*", "multiply", [createConstantNode(3), new OperatorNode("^", "pow", [arg0, new OperatorNode("/", "divide", [createConstantNode(2), createConstantNode(3)])])]);
                break;
              case "sqrt":
              case "nthRoot":
                if (node.args.length === 1) {
                  div2 = true;
                  funcDerivative = new OperatorNode("*", "multiply", [createConstantNode(2), new FunctionNode("sqrt", [arg0])]);
                } else if (node.args.length === 2) {
                  arg1 = new OperatorNode("/", "divide", [createConstantNode(1), node.args[1]]);
                  constNodes[arg1] = constNodes[node.args[1]];
                  return _derivative(new OperatorNode("^", "pow", [arg0, arg1]), constNodes);
                }
                break;
              case "log10":
                arg1 = createConstantNode(10);
              /* fall through! */
              case "log":
                if (!arg1 && node.args.length === 1) {
                  funcDerivative = arg0.clone();
                  div2 = true;
                } else if (node.args.length === 1 && arg1 || node.args.length === 2 && constNodes[node.args[1]] !== void 0) {
                  funcDerivative = new OperatorNode("*", "multiply", [arg0.clone(), new FunctionNode("log", [arg1 || node.args[1]])]);
                  div2 = true;
                } else if (node.args.length === 2) {
                  return _derivative(new OperatorNode("/", "divide", [new FunctionNode("log", [arg0]), new FunctionNode("log", [node.args[1]])]), constNodes);
                }
                break;
              case "pow":
                if (node.args.length === 2) {
                  constNodes[arg1] = constNodes[node.args[1]];
                  return _derivative(new OperatorNode("^", "pow", [arg0, node.args[1]]), constNodes);
                }
                break;
              case "exp":
                funcDerivative = new FunctionNode("exp", [arg0.clone()]);
                break;
              case "sin":
                funcDerivative = new FunctionNode("cos", [arg0.clone()]);
                break;
              case "cos":
                funcDerivative = new OperatorNode("-", "unaryMinus", [new FunctionNode("sin", [arg0.clone()])]);
                break;
              case "tan":
                funcDerivative = new OperatorNode("^", "pow", [new FunctionNode("sec", [arg0.clone()]), createConstantNode(2)]);
                break;
              case "sec":
                funcDerivative = new OperatorNode("*", "multiply", [node, new FunctionNode("tan", [arg0.clone()])]);
                break;
              case "csc":
                negative = true;
                funcDerivative = new OperatorNode("*", "multiply", [node, new FunctionNode("cot", [arg0.clone()])]);
                break;
              case "cot":
                negative = true;
                funcDerivative = new OperatorNode("^", "pow", [new FunctionNode("csc", [arg0.clone()]), createConstantNode(2)]);
                break;
              case "asin":
                div2 = true;
                funcDerivative = new FunctionNode("sqrt", [new OperatorNode("-", "subtract", [createConstantNode(1), new OperatorNode("^", "pow", [arg0.clone(), createConstantNode(2)])])]);
                break;
              case "acos":
                div2 = true;
                negative = true;
                funcDerivative = new FunctionNode("sqrt", [new OperatorNode("-", "subtract", [createConstantNode(1), new OperatorNode("^", "pow", [arg0.clone(), createConstantNode(2)])])]);
                break;
              case "atan":
                div2 = true;
                funcDerivative = new OperatorNode("+", "add", [new OperatorNode("^", "pow", [arg0.clone(), createConstantNode(2)]), createConstantNode(1)]);
                break;
              case "asec":
                div2 = true;
                funcDerivative = new OperatorNode("*", "multiply", [new FunctionNode("abs", [arg0.clone()]), new FunctionNode("sqrt", [new OperatorNode("-", "subtract", [new OperatorNode("^", "pow", [arg0.clone(), createConstantNode(2)]), createConstantNode(1)])])]);
                break;
              case "acsc":
                div2 = true;
                negative = true;
                funcDerivative = new OperatorNode("*", "multiply", [new FunctionNode("abs", [arg0.clone()]), new FunctionNode("sqrt", [new OperatorNode("-", "subtract", [new OperatorNode("^", "pow", [arg0.clone(), createConstantNode(2)]), createConstantNode(1)])])]);
                break;
              case "acot":
                div2 = true;
                negative = true;
                funcDerivative = new OperatorNode("+", "add", [new OperatorNode("^", "pow", [arg0.clone(), createConstantNode(2)]), createConstantNode(1)]);
                break;
              case "sinh":
                funcDerivative = new FunctionNode("cosh", [arg0.clone()]);
                break;
              case "cosh":
                funcDerivative = new FunctionNode("sinh", [arg0.clone()]);
                break;
              case "tanh":
                funcDerivative = new OperatorNode("^", "pow", [new FunctionNode("sech", [arg0.clone()]), createConstantNode(2)]);
                break;
              case "sech":
                negative = true;
                funcDerivative = new OperatorNode("*", "multiply", [node, new FunctionNode("tanh", [arg0.clone()])]);
                break;
              case "csch":
                negative = true;
                funcDerivative = new OperatorNode("*", "multiply", [node, new FunctionNode("coth", [arg0.clone()])]);
                break;
              case "coth":
                negative = true;
                funcDerivative = new OperatorNode("^", "pow", [new FunctionNode("csch", [arg0.clone()]), createConstantNode(2)]);
                break;
              case "asinh":
                div2 = true;
                funcDerivative = new FunctionNode("sqrt", [new OperatorNode("+", "add", [new OperatorNode("^", "pow", [arg0.clone(), createConstantNode(2)]), createConstantNode(1)])]);
                break;
              case "acosh":
                div2 = true;
                funcDerivative = new FunctionNode("sqrt", [new OperatorNode("-", "subtract", [new OperatorNode("^", "pow", [arg0.clone(), createConstantNode(2)]), createConstantNode(1)])]);
                break;
              case "atanh":
                div2 = true;
                funcDerivative = new OperatorNode("-", "subtract", [createConstantNode(1), new OperatorNode("^", "pow", [arg0.clone(), createConstantNode(2)])]);
                break;
              case "asech":
                div2 = true;
                negative = true;
                funcDerivative = new OperatorNode("*", "multiply", [arg0.clone(), new FunctionNode("sqrt", [new OperatorNode("-", "subtract", [createConstantNode(1), new OperatorNode("^", "pow", [arg0.clone(), createConstantNode(2)])])])]);
                break;
              case "acsch":
                div2 = true;
                negative = true;
                funcDerivative = new OperatorNode("*", "multiply", [new FunctionNode("abs", [arg0.clone()]), new FunctionNode("sqrt", [new OperatorNode("+", "add", [new OperatorNode("^", "pow", [arg0.clone(), createConstantNode(2)]), createConstantNode(1)])])]);
                break;
              case "acoth":
                div2 = true;
                negative = true;
                funcDerivative = new OperatorNode("-", "subtract", [createConstantNode(1), new OperatorNode("^", "pow", [arg0.clone(), createConstantNode(2)])]);
                break;
              case "abs":
                funcDerivative = new OperatorNode("/", "divide", [new FunctionNode(new SymbolNode("abs"), [arg0.clone()]), arg0.clone()]);
                break;
              case "gamma":
              // Needs digamma function, d/dx(gamma(x)) = gamma(x)digamma(x)
              default:
                throw new Error('Cannot process function "' + node.name + '" in derivative: the function is not supported, undefined, or the number of arguments passed to it are not supported');
            }
            var op, func;
            if (div2) {
              op = "/";
              func = "divide";
            } else {
              op = "*";
              func = "multiply";
            }
            var chainDerivative = _derivative(arg0, constNodes);
            if (negative) {
              chainDerivative = new OperatorNode("-", "unaryMinus", [chainDerivative]);
            }
            return new OperatorNode(op, func, [chainDerivative, funcDerivative]);
          },
          "OperatorNode, Object": function OperatorNodeObject(node, constNodes) {
            if (constNodes[node] !== void 0) {
              return createConstantNode(0);
            }
            if (node.op === "+") {
              return new OperatorNode(node.op, node.fn, node.args.map(function(arg) {
                return _derivative(arg, constNodes);
              }));
            }
            if (node.op === "-") {
              if (node.isUnary()) {
                return new OperatorNode(node.op, node.fn, [_derivative(node.args[0], constNodes)]);
              }
              if (node.isBinary()) {
                return new OperatorNode(node.op, node.fn, [_derivative(node.args[0], constNodes), _derivative(node.args[1], constNodes)]);
              }
            }
            if (node.op === "*") {
              var constantTerms = node.args.filter(function(arg) {
                return constNodes[arg] !== void 0;
              });
              if (constantTerms.length > 0) {
                var nonConstantTerms = node.args.filter(function(arg) {
                  return constNodes[arg] === void 0;
                });
                var nonConstantNode = nonConstantTerms.length === 1 ? nonConstantTerms[0] : new OperatorNode("*", "multiply", nonConstantTerms);
                var newArgs = constantTerms.concat(_derivative(nonConstantNode, constNodes));
                return new OperatorNode("*", "multiply", newArgs);
              }
              return new OperatorNode("+", "add", node.args.map(function(argOuter) {
                return new OperatorNode("*", "multiply", node.args.map(function(argInner) {
                  return argInner === argOuter ? _derivative(argInner, constNodes) : argInner.clone();
                }));
              }));
            }
            if (node.op === "/" && node.isBinary()) {
              var arg0 = node.args[0];
              var arg1 = node.args[1];
              if (constNodes[arg1] !== void 0) {
                return new OperatorNode("/", "divide", [_derivative(arg0, constNodes), arg1]);
              }
              if (constNodes[arg0] !== void 0) {
                return new OperatorNode("*", "multiply", [new OperatorNode("-", "unaryMinus", [arg0]), new OperatorNode("/", "divide", [_derivative(arg1, constNodes), new OperatorNode("^", "pow", [arg1.clone(), createConstantNode(2)])])]);
              }
              return new OperatorNode("/", "divide", [new OperatorNode("-", "subtract", [new OperatorNode("*", "multiply", [_derivative(arg0, constNodes), arg1.clone()]), new OperatorNode("*", "multiply", [arg0.clone(), _derivative(arg1, constNodes)])]), new OperatorNode("^", "pow", [arg1.clone(), createConstantNode(2)])]);
            }
            if (node.op === "^" && node.isBinary()) {
              var _arg = node.args[0];
              var _arg2 = node.args[1];
              if (constNodes[_arg] !== void 0) {
                if ((0, _is.isConstantNode)(_arg) && (isZero(_arg.value) || equal(_arg.value, 1))) {
                  return createConstantNode(0);
                }
                return new OperatorNode("*", "multiply", [node, new OperatorNode("*", "multiply", [new FunctionNode("log", [_arg.clone()]), _derivative(_arg2.clone(), constNodes)])]);
              }
              if (constNodes[_arg2] !== void 0) {
                if ((0, _is.isConstantNode)(_arg2)) {
                  if (isZero(_arg2.value)) {
                    return createConstantNode(0);
                  }
                  if (equal(_arg2.value, 1)) {
                    return _derivative(_arg, constNodes);
                  }
                }
                var powMinusOne = new OperatorNode("^", "pow", [_arg.clone(), new OperatorNode("-", "subtract", [_arg2, createConstantNode(1)])]);
                return new OperatorNode("*", "multiply", [_arg2.clone(), new OperatorNode("*", "multiply", [_derivative(_arg, constNodes), powMinusOne])]);
              }
              return new OperatorNode("*", "multiply", [new OperatorNode("^", "pow", [_arg.clone(), _arg2.clone()]), new OperatorNode("+", "add", [new OperatorNode("*", "multiply", [_derivative(_arg, constNodes), new OperatorNode("/", "divide", [_arg2.clone(), _arg.clone()])]), new OperatorNode("*", "multiply", [_derivative(_arg2, constNodes), new FunctionNode("log", [_arg.clone()])])])]);
            }
            throw new Error('Cannot process operator "' + node.op + '" in derivative: the operator is not supported, undefined, or the number of arguments passed to it are not supported');
          }
        });
        function createConstantNode(value, valueType) {
          return new ConstantNode(numeric(value, valueType || config4.number));
        }
        return derivative;
      });
    }
  });

  // node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/function/algebra/rationalize.js
  var require_rationalize2 = __commonJS({
    "node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/function/algebra/rationalize.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.createRationalize = void 0;
      var _number = require_number();
      var _factory = require_factory();
      var name18 = "rationalize";
      var dependencies19 = ["config", "typed", "equal", "isZero", "add", "subtract", "multiply", "divide", "pow", "parse", "simplifyConstant", "simplifyCore", "simplify", "?bignumber", "?fraction", "mathWithTransform", "matrix", "AccessorNode", "ArrayNode", "ConstantNode", "FunctionNode", "IndexNode", "ObjectNode", "OperatorNode", "SymbolNode", "ParenthesisNode"];
      var createRationalize = exports.createRationalize = /* @__PURE__ */ (0, _factory.factory)(name18, dependencies19, function(_ref) {
        var config4 = _ref.config, typed2 = _ref.typed, equal = _ref.equal, isZero = _ref.isZero, add2 = _ref.add, subtract = _ref.subtract, multiply2 = _ref.multiply, divide2 = _ref.divide, pow2 = _ref.pow, parse2 = _ref.parse, simplifyConstant = _ref.simplifyConstant, simplifyCore = _ref.simplifyCore, simplify = _ref.simplify, fraction = _ref.fraction, bignumber = _ref.bignumber, mathWithTransform = _ref.mathWithTransform, matrix2 = _ref.matrix, AccessorNode = _ref.AccessorNode, ArrayNode = _ref.ArrayNode, ConstantNode = _ref.ConstantNode, FunctionNode = _ref.FunctionNode, IndexNode = _ref.IndexNode, ObjectNode = _ref.ObjectNode, OperatorNode = _ref.OperatorNode, SymbolNode = _ref.SymbolNode, ParenthesisNode = _ref.ParenthesisNode;
        function _rationalize(expr) {
          var scope = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
          var detailed = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : false;
          var setRules = rulesRationalize();
          var polyRet = polynomial(expr, scope, true, setRules.firstRules);
          var nVars = polyRet.variables.length;
          var noExactFractions = {
            exactFractions: false
          };
          var withExactFractions = {
            exactFractions: true
          };
          expr = polyRet.expression;
          if (nVars >= 1) {
            expr = expandPower(expr);
            var sBefore;
            var rules;
            var eDistrDiv = true;
            var redoInic = false;
            expr = simplify(expr, setRules.firstRules, {}, noExactFractions);
            var s;
            while (true) {
              rules = eDistrDiv ? setRules.distrDivRules : setRules.sucDivRules;
              expr = simplify(expr, rules, {}, withExactFractions);
              eDistrDiv = !eDistrDiv;
              s = expr.toString();
              if (s === sBefore) {
                break;
              }
              redoInic = true;
              sBefore = s;
            }
            if (redoInic) {
              expr = simplify(expr, setRules.firstRulesAgain, {}, noExactFractions);
            }
            expr = simplify(expr, setRules.finalRules, {}, noExactFractions);
          }
          var coefficients = [];
          var retRationalize = {};
          if (expr.type === "OperatorNode" && expr.isBinary() && expr.op === "/") {
            if (nVars === 1) {
              expr.args[0] = polyToCanonical(expr.args[0], coefficients);
              expr.args[1] = polyToCanonical(expr.args[1]);
            }
            if (detailed) {
              retRationalize.numerator = expr.args[0];
              retRationalize.denominator = expr.args[1];
            }
          } else {
            if (nVars === 1) {
              expr = polyToCanonical(expr, coefficients);
            }
            if (detailed) {
              retRationalize.numerator = expr;
              retRationalize.denominator = null;
            }
          }
          if (!detailed) return expr;
          retRationalize.coefficients = coefficients;
          retRationalize.variables = polyRet.variables;
          retRationalize.expression = expr;
          return retRationalize;
        }
        return typed2(name18, {
          Node: _rationalize,
          "Node, boolean": function NodeBoolean(expr, detailed) {
            return _rationalize(expr, {}, detailed);
          },
          "Node, Object": _rationalize,
          "Node, Object, boolean": _rationalize
        });
        function polynomial(expr, scope, extended, rules) {
          var variables = [];
          var node = simplify(expr, rules, scope, {
            exactFractions: false
          });
          extended = !!extended;
          var oper = "+-*" + (extended ? "/" : "");
          recPoly(node);
          var retFunc = {};
          retFunc.expression = node;
          retFunc.variables = variables;
          return retFunc;
          function recPoly(node2) {
            var tp = node2.type;
            if (tp === "FunctionNode") {
              throw new Error("There is an unsolved function call");
            } else if (tp === "OperatorNode") {
              if (node2.op === "^") {
                if (node2.args[1].type !== "ConstantNode" || !(0, _number.isInteger)(parseFloat(node2.args[1].value))) {
                  throw new Error("There is a non-integer exponent");
                } else {
                  recPoly(node2.args[0]);
                }
              } else {
                if (!oper.includes(node2.op)) {
                  throw new Error("Operator " + node2.op + " invalid in polynomial expression");
                }
                for (var i = 0; i < node2.args.length; i++) {
                  recPoly(node2.args[i]);
                }
              }
            } else if (tp === "SymbolNode") {
              var _name = node2.name;
              var pos = variables.indexOf(_name);
              if (pos === -1) {
                variables.push(_name);
              }
            } else if (tp === "ParenthesisNode") {
              recPoly(node2.content);
            } else if (tp !== "ConstantNode") {
              throw new Error("type " + tp + " is not allowed in polynomial expression");
            }
          }
        }
        function rulesRationalize() {
          var oldRules = [
            simplifyCore,
            // sCore
            {
              l: "n+n",
              r: "2*n"
            },
            {
              l: "n+-n",
              r: "0"
            },
            simplifyConstant,
            // sConstant
            {
              l: "n*(n1^-1)",
              r: "n/n1"
            },
            {
              l: "n*n1^-n2",
              r: "n/n1^n2"
            },
            {
              l: "n1^-1",
              r: "1/n1"
            },
            {
              l: "n*(n1/n2)",
              r: "(n*n1)/n2"
            },
            {
              l: "1*n",
              r: "n"
            }
          ];
          var rulesFirst = [
            {
              l: "(-n1)/(-n2)",
              r: "n1/n2"
            },
            // Unary division
            {
              l: "(-n1)*(-n2)",
              r: "n1*n2"
            },
            // Unary multiplication
            {
              l: "n1--n2",
              r: "n1+n2"
            },
            // '--' elimination
            {
              l: "n1-n2",
              r: "n1+(-n2)"
            },
            // Subtraction turn into add with unry minus
            {
              l: "(n1+n2)*n3",
              r: "(n1*n3 + n2*n3)"
            },
            // Distributive 1
            {
              l: "n1*(n2+n3)",
              r: "(n1*n2+n1*n3)"
            },
            // Distributive 2
            {
              l: "c1*n + c2*n",
              r: "(c1+c2)*n"
            },
            // Joining constants
            {
              l: "c1*n + n",
              r: "(c1+1)*n"
            },
            // Joining constants
            {
              l: "c1*n - c2*n",
              r: "(c1-c2)*n"
            },
            // Joining constants
            {
              l: "c1*n - n",
              r: "(c1-1)*n"
            },
            // Joining constants
            {
              l: "v/c",
              r: "(1/c)*v"
            },
            // variable/constant (new!)
            {
              l: "v/-c",
              r: "-(1/c)*v"
            },
            // variable/constant (new!)
            {
              l: "-v*-c",
              r: "c*v"
            },
            // Inversion constant and variable 1
            {
              l: "-v*c",
              r: "-c*v"
            },
            // Inversion constant and variable 2
            {
              l: "v*-c",
              r: "-c*v"
            },
            // Inversion constant and variable 3
            {
              l: "v*c",
              r: "c*v"
            },
            // Inversion constant and variable 4
            {
              l: "-(-n1*n2)",
              r: "(n1*n2)"
            },
            // Unary propagation
            {
              l: "-(n1*n2)",
              r: "(-n1*n2)"
            },
            // Unary propagation
            {
              l: "-(-n1+n2)",
              r: "(n1-n2)"
            },
            // Unary propagation
            {
              l: "-(n1+n2)",
              r: "(-n1-n2)"
            },
            // Unary propagation
            {
              l: "(n1^n2)^n3",
              r: "(n1^(n2*n3))"
            },
            // Power to Power
            {
              l: "-(-n1/n2)",
              r: "(n1/n2)"
            },
            // Division and Unary
            {
              l: "-(n1/n2)",
              r: "(-n1/n2)"
            }
          ];
          var rulesDistrDiv = [
            {
              l: "(n1/n2 + n3/n4)",
              r: "((n1*n4 + n3*n2)/(n2*n4))"
            },
            // Sum of fractions
            {
              l: "(n1/n2 + n3)",
              r: "((n1 + n3*n2)/n2)"
            },
            // Sum fraction with number 1
            {
              l: "(n1 + n2/n3)",
              r: "((n1*n3 + n2)/n3)"
            }
          ];
          var rulesSucDiv = [
            {
              l: "(n1/(n2/n3))",
              r: "((n1*n3)/n2)"
            },
            // Division simplification
            {
              l: "(n1/n2/n3)",
              r: "(n1/(n2*n3))"
            }
          ];
          var setRules = {};
          setRules.firstRules = oldRules.concat(rulesFirst, rulesSucDiv);
          setRules.distrDivRules = rulesDistrDiv;
          setRules.sucDivRules = rulesSucDiv;
          setRules.firstRulesAgain = oldRules.concat(rulesFirst);
          setRules.finalRules = [
            simplifyCore,
            // simplify.rules[0]
            {
              l: "n*-n",
              r: "-n^2"
            },
            // Joining multiply with power 1
            {
              l: "n*n",
              r: "n^2"
            },
            // Joining multiply with power 2
            simplifyConstant,
            // simplify.rules[14] old 3rd index in oldRules
            {
              l: "n*-n^n1",
              r: "-n^(n1+1)"
            },
            // Joining multiply with power 3
            {
              l: "n*n^n1",
              r: "n^(n1+1)"
            },
            // Joining multiply with power 4
            {
              l: "n^n1*-n^n2",
              r: "-n^(n1+n2)"
            },
            // Joining multiply with power 5
            {
              l: "n^n1*n^n2",
              r: "n^(n1+n2)"
            },
            // Joining multiply with power 6
            {
              l: "n^n1*-n",
              r: "-n^(n1+1)"
            },
            // Joining multiply with power 7
            {
              l: "n^n1*n",
              r: "n^(n1+1)"
            },
            // Joining multiply with power 8
            {
              l: "n^n1/-n",
              r: "-n^(n1-1)"
            },
            // Joining multiply with power 8
            {
              l: "n^n1/n",
              r: "n^(n1-1)"
            },
            // Joining division with power 1
            {
              l: "n/-n^n1",
              r: "-n^(1-n1)"
            },
            // Joining division with power 2
            {
              l: "n/n^n1",
              r: "n^(1-n1)"
            },
            // Joining division with power 3
            {
              l: "n^n1/-n^n2",
              r: "n^(n1-n2)"
            },
            // Joining division with power 4
            {
              l: "n^n1/n^n2",
              r: "n^(n1-n2)"
            },
            // Joining division with power 5
            {
              l: "n1+(-n2*n3)",
              r: "n1-n2*n3"
            },
            // Solving useless parenthesis 1
            {
              l: "v*(-c)",
              r: "-c*v"
            },
            // Solving useless unary 2
            {
              l: "n1+-n2",
              r: "n1-n2"
            },
            // Solving +- together (new!)
            {
              l: "v*c",
              r: "c*v"
            },
            // inversion constant with variable
            {
              l: "(n1^n2)^n3",
              r: "(n1^(n2*n3))"
            }
            // Power to Power
          ];
          return setRules;
        }
        function expandPower(node, parent, indParent) {
          var tp = node.type;
          var internal = arguments.length > 1;
          if (tp === "OperatorNode" && node.isBinary()) {
            var does = false;
            var val;
            if (node.op === "^") {
              if ((node.args[0].type === "ParenthesisNode" || node.args[0].type === "OperatorNode") && node.args[1].type === "ConstantNode") {
                val = parseFloat(node.args[1].value);
                does = val >= 2 && (0, _number.isInteger)(val);
              }
            }
            if (does) {
              if (val > 2) {
                var nEsqTopo = node.args[0];
                var nDirTopo = new OperatorNode("^", "pow", [node.args[0].cloneDeep(), new ConstantNode(val - 1)]);
                node = new OperatorNode("*", "multiply", [nEsqTopo, nDirTopo]);
              } else {
                node = new OperatorNode("*", "multiply", [node.args[0], node.args[0].cloneDeep()]);
              }
              if (internal) {
                if (indParent === "content") {
                  parent.content = node;
                } else {
                  parent.args[indParent] = node;
                }
              }
            }
          }
          if (tp === "ParenthesisNode") {
            expandPower(node.content, node, "content");
          } else if (tp !== "ConstantNode" && tp !== "SymbolNode") {
            for (var i = 0; i < node.args.length; i++) {
              expandPower(node.args[i], node, i);
            }
          }
          if (!internal) {
            return node;
          }
        }
        function polyToCanonical(node, coefficients) {
          if (coefficients === void 0) {
            coefficients = [];
          }
          coefficients[0] = 0;
          var o = {};
          o.cte = 1;
          o.oper = "+";
          o.fire = "";
          var maxExpo = 0;
          var varname = "";
          recurPol(node, null, o);
          maxExpo = coefficients.length - 1;
          var first = true;
          var no;
          for (var i = maxExpo; i >= 0; i--) {
            if (coefficients[i] === 0) continue;
            var n12 = new ConstantNode(first ? coefficients[i] : Math.abs(coefficients[i]));
            var op = coefficients[i] < 0 ? "-" : "+";
            if (i > 0) {
              var n22 = new SymbolNode(varname);
              if (i > 1) {
                var n3 = new ConstantNode(i);
                n22 = new OperatorNode("^", "pow", [n22, n3]);
              }
              if (coefficients[i] === -1 && first) {
                n12 = new OperatorNode("-", "unaryMinus", [n22]);
              } else if (Math.abs(coefficients[i]) === 1) {
                n12 = n22;
              } else {
                n12 = new OperatorNode("*", "multiply", [n12, n22]);
              }
            }
            if (first) {
              no = n12;
            } else if (op === "+") {
              no = new OperatorNode("+", "add", [no, n12]);
            } else {
              no = new OperatorNode("-", "subtract", [no, n12]);
            }
            first = false;
          }
          if (first) {
            return new ConstantNode(0);
          } else {
            return no;
          }
          function recurPol(node2, noPai, o2) {
            var tp = node2.type;
            if (tp === "FunctionNode") {
              throw new Error("There is an unsolved function call");
            } else if (tp === "OperatorNode") {
              if (!"+-*^".includes(node2.op)) throw new Error("Operator " + node2.op + " invalid");
              if (noPai !== null) {
                if ((node2.fn === "unaryMinus" || node2.fn === "pow") && noPai.fn !== "add" && noPai.fn !== "subtract" && noPai.fn !== "multiply") {
                  throw new Error("Invalid " + node2.op + " placing");
                }
                if ((node2.fn === "subtract" || node2.fn === "add" || node2.fn === "multiply") && noPai.fn !== "add" && noPai.fn !== "subtract") {
                  throw new Error("Invalid " + node2.op + " placing");
                }
                if ((node2.fn === "subtract" || node2.fn === "add" || node2.fn === "unaryMinus") && o2.noFil !== 0) {
                  throw new Error("Invalid " + node2.op + " placing");
                }
              }
              if (node2.op === "^" || node2.op === "*") {
                o2.fire = node2.op;
              }
              for (var _i = 0; _i < node2.args.length; _i++) {
                if (node2.fn === "unaryMinus") o2.oper = "-";
                if (node2.op === "+" || node2.fn === "subtract") {
                  o2.fire = "";
                  o2.cte = 1;
                  o2.oper = _i === 0 ? "+" : node2.op;
                }
                o2.noFil = _i;
                recurPol(node2.args[_i], node2, o2);
              }
            } else if (tp === "SymbolNode") {
              if (node2.name !== varname && varname !== "") {
                throw new Error("There is more than one variable");
              }
              varname = node2.name;
              if (noPai === null) {
                coefficients[1] = 1;
                return;
              }
              if (noPai.op === "^" && o2.noFil !== 0) {
                throw new Error("In power the variable should be the first parameter");
              }
              if (noPai.op === "*" && o2.noFil !== 1) {
                throw new Error("In multiply the variable should be the second parameter");
              }
              if (o2.fire === "" || o2.fire === "*") {
                if (maxExpo < 1) coefficients[1] = 0;
                coefficients[1] += o2.cte * (o2.oper === "+" ? 1 : -1);
                maxExpo = Math.max(1, maxExpo);
              }
            } else if (tp === "ConstantNode") {
              var valor = parseFloat(node2.value);
              if (noPai === null) {
                coefficients[0] = valor;
                return;
              }
              if (noPai.op === "^") {
                if (o2.noFil !== 1) throw new Error("Constant cannot be powered");
                if (!(0, _number.isInteger)(valor) || valor <= 0) {
                  throw new Error("Non-integer exponent is not allowed");
                }
                for (var _i2 = maxExpo + 1; _i2 < valor; _i2++) coefficients[_i2] = 0;
                if (valor > maxExpo) coefficients[valor] = 0;
                coefficients[valor] += o2.cte * (o2.oper === "+" ? 1 : -1);
                maxExpo = Math.max(valor, maxExpo);
                return;
              }
              o2.cte = valor;
              if (o2.fire === "") {
                coefficients[0] += o2.cte * (o2.oper === "+" ? 1 : -1);
              }
            } else {
              throw new Error("Type " + tp + " is not allowed");
            }
          }
        }
      });
    }
  });

  // node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/function/signal/zpk2tf.js
  var require_zpk2tf2 = __commonJS({
    "node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/function/signal/zpk2tf.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.createZpk2tf = void 0;
      var _factory = require_factory();
      var name18 = "zpk2tf";
      var dependencies19 = ["typed", "add", "multiply", "Complex", "number"];
      var createZpk2tf2 = exports.createZpk2tf = /* @__PURE__ */ (0, _factory.factory)(name18, dependencies19, function(_ref) {
        var typed2 = _ref.typed, add2 = _ref.add, multiply2 = _ref.multiply, Complex3 = _ref.Complex, number = _ref.number;
        return typed2(name18, {
          "Array,Array,number": function ArrayArrayNumber(z, p, k) {
            return _zpk2tf(z, p, k);
          },
          "Array,Array": function ArrayArray(z, p) {
            return _zpk2tf(z, p, 1);
          },
          "Matrix,Matrix,number": function MatrixMatrixNumber(z, p, k) {
            return _zpk2tf(z.valueOf(), p.valueOf(), k);
          },
          "Matrix,Matrix": function MatrixMatrix(z, p) {
            return _zpk2tf(z.valueOf(), p.valueOf(), 1);
          }
        });
        function _zpk2tf(z, p, k) {
          if (z.some(function(el) {
            return el.type === "BigNumber";
          })) {
            z = z.map(function(el) {
              return number(el);
            });
          }
          if (p.some(function(el) {
            return el.type === "BigNumber";
          })) {
            p = p.map(function(el) {
              return number(el);
            });
          }
          var num = [Complex3(1, 0)];
          var den = [Complex3(1, 0)];
          for (var i = 0; i < z.length; i++) {
            var zero = z[i];
            if (typeof zero === "number") zero = Complex3(zero, 0);
            num = _multiply(num, [Complex3(1, 0), Complex3(-zero.re, -zero.im)]);
          }
          for (var _i = 0; _i < p.length; _i++) {
            var pole = p[_i];
            if (typeof pole === "number") pole = Complex3(pole, 0);
            den = _multiply(den, [Complex3(1, 0), Complex3(-pole.re, -pole.im)]);
          }
          for (var _i2 = 0; _i2 < num.length; _i2++) {
            num[_i2] = multiply2(num[_i2], k);
          }
          return [num, den];
        }
        function _multiply(a, b) {
          var c = [];
          for (var i = 0; i < a.length + b.length - 1; i++) {
            c[i] = Complex3(0, 0);
            for (var j = 0; j < a.length; j++) {
              if (i - j >= 0 && i - j < b.length) {
                c[i] = add2(c[i], multiply2(a[j], b[i - j]));
              }
            }
          }
          return c;
        }
      });
    }
  });

  // node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/function/signal/freqz.js
  var require_freqz2 = __commonJS({
    "node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/function/signal/freqz.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.createFreqz = void 0;
      var _factory = require_factory();
      var name18 = "freqz";
      var dependencies19 = ["typed", "add", "multiply", "Complex", "divide", "matrix"];
      var createFreqz2 = exports.createFreqz = /* @__PURE__ */ (0, _factory.factory)(name18, dependencies19, function(_ref) {
        var typed2 = _ref.typed, add2 = _ref.add, multiply2 = _ref.multiply, Complex3 = _ref.Complex, divide2 = _ref.divide, matrix2 = _ref.matrix;
        return typed2(name18, {
          "Array, Array": function ArrayArray(b, a) {
            var w = createBins(512);
            return _freqz(b, a, w);
          },
          "Array, Array, Array": function ArrayArrayArray(b, a, w) {
            return _freqz(b, a, w);
          },
          "Array, Array, number": function ArrayArrayNumber(b, a, w) {
            if (w < 0) {
              throw new Error("w must be a positive number");
            }
            var w2 = createBins(w);
            return _freqz(b, a, w2);
          },
          "Matrix, Matrix": function MatrixMatrix(b, a) {
            var _w = createBins(512);
            var _freqz2 = _freqz(b.valueOf(), a.valueOf(), _w), w = _freqz2.w, h = _freqz2.h;
            return {
              w: matrix2(w),
              h: matrix2(h)
            };
          },
          "Matrix, Matrix, Matrix": function MatrixMatrixMatrix(b, a, w) {
            var _freqz3 = _freqz(b.valueOf(), a.valueOf(), w.valueOf()), h = _freqz3.h;
            return {
              h: matrix2(h),
              w: matrix2(w)
            };
          },
          "Matrix, Matrix, number": function MatrixMatrixNumber(b, a, w) {
            if (w < 0) {
              throw new Error("w must be a positive number");
            }
            var _w = createBins(w);
            var _freqz4 = _freqz(b.valueOf(), a.valueOf(), _w), h = _freqz4.h;
            return {
              h: matrix2(h),
              w: matrix2(_w)
            };
          }
        });
        function _freqz(b, a, w) {
          var num = [];
          var den = [];
          for (var i = 0; i < w.length; i++) {
            var sumNum = Complex3(0, 0);
            var sumDen = Complex3(0, 0);
            for (var j = 0; j < b.length; j++) {
              sumNum = add2(sumNum, multiply2(b[j], Complex3(Math.cos(-j * w[i]), Math.sin(-j * w[i]))));
            }
            for (var _j = 0; _j < a.length; _j++) {
              sumDen = add2(sumDen, multiply2(a[_j], Complex3(Math.cos(-_j * w[i]), Math.sin(-_j * w[i]))));
            }
            num.push(sumNum);
            den.push(sumDen);
          }
          var h = [];
          for (var _i = 0; _i < num.length; _i++) {
            h.push(divide2(num[_i], den[_i]));
          }
          return {
            h,
            w
          };
        }
        function createBins(n) {
          var bins = [];
          for (var i = 0; i < n; i++) {
            bins.push(i / n * Math.PI);
          }
          return bins;
        }
      });
    }
  });

  // node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/json/reviver.js
  var require_reviver = __commonJS({
    "node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/json/reviver.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.createReviver = void 0;
      var _factory = require_factory();
      var name18 = "reviver";
      var dependencies19 = ["classes"];
      var createReviver = exports.createReviver = /* @__PURE__ */ (0, _factory.factory)(name18, dependencies19, function(_ref) {
        var classes = _ref.classes;
        return function reviver(key, value) {
          var constructor = classes[value && value.mathjs];
          if (constructor && typeof constructor.fromJSON === "function") {
            return constructor.fromJSON(value);
          }
          return value;
        };
      });
    }
  });

  // node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/json/replacer.js
  var require_replacer = __commonJS({
    "node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/json/replacer.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.createReplacer = void 0;
      var _factory = require_factory();
      var name18 = "replacer";
      var dependencies19 = [];
      var createReplacer2 = exports.createReplacer = /* @__PURE__ */ (0, _factory.factory)(name18, dependencies19, function() {
        return function replacer(key, value) {
          if (typeof value === "number" && (!isFinite(value) || isNaN(value))) {
            return {
              mathjs: "number",
              value: String(value)
            };
          }
          return value;
        };
      });
    }
  });

  // node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/version.js
  var require_version2 = __commonJS({
    "node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/version.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.version = void 0;
      var version = exports.version = "12.4.3";
    }
  });

  // node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/constants.js
  var require_constants3 = __commonJS({
    "node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/constants.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.createVersion = exports.createUppercasePi = exports.createUppercaseE = exports.createTrue = exports.createTau = exports.createSQRT2 = exports.createSQRT1_2 = exports.createPi = exports.createPhi = exports.createNull = exports.createNaN = exports.createLOG2E = exports.createLOG10E = exports.createLN2 = exports.createLN10 = exports.createInfinity = exports.createI = exports.createFalse = exports.createE = void 0;
      var _factory = require_factory();
      var _version = require_version2();
      var _constants = require_constants2();
      var _index = require_number2();
      var createTrue2 = exports.createTrue = /* @__PURE__ */ (0, _factory.factory)("true", [], function() {
        return true;
      });
      var createFalse2 = exports.createFalse = /* @__PURE__ */ (0, _factory.factory)("false", [], function() {
        return false;
      });
      var createNull2 = exports.createNull = /* @__PURE__ */ (0, _factory.factory)("null", [], function() {
        return null;
      });
      var createInfinity2 = exports.createInfinity = /* @__PURE__ */ recreateFactory("Infinity", ["config", "?BigNumber"], function(_ref) {
        var config4 = _ref.config, BigNumber2 = _ref.BigNumber;
        return config4.number === "BigNumber" ? new BigNumber2(Infinity) : Infinity;
      });
      var createNaN2 = exports.createNaN = /* @__PURE__ */ recreateFactory("NaN", ["config", "?BigNumber"], function(_ref2) {
        var config4 = _ref2.config, BigNumber2 = _ref2.BigNumber;
        return config4.number === "BigNumber" ? new BigNumber2(NaN) : NaN;
      });
      var createPi2 = exports.createPi = /* @__PURE__ */ recreateFactory("pi", ["config", "?BigNumber"], function(_ref3) {
        var config4 = _ref3.config, BigNumber2 = _ref3.BigNumber;
        return config4.number === "BigNumber" ? (0, _constants.createBigNumberPi)(BigNumber2) : _index.pi;
      });
      var createTau2 = exports.createTau = /* @__PURE__ */ recreateFactory("tau", ["config", "?BigNumber"], function(_ref4) {
        var config4 = _ref4.config, BigNumber2 = _ref4.BigNumber;
        return config4.number === "BigNumber" ? (0, _constants.createBigNumberTau)(BigNumber2) : _index.tau;
      });
      var createE2 = exports.createE = /* @__PURE__ */ recreateFactory("e", ["config", "?BigNumber"], function(_ref5) {
        var config4 = _ref5.config, BigNumber2 = _ref5.BigNumber;
        return config4.number === "BigNumber" ? (0, _constants.createBigNumberE)(BigNumber2) : _index.e;
      });
      var createPhi2 = exports.createPhi = /* @__PURE__ */ recreateFactory("phi", ["config", "?BigNumber"], function(_ref6) {
        var config4 = _ref6.config, BigNumber2 = _ref6.BigNumber;
        return config4.number === "BigNumber" ? (0, _constants.createBigNumberPhi)(BigNumber2) : _index.phi;
      });
      var createLN22 = exports.createLN2 = /* @__PURE__ */ recreateFactory("LN2", ["config", "?BigNumber"], function(_ref7) {
        var config4 = _ref7.config, BigNumber2 = _ref7.BigNumber;
        return config4.number === "BigNumber" ? new BigNumber2(2).ln() : Math.LN2;
      });
      var createLN102 = exports.createLN10 = /* @__PURE__ */ recreateFactory("LN10", ["config", "?BigNumber"], function(_ref8) {
        var config4 = _ref8.config, BigNumber2 = _ref8.BigNumber;
        return config4.number === "BigNumber" ? new BigNumber2(10).ln() : Math.LN10;
      });
      var createLOG2E2 = exports.createLOG2E = /* @__PURE__ */ recreateFactory("LOG2E", ["config", "?BigNumber"], function(_ref9) {
        var config4 = _ref9.config, BigNumber2 = _ref9.BigNumber;
        return config4.number === "BigNumber" ? new BigNumber2(1).div(new BigNumber2(2).ln()) : Math.LOG2E;
      });
      var createLOG10E2 = exports.createLOG10E = /* @__PURE__ */ recreateFactory("LOG10E", ["config", "?BigNumber"], function(_ref10) {
        var config4 = _ref10.config, BigNumber2 = _ref10.BigNumber;
        return config4.number === "BigNumber" ? new BigNumber2(1).div(new BigNumber2(10).ln()) : Math.LOG10E;
      });
      var createSQRT1_22 = exports.createSQRT1_2 = /* @__PURE__ */ recreateFactory(
        // eslint-disable-line camelcase
        "SQRT1_2",
        ["config", "?BigNumber"],
        function(_ref11) {
          var config4 = _ref11.config, BigNumber2 = _ref11.BigNumber;
          return config4.number === "BigNumber" ? new BigNumber2("0.5").sqrt() : Math.SQRT1_2;
        }
      );
      var createSQRT22 = exports.createSQRT2 = /* @__PURE__ */ recreateFactory("SQRT2", ["config", "?BigNumber"], function(_ref12) {
        var config4 = _ref12.config, BigNumber2 = _ref12.BigNumber;
        return config4.number === "BigNumber" ? new BigNumber2(2).sqrt() : Math.SQRT2;
      });
      var createI2 = exports.createI = /* @__PURE__ */ recreateFactory("i", ["Complex"], function(_ref13) {
        var Complex3 = _ref13.Complex;
        return Complex3.I;
      });
      var createUppercasePi = exports.createUppercasePi = /* @__PURE__ */ (0, _factory.factory)("PI", ["pi"], function(_ref14) {
        var pi = _ref14.pi;
        return pi;
      });
      var createUppercaseE = exports.createUppercaseE = /* @__PURE__ */ (0, _factory.factory)("E", ["e"], function(_ref15) {
        var e = _ref15.e;
        return e;
      });
      var createVersion2 = exports.createVersion = /* @__PURE__ */ (0, _factory.factory)("version", [], function() {
        return _version.version;
      });
      function recreateFactory(name18, dependencies19, create) {
        return (0, _factory.factory)(name18, dependencies19, create, {
          recreateOnConfigChange: true
        });
      }
    }
  });

  // node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/type/unit/physicalConstants.js
  var require_physicalConstants = __commonJS({
    "node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/type/unit/physicalConstants.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.createWienDisplacement = exports.createWeakMixingAngle = exports.createVacuumImpedance = exports.createThomsonCrossSection = exports.createStefanBoltzmann = exports.createSpeedOfLight = exports.createSecondRadiation = exports.createSackurTetrode = exports.createRydberg = exports.createReducedPlanckConstant = exports.createQuantumOfCirculation = exports.createProtonMass = exports.createPlanckTime = exports.createPlanckTemperature = exports.createPlanckMass = exports.createPlanckLength = exports.createPlanckConstant = exports.createPlanckCharge = exports.createNuclearMagneton = exports.createNeutronMass = exports.createMolarVolume = exports.createMolarPlanckConstant = exports.createMolarMassC12 = exports.createMolarMass = exports.createMagneticFluxQuantum = exports.createMagneticConstant = exports.createLoschmidt = exports.createKlitzing = exports.createJosephson = exports.createInverseConductanceQuantum = exports.createHartreeEnergy = exports.createGravity = exports.createGravitationConstant = exports.createGasConstant = exports.createFirstRadiation = exports.createFineStructure = exports.createFermiCoupling = exports.createFaraday = exports.createElementaryCharge = exports.createElectronMass = exports.createElectricConstant = exports.createEfimovFactor = exports.createDeuteronMass = exports.createCoulomb = exports.createConductanceQuantum = exports.createClassicalElectronRadius = exports.createBoltzmann = exports.createBohrRadius = exports.createBohrMagneton = exports.createAvogadro = exports.createAtomicMass = void 0;
      var _factory = require_factory();
      var createSpeedOfLight2 = exports.createSpeedOfLight = /* @__PURE__ */ unitFactory("speedOfLight", "299792458", "m s^-1");
      var createGravitationConstant2 = exports.createGravitationConstant = /* @__PURE__ */ unitFactory("gravitationConstant", "6.67430e-11", "m^3 kg^-1 s^-2");
      var createPlanckConstant2 = exports.createPlanckConstant = /* @__PURE__ */ unitFactory("planckConstant", "6.62607015e-34", "J s");
      var createReducedPlanckConstant2 = exports.createReducedPlanckConstant = /* @__PURE__ */ unitFactory("reducedPlanckConstant", "1.0545718176461565e-34", "J s");
      var createMagneticConstant2 = exports.createMagneticConstant = /* @__PURE__ */ unitFactory("magneticConstant", "1.25663706212e-6", "N A^-2");
      var createElectricConstant2 = exports.createElectricConstant = /* @__PURE__ */ unitFactory("electricConstant", "8.8541878128e-12", "F m^-1");
      var createVacuumImpedance2 = exports.createVacuumImpedance = /* @__PURE__ */ unitFactory("vacuumImpedance", "376.730313667", "ohm");
      var createCoulomb2 = exports.createCoulomb = /* @__PURE__ */ unitFactory("coulomb", "8.987551792261171e9", "N m^2 C^-2");
      var createElementaryCharge2 = exports.createElementaryCharge = /* @__PURE__ */ unitFactory("elementaryCharge", "1.602176634e-19", "C");
      var createBohrMagneton2 = exports.createBohrMagneton = /* @__PURE__ */ unitFactory("bohrMagneton", "9.2740100783e-24", "J T^-1");
      var createConductanceQuantum2 = exports.createConductanceQuantum = /* @__PURE__ */ unitFactory("conductanceQuantum", "7.748091729863649e-5", "S");
      var createInverseConductanceQuantum2 = exports.createInverseConductanceQuantum = /* @__PURE__ */ unitFactory("inverseConductanceQuantum", "12906.403729652257", "ohm");
      var createMagneticFluxQuantum2 = exports.createMagneticFluxQuantum = /* @__PURE__ */ unitFactory("magneticFluxQuantum", "2.0678338484619295e-15", "Wb");
      var createNuclearMagneton2 = exports.createNuclearMagneton = /* @__PURE__ */ unitFactory("nuclearMagneton", "5.0507837461e-27", "J T^-1");
      var createKlitzing2 = exports.createKlitzing = /* @__PURE__ */ unitFactory("klitzing", "25812.807459304513", "ohm");
      var createJosephson = exports.createJosephson = /* @__PURE__ */ unitFactory("josephson", "4.835978484169836e14 Hz V", "Hz V^-1");
      var createBohrRadius2 = exports.createBohrRadius = /* @__PURE__ */ unitFactory("bohrRadius", "5.29177210903e-11", "m");
      var createClassicalElectronRadius2 = exports.createClassicalElectronRadius = /* @__PURE__ */ unitFactory("classicalElectronRadius", "2.8179403262e-15", "m");
      var createElectronMass2 = exports.createElectronMass = /* @__PURE__ */ unitFactory("electronMass", "9.1093837015e-31", "kg");
      var createFermiCoupling2 = exports.createFermiCoupling = /* @__PURE__ */ unitFactory("fermiCoupling", "1.1663787e-5", "GeV^-2");
      var createFineStructure2 = exports.createFineStructure = numberFactory("fineStructure", 0.0072973525693);
      var createHartreeEnergy2 = exports.createHartreeEnergy = /* @__PURE__ */ unitFactory("hartreeEnergy", "4.3597447222071e-18", "J");
      var createProtonMass2 = exports.createProtonMass = /* @__PURE__ */ unitFactory("protonMass", "1.67262192369e-27", "kg");
      var createDeuteronMass2 = exports.createDeuteronMass = /* @__PURE__ */ unitFactory("deuteronMass", "3.3435830926e-27", "kg");
      var createNeutronMass2 = exports.createNeutronMass = /* @__PURE__ */ unitFactory("neutronMass", "1.6749271613e-27", "kg");
      var createQuantumOfCirculation2 = exports.createQuantumOfCirculation = /* @__PURE__ */ unitFactory("quantumOfCirculation", "3.6369475516e-4", "m^2 s^-1");
      var createRydberg2 = exports.createRydberg = /* @__PURE__ */ unitFactory("rydberg", "10973731.568160", "m^-1");
      var createThomsonCrossSection2 = exports.createThomsonCrossSection = /* @__PURE__ */ unitFactory("thomsonCrossSection", "6.6524587321e-29", "m^2");
      var createWeakMixingAngle2 = exports.createWeakMixingAngle = numberFactory("weakMixingAngle", 0.2229);
      var createEfimovFactor2 = exports.createEfimovFactor = numberFactory("efimovFactor", 22.7);
      var createAtomicMass2 = exports.createAtomicMass = /* @__PURE__ */ unitFactory("atomicMass", "1.66053906660e-27", "kg");
      var createAvogadro2 = exports.createAvogadro = /* @__PURE__ */ unitFactory("avogadro", "6.02214076e23", "mol^-1");
      var createBoltzmann2 = exports.createBoltzmann = /* @__PURE__ */ unitFactory("boltzmann", "1.380649e-23", "J K^-1");
      var createFaraday2 = exports.createFaraday = /* @__PURE__ */ unitFactory("faraday", "96485.33212331001", "C mol^-1");
      var createFirstRadiation2 = exports.createFirstRadiation = /* @__PURE__ */ unitFactory("firstRadiation", "3.7417718521927573e-16", "W m^2");
      var createLoschmidt2 = exports.createLoschmidt = /* @__PURE__ */ unitFactory("loschmidt", "2.686780111798444e25", "m^-3");
      var createGasConstant2 = exports.createGasConstant = /* @__PURE__ */ unitFactory("gasConstant", "8.31446261815324", "J K^-1 mol^-1");
      var createMolarPlanckConstant2 = exports.createMolarPlanckConstant = /* @__PURE__ */ unitFactory("molarPlanckConstant", "3.990312712893431e-10", "J s mol^-1");
      var createMolarVolume2 = exports.createMolarVolume = /* @__PURE__ */ unitFactory("molarVolume", "0.022413969545014137", "m^3 mol^-1");
      var createSackurTetrode2 = exports.createSackurTetrode = numberFactory("sackurTetrode", -1.16487052358);
      var createSecondRadiation2 = exports.createSecondRadiation = /* @__PURE__ */ unitFactory("secondRadiation", "0.014387768775039337", "m K");
      var createStefanBoltzmann2 = exports.createStefanBoltzmann = /* @__PURE__ */ unitFactory("stefanBoltzmann", "5.67037441918443e-8", "W m^-2 K^-4");
      var createWienDisplacement2 = exports.createWienDisplacement = /* @__PURE__ */ unitFactory("wienDisplacement", "2.897771955e-3", "m K");
      var createMolarMass2 = exports.createMolarMass = /* @__PURE__ */ unitFactory("molarMass", "0.99999999965e-3", "kg mol^-1");
      var createMolarMassC122 = exports.createMolarMassC12 = /* @__PURE__ */ unitFactory("molarMassC12", "11.9999999958e-3", "kg mol^-1");
      var createGravity2 = exports.createGravity = /* @__PURE__ */ unitFactory("gravity", "9.80665", "m s^-2");
      var createPlanckLength2 = exports.createPlanckLength = /* @__PURE__ */ unitFactory("planckLength", "1.616255e-35", "m");
      var createPlanckMass2 = exports.createPlanckMass = /* @__PURE__ */ unitFactory("planckMass", "2.176435e-8", "kg");
      var createPlanckTime2 = exports.createPlanckTime = /* @__PURE__ */ unitFactory("planckTime", "5.391245e-44", "s");
      var createPlanckCharge2 = exports.createPlanckCharge = /* @__PURE__ */ unitFactory("planckCharge", "1.87554603778e-18", "C");
      var createPlanckTemperature2 = exports.createPlanckTemperature = /* @__PURE__ */ unitFactory("planckTemperature", "1.416785e+32", "K");
      function unitFactory(name18, valueStr, unitStr) {
        var dependencies19 = ["config", "Unit", "BigNumber"];
        return (0, _factory.factory)(name18, dependencies19, function(_ref) {
          var config4 = _ref.config, Unit = _ref.Unit, BigNumber2 = _ref.BigNumber;
          var value = config4.number === "BigNumber" ? new BigNumber2(valueStr) : parseFloat(valueStr);
          var unit = new Unit(value, unitStr);
          unit.fixPrefix = true;
          return unit;
        });
      }
      function numberFactory(name18, value) {
        var dependencies19 = ["config", "BigNumber"];
        return (0, _factory.factory)(name18, dependencies19, function(_ref2) {
          var config4 = _ref2.config, BigNumber2 = _ref2.BigNumber;
          return config4.number === "BigNumber" ? new BigNumber2(value) : value;
        });
      }
    }
  });

  // node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/expression/transform/apply.transform.js
  var require_apply_transform = __commonJS({
    "node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/expression/transform/apply.transform.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.createApplyTransform = void 0;
      var _errorTransform = require_errorTransform();
      var _factory = require_factory();
      var _apply = require_apply();
      var _is = require_is();
      var name18 = "apply";
      var dependencies19 = ["typed", "isInteger"];
      var createApplyTransform = exports.createApplyTransform = /* @__PURE__ */ (0, _factory.factory)(name18, dependencies19, function(_ref) {
        var typed2 = _ref.typed, isInteger2 = _ref.isInteger;
        var apply = (0, _apply.createApply)({
          typed: typed2,
          isInteger: isInteger2
        });
        return typed2("apply", {
          "...any": function any(args) {
            var dim = args[1];
            if ((0, _is.isNumber)(dim)) {
              args[1] = dim - 1;
            } else if ((0, _is.isBigNumber)(dim)) {
              args[1] = dim.minus(1);
            }
            try {
              return apply.apply(null, args);
            } catch (err) {
              throw (0, _errorTransform.errorTransform)(err);
            }
          }
        });
      }, {
        isTransformFunction: true
      });
    }
  });

  // node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/expression/transform/column.transform.js
  var require_column_transform = __commonJS({
    "node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/expression/transform/column.transform.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.createColumnTransform = void 0;
      var _errorTransform = require_errorTransform();
      var _factory = require_factory();
      var _column = require_column();
      var _is = require_is();
      var name18 = "column";
      var dependencies19 = ["typed", "Index", "matrix", "range"];
      var createColumnTransform = exports.createColumnTransform = /* @__PURE__ */ (0, _factory.factory)(name18, dependencies19, function(_ref) {
        var typed2 = _ref.typed, Index = _ref.Index, matrix2 = _ref.matrix, range = _ref.range;
        var column = (0, _column.createColumn)({
          typed: typed2,
          Index,
          matrix: matrix2,
          range
        });
        return typed2("column", {
          "...any": function any(args) {
            var lastIndex = args.length - 1;
            var last = args[lastIndex];
            if ((0, _is.isNumber)(last)) {
              args[lastIndex] = last - 1;
            }
            try {
              return column.apply(null, args);
            } catch (err) {
              throw (0, _errorTransform.errorTransform)(err);
            }
          }
        });
      }, {
        isTransformFunction: true
      });
    }
  });

  // node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/expression/transform/utils/compileInlineExpression.js
  var require_compileInlineExpression = __commonJS({
    "node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/expression/transform/utils/compileInlineExpression.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.compileInlineExpression = compileInlineExpression;
      var _is = require_is();
      var _map = require_map();
      function compileInlineExpression(expression, math, scope) {
        var symbol = expression.filter(function(node) {
          return (0, _is.isSymbolNode)(node) && !(node.name in math) && !scope.has(node.name);
        })[0];
        if (!symbol) {
          throw new Error('No undefined variable found in inline expression "' + expression + '"');
        }
        var name18 = symbol.name;
        var argsScope = /* @__PURE__ */ new Map();
        var subScope = new _map.PartitionedMap(scope, argsScope, /* @__PURE__ */ new Set([name18]));
        var eq = expression.compile();
        return function inlineExpression(x) {
          argsScope.set(name18, x);
          return eq.evaluate(subScope);
        };
      }
    }
  });

  // node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/expression/transform/filter.transform.js
  var require_filter_transform = __commonJS({
    "node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/expression/transform/filter.transform.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.createFilterTransform = void 0;
      var _applyCallback = require_applyCallback();
      var _array = require_array();
      var _factory = require_factory();
      var _is = require_is();
      var _compileInlineExpression = require_compileInlineExpression();
      var name18 = "filter";
      var dependencies19 = ["typed"];
      var createFilterTransform = exports.createFilterTransform = /* @__PURE__ */ (0, _factory.factory)(name18, dependencies19, function(_ref) {
        var typed2 = _ref.typed;
        function filterTransform(args, math, scope) {
          var x, callback;
          if (args[0]) {
            x = args[0].compile().evaluate(scope);
          }
          if (args[1]) {
            if ((0, _is.isSymbolNode)(args[1]) || (0, _is.isFunctionAssignmentNode)(args[1])) {
              callback = args[1].compile().evaluate(scope);
            } else {
              callback = (0, _compileInlineExpression.compileInlineExpression)(args[1], math, scope);
            }
          }
          return filter(x, callback);
        }
        filterTransform.rawArgs = true;
        var filter = typed2("filter", {
          "Array, function": _filter,
          "Matrix, function": function MatrixFunction(x, test) {
            return x.create(_filter(x.toArray(), test));
          },
          "Array, RegExp": _array.filterRegExp,
          "Matrix, RegExp": function MatrixRegExp(x, test) {
            return x.create((0, _array.filterRegExp)(x.toArray(), test));
          }
        });
        return filterTransform;
      }, {
        isTransformFunction: true
      });
      function _filter(x, callback) {
        return (0, _array.filter)(x, function(value, index, array) {
          return (0, _applyCallback.applyCallback)(callback, value, [index + 1], array, "filter");
        });
      }
    }
  });

  // node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/expression/transform/forEach.transform.js
  var require_forEach_transform = __commonJS({
    "node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/expression/transform/forEach.transform.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.createForEachTransform = void 0;
      var _applyCallback = require_applyCallback();
      var _array = require_array();
      var _factory = require_factory();
      var _is = require_is();
      var _compileInlineExpression = require_compileInlineExpression();
      var name18 = "forEach";
      var dependencies19 = ["typed"];
      var createForEachTransform = exports.createForEachTransform = /* @__PURE__ */ (0, _factory.factory)(name18, dependencies19, function(_ref) {
        var typed2 = _ref.typed;
        function forEachTransform(args, math, scope) {
          var x, callback;
          if (args[0]) {
            x = args[0].compile().evaluate(scope);
          }
          if (args[1]) {
            if ((0, _is.isSymbolNode)(args[1]) || (0, _is.isFunctionAssignmentNode)(args[1])) {
              callback = args[1].compile().evaluate(scope);
            } else {
              callback = (0, _compileInlineExpression.compileInlineExpression)(args[1], math, scope);
            }
          }
          return _forEach(x, callback);
        }
        forEachTransform.rawArgs = true;
        var _forEach = typed2("forEach", {
          "Array | Matrix, function": function ArrayMatrixFunction(array, callback) {
            var recurse = function recurse2(value, index) {
              if (Array.isArray(value)) {
                (0, _array.forEach)(value, function(child, i) {
                  recurse2(child, index.concat(i + 1));
                });
              } else {
                return (0, _applyCallback.applyCallback)(callback, value, index, array, "forEach");
              }
            };
            recurse(array.valueOf(), []);
          }
        });
        return forEachTransform;
      }, {
        isTransformFunction: true
      });
    }
  });

  // node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/expression/transform/index.transform.js
  var require_index_transform = __commonJS({
    "node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/expression/transform/index.transform.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.createIndexTransform = void 0;
      var _is = require_is();
      var _factory = require_factory();
      var name18 = "index";
      var dependencies19 = ["Index", "getMatrixDataType"];
      var createIndexTransform = exports.createIndexTransform = /* @__PURE__ */ (0, _factory.factory)(name18, dependencies19, function(_ref) {
        var Index = _ref.Index, getMatrixDataType = _ref.getMatrixDataType;
        return function indexTransform() {
          var args = [];
          for (var i = 0, ii = arguments.length; i < ii; i++) {
            var arg = arguments[i];
            if ((0, _is.isRange)(arg)) {
              arg.start--;
              arg.end -= arg.step > 0 ? 0 : 2;
            } else if (arg && arg.isSet === true) {
              arg = arg.map(function(v) {
                return v - 1;
              });
            } else if ((0, _is.isArray)(arg) || (0, _is.isMatrix)(arg)) {
              if (getMatrixDataType(arg) !== "boolean") {
                arg = arg.map(function(v) {
                  return v - 1;
                });
              }
            } else if ((0, _is.isNumber)(arg)) {
              arg--;
            } else if ((0, _is.isBigNumber)(arg)) {
              arg = arg.toNumber() - 1;
            } else if (typeof arg === "string") {
            } else {
              throw new TypeError("Dimension must be an Array, Matrix, number, string, or Range");
            }
            args[i] = arg;
          }
          var res = new Index();
          Index.apply(res, args);
          return res;
        };
      }, {
        isTransformFunction: true
      });
    }
  });

  // node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/expression/transform/map.transform.js
  var require_map_transform = __commonJS({
    "node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/expression/transform/map.transform.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.createMapTransform = void 0;
      var _applyCallback = require_applyCallback();
      var _array = require_array();
      var _factory = require_factory();
      var _is = require_is();
      var _compileInlineExpression = require_compileInlineExpression();
      var name18 = "map";
      var dependencies19 = ["typed"];
      var createMapTransform = exports.createMapTransform = /* @__PURE__ */ (0, _factory.factory)(name18, dependencies19, function(_ref) {
        var typed2 = _ref.typed;
        function mapTransform(args, math, scope) {
          var x, callback;
          if (args[0]) {
            x = args[0].compile().evaluate(scope);
          }
          if (args[1]) {
            if ((0, _is.isSymbolNode)(args[1]) || (0, _is.isFunctionAssignmentNode)(args[1])) {
              callback = args[1].compile().evaluate(scope);
            } else {
              callback = (0, _compileInlineExpression.compileInlineExpression)(args[1], math, scope);
            }
          }
          return map(x, callback);
        }
        mapTransform.rawArgs = true;
        var map = typed2("map", {
          "Array, function": function ArrayFunction(x, callback) {
            return _map(x, callback, x);
          },
          "Matrix, function": function MatrixFunction(x, callback) {
            return x.create(_map(x.valueOf(), callback, x));
          }
        });
        return mapTransform;
      }, {
        isTransformFunction: true
      });
      function _map(array, callback, orig) {
        function recurse(value, index) {
          if (Array.isArray(value)) {
            return (0, _array.map)(value, function(child, i) {
              return recurse(child, index.concat(i + 1));
            });
          } else {
            return (0, _applyCallback.applyCallback)(callback, value, index, orig, "map");
          }
        }
        return recurse(array, []);
      }
    }
  });

  // node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/expression/transform/utils/lastDimToZeroBase.js
  var require_lastDimToZeroBase = __commonJS({
    "node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/expression/transform/utils/lastDimToZeroBase.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.lastDimToZeroBase = lastDimToZeroBase;
      var _is = require_is();
      function lastDimToZeroBase(args) {
        if (args.length === 2 && (0, _is.isCollection)(args[0])) {
          args = args.slice();
          var dim = args[1];
          if ((0, _is.isNumber)(dim)) {
            args[1] = dim - 1;
          } else if ((0, _is.isBigNumber)(dim)) {
            args[1] = dim.minus(1);
          }
        }
        return args;
      }
    }
  });

  // node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/expression/transform/max.transform.js
  var require_max_transform = __commonJS({
    "node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/expression/transform/max.transform.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.createMaxTransform = void 0;
      var _factory = require_factory();
      var _errorTransform = require_errorTransform();
      var _max = require_max();
      var _lastDimToZeroBase = require_lastDimToZeroBase();
      var name18 = "max";
      var dependencies19 = ["typed", "config", "numeric", "larger"];
      var createMaxTransform = exports.createMaxTransform = /* @__PURE__ */ (0, _factory.factory)(name18, dependencies19, function(_ref) {
        var typed2 = _ref.typed, config4 = _ref.config, numeric = _ref.numeric, larger = _ref.larger;
        var max2 = (0, _max.createMax)({
          typed: typed2,
          config: config4,
          numeric,
          larger
        });
        return typed2("max", {
          "...any": function any(args) {
            args = (0, _lastDimToZeroBase.lastDimToZeroBase)(args);
            try {
              return max2.apply(null, args);
            } catch (err) {
              throw (0, _errorTransform.errorTransform)(err);
            }
          }
        });
      }, {
        isTransformFunction: true
      });
    }
  });

  // node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/expression/transform/mean.transform.js
  var require_mean_transform = __commonJS({
    "node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/expression/transform/mean.transform.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.createMeanTransform = void 0;
      var _factory = require_factory();
      var _errorTransform = require_errorTransform();
      var _mean = require_mean2();
      var _lastDimToZeroBase = require_lastDimToZeroBase();
      var name18 = "mean";
      var dependencies19 = ["typed", "add", "divide"];
      var createMeanTransform = exports.createMeanTransform = /* @__PURE__ */ (0, _factory.factory)(name18, dependencies19, function(_ref) {
        var typed2 = _ref.typed, add2 = _ref.add, divide2 = _ref.divide;
        var mean = (0, _mean.createMean)({
          typed: typed2,
          add: add2,
          divide: divide2
        });
        return typed2("mean", {
          "...any": function any(args) {
            args = (0, _lastDimToZeroBase.lastDimToZeroBase)(args);
            try {
              return mean.apply(null, args);
            } catch (err) {
              throw (0, _errorTransform.errorTransform)(err);
            }
          }
        });
      }, {
        isTransformFunction: true
      });
    }
  });

  // node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/expression/transform/min.transform.js
  var require_min_transform = __commonJS({
    "node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/expression/transform/min.transform.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.createMinTransform = void 0;
      var _factory = require_factory();
      var _errorTransform = require_errorTransform();
      var _min = require_min();
      var _lastDimToZeroBase = require_lastDimToZeroBase();
      var name18 = "min";
      var dependencies19 = ["typed", "config", "numeric", "smaller"];
      var createMinTransform = exports.createMinTransform = /* @__PURE__ */ (0, _factory.factory)(name18, dependencies19, function(_ref) {
        var typed2 = _ref.typed, config4 = _ref.config, numeric = _ref.numeric, smaller = _ref.smaller;
        var min2 = (0, _min.createMin)({
          typed: typed2,
          config: config4,
          numeric,
          smaller
        });
        return typed2("min", {
          "...any": function any(args) {
            args = (0, _lastDimToZeroBase.lastDimToZeroBase)(args);
            try {
              return min2.apply(null, args);
            } catch (err) {
              throw (0, _errorTransform.errorTransform)(err);
            }
          }
        });
      }, {
        isTransformFunction: true
      });
    }
  });

  // node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/expression/transform/range.transform.js
  var require_range_transform = __commonJS({
    "node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/expression/transform/range.transform.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.createRangeTransform = void 0;
      var _factory = require_factory();
      var _range = require_range();
      var name18 = "range";
      var dependencies19 = ["typed", "config", "?matrix", "?bignumber", "smaller", "smallerEq", "larger", "largerEq", "add", "isPositive"];
      var createRangeTransform = exports.createRangeTransform = /* @__PURE__ */ (0, _factory.factory)(name18, dependencies19, function(_ref) {
        var typed2 = _ref.typed, config4 = _ref.config, matrix2 = _ref.matrix, bignumber = _ref.bignumber, smaller = _ref.smaller, smallerEq = _ref.smallerEq, larger = _ref.larger, largerEq = _ref.largerEq, add2 = _ref.add, isPositive = _ref.isPositive;
        var range = (0, _range.createRange)({
          typed: typed2,
          config: config4,
          matrix: matrix2,
          bignumber,
          smaller,
          smallerEq,
          larger,
          largerEq,
          add: add2,
          isPositive
        });
        return typed2("range", {
          "...any": function any(args) {
            var lastIndex = args.length - 1;
            var last = args[lastIndex];
            if (typeof last !== "boolean") {
              args.push(true);
            }
            return range.apply(null, args);
          }
        });
      }, {
        isTransformFunction: true
      });
    }
  });

  // node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/expression/transform/row.transform.js
  var require_row_transform = __commonJS({
    "node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/expression/transform/row.transform.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.createRowTransform = void 0;
      var _factory = require_factory();
      var _row = require_row();
      var _errorTransform = require_errorTransform();
      var _is = require_is();
      var name18 = "row";
      var dependencies19 = ["typed", "Index", "matrix", "range"];
      var createRowTransform = exports.createRowTransform = /* @__PURE__ */ (0, _factory.factory)(name18, dependencies19, function(_ref) {
        var typed2 = _ref.typed, Index = _ref.Index, matrix2 = _ref.matrix, range = _ref.range;
        var row = (0, _row.createRow)({
          typed: typed2,
          Index,
          matrix: matrix2,
          range
        });
        return typed2("row", {
          "...any": function any(args) {
            var lastIndex = args.length - 1;
            var last = args[lastIndex];
            if ((0, _is.isNumber)(last)) {
              args[lastIndex] = last - 1;
            }
            try {
              return row.apply(null, args);
            } catch (err) {
              throw (0, _errorTransform.errorTransform)(err);
            }
          }
        });
      }, {
        isTransformFunction: true
      });
    }
  });

  // node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/expression/transform/subset.transform.js
  var require_subset_transform = __commonJS({
    "node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/expression/transform/subset.transform.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.createSubsetTransform = void 0;
      var _factory = require_factory();
      var _errorTransform = require_errorTransform();
      var _subset = require_subset();
      var name18 = "subset";
      var dependencies19 = ["typed", "matrix", "zeros", "add"];
      var createSubsetTransform = exports.createSubsetTransform = /* @__PURE__ */ (0, _factory.factory)(name18, dependencies19, function(_ref) {
        var typed2 = _ref.typed, matrix2 = _ref.matrix, zeros2 = _ref.zeros, add2 = _ref.add;
        var subset = (0, _subset.createSubset)({
          typed: typed2,
          matrix: matrix2,
          zeros: zeros2,
          add: add2
        });
        return typed2("subset", {
          "...any": function any(args) {
            try {
              return subset.apply(null, args);
            } catch (err) {
              throw (0, _errorTransform.errorTransform)(err);
            }
          }
        });
      }, {
        isTransformFunction: true
      });
    }
  });

  // node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/expression/transform/concat.transform.js
  var require_concat_transform = __commonJS({
    "node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/expression/transform/concat.transform.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.createConcatTransform = void 0;
      var _is = require_is();
      var _errorTransform = require_errorTransform();
      var _factory = require_factory();
      var _concat = require_concat();
      var name18 = "concat";
      var dependencies19 = ["typed", "matrix", "isInteger"];
      var createConcatTransform = exports.createConcatTransform = /* @__PURE__ */ (0, _factory.factory)(name18, dependencies19, function(_ref) {
        var typed2 = _ref.typed, matrix2 = _ref.matrix, isInteger2 = _ref.isInteger;
        var concat2 = (0, _concat.createConcat)({
          typed: typed2,
          matrix: matrix2,
          isInteger: isInteger2
        });
        return typed2("concat", {
          "...any": function any(args) {
            var lastIndex = args.length - 1;
            var last = args[lastIndex];
            if ((0, _is.isNumber)(last)) {
              args[lastIndex] = last - 1;
            } else if ((0, _is.isBigNumber)(last)) {
              args[lastIndex] = last.minus(1);
            }
            try {
              return concat2.apply(null, args);
            } catch (err) {
              throw (0, _errorTransform.errorTransform)(err);
            }
          }
        });
      }, {
        isTransformFunction: true
      });
    }
  });

  // node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/expression/transform/diff.transform.js
  var require_diff_transform = __commonJS({
    "node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/expression/transform/diff.transform.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.createDiffTransform = void 0;
      var _factory = require_factory();
      var _errorTransform = require_errorTransform();
      var _diff = require_diff();
      var _lastDimToZeroBase = require_lastDimToZeroBase();
      var name18 = "diff";
      var dependencies19 = ["typed", "matrix", "subtract", "number", "bignumber"];
      var createDiffTransform = exports.createDiffTransform = /* @__PURE__ */ (0, _factory.factory)(name18, dependencies19, function(_ref) {
        var typed2 = _ref.typed, matrix2 = _ref.matrix, subtract = _ref.subtract, number = _ref.number, bignumber = _ref.bignumber;
        var diff = (0, _diff.createDiff)({
          typed: typed2,
          matrix: matrix2,
          subtract,
          number,
          bignumber
        });
        return typed2(name18, {
          "...any": function any(args) {
            args = (0, _lastDimToZeroBase.lastDimToZeroBase)(args);
            try {
              return diff.apply(null, args);
            } catch (err) {
              throw (0, _errorTransform.errorTransform)(err);
            }
          }
        });
      }, {
        isTransformFunction: true
      });
    }
  });

  // node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/expression/transform/std.transform.js
  var require_std_transform = __commonJS({
    "node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/expression/transform/std.transform.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.createStdTransform = void 0;
      var _factory = require_factory();
      var _std = require_std2();
      var _errorTransform = require_errorTransform();
      var _lastDimToZeroBase = require_lastDimToZeroBase();
      var name18 = "std";
      var dependencies19 = ["typed", "map", "sqrt", "variance"];
      var createStdTransform = exports.createStdTransform = /* @__PURE__ */ (0, _factory.factory)(name18, dependencies19, function(_ref) {
        var typed2 = _ref.typed, map = _ref.map, sqrt2 = _ref.sqrt, variance = _ref.variance;
        var std = (0, _std.createStd)({
          typed: typed2,
          map,
          sqrt: sqrt2,
          variance
        });
        return typed2("std", {
          "...any": function any(args) {
            args = (0, _lastDimToZeroBase.lastDimToZeroBase)(args);
            try {
              return std.apply(null, args);
            } catch (err) {
              throw (0, _errorTransform.errorTransform)(err);
            }
          }
        });
      }, {
        isTransformFunction: true
      });
    }
  });

  // node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/expression/transform/sum.transform.js
  var require_sum_transform = __commonJS({
    "node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/expression/transform/sum.transform.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.createSumTransform = void 0;
      var _factory = require_factory();
      var _errorTransform = require_errorTransform();
      var _sum = require_sum2();
      var _lastDimToZeroBase = require_lastDimToZeroBase();
      var name18 = "sum";
      var dependencies19 = ["typed", "config", "add", "numeric"];
      var createSumTransform = exports.createSumTransform = /* @__PURE__ */ (0, _factory.factory)(name18, dependencies19, function(_ref) {
        var typed2 = _ref.typed, config4 = _ref.config, add2 = _ref.add, numeric = _ref.numeric;
        var sum2 = (0, _sum.createSum)({
          typed: typed2,
          config: config4,
          add: add2,
          numeric
        });
        return typed2(name18, {
          "...any": function any(args) {
            args = (0, _lastDimToZeroBase.lastDimToZeroBase)(args);
            try {
              return sum2.apply(null, args);
            } catch (err) {
              throw (0, _errorTransform.errorTransform)(err);
            }
          }
        });
      }, {
        isTransformFunction: true
      });
    }
  });

  // node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/expression/transform/quantileSeq.transform.js
  var require_quantileSeq_transform = __commonJS({
    "node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/expression/transform/quantileSeq.transform.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.createQuantileSeqTransform = void 0;
      var _factory = require_factory();
      var _quantileSeq = require_quantileSeq2();
      var _lastDimToZeroBase = require_lastDimToZeroBase();
      var name18 = "quantileSeq";
      var dependencies19 = ["typed", "bignumber", "add", "subtract", "divide", "multiply", "partitionSelect", "compare", "isInteger", "smaller", "smallerEq", "larger"];
      var createQuantileSeqTransform = exports.createQuantileSeqTransform = /* @__PURE__ */ (0, _factory.factory)(name18, dependencies19, function(_ref) {
        var typed2 = _ref.typed, bignumber = _ref.bignumber, add2 = _ref.add, subtract = _ref.subtract, divide2 = _ref.divide, multiply2 = _ref.multiply, partitionSelect = _ref.partitionSelect, compare = _ref.compare, isInteger2 = _ref.isInteger, smaller = _ref.smaller, smallerEq = _ref.smallerEq, larger = _ref.larger;
        var quantileSeq = (0, _quantileSeq.createQuantileSeq)({
          typed: typed2,
          bignumber,
          add: add2,
          subtract,
          divide: divide2,
          multiply: multiply2,
          partitionSelect,
          compare,
          isInteger: isInteger2,
          smaller,
          smallerEq,
          larger
        });
        return typed2("quantileSeq", {
          "Array | Matrix, number | BigNumber": quantileSeq,
          "Array | Matrix, number | BigNumber, number": function ArrayMatrixNumberBigNumberNumber(arr, prob, dim) {
            return quantileSeq(arr, prob, dimToZeroBase(dim));
          },
          "Array | Matrix, number | BigNumber, boolean": quantileSeq,
          "Array | Matrix, number | BigNumber, boolean, number": function ArrayMatrixNumberBigNumberBooleanNumber(arr, prob, sorted, dim) {
            return quantileSeq(arr, prob, sorted, dimToZeroBase(dim));
          },
          "Array | Matrix, Array | Matrix": quantileSeq,
          "Array | Matrix, Array | Matrix, number": function ArrayMatrixArrayMatrixNumber(data, prob, dim) {
            return quantileSeq(data, prob, dimToZeroBase(dim));
          },
          "Array | Matrix, Array | Matrix, boolean": quantileSeq,
          "Array | Matrix, Array | Matrix, boolean, number": function ArrayMatrixArrayMatrixBooleanNumber(data, prob, sorted, dim) {
            return quantileSeq(data, prob, sorted, dimToZeroBase(dim));
          }
        });
        function dimToZeroBase(dim) {
          return (0, _lastDimToZeroBase.lastDimToZeroBase)([[], dim])[1];
        }
      }, {
        isTransformFunction: true
      });
    }
  });

  // node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/expression/transform/cumsum.transform.js
  var require_cumsum_transform = __commonJS({
    "node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/expression/transform/cumsum.transform.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.createCumSumTransform = void 0;
      var _is = require_is();
      var _factory = require_factory();
      var _errorTransform = require_errorTransform();
      var _cumsum = require_cumsum2();
      var name18 = "cumsum";
      var dependencies19 = ["typed", "add", "unaryPlus"];
      var createCumSumTransform = exports.createCumSumTransform = /* @__PURE__ */ (0, _factory.factory)(name18, dependencies19, function(_ref) {
        var typed2 = _ref.typed, add2 = _ref.add, unaryPlus = _ref.unaryPlus;
        var cumsum = (0, _cumsum.createCumSum)({
          typed: typed2,
          add: add2,
          unaryPlus
        });
        return typed2(name18, {
          "...any": function any(args) {
            if (args.length === 2 && (0, _is.isCollection)(args[0])) {
              var dim = args[1];
              if ((0, _is.isNumber)(dim)) {
                args[1] = dim - 1;
              } else if ((0, _is.isBigNumber)(dim)) {
                args[1] = dim.minus(1);
              }
            }
            try {
              return cumsum.apply(null, args);
            } catch (err) {
              throw (0, _errorTransform.errorTransform)(err);
            }
          }
        });
      }, {
        isTransformFunction: true
      });
    }
  });

  // node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/expression/transform/variance.transform.js
  var require_variance_transform = __commonJS({
    "node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/expression/transform/variance.transform.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.createVarianceTransform = void 0;
      var _factory = require_factory();
      var _errorTransform = require_errorTransform();
      var _variance = require_variance2();
      var _lastDimToZeroBase = require_lastDimToZeroBase();
      var name18 = "variance";
      var dependencies19 = ["typed", "add", "subtract", "multiply", "divide", "apply", "isNaN"];
      var createVarianceTransform = exports.createVarianceTransform = /* @__PURE__ */ (0, _factory.factory)(name18, dependencies19, function(_ref) {
        var typed2 = _ref.typed, add2 = _ref.add, subtract = _ref.subtract, multiply2 = _ref.multiply, divide2 = _ref.divide, apply = _ref.apply, isNaN2 = _ref.isNaN;
        var variance = (0, _variance.createVariance)({
          typed: typed2,
          add: add2,
          subtract,
          multiply: multiply2,
          divide: divide2,
          apply,
          isNaN: isNaN2
        });
        return typed2(name18, {
          "...any": function any(args) {
            args = (0, _lastDimToZeroBase.lastDimToZeroBase)(args);
            try {
              return variance.apply(null, args);
            } catch (err) {
              throw (0, _errorTransform.errorTransform)(err);
            }
          }
        });
      }, {
        isTransformFunction: true
      });
    }
  });

  // node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/expression/transform/print.transform.js
  var require_print_transform = __commonJS({
    "node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/expression/transform/print.transform.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.createPrintTransform = void 0;
      var _print = require_print2();
      var _factory = require_factory();
      var _print2 = require_print();
      var name18 = "print";
      var dependencies19 = ["typed", "matrix", "zeros", "add"];
      var createPrintTransform = exports.createPrintTransform = /* @__PURE__ */ (0, _factory.factory)(name18, dependencies19, function(_ref) {
        var typed2 = _ref.typed, matrix2 = _ref.matrix, zeros2 = _ref.zeros, add2 = _ref.add;
        var print = (0, _print.createPrint)({
          typed: typed2,
          matrix: matrix2,
          zeros: zeros2,
          add: add2
        });
        return typed2(name18, {
          "string, Object | Array": function stringObjectArray(template, values) {
            return print(_convertTemplateToZeroBasedIndex(template), values);
          },
          "string, Object | Array, number | Object": function stringObjectArrayNumberObject(template, values, options) {
            return print(_convertTemplateToZeroBasedIndex(template), values, options);
          }
        });
        function _convertTemplateToZeroBasedIndex(template) {
          return template.replace(_print2.printTemplate, function(x) {
            var parts = x.slice(1).split(".");
            var result = parts.map(function(part) {
              if (!isNaN(part) && part.length > 0) {
                return parseInt(part) - 1;
              } else {
                return part;
              }
            });
            return "$" + result.join(".");
          });
        }
      }, {
        isTransformFunction: true
      });
    }
  });

  // node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/expression/transform/and.transform.js
  var require_and_transform = __commonJS({
    "node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/expression/transform/and.transform.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.createAndTransform = void 0;
      var _and = require_and();
      var _factory = require_factory();
      var _is = require_is();
      var name18 = "and";
      var dependencies19 = ["typed", "matrix", "zeros", "add", "equalScalar", "not", "concat"];
      var createAndTransform = exports.createAndTransform = /* @__PURE__ */ (0, _factory.factory)(name18, dependencies19, function(_ref) {
        var typed2 = _ref.typed, matrix2 = _ref.matrix, equalScalar2 = _ref.equalScalar, zeros2 = _ref.zeros, not = _ref.not, concat2 = _ref.concat;
        var and = (0, _and.createAnd)({
          typed: typed2,
          matrix: matrix2,
          equalScalar: equalScalar2,
          zeros: zeros2,
          not,
          concat: concat2
        });
        function andTransform(args, math, scope) {
          var condition1 = args[0].compile().evaluate(scope);
          if (!(0, _is.isCollection)(condition1) && !and(condition1, true)) {
            return false;
          }
          var condition2 = args[1].compile().evaluate(scope);
          return and(condition1, condition2);
        }
        andTransform.rawArgs = true;
        return andTransform;
      }, {
        isTransformFunction: true
      });
    }
  });

  // node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/expression/transform/or.transform.js
  var require_or_transform = __commonJS({
    "node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/expression/transform/or.transform.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.createOrTransform = void 0;
      var _or = require_or();
      var _factory = require_factory();
      var _is = require_is();
      var name18 = "or";
      var dependencies19 = ["typed", "matrix", "equalScalar", "DenseMatrix", "concat"];
      var createOrTransform = exports.createOrTransform = /* @__PURE__ */ (0, _factory.factory)(name18, dependencies19, function(_ref) {
        var typed2 = _ref.typed, matrix2 = _ref.matrix, equalScalar2 = _ref.equalScalar, DenseMatrix2 = _ref.DenseMatrix, concat2 = _ref.concat;
        var or = (0, _or.createOr)({
          typed: typed2,
          matrix: matrix2,
          equalScalar: equalScalar2,
          DenseMatrix: DenseMatrix2,
          concat: concat2
        });
        function orTransform(args, math, scope) {
          var condition1 = args[0].compile().evaluate(scope);
          if (!(0, _is.isCollection)(condition1) && or(condition1, false)) {
            return true;
          }
          var condition2 = args[1].compile().evaluate(scope);
          return or(condition1, condition2);
        }
        orTransform.rawArgs = true;
        return orTransform;
      }, {
        isTransformFunction: true
      });
    }
  });

  // node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/expression/transform/bitAnd.transform.js
  var require_bitAnd_transform = __commonJS({
    "node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/expression/transform/bitAnd.transform.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.createBitAndTransform = void 0;
      var _bitAnd = require_bitAnd();
      var _factory = require_factory();
      var _is = require_is();
      var name18 = "bitAnd";
      var dependencies19 = ["typed", "matrix", "zeros", "add", "equalScalar", "not", "concat"];
      var createBitAndTransform = exports.createBitAndTransform = /* @__PURE__ */ (0, _factory.factory)(name18, dependencies19, function(_ref) {
        var typed2 = _ref.typed, matrix2 = _ref.matrix, equalScalar2 = _ref.equalScalar, zeros2 = _ref.zeros, not = _ref.not, concat2 = _ref.concat;
        var bitAnd = (0, _bitAnd.createBitAnd)({
          typed: typed2,
          matrix: matrix2,
          equalScalar: equalScalar2,
          zeros: zeros2,
          not,
          concat: concat2
        });
        function bitAndTransform(args, math, scope) {
          var condition1 = args[0].compile().evaluate(scope);
          if (!(0, _is.isCollection)(condition1)) {
            if (isNaN(condition1)) {
              return NaN;
            }
            if (condition1 === 0 || condition1 === false) {
              return 0;
            }
          }
          var condition2 = args[1].compile().evaluate(scope);
          return bitAnd(condition1, condition2);
        }
        bitAndTransform.rawArgs = true;
        return bitAndTransform;
      }, {
        isTransformFunction: true
      });
    }
  });

  // node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/expression/transform/bitOr.transform.js
  var require_bitOr_transform = __commonJS({
    "node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/expression/transform/bitOr.transform.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.createBitOrTransform = void 0;
      var _bitOr = require_bitOr();
      var _factory = require_factory();
      var _is = require_is();
      var name18 = "bitOr";
      var dependencies19 = ["typed", "matrix", "equalScalar", "DenseMatrix", "concat"];
      var createBitOrTransform = exports.createBitOrTransform = /* @__PURE__ */ (0, _factory.factory)(name18, dependencies19, function(_ref) {
        var typed2 = _ref.typed, matrix2 = _ref.matrix, equalScalar2 = _ref.equalScalar, DenseMatrix2 = _ref.DenseMatrix, concat2 = _ref.concat;
        var bitOr = (0, _bitOr.createBitOr)({
          typed: typed2,
          matrix: matrix2,
          equalScalar: equalScalar2,
          DenseMatrix: DenseMatrix2,
          concat: concat2
        });
        function bitOrTransform(args, math, scope) {
          var condition1 = args[0].compile().evaluate(scope);
          if (!(0, _is.isCollection)(condition1)) {
            if (isNaN(condition1)) {
              return NaN;
            }
            if (condition1 === -1) {
              return -1;
            }
            if (condition1 === true) {
              return 1;
            }
          }
          var condition2 = args[1].compile().evaluate(scope);
          return bitOr(condition1, condition2);
        }
        bitOrTransform.rawArgs = true;
        return bitOrTransform;
      }, {
        isTransformFunction: true
      });
    }
  });

  // node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/factoriesAny.js
  var require_factoriesAny = __commonJS({
    "node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/factoriesAny.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      Object.defineProperty(exports, "createAbs", {
        enumerable: true,
        get: function get() {
          return _abs.createAbs;
        }
      });
      Object.defineProperty(exports, "createAccessorNode", {
        enumerable: true,
        get: function get() {
          return _AccessorNode.createAccessorNode;
        }
      });
      Object.defineProperty(exports, "createAcos", {
        enumerable: true,
        get: function get() {
          return _acos.createAcos;
        }
      });
      Object.defineProperty(exports, "createAcosh", {
        enumerable: true,
        get: function get() {
          return _acosh.createAcosh;
        }
      });
      Object.defineProperty(exports, "createAcot", {
        enumerable: true,
        get: function get() {
          return _acot.createAcot;
        }
      });
      Object.defineProperty(exports, "createAcoth", {
        enumerable: true,
        get: function get() {
          return _acoth.createAcoth;
        }
      });
      Object.defineProperty(exports, "createAcsc", {
        enumerable: true,
        get: function get() {
          return _acsc.createAcsc;
        }
      });
      Object.defineProperty(exports, "createAcsch", {
        enumerable: true,
        get: function get() {
          return _acsch.createAcsch;
        }
      });
      Object.defineProperty(exports, "createAdd", {
        enumerable: true,
        get: function get() {
          return _add.createAdd;
        }
      });
      Object.defineProperty(exports, "createAddScalar", {
        enumerable: true,
        get: function get() {
          return _addScalar.createAddScalar;
        }
      });
      Object.defineProperty(exports, "createAnd", {
        enumerable: true,
        get: function get() {
          return _and.createAnd;
        }
      });
      Object.defineProperty(exports, "createAndTransform", {
        enumerable: true,
        get: function get() {
          return _andTransform.createAndTransform;
        }
      });
      Object.defineProperty(exports, "createApply", {
        enumerable: true,
        get: function get() {
          return _apply.createApply;
        }
      });
      Object.defineProperty(exports, "createApplyTransform", {
        enumerable: true,
        get: function get() {
          return _applyTransform.createApplyTransform;
        }
      });
      Object.defineProperty(exports, "createArg", {
        enumerable: true,
        get: function get() {
          return _arg.createArg;
        }
      });
      Object.defineProperty(exports, "createArrayNode", {
        enumerable: true,
        get: function get() {
          return _ArrayNode.createArrayNode;
        }
      });
      Object.defineProperty(exports, "createAsec", {
        enumerable: true,
        get: function get() {
          return _asec.createAsec;
        }
      });
      Object.defineProperty(exports, "createAsech", {
        enumerable: true,
        get: function get() {
          return _asech.createAsech;
        }
      });
      Object.defineProperty(exports, "createAsin", {
        enumerable: true,
        get: function get() {
          return _asin.createAsin;
        }
      });
      Object.defineProperty(exports, "createAsinh", {
        enumerable: true,
        get: function get() {
          return _asinh.createAsinh;
        }
      });
      Object.defineProperty(exports, "createAssignmentNode", {
        enumerable: true,
        get: function get() {
          return _AssignmentNode.createAssignmentNode;
        }
      });
      Object.defineProperty(exports, "createAtan", {
        enumerable: true,
        get: function get() {
          return _atan.createAtan;
        }
      });
      Object.defineProperty(exports, "createAtan2", {
        enumerable: true,
        get: function get() {
          return _atan2.createAtan2;
        }
      });
      Object.defineProperty(exports, "createAtanh", {
        enumerable: true,
        get: function get() {
          return _atanh.createAtanh;
        }
      });
      Object.defineProperty(exports, "createAtomicMass", {
        enumerable: true,
        get: function get() {
          return _physicalConstants.createAtomicMass;
        }
      });
      Object.defineProperty(exports, "createAvogadro", {
        enumerable: true,
        get: function get() {
          return _physicalConstants.createAvogadro;
        }
      });
      Object.defineProperty(exports, "createBellNumbers", {
        enumerable: true,
        get: function get() {
          return _bellNumbers.createBellNumbers;
        }
      });
      Object.defineProperty(exports, "createBigNumberClass", {
        enumerable: true,
        get: function get() {
          return _BigNumber.createBigNumberClass;
        }
      });
      Object.defineProperty(exports, "createBignumber", {
        enumerable: true,
        get: function get() {
          return _bignumber.createBignumber;
        }
      });
      Object.defineProperty(exports, "createBin", {
        enumerable: true,
        get: function get() {
          return _bin.createBin;
        }
      });
      Object.defineProperty(exports, "createBitAnd", {
        enumerable: true,
        get: function get() {
          return _bitAnd.createBitAnd;
        }
      });
      Object.defineProperty(exports, "createBitAndTransform", {
        enumerable: true,
        get: function get() {
          return _bitAndTransform.createBitAndTransform;
        }
      });
      Object.defineProperty(exports, "createBitNot", {
        enumerable: true,
        get: function get() {
          return _bitNot.createBitNot;
        }
      });
      Object.defineProperty(exports, "createBitOr", {
        enumerable: true,
        get: function get() {
          return _bitOr.createBitOr;
        }
      });
      Object.defineProperty(exports, "createBitOrTransform", {
        enumerable: true,
        get: function get() {
          return _bitOrTransform.createBitOrTransform;
        }
      });
      Object.defineProperty(exports, "createBitXor", {
        enumerable: true,
        get: function get() {
          return _bitXor.createBitXor;
        }
      });
      Object.defineProperty(exports, "createBlockNode", {
        enumerable: true,
        get: function get() {
          return _BlockNode.createBlockNode;
        }
      });
      Object.defineProperty(exports, "createBohrMagneton", {
        enumerable: true,
        get: function get() {
          return _physicalConstants.createBohrMagneton;
        }
      });
      Object.defineProperty(exports, "createBohrRadius", {
        enumerable: true,
        get: function get() {
          return _physicalConstants.createBohrRadius;
        }
      });
      Object.defineProperty(exports, "createBoltzmann", {
        enumerable: true,
        get: function get() {
          return _physicalConstants.createBoltzmann;
        }
      });
      Object.defineProperty(exports, "createBoolean", {
        enumerable: true,
        get: function get() {
          return _boolean.createBoolean;
        }
      });
      Object.defineProperty(exports, "createCatalan", {
        enumerable: true,
        get: function get() {
          return _catalan.createCatalan;
        }
      });
      Object.defineProperty(exports, "createCbrt", {
        enumerable: true,
        get: function get() {
          return _cbrt.createCbrt;
        }
      });
      Object.defineProperty(exports, "createCeil", {
        enumerable: true,
        get: function get() {
          return _ceil.createCeil;
        }
      });
      Object.defineProperty(exports, "createChain", {
        enumerable: true,
        get: function get() {
          return _chain.createChain;
        }
      });
      Object.defineProperty(exports, "createChainClass", {
        enumerable: true,
        get: function get() {
          return _Chain.createChainClass;
        }
      });
      Object.defineProperty(exports, "createClassicalElectronRadius", {
        enumerable: true,
        get: function get() {
          return _physicalConstants.createClassicalElectronRadius;
        }
      });
      Object.defineProperty(exports, "createClone", {
        enumerable: true,
        get: function get() {
          return _clone.createClone;
        }
      });
      Object.defineProperty(exports, "createColumn", {
        enumerable: true,
        get: function get() {
          return _column.createColumn;
        }
      });
      Object.defineProperty(exports, "createColumnTransform", {
        enumerable: true,
        get: function get() {
          return _columnTransform.createColumnTransform;
        }
      });
      Object.defineProperty(exports, "createCombinations", {
        enumerable: true,
        get: function get() {
          return _combinations.createCombinations;
        }
      });
      Object.defineProperty(exports, "createCombinationsWithRep", {
        enumerable: true,
        get: function get() {
          return _combinationsWithRep.createCombinationsWithRep;
        }
      });
      Object.defineProperty(exports, "createCompare", {
        enumerable: true,
        get: function get() {
          return _compare.createCompare;
        }
      });
      Object.defineProperty(exports, "createCompareNatural", {
        enumerable: true,
        get: function get() {
          return _compareNatural.createCompareNatural;
        }
      });
      Object.defineProperty(exports, "createCompareText", {
        enumerable: true,
        get: function get() {
          return _compareText.createCompareText;
        }
      });
      Object.defineProperty(exports, "createCompile", {
        enumerable: true,
        get: function get() {
          return _compile.createCompile;
        }
      });
      Object.defineProperty(exports, "createComplex", {
        enumerable: true,
        get: function get() {
          return _complex.createComplex;
        }
      });
      Object.defineProperty(exports, "createComplexClass", {
        enumerable: true,
        get: function get() {
          return _Complex.createComplexClass;
        }
      });
      Object.defineProperty(exports, "createComposition", {
        enumerable: true,
        get: function get() {
          return _composition.createComposition;
        }
      });
      Object.defineProperty(exports, "createConcat", {
        enumerable: true,
        get: function get() {
          return _concat.createConcat;
        }
      });
      Object.defineProperty(exports, "createConcatTransform", {
        enumerable: true,
        get: function get() {
          return _concatTransform.createConcatTransform;
        }
      });
      Object.defineProperty(exports, "createConditionalNode", {
        enumerable: true,
        get: function get() {
          return _ConditionalNode.createConditionalNode;
        }
      });
      Object.defineProperty(exports, "createConductanceQuantum", {
        enumerable: true,
        get: function get() {
          return _physicalConstants.createConductanceQuantum;
        }
      });
      Object.defineProperty(exports, "createConj", {
        enumerable: true,
        get: function get() {
          return _conj.createConj;
        }
      });
      Object.defineProperty(exports, "createConstantNode", {
        enumerable: true,
        get: function get() {
          return _ConstantNode.createConstantNode;
        }
      });
      Object.defineProperty(exports, "createCorr", {
        enumerable: true,
        get: function get() {
          return _corr.createCorr;
        }
      });
      Object.defineProperty(exports, "createCos", {
        enumerable: true,
        get: function get() {
          return _cos.createCos;
        }
      });
      Object.defineProperty(exports, "createCosh", {
        enumerable: true,
        get: function get() {
          return _cosh.createCosh;
        }
      });
      Object.defineProperty(exports, "createCot", {
        enumerable: true,
        get: function get() {
          return _cot.createCot;
        }
      });
      Object.defineProperty(exports, "createCoth", {
        enumerable: true,
        get: function get() {
          return _coth.createCoth;
        }
      });
      Object.defineProperty(exports, "createCoulomb", {
        enumerable: true,
        get: function get() {
          return _physicalConstants.createCoulomb;
        }
      });
      Object.defineProperty(exports, "createCount", {
        enumerable: true,
        get: function get() {
          return _count.createCount;
        }
      });
      Object.defineProperty(exports, "createCreateUnit", {
        enumerable: true,
        get: function get() {
          return _createUnit.createCreateUnit;
        }
      });
      Object.defineProperty(exports, "createCross", {
        enumerable: true,
        get: function get() {
          return _cross.createCross;
        }
      });
      Object.defineProperty(exports, "createCsc", {
        enumerable: true,
        get: function get() {
          return _csc.createCsc;
        }
      });
      Object.defineProperty(exports, "createCsch", {
        enumerable: true,
        get: function get() {
          return _csch.createCsch;
        }
      });
      Object.defineProperty(exports, "createCtranspose", {
        enumerable: true,
        get: function get() {
          return _ctranspose.createCtranspose;
        }
      });
      Object.defineProperty(exports, "createCube", {
        enumerable: true,
        get: function get() {
          return _cube.createCube;
        }
      });
      Object.defineProperty(exports, "createCumSum", {
        enumerable: true,
        get: function get() {
          return _cumsum.createCumSum;
        }
      });
      Object.defineProperty(exports, "createCumSumTransform", {
        enumerable: true,
        get: function get() {
          return _cumsumTransform.createCumSumTransform;
        }
      });
      Object.defineProperty(exports, "createDeepEqual", {
        enumerable: true,
        get: function get() {
          return _deepEqual.createDeepEqual;
        }
      });
      Object.defineProperty(exports, "createDenseMatrixClass", {
        enumerable: true,
        get: function get() {
          return _DenseMatrix.createDenseMatrixClass;
        }
      });
      Object.defineProperty(exports, "createDerivative", {
        enumerable: true,
        get: function get() {
          return _derivative.createDerivative;
        }
      });
      Object.defineProperty(exports, "createDet", {
        enumerable: true,
        get: function get() {
          return _det.createDet;
        }
      });
      Object.defineProperty(exports, "createDeuteronMass", {
        enumerable: true,
        get: function get() {
          return _physicalConstants.createDeuteronMass;
        }
      });
      Object.defineProperty(exports, "createDiag", {
        enumerable: true,
        get: function get() {
          return _diag.createDiag;
        }
      });
      Object.defineProperty(exports, "createDiff", {
        enumerable: true,
        get: function get() {
          return _diff.createDiff;
        }
      });
      Object.defineProperty(exports, "createDiffTransform", {
        enumerable: true,
        get: function get() {
          return _diffTransform.createDiffTransform;
        }
      });
      Object.defineProperty(exports, "createDistance", {
        enumerable: true,
        get: function get() {
          return _distance.createDistance;
        }
      });
      Object.defineProperty(exports, "createDivide", {
        enumerable: true,
        get: function get() {
          return _divide.createDivide;
        }
      });
      Object.defineProperty(exports, "createDivideScalar", {
        enumerable: true,
        get: function get() {
          return _divideScalar.createDivideScalar;
        }
      });
      Object.defineProperty(exports, "createDot", {
        enumerable: true,
        get: function get() {
          return _dot.createDot;
        }
      });
      Object.defineProperty(exports, "createDotDivide", {
        enumerable: true,
        get: function get() {
          return _dotDivide.createDotDivide;
        }
      });
      Object.defineProperty(exports, "createDotMultiply", {
        enumerable: true,
        get: function get() {
          return _dotMultiply.createDotMultiply;
        }
      });
      Object.defineProperty(exports, "createDotPow", {
        enumerable: true,
        get: function get() {
          return _dotPow.createDotPow;
        }
      });
      Object.defineProperty(exports, "createE", {
        enumerable: true,
        get: function get() {
          return _constants.createE;
        }
      });
      Object.defineProperty(exports, "createEfimovFactor", {
        enumerable: true,
        get: function get() {
          return _physicalConstants.createEfimovFactor;
        }
      });
      Object.defineProperty(exports, "createEigs", {
        enumerable: true,
        get: function get() {
          return _eigs.createEigs;
        }
      });
      Object.defineProperty(exports, "createElectricConstant", {
        enumerable: true,
        get: function get() {
          return _physicalConstants.createElectricConstant;
        }
      });
      Object.defineProperty(exports, "createElectronMass", {
        enumerable: true,
        get: function get() {
          return _physicalConstants.createElectronMass;
        }
      });
      Object.defineProperty(exports, "createElementaryCharge", {
        enumerable: true,
        get: function get() {
          return _physicalConstants.createElementaryCharge;
        }
      });
      Object.defineProperty(exports, "createEqual", {
        enumerable: true,
        get: function get() {
          return _equal.createEqual;
        }
      });
      Object.defineProperty(exports, "createEqualScalar", {
        enumerable: true,
        get: function get() {
          return _equalScalar.createEqualScalar;
        }
      });
      Object.defineProperty(exports, "createEqualText", {
        enumerable: true,
        get: function get() {
          return _equalText.createEqualText;
        }
      });
      Object.defineProperty(exports, "createErf", {
        enumerable: true,
        get: function get() {
          return _erf.createErf;
        }
      });
      Object.defineProperty(exports, "createEvaluate", {
        enumerable: true,
        get: function get() {
          return _evaluate.createEvaluate;
        }
      });
      Object.defineProperty(exports, "createExp", {
        enumerable: true,
        get: function get() {
          return _exp.createExp;
        }
      });
      Object.defineProperty(exports, "createExpm", {
        enumerable: true,
        get: function get() {
          return _expm2.createExpm;
        }
      });
      Object.defineProperty(exports, "createExpm1", {
        enumerable: true,
        get: function get() {
          return _expm.createExpm1;
        }
      });
      Object.defineProperty(exports, "createFactorial", {
        enumerable: true,
        get: function get() {
          return _factorial.createFactorial;
        }
      });
      Object.defineProperty(exports, "createFalse", {
        enumerable: true,
        get: function get() {
          return _constants.createFalse;
        }
      });
      Object.defineProperty(exports, "createFaraday", {
        enumerable: true,
        get: function get() {
          return _physicalConstants.createFaraday;
        }
      });
      Object.defineProperty(exports, "createFermiCoupling", {
        enumerable: true,
        get: function get() {
          return _physicalConstants.createFermiCoupling;
        }
      });
      Object.defineProperty(exports, "createFft", {
        enumerable: true,
        get: function get() {
          return _fft.createFft;
        }
      });
      Object.defineProperty(exports, "createFibonacciHeapClass", {
        enumerable: true,
        get: function get() {
          return _FibonacciHeap.createFibonacciHeapClass;
        }
      });
      Object.defineProperty(exports, "createFilter", {
        enumerable: true,
        get: function get() {
          return _filter.createFilter;
        }
      });
      Object.defineProperty(exports, "createFilterTransform", {
        enumerable: true,
        get: function get() {
          return _filterTransform.createFilterTransform;
        }
      });
      Object.defineProperty(exports, "createFineStructure", {
        enumerable: true,
        get: function get() {
          return _physicalConstants.createFineStructure;
        }
      });
      Object.defineProperty(exports, "createFirstRadiation", {
        enumerable: true,
        get: function get() {
          return _physicalConstants.createFirstRadiation;
        }
      });
      Object.defineProperty(exports, "createFix", {
        enumerable: true,
        get: function get() {
          return _fix.createFix;
        }
      });
      Object.defineProperty(exports, "createFlatten", {
        enumerable: true,
        get: function get() {
          return _flatten.createFlatten;
        }
      });
      Object.defineProperty(exports, "createFloor", {
        enumerable: true,
        get: function get() {
          return _floor.createFloor;
        }
      });
      Object.defineProperty(exports, "createForEach", {
        enumerable: true,
        get: function get() {
          return _forEach.createForEach;
        }
      });
      Object.defineProperty(exports, "createForEachTransform", {
        enumerable: true,
        get: function get() {
          return _forEachTransform.createForEachTransform;
        }
      });
      Object.defineProperty(exports, "createFormat", {
        enumerable: true,
        get: function get() {
          return _format2.createFormat;
        }
      });
      Object.defineProperty(exports, "createFraction", {
        enumerable: true,
        get: function get() {
          return _fraction.createFraction;
        }
      });
      Object.defineProperty(exports, "createFractionClass", {
        enumerable: true,
        get: function get() {
          return _Fraction.createFractionClass;
        }
      });
      Object.defineProperty(exports, "createFreqz", {
        enumerable: true,
        get: function get() {
          return _freqz.createFreqz;
        }
      });
      Object.defineProperty(exports, "createFunctionAssignmentNode", {
        enumerable: true,
        get: function get() {
          return _FunctionAssignmentNode.createFunctionAssignmentNode;
        }
      });
      Object.defineProperty(exports, "createFunctionNode", {
        enumerable: true,
        get: function get() {
          return _FunctionNode.createFunctionNode;
        }
      });
      Object.defineProperty(exports, "createGamma", {
        enumerable: true,
        get: function get() {
          return _gamma.createGamma;
        }
      });
      Object.defineProperty(exports, "createGasConstant", {
        enumerable: true,
        get: function get() {
          return _physicalConstants.createGasConstant;
        }
      });
      Object.defineProperty(exports, "createGcd", {
        enumerable: true,
        get: function get() {
          return _gcd.createGcd;
        }
      });
      Object.defineProperty(exports, "createGetMatrixDataType", {
        enumerable: true,
        get: function get() {
          return _getMatrixDataType.createGetMatrixDataType;
        }
      });
      Object.defineProperty(exports, "createGravitationConstant", {
        enumerable: true,
        get: function get() {
          return _physicalConstants.createGravitationConstant;
        }
      });
      Object.defineProperty(exports, "createGravity", {
        enumerable: true,
        get: function get() {
          return _physicalConstants.createGravity;
        }
      });
      Object.defineProperty(exports, "createHartreeEnergy", {
        enumerable: true,
        get: function get() {
          return _physicalConstants.createHartreeEnergy;
        }
      });
      Object.defineProperty(exports, "createHasNumericValue", {
        enumerable: true,
        get: function get() {
          return _hasNumericValue.createHasNumericValue;
        }
      });
      Object.defineProperty(exports, "createHelp", {
        enumerable: true,
        get: function get() {
          return _help.createHelp;
        }
      });
      Object.defineProperty(exports, "createHelpClass", {
        enumerable: true,
        get: function get() {
          return _Help.createHelpClass;
        }
      });
      Object.defineProperty(exports, "createHex", {
        enumerable: true,
        get: function get() {
          return _hex.createHex;
        }
      });
      Object.defineProperty(exports, "createHypot", {
        enumerable: true,
        get: function get() {
          return _hypot.createHypot;
        }
      });
      Object.defineProperty(exports, "createI", {
        enumerable: true,
        get: function get() {
          return _constants.createI;
        }
      });
      Object.defineProperty(exports, "createIdentity", {
        enumerable: true,
        get: function get() {
          return _identity.createIdentity;
        }
      });
      Object.defineProperty(exports, "createIfft", {
        enumerable: true,
        get: function get() {
          return _ifft.createIfft;
        }
      });
      Object.defineProperty(exports, "createIm", {
        enumerable: true,
        get: function get() {
          return _im.createIm;
        }
      });
      Object.defineProperty(exports, "createImmutableDenseMatrixClass", {
        enumerable: true,
        get: function get() {
          return _ImmutableDenseMatrix.createImmutableDenseMatrixClass;
        }
      });
      Object.defineProperty(exports, "createIndex", {
        enumerable: true,
        get: function get() {
          return _index.createIndex;
        }
      });
      Object.defineProperty(exports, "createIndexClass", {
        enumerable: true,
        get: function get() {
          return _MatrixIndex.createIndexClass;
        }
      });
      Object.defineProperty(exports, "createIndexNode", {
        enumerable: true,
        get: function get() {
          return _IndexNode.createIndexNode;
        }
      });
      Object.defineProperty(exports, "createIndexTransform", {
        enumerable: true,
        get: function get() {
          return _indexTransform.createIndexTransform;
        }
      });
      Object.defineProperty(exports, "createInfinity", {
        enumerable: true,
        get: function get() {
          return _constants.createInfinity;
        }
      });
      Object.defineProperty(exports, "createIntersect", {
        enumerable: true,
        get: function get() {
          return _intersect.createIntersect;
        }
      });
      Object.defineProperty(exports, "createInv", {
        enumerable: true,
        get: function get() {
          return _inv.createInv;
        }
      });
      Object.defineProperty(exports, "createInverseConductanceQuantum", {
        enumerable: true,
        get: function get() {
          return _physicalConstants.createInverseConductanceQuantum;
        }
      });
      Object.defineProperty(exports, "createInvmod", {
        enumerable: true,
        get: function get() {
          return _invmod.createInvmod;
        }
      });
      Object.defineProperty(exports, "createIsInteger", {
        enumerable: true,
        get: function get() {
          return _isInteger.createIsInteger;
        }
      });
      Object.defineProperty(exports, "createIsNaN", {
        enumerable: true,
        get: function get() {
          return _isNaN.createIsNaN;
        }
      });
      Object.defineProperty(exports, "createIsNegative", {
        enumerable: true,
        get: function get() {
          return _isNegative.createIsNegative;
        }
      });
      Object.defineProperty(exports, "createIsNumeric", {
        enumerable: true,
        get: function get() {
          return _isNumeric.createIsNumeric;
        }
      });
      Object.defineProperty(exports, "createIsPositive", {
        enumerable: true,
        get: function get() {
          return _isPositive.createIsPositive;
        }
      });
      Object.defineProperty(exports, "createIsPrime", {
        enumerable: true,
        get: function get() {
          return _isPrime.createIsPrime;
        }
      });
      Object.defineProperty(exports, "createIsZero", {
        enumerable: true,
        get: function get() {
          return _isZero.createIsZero;
        }
      });
      Object.defineProperty(exports, "createKldivergence", {
        enumerable: true,
        get: function get() {
          return _kldivergence.createKldivergence;
        }
      });
      Object.defineProperty(exports, "createKlitzing", {
        enumerable: true,
        get: function get() {
          return _physicalConstants.createKlitzing;
        }
      });
      Object.defineProperty(exports, "createKron", {
        enumerable: true,
        get: function get() {
          return _kron.createKron;
        }
      });
      Object.defineProperty(exports, "createLN10", {
        enumerable: true,
        get: function get() {
          return _constants.createLN10;
        }
      });
      Object.defineProperty(exports, "createLN2", {
        enumerable: true,
        get: function get() {
          return _constants.createLN2;
        }
      });
      Object.defineProperty(exports, "createLOG10E", {
        enumerable: true,
        get: function get() {
          return _constants.createLOG10E;
        }
      });
      Object.defineProperty(exports, "createLOG2E", {
        enumerable: true,
        get: function get() {
          return _constants.createLOG2E;
        }
      });
      Object.defineProperty(exports, "createLarger", {
        enumerable: true,
        get: function get() {
          return _larger.createLarger;
        }
      });
      Object.defineProperty(exports, "createLargerEq", {
        enumerable: true,
        get: function get() {
          return _largerEq.createLargerEq;
        }
      });
      Object.defineProperty(exports, "createLcm", {
        enumerable: true,
        get: function get() {
          return _lcm.createLcm;
        }
      });
      Object.defineProperty(exports, "createLeafCount", {
        enumerable: true,
        get: function get() {
          return _leafCount.createLeafCount;
        }
      });
      Object.defineProperty(exports, "createLeftShift", {
        enumerable: true,
        get: function get() {
          return _leftShift.createLeftShift;
        }
      });
      Object.defineProperty(exports, "createLgamma", {
        enumerable: true,
        get: function get() {
          return _lgamma.createLgamma;
        }
      });
      Object.defineProperty(exports, "createLog", {
        enumerable: true,
        get: function get() {
          return _log3.createLog;
        }
      });
      Object.defineProperty(exports, "createLog10", {
        enumerable: true,
        get: function get() {
          return _log.createLog10;
        }
      });
      Object.defineProperty(exports, "createLog1p", {
        enumerable: true,
        get: function get() {
          return _log1p.createLog1p;
        }
      });
      Object.defineProperty(exports, "createLog2", {
        enumerable: true,
        get: function get() {
          return _log2.createLog2;
        }
      });
      Object.defineProperty(exports, "createLoschmidt", {
        enumerable: true,
        get: function get() {
          return _physicalConstants.createLoschmidt;
        }
      });
      Object.defineProperty(exports, "createLsolve", {
        enumerable: true,
        get: function get() {
          return _lsolve.createLsolve;
        }
      });
      Object.defineProperty(exports, "createLsolveAll", {
        enumerable: true,
        get: function get() {
          return _lsolveAll.createLsolveAll;
        }
      });
      Object.defineProperty(exports, "createLup", {
        enumerable: true,
        get: function get() {
          return _lup.createLup;
        }
      });
      Object.defineProperty(exports, "createLusolve", {
        enumerable: true,
        get: function get() {
          return _lusolve.createLusolve;
        }
      });
      Object.defineProperty(exports, "createLyap", {
        enumerable: true,
        get: function get() {
          return _lyap.createLyap;
        }
      });
      Object.defineProperty(exports, "createMad", {
        enumerable: true,
        get: function get() {
          return _mad.createMad;
        }
      });
      Object.defineProperty(exports, "createMagneticConstant", {
        enumerable: true,
        get: function get() {
          return _physicalConstants.createMagneticConstant;
        }
      });
      Object.defineProperty(exports, "createMagneticFluxQuantum", {
        enumerable: true,
        get: function get() {
          return _physicalConstants.createMagneticFluxQuantum;
        }
      });
      Object.defineProperty(exports, "createMap", {
        enumerable: true,
        get: function get() {
          return _map.createMap;
        }
      });
      Object.defineProperty(exports, "createMapTransform", {
        enumerable: true,
        get: function get() {
          return _mapTransform.createMapTransform;
        }
      });
      Object.defineProperty(exports, "createMatrix", {
        enumerable: true,
        get: function get() {
          return _matrix.createMatrix;
        }
      });
      Object.defineProperty(exports, "createMatrixClass", {
        enumerable: true,
        get: function get() {
          return _Matrix.createMatrixClass;
        }
      });
      Object.defineProperty(exports, "createMatrixFromColumns", {
        enumerable: true,
        get: function get() {
          return _matrixFromColumns.createMatrixFromColumns;
        }
      });
      Object.defineProperty(exports, "createMatrixFromFunction", {
        enumerable: true,
        get: function get() {
          return _matrixFromFunction.createMatrixFromFunction;
        }
      });
      Object.defineProperty(exports, "createMatrixFromRows", {
        enumerable: true,
        get: function get() {
          return _matrixFromRows.createMatrixFromRows;
        }
      });
      Object.defineProperty(exports, "createMax", {
        enumerable: true,
        get: function get() {
          return _max.createMax;
        }
      });
      Object.defineProperty(exports, "createMaxTransform", {
        enumerable: true,
        get: function get() {
          return _maxTransform.createMaxTransform;
        }
      });
      Object.defineProperty(exports, "createMean", {
        enumerable: true,
        get: function get() {
          return _mean.createMean;
        }
      });
      Object.defineProperty(exports, "createMeanTransform", {
        enumerable: true,
        get: function get() {
          return _meanTransform.createMeanTransform;
        }
      });
      Object.defineProperty(exports, "createMedian", {
        enumerable: true,
        get: function get() {
          return _median.createMedian;
        }
      });
      Object.defineProperty(exports, "createMin", {
        enumerable: true,
        get: function get() {
          return _min.createMin;
        }
      });
      Object.defineProperty(exports, "createMinTransform", {
        enumerable: true,
        get: function get() {
          return _minTransform.createMinTransform;
        }
      });
      Object.defineProperty(exports, "createMod", {
        enumerable: true,
        get: function get() {
          return _mod.createMod;
        }
      });
      Object.defineProperty(exports, "createMode", {
        enumerable: true,
        get: function get() {
          return _mode.createMode;
        }
      });
      Object.defineProperty(exports, "createMolarMass", {
        enumerable: true,
        get: function get() {
          return _physicalConstants.createMolarMass;
        }
      });
      Object.defineProperty(exports, "createMolarMassC12", {
        enumerable: true,
        get: function get() {
          return _physicalConstants.createMolarMassC12;
        }
      });
      Object.defineProperty(exports, "createMolarPlanckConstant", {
        enumerable: true,
        get: function get() {
          return _physicalConstants.createMolarPlanckConstant;
        }
      });
      Object.defineProperty(exports, "createMolarVolume", {
        enumerable: true,
        get: function get() {
          return _physicalConstants.createMolarVolume;
        }
      });
      Object.defineProperty(exports, "createMultinomial", {
        enumerable: true,
        get: function get() {
          return _multinomial.createMultinomial;
        }
      });
      Object.defineProperty(exports, "createMultiply", {
        enumerable: true,
        get: function get() {
          return _multiply.createMultiply;
        }
      });
      Object.defineProperty(exports, "createMultiplyScalar", {
        enumerable: true,
        get: function get() {
          return _multiplyScalar.createMultiplyScalar;
        }
      });
      Object.defineProperty(exports, "createNaN", {
        enumerable: true,
        get: function get() {
          return _constants.createNaN;
        }
      });
      Object.defineProperty(exports, "createNeutronMass", {
        enumerable: true,
        get: function get() {
          return _physicalConstants.createNeutronMass;
        }
      });
      Object.defineProperty(exports, "createNode", {
        enumerable: true,
        get: function get() {
          return _Node.createNode;
        }
      });
      Object.defineProperty(exports, "createNorm", {
        enumerable: true,
        get: function get() {
          return _norm.createNorm;
        }
      });
      Object.defineProperty(exports, "createNot", {
        enumerable: true,
        get: function get() {
          return _not.createNot;
        }
      });
      Object.defineProperty(exports, "createNthRoot", {
        enumerable: true,
        get: function get() {
          return _nthRoot.createNthRoot;
        }
      });
      Object.defineProperty(exports, "createNthRoots", {
        enumerable: true,
        get: function get() {
          return _nthRoots.createNthRoots;
        }
      });
      Object.defineProperty(exports, "createNuclearMagneton", {
        enumerable: true,
        get: function get() {
          return _physicalConstants.createNuclearMagneton;
        }
      });
      Object.defineProperty(exports, "createNull", {
        enumerable: true,
        get: function get() {
          return _constants.createNull;
        }
      });
      Object.defineProperty(exports, "createNumber", {
        enumerable: true,
        get: function get() {
          return _number.createNumber;
        }
      });
      Object.defineProperty(exports, "createNumeric", {
        enumerable: true,
        get: function get() {
          return _numeric.createNumeric;
        }
      });
      Object.defineProperty(exports, "createObjectNode", {
        enumerable: true,
        get: function get() {
          return _ObjectNode.createObjectNode;
        }
      });
      Object.defineProperty(exports, "createOct", {
        enumerable: true,
        get: function get() {
          return _oct.createOct;
        }
      });
      Object.defineProperty(exports, "createOnes", {
        enumerable: true,
        get: function get() {
          return _ones.createOnes;
        }
      });
      Object.defineProperty(exports, "createOperatorNode", {
        enumerable: true,
        get: function get() {
          return _OperatorNode.createOperatorNode;
        }
      });
      Object.defineProperty(exports, "createOr", {
        enumerable: true,
        get: function get() {
          return _or.createOr;
        }
      });
      Object.defineProperty(exports, "createOrTransform", {
        enumerable: true,
        get: function get() {
          return _orTransform.createOrTransform;
        }
      });
      Object.defineProperty(exports, "createParenthesisNode", {
        enumerable: true,
        get: function get() {
          return _ParenthesisNode.createParenthesisNode;
        }
      });
      Object.defineProperty(exports, "createParse", {
        enumerable: true,
        get: function get() {
          return _parse.createParse;
        }
      });
      Object.defineProperty(exports, "createParser", {
        enumerable: true,
        get: function get() {
          return _parser.createParser;
        }
      });
      Object.defineProperty(exports, "createParserClass", {
        enumerable: true,
        get: function get() {
          return _Parser.createParserClass;
        }
      });
      Object.defineProperty(exports, "createPartitionSelect", {
        enumerable: true,
        get: function get() {
          return _partitionSelect.createPartitionSelect;
        }
      });
      Object.defineProperty(exports, "createPermutations", {
        enumerable: true,
        get: function get() {
          return _permutations.createPermutations;
        }
      });
      Object.defineProperty(exports, "createPhi", {
        enumerable: true,
        get: function get() {
          return _constants.createPhi;
        }
      });
      Object.defineProperty(exports, "createPi", {
        enumerable: true,
        get: function get() {
          return _constants.createPi;
        }
      });
      Object.defineProperty(exports, "createPickRandom", {
        enumerable: true,
        get: function get() {
          return _pickRandom.createPickRandom;
        }
      });
      Object.defineProperty(exports, "createPinv", {
        enumerable: true,
        get: function get() {
          return _pinv.createPinv;
        }
      });
      Object.defineProperty(exports, "createPlanckCharge", {
        enumerable: true,
        get: function get() {
          return _physicalConstants.createPlanckCharge;
        }
      });
      Object.defineProperty(exports, "createPlanckConstant", {
        enumerable: true,
        get: function get() {
          return _physicalConstants.createPlanckConstant;
        }
      });
      Object.defineProperty(exports, "createPlanckLength", {
        enumerable: true,
        get: function get() {
          return _physicalConstants.createPlanckLength;
        }
      });
      Object.defineProperty(exports, "createPlanckMass", {
        enumerable: true,
        get: function get() {
          return _physicalConstants.createPlanckMass;
        }
      });
      Object.defineProperty(exports, "createPlanckTemperature", {
        enumerable: true,
        get: function get() {
          return _physicalConstants.createPlanckTemperature;
        }
      });
      Object.defineProperty(exports, "createPlanckTime", {
        enumerable: true,
        get: function get() {
          return _physicalConstants.createPlanckTime;
        }
      });
      Object.defineProperty(exports, "createPolynomialRoot", {
        enumerable: true,
        get: function get() {
          return _polynomialRoot.createPolynomialRoot;
        }
      });
      Object.defineProperty(exports, "createPow", {
        enumerable: true,
        get: function get() {
          return _pow.createPow;
        }
      });
      Object.defineProperty(exports, "createPrint", {
        enumerable: true,
        get: function get() {
          return _print.createPrint;
        }
      });
      Object.defineProperty(exports, "createPrintTransform", {
        enumerable: true,
        get: function get() {
          return _printTransform.createPrintTransform;
        }
      });
      Object.defineProperty(exports, "createProd", {
        enumerable: true,
        get: function get() {
          return _prod.createProd;
        }
      });
      Object.defineProperty(exports, "createProtonMass", {
        enumerable: true,
        get: function get() {
          return _physicalConstants.createProtonMass;
        }
      });
      Object.defineProperty(exports, "createQr", {
        enumerable: true,
        get: function get() {
          return _qr.createQr;
        }
      });
      Object.defineProperty(exports, "createQuantileSeq", {
        enumerable: true,
        get: function get() {
          return _quantileSeq.createQuantileSeq;
        }
      });
      Object.defineProperty(exports, "createQuantileSeqTransform", {
        enumerable: true,
        get: function get() {
          return _quantileSeqTransform.createQuantileSeqTransform;
        }
      });
      Object.defineProperty(exports, "createQuantumOfCirculation", {
        enumerable: true,
        get: function get() {
          return _physicalConstants.createQuantumOfCirculation;
        }
      });
      Object.defineProperty(exports, "createRandom", {
        enumerable: true,
        get: function get() {
          return _random.createRandom;
        }
      });
      Object.defineProperty(exports, "createRandomInt", {
        enumerable: true,
        get: function get() {
          return _randomInt.createRandomInt;
        }
      });
      Object.defineProperty(exports, "createRange", {
        enumerable: true,
        get: function get() {
          return _range.createRange;
        }
      });
      Object.defineProperty(exports, "createRangeClass", {
        enumerable: true,
        get: function get() {
          return _Range.createRangeClass;
        }
      });
      Object.defineProperty(exports, "createRangeNode", {
        enumerable: true,
        get: function get() {
          return _RangeNode.createRangeNode;
        }
      });
      Object.defineProperty(exports, "createRangeTransform", {
        enumerable: true,
        get: function get() {
          return _rangeTransform.createRangeTransform;
        }
      });
      Object.defineProperty(exports, "createRationalize", {
        enumerable: true,
        get: function get() {
          return _rationalize.createRationalize;
        }
      });
      Object.defineProperty(exports, "createRe", {
        enumerable: true,
        get: function get() {
          return _re.createRe;
        }
      });
      Object.defineProperty(exports, "createReducedPlanckConstant", {
        enumerable: true,
        get: function get() {
          return _physicalConstants.createReducedPlanckConstant;
        }
      });
      Object.defineProperty(exports, "createRelationalNode", {
        enumerable: true,
        get: function get() {
          return _RelationalNode.createRelationalNode;
        }
      });
      Object.defineProperty(exports, "createReplacer", {
        enumerable: true,
        get: function get() {
          return _replacer.createReplacer;
        }
      });
      Object.defineProperty(exports, "createReshape", {
        enumerable: true,
        get: function get() {
          return _reshape2.createReshape;
        }
      });
      Object.defineProperty(exports, "createResize", {
        enumerable: true,
        get: function get() {
          return _resize2.createResize;
        }
      });
      Object.defineProperty(exports, "createResolve", {
        enumerable: true,
        get: function get() {
          return _resolve.createResolve;
        }
      });
      Object.defineProperty(exports, "createResultSet", {
        enumerable: true,
        get: function get() {
          return _ResultSet.createResultSet;
        }
      });
      Object.defineProperty(exports, "createReviver", {
        enumerable: true,
        get: function get() {
          return _reviver.createReviver;
        }
      });
      Object.defineProperty(exports, "createRightArithShift", {
        enumerable: true,
        get: function get() {
          return _rightArithShift.createRightArithShift;
        }
      });
      Object.defineProperty(exports, "createRightLogShift", {
        enumerable: true,
        get: function get() {
          return _rightLogShift.createRightLogShift;
        }
      });
      Object.defineProperty(exports, "createRotate", {
        enumerable: true,
        get: function get() {
          return _rotate.createRotate;
        }
      });
      Object.defineProperty(exports, "createRotationMatrix", {
        enumerable: true,
        get: function get() {
          return _rotationMatrix.createRotationMatrix;
        }
      });
      Object.defineProperty(exports, "createRound", {
        enumerable: true,
        get: function get() {
          return _round.createRound;
        }
      });
      Object.defineProperty(exports, "createRow", {
        enumerable: true,
        get: function get() {
          return _row.createRow;
        }
      });
      Object.defineProperty(exports, "createRowTransform", {
        enumerable: true,
        get: function get() {
          return _rowTransform.createRowTransform;
        }
      });
      Object.defineProperty(exports, "createRydberg", {
        enumerable: true,
        get: function get() {
          return _physicalConstants.createRydberg;
        }
      });
      Object.defineProperty(exports, "createSQRT1_2", {
        enumerable: true,
        get: function get() {
          return _constants.createSQRT1_2;
        }
      });
      Object.defineProperty(exports, "createSQRT2", {
        enumerable: true,
        get: function get() {
          return _constants.createSQRT2;
        }
      });
      Object.defineProperty(exports, "createSackurTetrode", {
        enumerable: true,
        get: function get() {
          return _physicalConstants.createSackurTetrode;
        }
      });
      Object.defineProperty(exports, "createSchur", {
        enumerable: true,
        get: function get() {
          return _schur.createSchur;
        }
      });
      Object.defineProperty(exports, "createSec", {
        enumerable: true,
        get: function get() {
          return _sec.createSec;
        }
      });
      Object.defineProperty(exports, "createSech", {
        enumerable: true,
        get: function get() {
          return _sech.createSech;
        }
      });
      Object.defineProperty(exports, "createSecondRadiation", {
        enumerable: true,
        get: function get() {
          return _physicalConstants.createSecondRadiation;
        }
      });
      Object.defineProperty(exports, "createSetCartesian", {
        enumerable: true,
        get: function get() {
          return _setCartesian.createSetCartesian;
        }
      });
      Object.defineProperty(exports, "createSetDifference", {
        enumerable: true,
        get: function get() {
          return _setDifference.createSetDifference;
        }
      });
      Object.defineProperty(exports, "createSetDistinct", {
        enumerable: true,
        get: function get() {
          return _setDistinct.createSetDistinct;
        }
      });
      Object.defineProperty(exports, "createSetIntersect", {
        enumerable: true,
        get: function get() {
          return _setIntersect.createSetIntersect;
        }
      });
      Object.defineProperty(exports, "createSetIsSubset", {
        enumerable: true,
        get: function get() {
          return _setIsSubset.createSetIsSubset;
        }
      });
      Object.defineProperty(exports, "createSetMultiplicity", {
        enumerable: true,
        get: function get() {
          return _setMultiplicity.createSetMultiplicity;
        }
      });
      Object.defineProperty(exports, "createSetPowerset", {
        enumerable: true,
        get: function get() {
          return _setPowerset.createSetPowerset;
        }
      });
      Object.defineProperty(exports, "createSetSize", {
        enumerable: true,
        get: function get() {
          return _setSize.createSetSize;
        }
      });
      Object.defineProperty(exports, "createSetSymDifference", {
        enumerable: true,
        get: function get() {
          return _setSymDifference.createSetSymDifference;
        }
      });
      Object.defineProperty(exports, "createSetUnion", {
        enumerable: true,
        get: function get() {
          return _setUnion.createSetUnion;
        }
      });
      Object.defineProperty(exports, "createSign", {
        enumerable: true,
        get: function get() {
          return _sign.createSign;
        }
      });
      Object.defineProperty(exports, "createSimplify", {
        enumerable: true,
        get: function get() {
          return _simplify.createSimplify;
        }
      });
      Object.defineProperty(exports, "createSimplifyConstant", {
        enumerable: true,
        get: function get() {
          return _simplifyConstant.createSimplifyConstant;
        }
      });
      Object.defineProperty(exports, "createSimplifyCore", {
        enumerable: true,
        get: function get() {
          return _simplifyCore.createSimplifyCore;
        }
      });
      Object.defineProperty(exports, "createSin", {
        enumerable: true,
        get: function get() {
          return _sin.createSin;
        }
      });
      Object.defineProperty(exports, "createSinh", {
        enumerable: true,
        get: function get() {
          return _sinh.createSinh;
        }
      });
      Object.defineProperty(exports, "createSize", {
        enumerable: true,
        get: function get() {
          return _size.createSize;
        }
      });
      Object.defineProperty(exports, "createSlu", {
        enumerable: true,
        get: function get() {
          return _slu.createSlu;
        }
      });
      Object.defineProperty(exports, "createSmaller", {
        enumerable: true,
        get: function get() {
          return _smaller.createSmaller;
        }
      });
      Object.defineProperty(exports, "createSmallerEq", {
        enumerable: true,
        get: function get() {
          return _smallerEq.createSmallerEq;
        }
      });
      Object.defineProperty(exports, "createSolveODE", {
        enumerable: true,
        get: function get() {
          return _solveODE.createSolveODE;
        }
      });
      Object.defineProperty(exports, "createSort", {
        enumerable: true,
        get: function get() {
          return _sort.createSort;
        }
      });
      Object.defineProperty(exports, "createSpaClass", {
        enumerable: true,
        get: function get() {
          return _Spa.createSpaClass;
        }
      });
      Object.defineProperty(exports, "createSparse", {
        enumerable: true,
        get: function get() {
          return _sparse.createSparse;
        }
      });
      Object.defineProperty(exports, "createSparseMatrixClass", {
        enumerable: true,
        get: function get() {
          return _SparseMatrix.createSparseMatrixClass;
        }
      });
      Object.defineProperty(exports, "createSpeedOfLight", {
        enumerable: true,
        get: function get() {
          return _physicalConstants.createSpeedOfLight;
        }
      });
      Object.defineProperty(exports, "createSplitUnit", {
        enumerable: true,
        get: function get() {
          return _splitUnit.createSplitUnit;
        }
      });
      Object.defineProperty(exports, "createSqrt", {
        enumerable: true,
        get: function get() {
          return _sqrt.createSqrt;
        }
      });
      Object.defineProperty(exports, "createSqrtm", {
        enumerable: true,
        get: function get() {
          return _sqrtm.createSqrtm;
        }
      });
      Object.defineProperty(exports, "createSquare", {
        enumerable: true,
        get: function get() {
          return _square.createSquare;
        }
      });
      Object.defineProperty(exports, "createSqueeze", {
        enumerable: true,
        get: function get() {
          return _squeeze.createSqueeze;
        }
      });
      Object.defineProperty(exports, "createStd", {
        enumerable: true,
        get: function get() {
          return _std.createStd;
        }
      });
      Object.defineProperty(exports, "createStdTransform", {
        enumerable: true,
        get: function get() {
          return _stdTransform.createStdTransform;
        }
      });
      Object.defineProperty(exports, "createStefanBoltzmann", {
        enumerable: true,
        get: function get() {
          return _physicalConstants.createStefanBoltzmann;
        }
      });
      Object.defineProperty(exports, "createStirlingS2", {
        enumerable: true,
        get: function get() {
          return _stirlingS.createStirlingS2;
        }
      });
      Object.defineProperty(exports, "createString", {
        enumerable: true,
        get: function get() {
          return _string.createString;
        }
      });
      Object.defineProperty(exports, "createSubset", {
        enumerable: true,
        get: function get() {
          return _subset.createSubset;
        }
      });
      Object.defineProperty(exports, "createSubsetTransform", {
        enumerable: true,
        get: function get() {
          return _subsetTransform.createSubsetTransform;
        }
      });
      Object.defineProperty(exports, "createSubtract", {
        enumerable: true,
        get: function get() {
          return _subtract.createSubtract;
        }
      });
      Object.defineProperty(exports, "createSubtractScalar", {
        enumerable: true,
        get: function get() {
          return _subtractScalar.createSubtractScalar;
        }
      });
      Object.defineProperty(exports, "createSum", {
        enumerable: true,
        get: function get() {
          return _sum.createSum;
        }
      });
      Object.defineProperty(exports, "createSumTransform", {
        enumerable: true,
        get: function get() {
          return _sumTransform.createSumTransform;
        }
      });
      Object.defineProperty(exports, "createSylvester", {
        enumerable: true,
        get: function get() {
          return _sylvester.createSylvester;
        }
      });
      Object.defineProperty(exports, "createSymbolNode", {
        enumerable: true,
        get: function get() {
          return _SymbolNode.createSymbolNode;
        }
      });
      Object.defineProperty(exports, "createSymbolicEqual", {
        enumerable: true,
        get: function get() {
          return _symbolicEqual.createSymbolicEqual;
        }
      });
      Object.defineProperty(exports, "createTan", {
        enumerable: true,
        get: function get() {
          return _tan.createTan;
        }
      });
      Object.defineProperty(exports, "createTanh", {
        enumerable: true,
        get: function get() {
          return _tanh.createTanh;
        }
      });
      Object.defineProperty(exports, "createTau", {
        enumerable: true,
        get: function get() {
          return _constants.createTau;
        }
      });
      Object.defineProperty(exports, "createThomsonCrossSection", {
        enumerable: true,
        get: function get() {
          return _physicalConstants.createThomsonCrossSection;
        }
      });
      Object.defineProperty(exports, "createTo", {
        enumerable: true,
        get: function get() {
          return _to.createTo;
        }
      });
      Object.defineProperty(exports, "createTrace", {
        enumerable: true,
        get: function get() {
          return _trace.createTrace;
        }
      });
      Object.defineProperty(exports, "createTranspose", {
        enumerable: true,
        get: function get() {
          return _transpose.createTranspose;
        }
      });
      Object.defineProperty(exports, "createTrue", {
        enumerable: true,
        get: function get() {
          return _constants.createTrue;
        }
      });
      Object.defineProperty(exports, "createTypeOf", {
        enumerable: true,
        get: function get() {
          return _typeOf.createTypeOf;
        }
      });
      Object.defineProperty(exports, "createTyped", {
        enumerable: true,
        get: function get() {
          return _typed.createTyped;
        }
      });
      Object.defineProperty(exports, "createUnaryMinus", {
        enumerable: true,
        get: function get() {
          return _unaryMinus.createUnaryMinus;
        }
      });
      Object.defineProperty(exports, "createUnaryPlus", {
        enumerable: true,
        get: function get() {
          return _unaryPlus.createUnaryPlus;
        }
      });
      Object.defineProperty(exports, "createUnequal", {
        enumerable: true,
        get: function get() {
          return _unequal.createUnequal;
        }
      });
      Object.defineProperty(exports, "createUnitClass", {
        enumerable: true,
        get: function get() {
          return _Unit.createUnitClass;
        }
      });
      Object.defineProperty(exports, "createUnitFunction", {
        enumerable: true,
        get: function get() {
          return _unit.createUnitFunction;
        }
      });
      Object.defineProperty(exports, "createUppercaseE", {
        enumerable: true,
        get: function get() {
          return _constants.createUppercaseE;
        }
      });
      Object.defineProperty(exports, "createUppercasePi", {
        enumerable: true,
        get: function get() {
          return _constants.createUppercasePi;
        }
      });
      Object.defineProperty(exports, "createUsolve", {
        enumerable: true,
        get: function get() {
          return _usolve.createUsolve;
        }
      });
      Object.defineProperty(exports, "createUsolveAll", {
        enumerable: true,
        get: function get() {
          return _usolveAll.createUsolveAll;
        }
      });
      Object.defineProperty(exports, "createVacuumImpedance", {
        enumerable: true,
        get: function get() {
          return _physicalConstants.createVacuumImpedance;
        }
      });
      Object.defineProperty(exports, "createVariance", {
        enumerable: true,
        get: function get() {
          return _variance.createVariance;
        }
      });
      Object.defineProperty(exports, "createVarianceTransform", {
        enumerable: true,
        get: function get() {
          return _varianceTransform.createVarianceTransform;
        }
      });
      Object.defineProperty(exports, "createVersion", {
        enumerable: true,
        get: function get() {
          return _constants.createVersion;
        }
      });
      Object.defineProperty(exports, "createWeakMixingAngle", {
        enumerable: true,
        get: function get() {
          return _physicalConstants.createWeakMixingAngle;
        }
      });
      Object.defineProperty(exports, "createWienDisplacement", {
        enumerable: true,
        get: function get() {
          return _physicalConstants.createWienDisplacement;
        }
      });
      Object.defineProperty(exports, "createXgcd", {
        enumerable: true,
        get: function get() {
          return _xgcd.createXgcd;
        }
      });
      Object.defineProperty(exports, "createXor", {
        enumerable: true,
        get: function get() {
          return _xor.createXor;
        }
      });
      Object.defineProperty(exports, "createZeros", {
        enumerable: true,
        get: function get() {
          return _zeros.createZeros;
        }
      });
      Object.defineProperty(exports, "createZeta", {
        enumerable: true,
        get: function get() {
          return _zeta.createZeta;
        }
      });
      Object.defineProperty(exports, "createZpk2tf", {
        enumerable: true,
        get: function get() {
          return _zpk2tf.createZpk2tf;
        }
      });
      var _typed = require_typed();
      var _ResultSet = require_ResultSet();
      var _BigNumber = require_BigNumber();
      var _Complex = require_Complex();
      var _Fraction = require_Fraction();
      var _Range = require_Range();
      var _Matrix = require_Matrix();
      var _DenseMatrix = require_DenseMatrix();
      var _clone = require_clone();
      var _isInteger = require_isInteger();
      var _isNegative = require_isNegative();
      var _isNumeric = require_isNumeric();
      var _hasNumericValue = require_hasNumericValue();
      var _isPositive = require_isPositive();
      var _isZero = require_isZero();
      var _isNaN = require_isNaN();
      var _typeOf = require_typeOf();
      var _equalScalar = require_equalScalar();
      var _SparseMatrix = require_SparseMatrix();
      var _number = require_number3();
      var _string = require_string2();
      var _boolean = require_boolean();
      var _bignumber = require_bignumber();
      var _complex = require_complex3();
      var _fraction = require_fraction2();
      var _matrix = require_matrix();
      var _matrixFromFunction = require_matrixFromFunction();
      var _matrixFromRows = require_matrixFromRows();
      var _matrixFromColumns = require_matrixFromColumns();
      var _splitUnit = require_splitUnit();
      var _unaryMinus = require_unaryMinus();
      var _unaryPlus = require_unaryPlus();
      var _abs = require_abs();
      var _apply = require_apply();
      var _addScalar = require_addScalar();
      var _subtractScalar = require_subtractScalar();
      var _cbrt = require_cbrt();
      var _ceil = require_ceil();
      var _cube = require_cube();
      var _exp = require_exp();
      var _expm = require_expm1();
      var _fix = require_fix();
      var _floor = require_floor();
      var _gcd = require_gcd();
      var _lcm = require_lcm();
      var _log = require_log10();
      var _log2 = require_log2();
      var _mod = require_mod();
      var _multiplyScalar = require_multiplyScalar();
      var _multiply = require_multiply();
      var _nthRoot = require_nthRoot();
      var _sign = require_sign();
      var _sqrt = require_sqrt();
      var _square = require_square();
      var _subtract = require_subtract();
      var _xgcd = require_xgcd();
      var _invmod = require_invmod();
      var _dotMultiply = require_dotMultiply();
      var _bitAnd = require_bitAnd();
      var _bitNot = require_bitNot();
      var _bitOr = require_bitOr();
      var _bitXor = require_bitXor();
      var _arg = require_arg();
      var _conj = require_conj();
      var _im = require_im();
      var _re = require_re();
      var _not = require_not();
      var _or = require_or();
      var _xor = require_xor();
      var _concat = require_concat();
      var _column = require_column();
      var _count = require_count();
      var _cross = require_cross();
      var _diag = require_diag();
      var _filter = require_filter();
      var _flatten = require_flatten();
      var _forEach = require_forEach();
      var _getMatrixDataType = require_getMatrixDataType();
      var _identity = require_identity();
      var _kron = require_kron();
      var _map = require_map2();
      var _diff = require_diff();
      var _ones = require_ones();
      var _range = require_range();
      var _reshape2 = require_reshape();
      var _resize2 = require_resize();
      var _rotate = require_rotate();
      var _rotationMatrix = require_rotationMatrix();
      var _row = require_row();
      var _size = require_size();
      var _squeeze = require_squeeze();
      var _subset = require_subset();
      var _transpose = require_transpose();
      var _ctranspose = require_ctranspose();
      var _zeros = require_zeros();
      var _fft = require_fft();
      var _ifft = require_ifft();
      var _solveODE = require_solveODE();
      var _erf = require_erf();
      var _zeta = require_zeta();
      var _mode = require_mode();
      var _prod = require_prod();
      var _format2 = require_format();
      var _bin = require_bin();
      var _oct = require_oct();
      var _hex = require_hex();
      var _print = require_print2();
      var _to = require_to();
      var _isPrime = require_isPrime();
      var _numeric = require_numeric();
      var _divideScalar = require_divideScalar();
      var _pow = require_pow();
      var _round = require_round();
      var _log3 = require_log();
      var _log1p = require_log1p();
      var _nthRoots = require_nthRoots();
      var _dotPow = require_dotPow();
      var _dotDivide = require_dotDivide();
      var _lsolve = require_lsolve();
      var _usolve = require_usolve();
      var _lsolveAll = require_lsolveAll();
      var _usolveAll = require_usolveAll();
      var _leftShift = require_leftShift();
      var _rightArithShift = require_rightArithShift();
      var _rightLogShift = require_rightLogShift();
      var _and = require_and();
      var _compare = require_compare();
      var _compareNatural = require_compareNatural();
      var _compareText = require_compareText();
      var _equal = require_equal();
      var _equalText = require_equalText();
      var _smaller = require_smaller();
      var _smallerEq = require_smallerEq();
      var _larger = require_larger();
      var _largerEq = require_largerEq();
      var _deepEqual = require_deepEqual();
      var _unequal = require_unequal();
      var _partitionSelect = require_partitionSelect();
      var _sort = require_sort();
      var _max = require_max();
      var _min = require_min();
      var _ImmutableDenseMatrix = require_ImmutableDenseMatrix();
      var _MatrixIndex = require_MatrixIndex();
      var _FibonacciHeap = require_FibonacciHeap();
      var _Spa = require_Spa();
      var _Unit = require_Unit();
      var _unit = require_unit();
      var _sparse = require_sparse();
      var _createUnit = require_createUnit();
      var _acos = require_acos();
      var _acosh = require_acosh();
      var _acot = require_acot();
      var _acoth = require_acoth();
      var _acsc = require_acsc();
      var _acsch = require_acsch();
      var _asec = require_asec();
      var _asech = require_asech();
      var _asin = require_asin();
      var _asinh = require_asinh();
      var _atan = require_atan();
      var _atan2 = require_atan2();
      var _atanh = require_atanh();
      var _cos = require_cos();
      var _cosh = require_cosh();
      var _cot = require_cot();
      var _coth = require_coth();
      var _csc = require_csc();
      var _csch = require_csch();
      var _sec = require_sec();
      var _sech = require_sech();
      var _sin = require_sin();
      var _sinh = require_sinh();
      var _tan = require_tan();
      var _tanh = require_tanh();
      var _setCartesian = require_setCartesian();
      var _setDifference = require_setDifference();
      var _setDistinct = require_setDistinct();
      var _setIntersect = require_setIntersect();
      var _setIsSubset = require_setIsSubset();
      var _setMultiplicity = require_setMultiplicity();
      var _setPowerset = require_setPowerset();
      var _setSize = require_setSize();
      var _setSymDifference = require_setSymDifference();
      var _setUnion = require_setUnion();
      var _add = require_add();
      var _hypot = require_hypot();
      var _norm = require_norm();
      var _dot = require_dot();
      var _trace = require_trace();
      var _index = require_function2();
      var _Node = require_Node();
      var _AccessorNode = require_AccessorNode();
      var _ArrayNode = require_ArrayNode();
      var _AssignmentNode = require_AssignmentNode();
      var _BlockNode = require_BlockNode();
      var _ConditionalNode = require_ConditionalNode();
      var _ConstantNode = require_ConstantNode();
      var _FunctionAssignmentNode = require_FunctionAssignmentNode();
      var _IndexNode = require_IndexNode();
      var _ObjectNode = require_ObjectNode();
      var _OperatorNode = require_OperatorNode();
      var _ParenthesisNode = require_ParenthesisNode();
      var _RangeNode = require_RangeNode();
      var _RelationalNode = require_RelationalNode();
      var _SymbolNode = require_SymbolNode();
      var _FunctionNode = require_FunctionNode();
      var _parse = require_parse();
      var _compile = require_compile();
      var _evaluate = require_evaluate();
      var _Parser = require_Parser();
      var _parser = require_parser();
      var _lup = require_lup();
      var _qr = require_qr();
      var _slu = require_slu();
      var _lusolve = require_lusolve();
      var _polynomialRoot = require_polynomialRoot();
      var _Help = require_Help();
      var _Chain = require_Chain();
      var _help = require_help2();
      var _chain = require_chain();
      var _det = require_det2();
      var _inv = require_inv2();
      var _pinv = require_pinv2();
      var _eigs = require_eigs2();
      var _expm2 = require_expm2();
      var _sqrtm = require_sqrtm2();
      var _sylvester = require_sylvester2();
      var _schur = require_schur2();
      var _lyap = require_lyap2();
      var _divide = require_divide2();
      var _distance = require_distance2();
      var _intersect = require_intersect2();
      var _sum = require_sum2();
      var _cumsum = require_cumsum2();
      var _mean = require_mean2();
      var _median = require_median2();
      var _mad = require_mad2();
      var _variance = require_variance2();
      var _quantileSeq = require_quantileSeq2();
      var _std = require_std2();
      var _corr = require_corr2();
      var _combinations = require_combinations3();
      var _combinationsWithRep = require_combinationsWithRep2();
      var _gamma = require_gamma2();
      var _lgamma = require_lgamma2();
      var _factorial = require_factorial2();
      var _kldivergence = require_kldivergence2();
      var _multinomial = require_multinomial2();
      var _permutations = require_permutations2();
      var _pickRandom = require_pickRandom2();
      var _random = require_random2();
      var _randomInt = require_randomInt2();
      var _stirlingS = require_stirlingS22();
      var _bellNumbers = require_bellNumbers2();
      var _catalan = require_catalan2();
      var _composition = require_composition2();
      var _leafCount = require_leafCount2();
      var _simplify = require_simplify2();
      var _simplifyConstant = require_simplifyConstant2();
      var _simplifyCore = require_simplifyCore2();
      var _resolve = require_resolve2();
      var _symbolicEqual = require_symbolicEqual2();
      var _derivative = require_derivative2();
      var _rationalize = require_rationalize2();
      var _zpk2tf = require_zpk2tf2();
      var _freqz = require_freqz2();
      var _reviver = require_reviver();
      var _replacer = require_replacer();
      var _constants = require_constants3();
      var _physicalConstants = require_physicalConstants();
      var _applyTransform = require_apply_transform();
      var _columnTransform = require_column_transform();
      var _filterTransform = require_filter_transform();
      var _forEachTransform = require_forEach_transform();
      var _indexTransform = require_index_transform();
      var _mapTransform = require_map_transform();
      var _maxTransform = require_max_transform();
      var _meanTransform = require_mean_transform();
      var _minTransform = require_min_transform();
      var _rangeTransform = require_range_transform();
      var _rowTransform = require_row_transform();
      var _subsetTransform = require_subset_transform();
      var _concatTransform = require_concat_transform();
      var _diffTransform = require_diff_transform();
      var _stdTransform = require_std_transform();
      var _sumTransform = require_sum_transform();
      var _quantileSeqTransform = require_quantileSeq_transform();
      var _cumsumTransform = require_cumsum_transform();
      var _varianceTransform = require_variance_transform();
      var _printTransform = require_print_transform();
      var _andTransform = require_and_transform();
      var _orTransform = require_or_transform();
      var _bitAndTransform = require_bitAnd_transform();
      var _bitOrTransform = require_bitOr_transform();
    }
  });

  // node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/entry/pureFunctionsAny.generated.js
  var require_pureFunctionsAny_generated = __commonJS({
    "node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/entry/pureFunctionsAny.generated.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.efimovFactor = exports.e = exports.dotPow = exports.dotMultiply = exports.dotDivide = exports.dot = exports.divideScalar = exports.divide = exports.distance = exports.diff = exports.diag = exports.deuteronMass = exports.det = exports.deepEqual = exports.cumsum = exports.cube = exports.ctranspose = exports.csch = exports.csc = exports.cross = exports.createUnit = exports.count = exports.coulomb = exports.coth = exports.cot = exports.cosh = exports.cos = exports.corr = exports.conj = exports.conductanceQuantum = exports.concat = exports.composition = exports.complex = exports.compareText = exports.compareNatural = exports.compare = exports.combinationsWithRep = exports.combinations = exports.column = exports.clone = exports.classicalElectronRadius = exports.ceil = exports.cbrt = exports.catalan = exports["boolean"] = exports.boltzmann = exports.bohrRadius = exports.bohrMagneton = exports.bitXor = exports.bitOr = exports.bitNot = exports.bitAnd = exports.bin = exports.bignumber = exports.bellNumbers = exports.avogadro = exports.atomicMass = exports.atanh = exports.atan2 = exports.atan = exports.asinh = exports.asin = exports.asech = exports.asec = exports.arg = exports.apply = exports.and = exports.addScalar = exports.add = exports.acsch = exports.acsc = exports.acoth = exports.acot = exports.acosh = exports.acos = exports.abs = exports._true = exports._null = exports._false = exports._NaN = exports._Infinity = exports.Unit = exports.SparseMatrix = exports.Spa = exports.SQRT2 = exports.SQRT1_2 = exports.ResultSet = exports.Range = exports.Matrix = exports.LOG2E = exports.LOG10E = exports.LN2 = exports.LN10 = exports.Index = exports.ImmutableDenseMatrix = exports.Fraction = exports.FibonacciHeap = exports.DenseMatrix = exports.Complex = exports.BigNumber = void 0;
      exports.ones = exports.oct = exports.numeric = exports.number = exports.nuclearMagneton = exports.nthRoots = exports.nthRoot = exports.not = exports.norm = exports.neutronMass = exports.multiplyScalar = exports.multiply = exports.multinomial = exports.molarVolume = exports.molarPlanckConstant = exports.molarMassC12 = exports.molarMass = exports.mode = exports.mod = exports.min = exports.median = exports.mean = exports.max = exports.matrixFromRows = exports.matrixFromFunction = exports.matrixFromColumns = exports.matrix = exports.map = exports.magneticFluxQuantum = exports.magneticConstant = exports.mad = exports.lyap = exports.lusolve = exports.lup = exports.lsolveAll = exports.lsolve = exports.loschmidt = exports.log2 = exports.log1p = exports.log10 = exports.log = exports.lgamma = exports.leftShift = exports.lcm = exports.largerEq = exports.larger = exports.kron = exports.klitzing = exports.kldivergence = exports.isZero = exports.isPrime = exports.isPositive = exports.isNumeric = exports.isNegative = exports.isNaN = exports.isInteger = exports.invmod = exports.inverseConductanceQuantum = exports.inv = exports.intersect = exports.index = exports.im = exports.ifft = exports.identity = exports.i = exports.hypot = exports.hex = exports.hasNumericValue = exports.hartreeEnergy = exports.gravity = exports.gravitationConstant = exports.getMatrixDataType = exports.gcd = exports.gasConstant = exports.gamma = exports.freqz = exports.fraction = exports.format = exports.forEach = exports.floor = exports.flatten = exports.fix = exports.firstRadiation = exports.fineStructure = exports.filter = exports.fft = exports.fermiCoupling = exports.faraday = exports.factorial = exports.expm1 = exports.expm = exports.exp = exports.erf = exports.equalText = exports.equalScalar = exports.equal = exports.elementaryCharge = exports.electronMass = exports.electricConstant = exports.eigs = void 0;
      exports.zeta = exports.zeros = exports.xor = exports.xgcd = exports.wienDisplacement = exports.weakMixingAngle = exports.version = exports.variance = exports.vacuumImpedance = exports.usolveAll = exports.usolve = exports.unit = exports.unequal = exports.unaryPlus = exports.unaryMinus = exports.typed = exports.typeOf = exports.transpose = exports.trace = exports.to = exports.thomsonCrossSection = exports.tau = exports.tanh = exports.tan = exports.sylvester = exports.sum = exports.subtractScalar = exports.subtract = exports.subset = exports.string = exports.stirlingS2 = exports.stefanBoltzmann = exports.std = exports.squeeze = exports.square = exports.sqrtm = exports.sqrt = exports.splitUnit = exports.speedOfLight = exports.sparse = exports.sort = exports.solveODE = exports.smallerEq = exports.smaller = exports.slu = exports.size = exports.sinh = exports.sin = exports.sign = exports.setUnion = exports.setSymDifference = exports.setSize = exports.setPowerset = exports.setMultiplicity = exports.setIsSubset = exports.setIntersect = exports.setDistinct = exports.setDifference = exports.setCartesian = exports.secondRadiation = exports.sech = exports.sec = exports.schur = exports.sackurTetrode = exports.rydberg = exports.row = exports.round = exports.rotationMatrix = exports.rotate = exports.rightLogShift = exports.rightArithShift = exports.resize = exports.reshape = exports.replacer = exports.reducedPlanckConstant = exports.re = exports.range = exports.randomInt = exports.random = exports.quantumOfCirculation = exports.quantileSeq = exports.qr = exports.protonMass = exports.prod = exports.print = exports.pow = exports.polynomialRoot = exports.planckTime = exports.planckTemperature = exports.planckMass = exports.planckLength = exports.planckConstant = exports.planckCharge = exports.pinv = exports.pickRandom = exports.pi = exports.phi = exports.permutations = exports.partitionSelect = exports.or = void 0;
      exports.zpk2tf = void 0;
      var _configReadonly = require_configReadonly();
      var _factoriesAny = require_factoriesAny();
      var BigNumber2 = exports.BigNumber = /* @__PURE__ */ (0, _factoriesAny.createBigNumberClass)({
        config: _configReadonly.config
      });
      var Complex3 = exports.Complex = /* @__PURE__ */ (0, _factoriesAny.createComplexClass)({});
      var e = exports.e = /* @__PURE__ */ (0, _factoriesAny.createE)({
        BigNumber: BigNumber2,
        config: _configReadonly.config
      });
      var _false = exports._false = /* @__PURE__ */ (0, _factoriesAny.createFalse)({});
      var fineStructure = exports.fineStructure = /* @__PURE__ */ (0, _factoriesAny.createFineStructure)({
        BigNumber: BigNumber2,
        config: _configReadonly.config
      });
      var Fraction3 = exports.Fraction = /* @__PURE__ */ (0, _factoriesAny.createFractionClass)({});
      var i = exports.i = /* @__PURE__ */ (0, _factoriesAny.createI)({
        Complex: Complex3
      });
      var _Infinity = exports._Infinity = /* @__PURE__ */ (0, _factoriesAny.createInfinity)({
        BigNumber: BigNumber2,
        config: _configReadonly.config
      });
      var LN102 = exports.LN10 = /* @__PURE__ */ (0, _factoriesAny.createLN10)({
        BigNumber: BigNumber2,
        config: _configReadonly.config
      });
      var LOG10E = exports.LOG10E = /* @__PURE__ */ (0, _factoriesAny.createLOG10E)({
        BigNumber: BigNumber2,
        config: _configReadonly.config
      });
      var Matrix2 = exports.Matrix = /* @__PURE__ */ (0, _factoriesAny.createMatrixClass)({});
      var _NaN = exports._NaN = /* @__PURE__ */ (0, _factoriesAny.createNaN)({
        BigNumber: BigNumber2,
        config: _configReadonly.config
      });
      var _null = exports._null = /* @__PURE__ */ (0, _factoriesAny.createNull)({});
      var phi = exports.phi = /* @__PURE__ */ (0, _factoriesAny.createPhi)({
        BigNumber: BigNumber2,
        config: _configReadonly.config
      });
      var Range = exports.Range = /* @__PURE__ */ (0, _factoriesAny.createRangeClass)({});
      var ResultSet = exports.ResultSet = /* @__PURE__ */ (0, _factoriesAny.createResultSet)({});
      var SQRT1_2 = exports.SQRT1_2 = /* @__PURE__ */ (0, _factoriesAny.createSQRT1_2)({
        BigNumber: BigNumber2,
        config: _configReadonly.config
      });
      var sackurTetrode = exports.sackurTetrode = /* @__PURE__ */ (0, _factoriesAny.createSackurTetrode)({
        BigNumber: BigNumber2,
        config: _configReadonly.config
      });
      var tau = exports.tau = /* @__PURE__ */ (0, _factoriesAny.createTau)({
        BigNumber: BigNumber2,
        config: _configReadonly.config
      });
      var _true = exports._true = /* @__PURE__ */ (0, _factoriesAny.createTrue)({});
      var version = exports.version = /* @__PURE__ */ (0, _factoriesAny.createVersion)({});
      var DenseMatrix2 = exports.DenseMatrix = /* @__PURE__ */ (0, _factoriesAny.createDenseMatrixClass)({
        Matrix: Matrix2
      });
      var efimovFactor = exports.efimovFactor = /* @__PURE__ */ (0, _factoriesAny.createEfimovFactor)({
        BigNumber: BigNumber2,
        config: _configReadonly.config
      });
      var LN2 = exports.LN2 = /* @__PURE__ */ (0, _factoriesAny.createLN2)({
        BigNumber: BigNumber2,
        config: _configReadonly.config
      });
      var pi = exports.pi = /* @__PURE__ */ (0, _factoriesAny.createPi)({
        BigNumber: BigNumber2,
        config: _configReadonly.config
      });
      var replacer = exports.replacer = /* @__PURE__ */ (0, _factoriesAny.createReplacer)({});
      var SQRT2 = exports.SQRT2 = /* @__PURE__ */ (0, _factoriesAny.createSQRT2)({
        BigNumber: BigNumber2,
        config: _configReadonly.config
      });
      var typed2 = exports.typed = /* @__PURE__ */ (0, _factoriesAny.createTyped)({
        BigNumber: BigNumber2,
        Complex: Complex3,
        DenseMatrix: DenseMatrix2,
        Fraction: Fraction3
      });
      var unaryPlus = exports.unaryPlus = /* @__PURE__ */ (0, _factoriesAny.createUnaryPlus)({
        BigNumber: BigNumber2,
        config: _configReadonly.config,
        typed: typed2
      });
      var weakMixingAngle = exports.weakMixingAngle = /* @__PURE__ */ (0, _factoriesAny.createWeakMixingAngle)({
        BigNumber: BigNumber2,
        config: _configReadonly.config
      });
      var abs2 = exports.abs = /* @__PURE__ */ (0, _factoriesAny.createAbs)({
        typed: typed2
      });
      var acos2 = exports.acos = /* @__PURE__ */ (0, _factoriesAny.createAcos)({
        Complex: Complex3,
        config: _configReadonly.config,
        typed: typed2
      });
      var acot = exports.acot = /* @__PURE__ */ (0, _factoriesAny.createAcot)({
        BigNumber: BigNumber2,
        typed: typed2
      });
      var acsc = exports.acsc = /* @__PURE__ */ (0, _factoriesAny.createAcsc)({
        BigNumber: BigNumber2,
        Complex: Complex3,
        config: _configReadonly.config,
        typed: typed2
      });
      var addScalar2 = exports.addScalar = /* @__PURE__ */ (0, _factoriesAny.createAddScalar)({
        typed: typed2
      });
      var arg = exports.arg = /* @__PURE__ */ (0, _factoriesAny.createArg)({
        typed: typed2
      });
      var asech = exports.asech = /* @__PURE__ */ (0, _factoriesAny.createAsech)({
        BigNumber: BigNumber2,
        Complex: Complex3,
        config: _configReadonly.config,
        typed: typed2
      });
      var asinh2 = exports.asinh = /* @__PURE__ */ (0, _factoriesAny.createAsinh)({
        typed: typed2
      });
      var atan3 = exports.atan = /* @__PURE__ */ (0, _factoriesAny.createAtan)({
        typed: typed2
      });
      var atanh2 = exports.atanh = /* @__PURE__ */ (0, _factoriesAny.createAtanh)({
        Complex: Complex3,
        config: _configReadonly.config,
        typed: typed2
      });
      var bignumber = exports.bignumber = /* @__PURE__ */ (0, _factoriesAny.createBignumber)({
        BigNumber: BigNumber2,
        typed: typed2
      });
      var bitNot = exports.bitNot = /* @__PURE__ */ (0, _factoriesAny.createBitNot)({
        typed: typed2
      });
      var _boolean = exports["boolean"] = /* @__PURE__ */ (0, _factoriesAny.createBoolean)({
        typed: typed2
      });
      var clone4 = exports.clone = /* @__PURE__ */ (0, _factoriesAny.createClone)({
        typed: typed2
      });
      var combinations = exports.combinations = /* @__PURE__ */ (0, _factoriesAny.createCombinations)({
        typed: typed2
      });
      var complex2 = exports.complex = /* @__PURE__ */ (0, _factoriesAny.createComplex)({
        Complex: Complex3,
        typed: typed2
      });
      var conj2 = exports.conj = /* @__PURE__ */ (0, _factoriesAny.createConj)({
        typed: typed2
      });
      var cos2 = exports.cos = /* @__PURE__ */ (0, _factoriesAny.createCos)({
        typed: typed2
      });
      var cot = exports.cot = /* @__PURE__ */ (0, _factoriesAny.createCot)({
        BigNumber: BigNumber2,
        typed: typed2
      });
      var csc = exports.csc = /* @__PURE__ */ (0, _factoriesAny.createCsc)({
        BigNumber: BigNumber2,
        typed: typed2
      });
      var cube = exports.cube = /* @__PURE__ */ (0, _factoriesAny.createCube)({
        typed: typed2
      });
      var equalScalar2 = exports.equalScalar = /* @__PURE__ */ (0, _factoriesAny.createEqualScalar)({
        config: _configReadonly.config,
        typed: typed2
      });
      var erf = exports.erf = /* @__PURE__ */ (0, _factoriesAny.createErf)({
        typed: typed2
      });
      var exp2 = exports.exp = /* @__PURE__ */ (0, _factoriesAny.createExp)({
        typed: typed2
      });
      var expm13 = exports.expm1 = /* @__PURE__ */ (0, _factoriesAny.createExpm1)({
        Complex: Complex3,
        typed: typed2
      });
      var filter = exports.filter = /* @__PURE__ */ (0, _factoriesAny.createFilter)({
        typed: typed2
      });
      var forEach = exports.forEach = /* @__PURE__ */ (0, _factoriesAny.createForEach)({
        typed: typed2
      });
      var format4 = exports.format = /* @__PURE__ */ (0, _factoriesAny.createFormat)({
        typed: typed2
      });
      var getMatrixDataType = exports.getMatrixDataType = /* @__PURE__ */ (0, _factoriesAny.createGetMatrixDataType)({
        typed: typed2
      });
      var hex = exports.hex = /* @__PURE__ */ (0, _factoriesAny.createHex)({
        format: format4,
        typed: typed2
      });
      var im = exports.im = /* @__PURE__ */ (0, _factoriesAny.createIm)({
        typed: typed2
      });
      var isInteger2 = exports.isInteger = /* @__PURE__ */ (0, _factoriesAny.createIsInteger)({
        typed: typed2
      });
      var isNegative = exports.isNegative = /* @__PURE__ */ (0, _factoriesAny.createIsNegative)({
        typed: typed2
      });
      var isPositive = exports.isPositive = /* @__PURE__ */ (0, _factoriesAny.createIsPositive)({
        typed: typed2
      });
      var isZero = exports.isZero = /* @__PURE__ */ (0, _factoriesAny.createIsZero)({
        typed: typed2
      });
      var LOG2E = exports.LOG2E = /* @__PURE__ */ (0, _factoriesAny.createLOG2E)({
        BigNumber: BigNumber2,
        config: _configReadonly.config
      });
      var lgamma = exports.lgamma = /* @__PURE__ */ (0, _factoriesAny.createLgamma)({
        Complex: Complex3,
        typed: typed2
      });
      var log104 = exports.log10 = /* @__PURE__ */ (0, _factoriesAny.createLog10)({
        Complex: Complex3,
        config: _configReadonly.config,
        typed: typed2
      });
      var log24 = exports.log2 = /* @__PURE__ */ (0, _factoriesAny.createLog2)({
        Complex: Complex3,
        config: _configReadonly.config,
        typed: typed2
      });
      var map = exports.map = /* @__PURE__ */ (0, _factoriesAny.createMap)({
        typed: typed2
      });
      var multiplyScalar2 = exports.multiplyScalar = /* @__PURE__ */ (0, _factoriesAny.createMultiplyScalar)({
        typed: typed2
      });
      var not = exports.not = /* @__PURE__ */ (0, _factoriesAny.createNot)({
        typed: typed2
      });
      var number = exports.number = /* @__PURE__ */ (0, _factoriesAny.createNumber)({
        typed: typed2
      });
      var oct = exports.oct = /* @__PURE__ */ (0, _factoriesAny.createOct)({
        format: format4,
        typed: typed2
      });
      var pickRandom = exports.pickRandom = /* @__PURE__ */ (0, _factoriesAny.createPickRandom)({
        config: _configReadonly.config,
        typed: typed2
      });
      var print = exports.print = /* @__PURE__ */ (0, _factoriesAny.createPrint)({
        typed: typed2
      });
      var random2 = exports.random = /* @__PURE__ */ (0, _factoriesAny.createRandom)({
        config: _configReadonly.config,
        typed: typed2
      });
      var re = exports.re = /* @__PURE__ */ (0, _factoriesAny.createRe)({
        typed: typed2
      });
      var sec = exports.sec = /* @__PURE__ */ (0, _factoriesAny.createSec)({
        BigNumber: BigNumber2,
        typed: typed2
      });
      var sign3 = exports.sign = /* @__PURE__ */ (0, _factoriesAny.createSign)({
        BigNumber: BigNumber2,
        Fraction: Fraction3,
        complex: complex2,
        typed: typed2
      });
      var sin2 = exports.sin = /* @__PURE__ */ (0, _factoriesAny.createSin)({
        typed: typed2
      });
      var SparseMatrix2 = exports.SparseMatrix = /* @__PURE__ */ (0, _factoriesAny.createSparseMatrixClass)({
        Matrix: Matrix2,
        equalScalar: equalScalar2,
        typed: typed2
      });
      var splitUnit = exports.splitUnit = /* @__PURE__ */ (0, _factoriesAny.createSplitUnit)({
        typed: typed2
      });
      var square = exports.square = /* @__PURE__ */ (0, _factoriesAny.createSquare)({
        typed: typed2
      });
      var string = exports.string = /* @__PURE__ */ (0, _factoriesAny.createString)({
        typed: typed2
      });
      var subtractScalar = exports.subtractScalar = /* @__PURE__ */ (0, _factoriesAny.createSubtractScalar)({
        typed: typed2
      });
      var tan2 = exports.tan = /* @__PURE__ */ (0, _factoriesAny.createTan)({
        typed: typed2
      });
      var typeOf2 = exports.typeOf = /* @__PURE__ */ (0, _factoriesAny.createTypeOf)({
        typed: typed2
      });
      var acosh2 = exports.acosh = /* @__PURE__ */ (0, _factoriesAny.createAcosh)({
        Complex: Complex3,
        config: _configReadonly.config,
        typed: typed2
      });
      var acsch = exports.acsch = /* @__PURE__ */ (0, _factoriesAny.createAcsch)({
        BigNumber: BigNumber2,
        typed: typed2
      });
      var apply = exports.apply = /* @__PURE__ */ (0, _factoriesAny.createApply)({
        isInteger: isInteger2,
        typed: typed2
      });
      var asec = exports.asec = /* @__PURE__ */ (0, _factoriesAny.createAsec)({
        BigNumber: BigNumber2,
        Complex: Complex3,
        config: _configReadonly.config,
        typed: typed2
      });
      var bin = exports.bin = /* @__PURE__ */ (0, _factoriesAny.createBin)({
        format: format4,
        typed: typed2
      });
      var combinationsWithRep = exports.combinationsWithRep = /* @__PURE__ */ (0, _factoriesAny.createCombinationsWithRep)({
        typed: typed2
      });
      var cosh3 = exports.cosh = /* @__PURE__ */ (0, _factoriesAny.createCosh)({
        typed: typed2
      });
      var csch = exports.csch = /* @__PURE__ */ (0, _factoriesAny.createCsch)({
        BigNumber: BigNumber2,
        typed: typed2
      });
      var isNaN2 = exports.isNaN = /* @__PURE__ */ (0, _factoriesAny.createIsNaN)({
        typed: typed2
      });
      var isPrime = exports.isPrime = /* @__PURE__ */ (0, _factoriesAny.createIsPrime)({
        typed: typed2
      });
      var randomInt = exports.randomInt = /* @__PURE__ */ (0, _factoriesAny.createRandomInt)({
        config: _configReadonly.config,
        typed: typed2
      });
      var sech = exports.sech = /* @__PURE__ */ (0, _factoriesAny.createSech)({
        BigNumber: BigNumber2,
        typed: typed2
      });
      var sinh3 = exports.sinh = /* @__PURE__ */ (0, _factoriesAny.createSinh)({
        typed: typed2
      });
      var sparse = exports.sparse = /* @__PURE__ */ (0, _factoriesAny.createSparse)({
        SparseMatrix: SparseMatrix2,
        typed: typed2
      });
      var sqrt2 = exports.sqrt = /* @__PURE__ */ (0, _factoriesAny.createSqrt)({
        Complex: Complex3,
        config: _configReadonly.config,
        typed: typed2
      });
      var tanh2 = exports.tanh = /* @__PURE__ */ (0, _factoriesAny.createTanh)({
        typed: typed2
      });
      var unaryMinus = exports.unaryMinus = /* @__PURE__ */ (0, _factoriesAny.createUnaryMinus)({
        typed: typed2
      });
      var acoth = exports.acoth = /* @__PURE__ */ (0, _factoriesAny.createAcoth)({
        BigNumber: BigNumber2,
        Complex: Complex3,
        config: _configReadonly.config,
        typed: typed2
      });
      var coth = exports.coth = /* @__PURE__ */ (0, _factoriesAny.createCoth)({
        BigNumber: BigNumber2,
        typed: typed2
      });
      var fraction = exports.fraction = /* @__PURE__ */ (0, _factoriesAny.createFraction)({
        Fraction: Fraction3,
        typed: typed2
      });
      var isNumeric = exports.isNumeric = /* @__PURE__ */ (0, _factoriesAny.createIsNumeric)({
        typed: typed2
      });
      var matrix2 = exports.matrix = /* @__PURE__ */ (0, _factoriesAny.createMatrix)({
        DenseMatrix: DenseMatrix2,
        Matrix: Matrix2,
        SparseMatrix: SparseMatrix2,
        typed: typed2
      });
      var matrixFromFunction = exports.matrixFromFunction = /* @__PURE__ */ (0, _factoriesAny.createMatrixFromFunction)({
        isZero,
        matrix: matrix2,
        typed: typed2
      });
      var mode = exports.mode = /* @__PURE__ */ (0, _factoriesAny.createMode)({
        isNaN: isNaN2,
        isNumeric,
        typed: typed2
      });
      var numeric = exports.numeric = /* @__PURE__ */ (0, _factoriesAny.createNumeric)({
        bignumber,
        fraction,
        number
      });
      var prod = exports.prod = /* @__PURE__ */ (0, _factoriesAny.createProd)({
        config: _configReadonly.config,
        multiplyScalar: multiplyScalar2,
        numeric,
        typed: typed2
      });
      var reshape2 = exports.reshape = /* @__PURE__ */ (0, _factoriesAny.createReshape)({
        isInteger: isInteger2,
        matrix: matrix2,
        typed: typed2
      });
      var size2 = exports.size = /* @__PURE__ */ (0, _factoriesAny.createSize)({
        matrix: matrix2,
        config: _configReadonly.config,
        typed: typed2
      });
      var squeeze = exports.squeeze = /* @__PURE__ */ (0, _factoriesAny.createSqueeze)({
        matrix: matrix2,
        typed: typed2
      });
      var transpose = exports.transpose = /* @__PURE__ */ (0, _factoriesAny.createTranspose)({
        matrix: matrix2,
        typed: typed2
      });
      var xgcd = exports.xgcd = /* @__PURE__ */ (0, _factoriesAny.createXgcd)({
        BigNumber: BigNumber2,
        config: _configReadonly.config,
        matrix: matrix2,
        typed: typed2
      });
      var zeros2 = exports.zeros = /* @__PURE__ */ (0, _factoriesAny.createZeros)({
        BigNumber: BigNumber2,
        config: _configReadonly.config,
        matrix: matrix2,
        typed: typed2
      });
      var asin2 = exports.asin = /* @__PURE__ */ (0, _factoriesAny.createAsin)({
        Complex: Complex3,
        config: _configReadonly.config,
        typed: typed2
      });
      var cbrt4 = exports.cbrt = /* @__PURE__ */ (0, _factoriesAny.createCbrt)({
        BigNumber: BigNumber2,
        Complex: Complex3,
        Fraction: Fraction3,
        config: _configReadonly.config,
        isNegative,
        matrix: matrix2,
        typed: typed2,
        unaryMinus
      });
      var concat2 = exports.concat = /* @__PURE__ */ (0, _factoriesAny.createConcat)({
        isInteger: isInteger2,
        matrix: matrix2,
        typed: typed2
      });
      var count = exports.count = /* @__PURE__ */ (0, _factoriesAny.createCount)({
        prod,
        size: size2,
        typed: typed2
      });
      var ctranspose = exports.ctranspose = /* @__PURE__ */ (0, _factoriesAny.createCtranspose)({
        conj: conj2,
        transpose,
        typed: typed2
      });
      var diag = exports.diag = /* @__PURE__ */ (0, _factoriesAny.createDiag)({
        DenseMatrix: DenseMatrix2,
        SparseMatrix: SparseMatrix2,
        matrix: matrix2,
        typed: typed2
      });
      var divideScalar = exports.divideScalar = /* @__PURE__ */ (0, _factoriesAny.createDivideScalar)({
        numeric,
        typed: typed2
      });
      var dotDivide = exports.dotDivide = /* @__PURE__ */ (0, _factoriesAny.createDotDivide)({
        DenseMatrix: DenseMatrix2,
        concat: concat2,
        divideScalar,
        equalScalar: equalScalar2,
        matrix: matrix2,
        typed: typed2
      });
      var equal = exports.equal = /* @__PURE__ */ (0, _factoriesAny.createEqual)({
        DenseMatrix: DenseMatrix2,
        concat: concat2,
        equalScalar: equalScalar2,
        matrix: matrix2,
        typed: typed2
      });
      var flatten2 = exports.flatten = /* @__PURE__ */ (0, _factoriesAny.createFlatten)({
        matrix: matrix2,
        typed: typed2
      });
      var hasNumericValue = exports.hasNumericValue = /* @__PURE__ */ (0, _factoriesAny.createHasNumericValue)({
        isNumeric,
        typed: typed2
      });
      var identity = exports.identity = /* @__PURE__ */ (0, _factoriesAny.createIdentity)({
        BigNumber: BigNumber2,
        DenseMatrix: DenseMatrix2,
        SparseMatrix: SparseMatrix2,
        config: _configReadonly.config,
        matrix: matrix2,
        typed: typed2
      });
      var kron = exports.kron = /* @__PURE__ */ (0, _factoriesAny.createKron)({
        matrix: matrix2,
        multiplyScalar: multiplyScalar2,
        typed: typed2
      });
      var largerEq = exports.largerEq = /* @__PURE__ */ (0, _factoriesAny.createLargerEq)({
        DenseMatrix: DenseMatrix2,
        concat: concat2,
        config: _configReadonly.config,
        matrix: matrix2,
        typed: typed2
      });
      var leftShift = exports.leftShift = /* @__PURE__ */ (0, _factoriesAny.createLeftShift)({
        DenseMatrix: DenseMatrix2,
        concat: concat2,
        equalScalar: equalScalar2,
        matrix: matrix2,
        typed: typed2,
        zeros: zeros2
      });
      var lsolve = exports.lsolve = /* @__PURE__ */ (0, _factoriesAny.createLsolve)({
        DenseMatrix: DenseMatrix2,
        divideScalar,
        equalScalar: equalScalar2,
        matrix: matrix2,
        multiplyScalar: multiplyScalar2,
        subtractScalar,
        typed: typed2
      });
      var matrixFromColumns = exports.matrixFromColumns = /* @__PURE__ */ (0, _factoriesAny.createMatrixFromColumns)({
        flatten: flatten2,
        matrix: matrix2,
        size: size2,
        typed: typed2
      });
      var nthRoot = exports.nthRoot = /* @__PURE__ */ (0, _factoriesAny.createNthRoot)({
        BigNumber: BigNumber2,
        concat: concat2,
        equalScalar: equalScalar2,
        matrix: matrix2,
        typed: typed2
      });
      var ones = exports.ones = /* @__PURE__ */ (0, _factoriesAny.createOnes)({
        BigNumber: BigNumber2,
        config: _configReadonly.config,
        matrix: matrix2,
        typed: typed2
      });
      var qr = exports.qr = /* @__PURE__ */ (0, _factoriesAny.createQr)({
        addScalar: addScalar2,
        complex: complex2,
        conj: conj2,
        divideScalar,
        equal,
        identity,
        isZero,
        matrix: matrix2,
        multiplyScalar: multiplyScalar2,
        sign: sign3,
        sqrt: sqrt2,
        subtractScalar,
        typed: typed2,
        unaryMinus,
        zeros: zeros2
      });
      var resize2 = exports.resize = /* @__PURE__ */ (0, _factoriesAny.createResize)({
        config: _configReadonly.config,
        matrix: matrix2
      });
      var rightArithShift = exports.rightArithShift = /* @__PURE__ */ (0, _factoriesAny.createRightArithShift)({
        DenseMatrix: DenseMatrix2,
        concat: concat2,
        equalScalar: equalScalar2,
        matrix: matrix2,
        typed: typed2,
        zeros: zeros2
      });
      var round2 = exports.round = /* @__PURE__ */ (0, _factoriesAny.createRound)({
        BigNumber: BigNumber2,
        DenseMatrix: DenseMatrix2,
        config: _configReadonly.config,
        equalScalar: equalScalar2,
        matrix: matrix2,
        typed: typed2,
        zeros: zeros2
      });
      var smaller = exports.smaller = /* @__PURE__ */ (0, _factoriesAny.createSmaller)({
        DenseMatrix: DenseMatrix2,
        concat: concat2,
        config: _configReadonly.config,
        matrix: matrix2,
        typed: typed2
      });
      var subtract = exports.subtract = /* @__PURE__ */ (0, _factoriesAny.createSubtract)({
        DenseMatrix: DenseMatrix2,
        concat: concat2,
        equalScalar: equalScalar2,
        matrix: matrix2,
        subtractScalar,
        typed: typed2,
        unaryMinus
      });
      var to = exports.to = /* @__PURE__ */ (0, _factoriesAny.createTo)({
        concat: concat2,
        matrix: matrix2,
        typed: typed2
      });
      var unequal = exports.unequal = /* @__PURE__ */ (0, _factoriesAny.createUnequal)({
        DenseMatrix: DenseMatrix2,
        concat: concat2,
        config: _configReadonly.config,
        equalScalar: equalScalar2,
        matrix: matrix2,
        typed: typed2
      });
      var usolve = exports.usolve = /* @__PURE__ */ (0, _factoriesAny.createUsolve)({
        DenseMatrix: DenseMatrix2,
        divideScalar,
        equalScalar: equalScalar2,
        matrix: matrix2,
        multiplyScalar: multiplyScalar2,
        subtractScalar,
        typed: typed2
      });
      var xor = exports.xor = /* @__PURE__ */ (0, _factoriesAny.createXor)({
        DenseMatrix: DenseMatrix2,
        concat: concat2,
        matrix: matrix2,
        typed: typed2
      });
      var add2 = exports.add = /* @__PURE__ */ (0, _factoriesAny.createAdd)({
        DenseMatrix: DenseMatrix2,
        SparseMatrix: SparseMatrix2,
        addScalar: addScalar2,
        concat: concat2,
        equalScalar: equalScalar2,
        matrix: matrix2,
        typed: typed2
      });
      var atan22 = exports.atan2 = /* @__PURE__ */ (0, _factoriesAny.createAtan2)({
        BigNumber: BigNumber2,
        DenseMatrix: DenseMatrix2,
        concat: concat2,
        equalScalar: equalScalar2,
        matrix: matrix2,
        typed: typed2
      });
      var bitAnd = exports.bitAnd = /* @__PURE__ */ (0, _factoriesAny.createBitAnd)({
        concat: concat2,
        equalScalar: equalScalar2,
        matrix: matrix2,
        typed: typed2
      });
      var bitOr = exports.bitOr = /* @__PURE__ */ (0, _factoriesAny.createBitOr)({
        DenseMatrix: DenseMatrix2,
        concat: concat2,
        equalScalar: equalScalar2,
        matrix: matrix2,
        typed: typed2
      });
      var bitXor = exports.bitXor = /* @__PURE__ */ (0, _factoriesAny.createBitXor)({
        DenseMatrix: DenseMatrix2,
        concat: concat2,
        matrix: matrix2,
        typed: typed2
      });
      var catalan = exports.catalan = /* @__PURE__ */ (0, _factoriesAny.createCatalan)({
        addScalar: addScalar2,
        combinations,
        divideScalar,
        isInteger: isInteger2,
        isNegative,
        multiplyScalar: multiplyScalar2,
        typed: typed2
      });
      var compare = exports.compare = /* @__PURE__ */ (0, _factoriesAny.createCompare)({
        BigNumber: BigNumber2,
        DenseMatrix: DenseMatrix2,
        Fraction: Fraction3,
        concat: concat2,
        config: _configReadonly.config,
        equalScalar: equalScalar2,
        matrix: matrix2,
        typed: typed2
      });
      var compareText = exports.compareText = /* @__PURE__ */ (0, _factoriesAny.createCompareText)({
        concat: concat2,
        matrix: matrix2,
        typed: typed2
      });
      var cumsum = exports.cumsum = /* @__PURE__ */ (0, _factoriesAny.createCumSum)({
        add: add2,
        typed: typed2,
        unaryPlus
      });
      var deepEqual = exports.deepEqual = /* @__PURE__ */ (0, _factoriesAny.createDeepEqual)({
        equal,
        typed: typed2
      });
      var diff = exports.diff = /* @__PURE__ */ (0, _factoriesAny.createDiff)({
        matrix: matrix2,
        number,
        subtract,
        typed: typed2
      });
      var distance = exports.distance = /* @__PURE__ */ (0, _factoriesAny.createDistance)({
        abs: abs2,
        addScalar: addScalar2,
        deepEqual,
        divideScalar,
        multiplyScalar: multiplyScalar2,
        sqrt: sqrt2,
        subtractScalar,
        typed: typed2
      });
      var dot2 = exports.dot = /* @__PURE__ */ (0, _factoriesAny.createDot)({
        addScalar: addScalar2,
        conj: conj2,
        multiplyScalar: multiplyScalar2,
        size: size2,
        typed: typed2
      });
      var equalText = exports.equalText = /* @__PURE__ */ (0, _factoriesAny.createEqualText)({
        compareText,
        isZero,
        typed: typed2
      });
      var floor2 = exports.floor = /* @__PURE__ */ (0, _factoriesAny.createFloor)({
        DenseMatrix: DenseMatrix2,
        config: _configReadonly.config,
        equalScalar: equalScalar2,
        matrix: matrix2,
        round: round2,
        typed: typed2,
        zeros: zeros2
      });
      var gcd = exports.gcd = /* @__PURE__ */ (0, _factoriesAny.createGcd)({
        BigNumber: BigNumber2,
        DenseMatrix: DenseMatrix2,
        concat: concat2,
        config: _configReadonly.config,
        equalScalar: equalScalar2,
        matrix: matrix2,
        round: round2,
        typed: typed2,
        zeros: zeros2
      });
      var hypot3 = exports.hypot = /* @__PURE__ */ (0, _factoriesAny.createHypot)({
        abs: abs2,
        addScalar: addScalar2,
        divideScalar,
        isPositive,
        multiplyScalar: multiplyScalar2,
        smaller,
        sqrt: sqrt2,
        typed: typed2
      });
      var ImmutableDenseMatrix = exports.ImmutableDenseMatrix = /* @__PURE__ */ (0, _factoriesAny.createImmutableDenseMatrixClass)({
        DenseMatrix: DenseMatrix2,
        smaller
      });
      var Index = exports.Index = /* @__PURE__ */ (0, _factoriesAny.createIndexClass)({
        ImmutableDenseMatrix,
        getMatrixDataType
      });
      var larger = exports.larger = /* @__PURE__ */ (0, _factoriesAny.createLarger)({
        DenseMatrix: DenseMatrix2,
        concat: concat2,
        config: _configReadonly.config,
        matrix: matrix2,
        typed: typed2
      });
      var log3 = exports.log = /* @__PURE__ */ (0, _factoriesAny.createLog)({
        Complex: Complex3,
        config: _configReadonly.config,
        divideScalar,
        typed: typed2
      });
      var lsolveAll = exports.lsolveAll = /* @__PURE__ */ (0, _factoriesAny.createLsolveAll)({
        DenseMatrix: DenseMatrix2,
        divideScalar,
        equalScalar: equalScalar2,
        matrix: matrix2,
        multiplyScalar: multiplyScalar2,
        subtractScalar,
        typed: typed2
      });
      var matrixFromRows = exports.matrixFromRows = /* @__PURE__ */ (0, _factoriesAny.createMatrixFromRows)({
        flatten: flatten2,
        matrix: matrix2,
        size: size2,
        typed: typed2
      });
      var min2 = exports.min = /* @__PURE__ */ (0, _factoriesAny.createMin)({
        config: _configReadonly.config,
        numeric,
        smaller,
        typed: typed2
      });
      var mod2 = exports.mod = /* @__PURE__ */ (0, _factoriesAny.createMod)({
        DenseMatrix: DenseMatrix2,
        concat: concat2,
        config: _configReadonly.config,
        equalScalar: equalScalar2,
        matrix: matrix2,
        round: round2,
        typed: typed2,
        zeros: zeros2
      });
      var multiply2 = exports.multiply = /* @__PURE__ */ (0, _factoriesAny.createMultiply)({
        addScalar: addScalar2,
        dot: dot2,
        equalScalar: equalScalar2,
        matrix: matrix2,
        multiplyScalar: multiplyScalar2,
        typed: typed2
      });
      var nthRoots = exports.nthRoots = /* @__PURE__ */ (0, _factoriesAny.createNthRoots)({
        Complex: Complex3,
        config: _configReadonly.config,
        divideScalar,
        typed: typed2
      });
      var or = exports.or = /* @__PURE__ */ (0, _factoriesAny.createOr)({
        DenseMatrix: DenseMatrix2,
        concat: concat2,
        equalScalar: equalScalar2,
        matrix: matrix2,
        typed: typed2
      });
      var partitionSelect = exports.partitionSelect = /* @__PURE__ */ (0, _factoriesAny.createPartitionSelect)({
        compare,
        isNaN: isNaN2,
        isNumeric,
        typed: typed2
      });
      var rightLogShift = exports.rightLogShift = /* @__PURE__ */ (0, _factoriesAny.createRightLogShift)({
        DenseMatrix: DenseMatrix2,
        concat: concat2,
        equalScalar: equalScalar2,
        matrix: matrix2,
        typed: typed2,
        zeros: zeros2
      });
      var slu = exports.slu = /* @__PURE__ */ (0, _factoriesAny.createSlu)({
        SparseMatrix: SparseMatrix2,
        abs: abs2,
        add: add2,
        divideScalar,
        larger,
        largerEq,
        multiply: multiply2,
        subtract,
        transpose,
        typed: typed2
      });
      var subset = exports.subset = /* @__PURE__ */ (0, _factoriesAny.createSubset)({
        add: add2,
        matrix: matrix2,
        typed: typed2,
        zeros: zeros2
      });
      var sum2 = exports.sum = /* @__PURE__ */ (0, _factoriesAny.createSum)({
        add: add2,
        config: _configReadonly.config,
        numeric,
        typed: typed2
      });
      var trace = exports.trace = /* @__PURE__ */ (0, _factoriesAny.createTrace)({
        add: add2,
        matrix: matrix2,
        typed: typed2
      });
      var usolveAll = exports.usolveAll = /* @__PURE__ */ (0, _factoriesAny.createUsolveAll)({
        DenseMatrix: DenseMatrix2,
        divideScalar,
        equalScalar: equalScalar2,
        matrix: matrix2,
        multiplyScalar: multiplyScalar2,
        subtractScalar,
        typed: typed2
      });
      var zpk2tf = exports.zpk2tf = /* @__PURE__ */ (0, _factoriesAny.createZpk2tf)({
        Complex: Complex3,
        add: add2,
        multiply: multiply2,
        number,
        typed: typed2
      });
      var ceil2 = exports.ceil = /* @__PURE__ */ (0, _factoriesAny.createCeil)({
        DenseMatrix: DenseMatrix2,
        config: _configReadonly.config,
        equalScalar: equalScalar2,
        matrix: matrix2,
        round: round2,
        typed: typed2,
        zeros: zeros2
      });
      var compareNatural = exports.compareNatural = /* @__PURE__ */ (0, _factoriesAny.createCompareNatural)({
        compare,
        typed: typed2
      });
      var composition = exports.composition = /* @__PURE__ */ (0, _factoriesAny.createComposition)({
        addScalar: addScalar2,
        combinations,
        isInteger: isInteger2,
        isNegative,
        isPositive,
        larger,
        typed: typed2
      });
      var cross = exports.cross = /* @__PURE__ */ (0, _factoriesAny.createCross)({
        matrix: matrix2,
        multiply: multiply2,
        subtract,
        typed: typed2
      });
      var det = exports.det = /* @__PURE__ */ (0, _factoriesAny.createDet)({
        divideScalar,
        isZero,
        matrix: matrix2,
        multiply: multiply2,
        subtractScalar,
        typed: typed2,
        unaryMinus
      });
      var dotMultiply = exports.dotMultiply = /* @__PURE__ */ (0, _factoriesAny.createDotMultiply)({
        concat: concat2,
        equalScalar: equalScalar2,
        matrix: matrix2,
        multiplyScalar: multiplyScalar2,
        typed: typed2
      });
      var FibonacciHeap = exports.FibonacciHeap = /* @__PURE__ */ (0, _factoriesAny.createFibonacciHeapClass)({
        larger,
        smaller
      });
      var fix = exports.fix = /* @__PURE__ */ (0, _factoriesAny.createFix)({
        Complex: Complex3,
        DenseMatrix: DenseMatrix2,
        ceil: ceil2,
        equalScalar: equalScalar2,
        floor: floor2,
        matrix: matrix2,
        typed: typed2,
        zeros: zeros2
      });
      var index = exports.index = /* @__PURE__ */ (0, _factoriesAny.createIndex)({
        Index,
        typed: typed2
      });
      var intersect = exports.intersect = /* @__PURE__ */ (0, _factoriesAny.createIntersect)({
        abs: abs2,
        add: add2,
        addScalar: addScalar2,
        config: _configReadonly.config,
        divideScalar,
        equalScalar: equalScalar2,
        flatten: flatten2,
        isNumeric,
        isZero,
        matrix: matrix2,
        multiply: multiply2,
        multiplyScalar: multiplyScalar2,
        smaller,
        subtract,
        typed: typed2
      });
      var invmod = exports.invmod = /* @__PURE__ */ (0, _factoriesAny.createInvmod)({
        BigNumber: BigNumber2,
        add: add2,
        config: _configReadonly.config,
        equal,
        isInteger: isInteger2,
        mod: mod2,
        smaller,
        typed: typed2,
        xgcd
      });
      var lcm = exports.lcm = /* @__PURE__ */ (0, _factoriesAny.createLcm)({
        concat: concat2,
        equalScalar: equalScalar2,
        matrix: matrix2,
        typed: typed2
      });
      var log1p2 = exports.log1p = /* @__PURE__ */ (0, _factoriesAny.createLog1p)({
        Complex: Complex3,
        config: _configReadonly.config,
        divideScalar,
        log: log3,
        typed: typed2
      });
      var max2 = exports.max = /* @__PURE__ */ (0, _factoriesAny.createMax)({
        config: _configReadonly.config,
        larger,
        numeric,
        typed: typed2
      });
      var setCartesian = exports.setCartesian = /* @__PURE__ */ (0, _factoriesAny.createSetCartesian)({
        DenseMatrix: DenseMatrix2,
        Index,
        compareNatural,
        size: size2,
        subset,
        typed: typed2
      });
      var setDistinct = exports.setDistinct = /* @__PURE__ */ (0, _factoriesAny.createSetDistinct)({
        DenseMatrix: DenseMatrix2,
        Index,
        compareNatural,
        size: size2,
        subset,
        typed: typed2
      });
      var setIsSubset = exports.setIsSubset = /* @__PURE__ */ (0, _factoriesAny.createSetIsSubset)({
        Index,
        compareNatural,
        size: size2,
        subset,
        typed: typed2
      });
      var setPowerset = exports.setPowerset = /* @__PURE__ */ (0, _factoriesAny.createSetPowerset)({
        Index,
        compareNatural,
        size: size2,
        subset,
        typed: typed2
      });
      var smallerEq = exports.smallerEq = /* @__PURE__ */ (0, _factoriesAny.createSmallerEq)({
        DenseMatrix: DenseMatrix2,
        concat: concat2,
        config: _configReadonly.config,
        matrix: matrix2,
        typed: typed2
      });
      var sort = exports.sort = /* @__PURE__ */ (0, _factoriesAny.createSort)({
        compare,
        compareNatural,
        matrix: matrix2,
        typed: typed2
      });
      var and = exports.and = /* @__PURE__ */ (0, _factoriesAny.createAnd)({
        concat: concat2,
        equalScalar: equalScalar2,
        matrix: matrix2,
        not,
        typed: typed2,
        zeros: zeros2
      });
      var range = exports.range = /* @__PURE__ */ (0, _factoriesAny.createRange)({
        bignumber,
        matrix: matrix2,
        add: add2,
        config: _configReadonly.config,
        isPositive,
        larger,
        largerEq,
        smaller,
        smallerEq,
        typed: typed2
      });
      var row = exports.row = /* @__PURE__ */ (0, _factoriesAny.createRow)({
        Index,
        matrix: matrix2,
        range,
        typed: typed2
      });
      var setDifference = exports.setDifference = /* @__PURE__ */ (0, _factoriesAny.createSetDifference)({
        DenseMatrix: DenseMatrix2,
        Index,
        compareNatural,
        size: size2,
        subset,
        typed: typed2
      });
      var setMultiplicity = exports.setMultiplicity = /* @__PURE__ */ (0, _factoriesAny.createSetMultiplicity)({
        Index,
        compareNatural,
        size: size2,
        subset,
        typed: typed2
      });
      var setSymDifference = exports.setSymDifference = /* @__PURE__ */ (0, _factoriesAny.createSetSymDifference)({
        Index,
        concat: concat2,
        setDifference,
        size: size2,
        subset,
        typed: typed2
      });
      var Spa = exports.Spa = /* @__PURE__ */ (0, _factoriesAny.createSpaClass)({
        FibonacciHeap,
        addScalar: addScalar2,
        equalScalar: equalScalar2
      });
      var column = exports.column = /* @__PURE__ */ (0, _factoriesAny.createColumn)({
        Index,
        matrix: matrix2,
        range,
        typed: typed2
      });
      var inv = exports.inv = /* @__PURE__ */ (0, _factoriesAny.createInv)({
        abs: abs2,
        addScalar: addScalar2,
        det,
        divideScalar,
        identity,
        matrix: matrix2,
        multiply: multiply2,
        typed: typed2,
        unaryMinus
      });
      var lup = exports.lup = /* @__PURE__ */ (0, _factoriesAny.createLup)({
        DenseMatrix: DenseMatrix2,
        Spa,
        SparseMatrix: SparseMatrix2,
        abs: abs2,
        addScalar: addScalar2,
        divideScalar,
        equalScalar: equalScalar2,
        larger,
        matrix: matrix2,
        multiplyScalar: multiplyScalar2,
        subtractScalar,
        typed: typed2,
        unaryMinus
      });
      var pinv = exports.pinv = /* @__PURE__ */ (0, _factoriesAny.createPinv)({
        Complex: Complex3,
        add: add2,
        ctranspose,
        deepEqual,
        divideScalar,
        dot: dot2,
        dotDivide,
        equal,
        inv,
        matrix: matrix2,
        multiply: multiply2,
        typed: typed2
      });
      var pow2 = exports.pow = /* @__PURE__ */ (0, _factoriesAny.createPow)({
        Complex: Complex3,
        config: _configReadonly.config,
        fraction,
        identity,
        inv,
        matrix: matrix2,
        multiply: multiply2,
        number,
        typed: typed2
      });
      var setIntersect = exports.setIntersect = /* @__PURE__ */ (0, _factoriesAny.createSetIntersect)({
        DenseMatrix: DenseMatrix2,
        Index,
        compareNatural,
        size: size2,
        subset,
        typed: typed2
      });
      var setUnion = exports.setUnion = /* @__PURE__ */ (0, _factoriesAny.createSetUnion)({
        Index,
        concat: concat2,
        setIntersect,
        setSymDifference,
        size: size2,
        subset,
        typed: typed2
      });
      var sqrtm = exports.sqrtm = /* @__PURE__ */ (0, _factoriesAny.createSqrtm)({
        abs: abs2,
        add: add2,
        identity,
        inv,
        map,
        max: max2,
        multiply: multiply2,
        size: size2,
        sqrt: sqrt2,
        subtract,
        typed: typed2
      });
      var Unit = exports.Unit = /* @__PURE__ */ (0, _factoriesAny.createUnitClass)({
        BigNumber: BigNumber2,
        Complex: Complex3,
        Fraction: Fraction3,
        abs: abs2,
        addScalar: addScalar2,
        config: _configReadonly.config,
        divideScalar,
        equal,
        fix,
        format: format4,
        isNumeric,
        multiplyScalar: multiplyScalar2,
        number,
        pow: pow2,
        round: round2,
        subtractScalar
      });
      var vacuumImpedance = exports.vacuumImpedance = /* @__PURE__ */ (0, _factoriesAny.createVacuumImpedance)({
        BigNumber: BigNumber2,
        Unit,
        config: _configReadonly.config
      });
      var wienDisplacement = exports.wienDisplacement = /* @__PURE__ */ (0, _factoriesAny.createWienDisplacement)({
        BigNumber: BigNumber2,
        Unit,
        config: _configReadonly.config
      });
      var atomicMass = exports.atomicMass = /* @__PURE__ */ (0, _factoriesAny.createAtomicMass)({
        BigNumber: BigNumber2,
        Unit,
        config: _configReadonly.config
      });
      var bohrMagneton = exports.bohrMagneton = /* @__PURE__ */ (0, _factoriesAny.createBohrMagneton)({
        BigNumber: BigNumber2,
        Unit,
        config: _configReadonly.config
      });
      var boltzmann = exports.boltzmann = /* @__PURE__ */ (0, _factoriesAny.createBoltzmann)({
        BigNumber: BigNumber2,
        Unit,
        config: _configReadonly.config
      });
      var conductanceQuantum = exports.conductanceQuantum = /* @__PURE__ */ (0, _factoriesAny.createConductanceQuantum)({
        BigNumber: BigNumber2,
        Unit,
        config: _configReadonly.config
      });
      var coulomb = exports.coulomb = /* @__PURE__ */ (0, _factoriesAny.createCoulomb)({
        BigNumber: BigNumber2,
        Unit,
        config: _configReadonly.config
      });
      var deuteronMass = exports.deuteronMass = /* @__PURE__ */ (0, _factoriesAny.createDeuteronMass)({
        BigNumber: BigNumber2,
        Unit,
        config: _configReadonly.config
      });
      var dotPow = exports.dotPow = /* @__PURE__ */ (0, _factoriesAny.createDotPow)({
        DenseMatrix: DenseMatrix2,
        concat: concat2,
        equalScalar: equalScalar2,
        matrix: matrix2,
        pow: pow2,
        typed: typed2
      });
      var electricConstant = exports.electricConstant = /* @__PURE__ */ (0, _factoriesAny.createElectricConstant)({
        BigNumber: BigNumber2,
        Unit,
        config: _configReadonly.config
      });
      var elementaryCharge = exports.elementaryCharge = /* @__PURE__ */ (0, _factoriesAny.createElementaryCharge)({
        BigNumber: BigNumber2,
        Unit,
        config: _configReadonly.config
      });
      var expm = exports.expm = /* @__PURE__ */ (0, _factoriesAny.createExpm)({
        abs: abs2,
        add: add2,
        identity,
        inv,
        multiply: multiply2,
        typed: typed2
      });
      var faraday = exports.faraday = /* @__PURE__ */ (0, _factoriesAny.createFaraday)({
        BigNumber: BigNumber2,
        Unit,
        config: _configReadonly.config
      });
      var fft = exports.fft = /* @__PURE__ */ (0, _factoriesAny.createFft)({
        addScalar: addScalar2,
        ceil: ceil2,
        conj: conj2,
        divideScalar,
        dotDivide,
        exp: exp2,
        i,
        log2: log24,
        matrix: matrix2,
        multiplyScalar: multiplyScalar2,
        pow: pow2,
        tau,
        typed: typed2
      });
      var gamma = exports.gamma = /* @__PURE__ */ (0, _factoriesAny.createGamma)({
        BigNumber: BigNumber2,
        Complex: Complex3,
        config: _configReadonly.config,
        multiplyScalar: multiplyScalar2,
        pow: pow2,
        typed: typed2
      });
      var gravitationConstant = exports.gravitationConstant = /* @__PURE__ */ (0, _factoriesAny.createGravitationConstant)({
        BigNumber: BigNumber2,
        Unit,
        config: _configReadonly.config
      });
      var hartreeEnergy = exports.hartreeEnergy = /* @__PURE__ */ (0, _factoriesAny.createHartreeEnergy)({
        BigNumber: BigNumber2,
        Unit,
        config: _configReadonly.config
      });
      var ifft = exports.ifft = /* @__PURE__ */ (0, _factoriesAny.createIfft)({
        conj: conj2,
        dotDivide,
        fft,
        typed: typed2
      });
      var klitzing = exports.klitzing = /* @__PURE__ */ (0, _factoriesAny.createKlitzing)({
        BigNumber: BigNumber2,
        Unit,
        config: _configReadonly.config
      });
      var loschmidt = exports.loschmidt = /* @__PURE__ */ (0, _factoriesAny.createLoschmidt)({
        BigNumber: BigNumber2,
        Unit,
        config: _configReadonly.config
      });
      var magneticConstant = exports.magneticConstant = /* @__PURE__ */ (0, _factoriesAny.createMagneticConstant)({
        BigNumber: BigNumber2,
        Unit,
        config: _configReadonly.config
      });
      var molarMass = exports.molarMass = /* @__PURE__ */ (0, _factoriesAny.createMolarMass)({
        BigNumber: BigNumber2,
        Unit,
        config: _configReadonly.config
      });
      var molarPlanckConstant = exports.molarPlanckConstant = /* @__PURE__ */ (0, _factoriesAny.createMolarPlanckConstant)({
        BigNumber: BigNumber2,
        Unit,
        config: _configReadonly.config
      });
      var neutronMass = exports.neutronMass = /* @__PURE__ */ (0, _factoriesAny.createNeutronMass)({
        BigNumber: BigNumber2,
        Unit,
        config: _configReadonly.config
      });
      var nuclearMagneton = exports.nuclearMagneton = /* @__PURE__ */ (0, _factoriesAny.createNuclearMagneton)({
        BigNumber: BigNumber2,
        Unit,
        config: _configReadonly.config
      });
      var planckCharge = exports.planckCharge = /* @__PURE__ */ (0, _factoriesAny.createPlanckCharge)({
        BigNumber: BigNumber2,
        Unit,
        config: _configReadonly.config
      });
      var planckLength = exports.planckLength = /* @__PURE__ */ (0, _factoriesAny.createPlanckLength)({
        BigNumber: BigNumber2,
        Unit,
        config: _configReadonly.config
      });
      var planckTemperature = exports.planckTemperature = /* @__PURE__ */ (0, _factoriesAny.createPlanckTemperature)({
        BigNumber: BigNumber2,
        Unit,
        config: _configReadonly.config
      });
      var protonMass = exports.protonMass = /* @__PURE__ */ (0, _factoriesAny.createProtonMass)({
        BigNumber: BigNumber2,
        Unit,
        config: _configReadonly.config
      });
      var quantumOfCirculation = exports.quantumOfCirculation = /* @__PURE__ */ (0, _factoriesAny.createQuantumOfCirculation)({
        BigNumber: BigNumber2,
        Unit,
        config: _configReadonly.config
      });
      var reducedPlanckConstant = exports.reducedPlanckConstant = /* @__PURE__ */ (0, _factoriesAny.createReducedPlanckConstant)({
        BigNumber: BigNumber2,
        Unit,
        config: _configReadonly.config
      });
      var rydberg = exports.rydberg = /* @__PURE__ */ (0, _factoriesAny.createRydberg)({
        BigNumber: BigNumber2,
        Unit,
        config: _configReadonly.config
      });
      var secondRadiation = exports.secondRadiation = /* @__PURE__ */ (0, _factoriesAny.createSecondRadiation)({
        BigNumber: BigNumber2,
        Unit,
        config: _configReadonly.config
      });
      var speedOfLight = exports.speedOfLight = /* @__PURE__ */ (0, _factoriesAny.createSpeedOfLight)({
        BigNumber: BigNumber2,
        Unit,
        config: _configReadonly.config
      });
      var stefanBoltzmann = exports.stefanBoltzmann = /* @__PURE__ */ (0, _factoriesAny.createStefanBoltzmann)({
        BigNumber: BigNumber2,
        Unit,
        config: _configReadonly.config
      });
      var thomsonCrossSection = exports.thomsonCrossSection = /* @__PURE__ */ (0, _factoriesAny.createThomsonCrossSection)({
        BigNumber: BigNumber2,
        Unit,
        config: _configReadonly.config
      });
      var avogadro = exports.avogadro = /* @__PURE__ */ (0, _factoriesAny.createAvogadro)({
        BigNumber: BigNumber2,
        Unit,
        config: _configReadonly.config
      });
      var bohrRadius = exports.bohrRadius = /* @__PURE__ */ (0, _factoriesAny.createBohrRadius)({
        BigNumber: BigNumber2,
        Unit,
        config: _configReadonly.config
      });
      var createUnit = exports.createUnit = /* @__PURE__ */ (0, _factoriesAny.createCreateUnit)({
        Unit,
        typed: typed2
      });
      var divide2 = exports.divide = /* @__PURE__ */ (0, _factoriesAny.createDivide)({
        divideScalar,
        equalScalar: equalScalar2,
        inv,
        matrix: matrix2,
        multiply: multiply2,
        typed: typed2
      });
      var electronMass = exports.electronMass = /* @__PURE__ */ (0, _factoriesAny.createElectronMass)({
        BigNumber: BigNumber2,
        Unit,
        config: _configReadonly.config
      });
      var factorial = exports.factorial = /* @__PURE__ */ (0, _factoriesAny.createFactorial)({
        gamma,
        typed: typed2
      });
      var firstRadiation = exports.firstRadiation = /* @__PURE__ */ (0, _factoriesAny.createFirstRadiation)({
        BigNumber: BigNumber2,
        Unit,
        config: _configReadonly.config
      });
      var gravity = exports.gravity = /* @__PURE__ */ (0, _factoriesAny.createGravity)({
        BigNumber: BigNumber2,
        Unit,
        config: _configReadonly.config
      });
      var inverseConductanceQuantum = exports.inverseConductanceQuantum = /* @__PURE__ */ (0, _factoriesAny.createInverseConductanceQuantum)({
        BigNumber: BigNumber2,
        Unit,
        config: _configReadonly.config
      });
      var lusolve = exports.lusolve = /* @__PURE__ */ (0, _factoriesAny.createLusolve)({
        DenseMatrix: DenseMatrix2,
        lsolve,
        lup,
        matrix: matrix2,
        slu,
        typed: typed2,
        usolve
      });
      var magneticFluxQuantum = exports.magneticFluxQuantum = /* @__PURE__ */ (0, _factoriesAny.createMagneticFluxQuantum)({
        BigNumber: BigNumber2,
        Unit,
        config: _configReadonly.config
      });
      var molarMassC12 = exports.molarMassC12 = /* @__PURE__ */ (0, _factoriesAny.createMolarMassC12)({
        BigNumber: BigNumber2,
        Unit,
        config: _configReadonly.config
      });
      var multinomial = exports.multinomial = /* @__PURE__ */ (0, _factoriesAny.createMultinomial)({
        add: add2,
        divide: divide2,
        factorial,
        isInteger: isInteger2,
        isPositive,
        multiply: multiply2,
        typed: typed2
      });
      var permutations = exports.permutations = /* @__PURE__ */ (0, _factoriesAny.createPermutations)({
        factorial,
        typed: typed2
      });
      var planckMass = exports.planckMass = /* @__PURE__ */ (0, _factoriesAny.createPlanckMass)({
        BigNumber: BigNumber2,
        Unit,
        config: _configReadonly.config
      });
      var polynomialRoot = exports.polynomialRoot = /* @__PURE__ */ (0, _factoriesAny.createPolynomialRoot)({
        add: add2,
        cbrt: cbrt4,
        divide: divide2,
        equalScalar: equalScalar2,
        im,
        isZero,
        multiply: multiply2,
        re,
        sqrt: sqrt2,
        subtract,
        typeOf: typeOf2,
        typed: typed2,
        unaryMinus
      });
      var setSize = exports.setSize = /* @__PURE__ */ (0, _factoriesAny.createSetSize)({
        compareNatural,
        typed: typed2
      });
      var solveODE = exports.solveODE = /* @__PURE__ */ (0, _factoriesAny.createSolveODE)({
        abs: abs2,
        add: add2,
        bignumber,
        divide: divide2,
        isNegative,
        isPositive,
        larger,
        map,
        matrix: matrix2,
        max: max2,
        multiply: multiply2,
        smaller,
        subtract,
        typed: typed2,
        unaryMinus
      });
      var stirlingS2 = exports.stirlingS2 = /* @__PURE__ */ (0, _factoriesAny.createStirlingS2)({
        bignumber,
        addScalar: addScalar2,
        combinations,
        divideScalar,
        factorial,
        isInteger: isInteger2,
        isNegative,
        larger,
        multiplyScalar: multiplyScalar2,
        number,
        pow: pow2,
        subtractScalar,
        typed: typed2
      });
      var unit = exports.unit = /* @__PURE__ */ (0, _factoriesAny.createUnitFunction)({
        Unit,
        typed: typed2
      });
      var bellNumbers = exports.bellNumbers = /* @__PURE__ */ (0, _factoriesAny.createBellNumbers)({
        addScalar: addScalar2,
        isInteger: isInteger2,
        isNegative,
        stirlingS2,
        typed: typed2
      });
      var eigs = exports.eigs = /* @__PURE__ */ (0, _factoriesAny.createEigs)({
        abs: abs2,
        add: add2,
        addScalar: addScalar2,
        atan: atan3,
        bignumber,
        column,
        complex: complex2,
        config: _configReadonly.config,
        cos: cos2,
        diag,
        divideScalar,
        dot: dot2,
        equal,
        flatten: flatten2,
        im,
        inv,
        larger,
        matrix: matrix2,
        matrixFromColumns,
        multiply: multiply2,
        multiplyScalar: multiplyScalar2,
        number,
        qr,
        re,
        reshape: reshape2,
        sin: sin2,
        size: size2,
        smaller,
        sqrt: sqrt2,
        subtract,
        typed: typed2,
        usolve,
        usolveAll
      });
      var fermiCoupling = exports.fermiCoupling = /* @__PURE__ */ (0, _factoriesAny.createFermiCoupling)({
        BigNumber: BigNumber2,
        Unit,
        config: _configReadonly.config
      });
      var gasConstant = exports.gasConstant = /* @__PURE__ */ (0, _factoriesAny.createGasConstant)({
        BigNumber: BigNumber2,
        Unit,
        config: _configReadonly.config
      });
      var kldivergence = exports.kldivergence = /* @__PURE__ */ (0, _factoriesAny.createKldivergence)({
        divide: divide2,
        dotDivide,
        isNumeric,
        log: log3,
        map,
        matrix: matrix2,
        multiply: multiply2,
        sum: sum2,
        typed: typed2
      });
      var mean = exports.mean = /* @__PURE__ */ (0, _factoriesAny.createMean)({
        add: add2,
        divide: divide2,
        typed: typed2
      });
      var molarVolume = exports.molarVolume = /* @__PURE__ */ (0, _factoriesAny.createMolarVolume)({
        BigNumber: BigNumber2,
        Unit,
        config: _configReadonly.config
      });
      var planckConstant = exports.planckConstant = /* @__PURE__ */ (0, _factoriesAny.createPlanckConstant)({
        BigNumber: BigNumber2,
        Unit,
        config: _configReadonly.config
      });
      var quantileSeq = exports.quantileSeq = /* @__PURE__ */ (0, _factoriesAny.createQuantileSeq)({
        bignumber,
        add: add2,
        compare,
        divide: divide2,
        isInteger: isInteger2,
        larger,
        multiply: multiply2,
        partitionSelect,
        smaller,
        smallerEq,
        subtract,
        typed: typed2
      });
      var variance = exports.variance = /* @__PURE__ */ (0, _factoriesAny.createVariance)({
        add: add2,
        apply,
        divide: divide2,
        isNaN: isNaN2,
        multiply: multiply2,
        subtract,
        typed: typed2
      });
      var classicalElectronRadius = exports.classicalElectronRadius = /* @__PURE__ */ (0, _factoriesAny.createClassicalElectronRadius)({
        BigNumber: BigNumber2,
        Unit,
        config: _configReadonly.config
      });
      var median = exports.median = /* @__PURE__ */ (0, _factoriesAny.createMedian)({
        add: add2,
        compare,
        divide: divide2,
        partitionSelect,
        typed: typed2
      });
      var corr = exports.corr = /* @__PURE__ */ (0, _factoriesAny.createCorr)({
        add: add2,
        divide: divide2,
        matrix: matrix2,
        mean,
        multiply: multiply2,
        pow: pow2,
        sqrt: sqrt2,
        subtract,
        sum: sum2,
        typed: typed2
      });
      var freqz = exports.freqz = /* @__PURE__ */ (0, _factoriesAny.createFreqz)({
        Complex: Complex3,
        add: add2,
        divide: divide2,
        matrix: matrix2,
        multiply: multiply2,
        typed: typed2
      });
      var mad = exports.mad = /* @__PURE__ */ (0, _factoriesAny.createMad)({
        abs: abs2,
        map,
        median,
        subtract,
        typed: typed2
      });
      var std = exports.std = /* @__PURE__ */ (0, _factoriesAny.createStd)({
        map,
        sqrt: sqrt2,
        typed: typed2,
        variance
      });
      var zeta = exports.zeta = /* @__PURE__ */ (0, _factoriesAny.createZeta)({
        BigNumber: BigNumber2,
        Complex: Complex3,
        add: add2,
        config: _configReadonly.config,
        divide: divide2,
        equal,
        factorial,
        gamma,
        isNegative,
        multiply: multiply2,
        pi,
        pow: pow2,
        sin: sin2,
        smallerEq,
        subtract,
        typed: typed2
      });
      var norm = exports.norm = /* @__PURE__ */ (0, _factoriesAny.createNorm)({
        abs: abs2,
        add: add2,
        conj: conj2,
        ctranspose,
        eigs,
        equalScalar: equalScalar2,
        larger,
        matrix: matrix2,
        multiply: multiply2,
        pow: pow2,
        smaller,
        sqrt: sqrt2,
        typed: typed2
      });
      var rotationMatrix = exports.rotationMatrix = /* @__PURE__ */ (0, _factoriesAny.createRotationMatrix)({
        BigNumber: BigNumber2,
        DenseMatrix: DenseMatrix2,
        SparseMatrix: SparseMatrix2,
        addScalar: addScalar2,
        config: _configReadonly.config,
        cos: cos2,
        matrix: matrix2,
        multiplyScalar: multiplyScalar2,
        norm,
        sin: sin2,
        typed: typed2,
        unaryMinus
      });
      var planckTime = exports.planckTime = /* @__PURE__ */ (0, _factoriesAny.createPlanckTime)({
        BigNumber: BigNumber2,
        Unit,
        config: _configReadonly.config
      });
      var schur = exports.schur = /* @__PURE__ */ (0, _factoriesAny.createSchur)({
        identity,
        matrix: matrix2,
        multiply: multiply2,
        norm,
        qr,
        subtract,
        typed: typed2
      });
      var rotate = exports.rotate = /* @__PURE__ */ (0, _factoriesAny.createRotate)({
        multiply: multiply2,
        rotationMatrix,
        typed: typed2
      });
      var sylvester = exports.sylvester = /* @__PURE__ */ (0, _factoriesAny.createSylvester)({
        abs: abs2,
        add: add2,
        concat: concat2,
        identity,
        index,
        lusolve,
        matrix: matrix2,
        matrixFromColumns,
        multiply: multiply2,
        range,
        schur,
        subset,
        subtract,
        transpose,
        typed: typed2
      });
      var lyap = exports.lyap = /* @__PURE__ */ (0, _factoriesAny.createLyap)({
        matrix: matrix2,
        multiply: multiply2,
        sylvester,
        transpose,
        typed: typed2
      });
    }
  });

  // node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/entry/impureFunctionsAny.generated.js
  var require_impureFunctionsAny_generated = __commonJS({
    "node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/entry/impureFunctionsAny.generated.js"(exports) {
      "use strict";
      var _interopRequireDefault = require_interopRequireDefault();
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.derivative = exports.compile = exports.chain = exports.SymbolNode = exports.RelationalNode = exports.RangeNode = exports.Parser = exports.ParenthesisNode = exports.OperatorNode = exports.ObjectNode = exports.Node = exports.IndexNode = exports.Help = exports.FunctionNode = exports.FunctionAssignmentNode = exports.ConstantNode = exports.ConditionalNode = exports.Chain = exports.BlockNode = exports.AssignmentNode = exports.ArrayNode = exports.AccessorNode = void 0;
      Object.defineProperty(exports, "docs", {
        enumerable: true,
        get: function get() {
          return _embeddedDocs.embeddedDocs;
        }
      });
      exports.symbolicEqual = exports.simplifyCore = exports.simplifyConstant = exports.simplify = exports.reviver = exports.resolve = exports.rationalize = exports.parser = exports.parse = exports.leafCount = exports.help = exports.evaluate = void 0;
      var _extends2 = _interopRequireDefault(require_extends());
      var _configReadonly = require_configReadonly();
      var _factoriesAny = require_factoriesAny();
      var _pureFunctionsAnyGenerated = require_pureFunctionsAny_generated();
      var _embeddedDocs = require_embeddedDocs();
      var math = {};
      var mathWithTransform = {};
      var classes = {};
      var Node = exports.Node = (0, _factoriesAny.createNode)({
        mathWithTransform
      });
      var ObjectNode = exports.ObjectNode = (0, _factoriesAny.createObjectNode)({
        Node
      });
      var OperatorNode = exports.OperatorNode = (0, _factoriesAny.createOperatorNode)({
        Node
      });
      var ParenthesisNode = exports.ParenthesisNode = (0, _factoriesAny.createParenthesisNode)({
        Node
      });
      var RelationalNode = exports.RelationalNode = (0, _factoriesAny.createRelationalNode)({
        Node
      });
      var ArrayNode = exports.ArrayNode = (0, _factoriesAny.createArrayNode)({
        Node
      });
      var BlockNode = exports.BlockNode = (0, _factoriesAny.createBlockNode)({
        Node,
        ResultSet: _pureFunctionsAnyGenerated.ResultSet
      });
      var ConditionalNode = exports.ConditionalNode = (0, _factoriesAny.createConditionalNode)({
        Node
      });
      var ConstantNode = exports.ConstantNode = (0, _factoriesAny.createConstantNode)({
        Node
      });
      var RangeNode = exports.RangeNode = (0, _factoriesAny.createRangeNode)({
        Node
      });
      var reviver = exports.reviver = (0, _factoriesAny.createReviver)({
        classes
      });
      var Chain = exports.Chain = (0, _factoriesAny.createChainClass)({
        math,
        typed: _pureFunctionsAnyGenerated.typed
      });
      var FunctionAssignmentNode = exports.FunctionAssignmentNode = (0, _factoriesAny.createFunctionAssignmentNode)({
        Node,
        typed: _pureFunctionsAnyGenerated.typed
      });
      var chain = exports.chain = (0, _factoriesAny.createChain)({
        Chain,
        typed: _pureFunctionsAnyGenerated.typed
      });
      var IndexNode = exports.IndexNode = (0, _factoriesAny.createIndexNode)({
        Node,
        size: _pureFunctionsAnyGenerated.size
      });
      var AccessorNode = exports.AccessorNode = (0, _factoriesAny.createAccessorNode)({
        Node,
        subset: _pureFunctionsAnyGenerated.subset
      });
      var AssignmentNode = exports.AssignmentNode = (0, _factoriesAny.createAssignmentNode)({
        matrix: _pureFunctionsAnyGenerated.matrix,
        Node,
        subset: _pureFunctionsAnyGenerated.subset
      });
      var SymbolNode = exports.SymbolNode = (0, _factoriesAny.createSymbolNode)({
        Unit: _pureFunctionsAnyGenerated.Unit,
        Node,
        math
      });
      var FunctionNode = exports.FunctionNode = (0, _factoriesAny.createFunctionNode)({
        Node,
        SymbolNode,
        math
      });
      var parse2 = exports.parse = (0, _factoriesAny.createParse)({
        AccessorNode,
        ArrayNode,
        AssignmentNode,
        BlockNode,
        ConditionalNode,
        ConstantNode,
        FunctionAssignmentNode,
        FunctionNode,
        IndexNode,
        ObjectNode,
        OperatorNode,
        ParenthesisNode,
        RangeNode,
        RelationalNode,
        SymbolNode,
        config: _configReadonly.config,
        numeric: _pureFunctionsAnyGenerated.numeric,
        typed: _pureFunctionsAnyGenerated.typed
      });
      var resolve = exports.resolve = (0, _factoriesAny.createResolve)({
        ConstantNode,
        FunctionNode,
        OperatorNode,
        ParenthesisNode,
        parse: parse2,
        typed: _pureFunctionsAnyGenerated.typed
      });
      var simplifyConstant = exports.simplifyConstant = (0, _factoriesAny.createSimplifyConstant)({
        bignumber: _pureFunctionsAnyGenerated.bignumber,
        fraction: _pureFunctionsAnyGenerated.fraction,
        AccessorNode,
        ArrayNode,
        ConstantNode,
        FunctionNode,
        IndexNode,
        ObjectNode,
        OperatorNode,
        SymbolNode,
        config: _configReadonly.config,
        mathWithTransform,
        matrix: _pureFunctionsAnyGenerated.matrix,
        typed: _pureFunctionsAnyGenerated.typed
      });
      var compile = exports.compile = (0, _factoriesAny.createCompile)({
        parse: parse2,
        typed: _pureFunctionsAnyGenerated.typed
      });
      var simplifyCore = exports.simplifyCore = (0, _factoriesAny.createSimplifyCore)({
        AccessorNode,
        ArrayNode,
        ConstantNode,
        FunctionNode,
        IndexNode,
        ObjectNode,
        OperatorNode,
        ParenthesisNode,
        SymbolNode,
        add: _pureFunctionsAnyGenerated.add,
        divide: _pureFunctionsAnyGenerated.divide,
        equal: _pureFunctionsAnyGenerated.equal,
        isZero: _pureFunctionsAnyGenerated.isZero,
        multiply: _pureFunctionsAnyGenerated.multiply,
        parse: parse2,
        pow: _pureFunctionsAnyGenerated.pow,
        subtract: _pureFunctionsAnyGenerated.subtract,
        typed: _pureFunctionsAnyGenerated.typed
      });
      var evaluate = exports.evaluate = (0, _factoriesAny.createEvaluate)({
        parse: parse2,
        typed: _pureFunctionsAnyGenerated.typed
      });
      var Help = exports.Help = (0, _factoriesAny.createHelpClass)({
        evaluate
      });
      var Parser = exports.Parser = (0, _factoriesAny.createParserClass)({
        evaluate
      });
      var simplify = exports.simplify = (0, _factoriesAny.createSimplify)({
        bignumber: _pureFunctionsAnyGenerated.bignumber,
        fraction: _pureFunctionsAnyGenerated.fraction,
        AccessorNode,
        ArrayNode,
        ConstantNode,
        FunctionNode,
        IndexNode,
        ObjectNode,
        OperatorNode,
        ParenthesisNode,
        SymbolNode,
        add: _pureFunctionsAnyGenerated.add,
        config: _configReadonly.config,
        divide: _pureFunctionsAnyGenerated.divide,
        equal: _pureFunctionsAnyGenerated.equal,
        isZero: _pureFunctionsAnyGenerated.isZero,
        mathWithTransform,
        matrix: _pureFunctionsAnyGenerated.matrix,
        multiply: _pureFunctionsAnyGenerated.multiply,
        parse: parse2,
        pow: _pureFunctionsAnyGenerated.pow,
        resolve,
        simplifyConstant,
        simplifyCore,
        subtract: _pureFunctionsAnyGenerated.subtract,
        typed: _pureFunctionsAnyGenerated.typed
      });
      var symbolicEqual = exports.symbolicEqual = (0, _factoriesAny.createSymbolicEqual)({
        OperatorNode,
        parse: parse2,
        simplify,
        typed: _pureFunctionsAnyGenerated.typed
      });
      var leafCount = exports.leafCount = (0, _factoriesAny.createLeafCount)({
        parse: parse2,
        typed: _pureFunctionsAnyGenerated.typed
      });
      var parser = exports.parser = (0, _factoriesAny.createParser)({
        Parser,
        typed: _pureFunctionsAnyGenerated.typed
      });
      var rationalize = exports.rationalize = (0, _factoriesAny.createRationalize)({
        bignumber: _pureFunctionsAnyGenerated.bignumber,
        fraction: _pureFunctionsAnyGenerated.fraction,
        AccessorNode,
        ArrayNode,
        ConstantNode,
        FunctionNode,
        IndexNode,
        ObjectNode,
        OperatorNode,
        ParenthesisNode,
        SymbolNode,
        add: _pureFunctionsAnyGenerated.add,
        config: _configReadonly.config,
        divide: _pureFunctionsAnyGenerated.divide,
        equal: _pureFunctionsAnyGenerated.equal,
        isZero: _pureFunctionsAnyGenerated.isZero,
        mathWithTransform,
        matrix: _pureFunctionsAnyGenerated.matrix,
        multiply: _pureFunctionsAnyGenerated.multiply,
        parse: parse2,
        pow: _pureFunctionsAnyGenerated.pow,
        simplify,
        simplifyConstant,
        simplifyCore,
        subtract: _pureFunctionsAnyGenerated.subtract,
        typed: _pureFunctionsAnyGenerated.typed
      });
      var derivative = exports.derivative = (0, _factoriesAny.createDerivative)({
        ConstantNode,
        FunctionNode,
        OperatorNode,
        ParenthesisNode,
        SymbolNode,
        config: _configReadonly.config,
        equal: _pureFunctionsAnyGenerated.equal,
        isZero: _pureFunctionsAnyGenerated.isZero,
        numeric: _pureFunctionsAnyGenerated.numeric,
        parse: parse2,
        simplify,
        typed: _pureFunctionsAnyGenerated.typed
      });
      var help = exports.help = (0, _factoriesAny.createHelp)({
        Help,
        mathWithTransform,
        typed: _pureFunctionsAnyGenerated.typed
      });
      (0, _extends2["default"])(math, {
        e: _pureFunctionsAnyGenerated.e,
        "false": _pureFunctionsAnyGenerated._false,
        fineStructure: _pureFunctionsAnyGenerated.fineStructure,
        i: _pureFunctionsAnyGenerated.i,
        Infinity: _pureFunctionsAnyGenerated._Infinity,
        LN10: _pureFunctionsAnyGenerated.LN10,
        LOG10E: _pureFunctionsAnyGenerated.LOG10E,
        NaN: _pureFunctionsAnyGenerated._NaN,
        "null": _pureFunctionsAnyGenerated._null,
        phi: _pureFunctionsAnyGenerated.phi,
        SQRT1_2: _pureFunctionsAnyGenerated.SQRT1_2,
        sackurTetrode: _pureFunctionsAnyGenerated.sackurTetrode,
        tau: _pureFunctionsAnyGenerated.tau,
        "true": _pureFunctionsAnyGenerated._true,
        "E": _pureFunctionsAnyGenerated.e,
        version: _pureFunctionsAnyGenerated.version,
        efimovFactor: _pureFunctionsAnyGenerated.efimovFactor,
        LN2: _pureFunctionsAnyGenerated.LN2,
        pi: _pureFunctionsAnyGenerated.pi,
        replacer: _pureFunctionsAnyGenerated.replacer,
        reviver,
        SQRT2: _pureFunctionsAnyGenerated.SQRT2,
        typed: _pureFunctionsAnyGenerated.typed,
        unaryPlus: _pureFunctionsAnyGenerated.unaryPlus,
        "PI": _pureFunctionsAnyGenerated.pi,
        weakMixingAngle: _pureFunctionsAnyGenerated.weakMixingAngle,
        abs: _pureFunctionsAnyGenerated.abs,
        acos: _pureFunctionsAnyGenerated.acos,
        acot: _pureFunctionsAnyGenerated.acot,
        acsc: _pureFunctionsAnyGenerated.acsc,
        addScalar: _pureFunctionsAnyGenerated.addScalar,
        arg: _pureFunctionsAnyGenerated.arg,
        asech: _pureFunctionsAnyGenerated.asech,
        asinh: _pureFunctionsAnyGenerated.asinh,
        atan: _pureFunctionsAnyGenerated.atan,
        atanh: _pureFunctionsAnyGenerated.atanh,
        bignumber: _pureFunctionsAnyGenerated.bignumber,
        bitNot: _pureFunctionsAnyGenerated.bitNot,
        "boolean": _pureFunctionsAnyGenerated["boolean"],
        clone: _pureFunctionsAnyGenerated.clone,
        combinations: _pureFunctionsAnyGenerated.combinations,
        complex: _pureFunctionsAnyGenerated.complex,
        conj: _pureFunctionsAnyGenerated.conj,
        cos: _pureFunctionsAnyGenerated.cos,
        cot: _pureFunctionsAnyGenerated.cot,
        csc: _pureFunctionsAnyGenerated.csc,
        cube: _pureFunctionsAnyGenerated.cube,
        equalScalar: _pureFunctionsAnyGenerated.equalScalar,
        erf: _pureFunctionsAnyGenerated.erf,
        exp: _pureFunctionsAnyGenerated.exp,
        expm1: _pureFunctionsAnyGenerated.expm1,
        filter: _pureFunctionsAnyGenerated.filter,
        forEach: _pureFunctionsAnyGenerated.forEach,
        format: _pureFunctionsAnyGenerated.format,
        getMatrixDataType: _pureFunctionsAnyGenerated.getMatrixDataType,
        hex: _pureFunctionsAnyGenerated.hex,
        im: _pureFunctionsAnyGenerated.im,
        isInteger: _pureFunctionsAnyGenerated.isInteger,
        isNegative: _pureFunctionsAnyGenerated.isNegative,
        isPositive: _pureFunctionsAnyGenerated.isPositive,
        isZero: _pureFunctionsAnyGenerated.isZero,
        LOG2E: _pureFunctionsAnyGenerated.LOG2E,
        lgamma: _pureFunctionsAnyGenerated.lgamma,
        log10: _pureFunctionsAnyGenerated.log10,
        log2: _pureFunctionsAnyGenerated.log2,
        map: _pureFunctionsAnyGenerated.map,
        multiplyScalar: _pureFunctionsAnyGenerated.multiplyScalar,
        not: _pureFunctionsAnyGenerated.not,
        number: _pureFunctionsAnyGenerated.number,
        oct: _pureFunctionsAnyGenerated.oct,
        pickRandom: _pureFunctionsAnyGenerated.pickRandom,
        print: _pureFunctionsAnyGenerated.print,
        random: _pureFunctionsAnyGenerated.random,
        re: _pureFunctionsAnyGenerated.re,
        sec: _pureFunctionsAnyGenerated.sec,
        sign: _pureFunctionsAnyGenerated.sign,
        sin: _pureFunctionsAnyGenerated.sin,
        splitUnit: _pureFunctionsAnyGenerated.splitUnit,
        square: _pureFunctionsAnyGenerated.square,
        string: _pureFunctionsAnyGenerated.string,
        subtractScalar: _pureFunctionsAnyGenerated.subtractScalar,
        tan: _pureFunctionsAnyGenerated.tan,
        typeOf: _pureFunctionsAnyGenerated.typeOf,
        acosh: _pureFunctionsAnyGenerated.acosh,
        acsch: _pureFunctionsAnyGenerated.acsch,
        apply: _pureFunctionsAnyGenerated.apply,
        asec: _pureFunctionsAnyGenerated.asec,
        bin: _pureFunctionsAnyGenerated.bin,
        chain,
        combinationsWithRep: _pureFunctionsAnyGenerated.combinationsWithRep,
        cosh: _pureFunctionsAnyGenerated.cosh,
        csch: _pureFunctionsAnyGenerated.csch,
        isNaN: _pureFunctionsAnyGenerated.isNaN,
        isPrime: _pureFunctionsAnyGenerated.isPrime,
        randomInt: _pureFunctionsAnyGenerated.randomInt,
        sech: _pureFunctionsAnyGenerated.sech,
        sinh: _pureFunctionsAnyGenerated.sinh,
        sparse: _pureFunctionsAnyGenerated.sparse,
        sqrt: _pureFunctionsAnyGenerated.sqrt,
        tanh: _pureFunctionsAnyGenerated.tanh,
        unaryMinus: _pureFunctionsAnyGenerated.unaryMinus,
        acoth: _pureFunctionsAnyGenerated.acoth,
        coth: _pureFunctionsAnyGenerated.coth,
        fraction: _pureFunctionsAnyGenerated.fraction,
        isNumeric: _pureFunctionsAnyGenerated.isNumeric,
        matrix: _pureFunctionsAnyGenerated.matrix,
        matrixFromFunction: _pureFunctionsAnyGenerated.matrixFromFunction,
        mode: _pureFunctionsAnyGenerated.mode,
        numeric: _pureFunctionsAnyGenerated.numeric,
        prod: _pureFunctionsAnyGenerated.prod,
        reshape: _pureFunctionsAnyGenerated.reshape,
        size: _pureFunctionsAnyGenerated.size,
        squeeze: _pureFunctionsAnyGenerated.squeeze,
        transpose: _pureFunctionsAnyGenerated.transpose,
        xgcd: _pureFunctionsAnyGenerated.xgcd,
        zeros: _pureFunctionsAnyGenerated.zeros,
        asin: _pureFunctionsAnyGenerated.asin,
        cbrt: _pureFunctionsAnyGenerated.cbrt,
        concat: _pureFunctionsAnyGenerated.concat,
        count: _pureFunctionsAnyGenerated.count,
        ctranspose: _pureFunctionsAnyGenerated.ctranspose,
        diag: _pureFunctionsAnyGenerated.diag,
        divideScalar: _pureFunctionsAnyGenerated.divideScalar,
        dotDivide: _pureFunctionsAnyGenerated.dotDivide,
        equal: _pureFunctionsAnyGenerated.equal,
        flatten: _pureFunctionsAnyGenerated.flatten,
        hasNumericValue: _pureFunctionsAnyGenerated.hasNumericValue,
        identity: _pureFunctionsAnyGenerated.identity,
        kron: _pureFunctionsAnyGenerated.kron,
        largerEq: _pureFunctionsAnyGenerated.largerEq,
        leftShift: _pureFunctionsAnyGenerated.leftShift,
        lsolve: _pureFunctionsAnyGenerated.lsolve,
        matrixFromColumns: _pureFunctionsAnyGenerated.matrixFromColumns,
        nthRoot: _pureFunctionsAnyGenerated.nthRoot,
        ones: _pureFunctionsAnyGenerated.ones,
        qr: _pureFunctionsAnyGenerated.qr,
        resize: _pureFunctionsAnyGenerated.resize,
        rightArithShift: _pureFunctionsAnyGenerated.rightArithShift,
        round: _pureFunctionsAnyGenerated.round,
        smaller: _pureFunctionsAnyGenerated.smaller,
        subtract: _pureFunctionsAnyGenerated.subtract,
        to: _pureFunctionsAnyGenerated.to,
        unequal: _pureFunctionsAnyGenerated.unequal,
        usolve: _pureFunctionsAnyGenerated.usolve,
        xor: _pureFunctionsAnyGenerated.xor,
        add: _pureFunctionsAnyGenerated.add,
        atan2: _pureFunctionsAnyGenerated.atan2,
        bitAnd: _pureFunctionsAnyGenerated.bitAnd,
        bitOr: _pureFunctionsAnyGenerated.bitOr,
        bitXor: _pureFunctionsAnyGenerated.bitXor,
        catalan: _pureFunctionsAnyGenerated.catalan,
        compare: _pureFunctionsAnyGenerated.compare,
        compareText: _pureFunctionsAnyGenerated.compareText,
        cumsum: _pureFunctionsAnyGenerated.cumsum,
        deepEqual: _pureFunctionsAnyGenerated.deepEqual,
        diff: _pureFunctionsAnyGenerated.diff,
        distance: _pureFunctionsAnyGenerated.distance,
        dot: _pureFunctionsAnyGenerated.dot,
        equalText: _pureFunctionsAnyGenerated.equalText,
        floor: _pureFunctionsAnyGenerated.floor,
        gcd: _pureFunctionsAnyGenerated.gcd,
        hypot: _pureFunctionsAnyGenerated.hypot,
        larger: _pureFunctionsAnyGenerated.larger,
        log: _pureFunctionsAnyGenerated.log,
        lsolveAll: _pureFunctionsAnyGenerated.lsolveAll,
        matrixFromRows: _pureFunctionsAnyGenerated.matrixFromRows,
        min: _pureFunctionsAnyGenerated.min,
        mod: _pureFunctionsAnyGenerated.mod,
        multiply: _pureFunctionsAnyGenerated.multiply,
        nthRoots: _pureFunctionsAnyGenerated.nthRoots,
        or: _pureFunctionsAnyGenerated.or,
        partitionSelect: _pureFunctionsAnyGenerated.partitionSelect,
        rightLogShift: _pureFunctionsAnyGenerated.rightLogShift,
        slu: _pureFunctionsAnyGenerated.slu,
        subset: _pureFunctionsAnyGenerated.subset,
        sum: _pureFunctionsAnyGenerated.sum,
        trace: _pureFunctionsAnyGenerated.trace,
        usolveAll: _pureFunctionsAnyGenerated.usolveAll,
        zpk2tf: _pureFunctionsAnyGenerated.zpk2tf,
        ceil: _pureFunctionsAnyGenerated.ceil,
        compareNatural: _pureFunctionsAnyGenerated.compareNatural,
        composition: _pureFunctionsAnyGenerated.composition,
        cross: _pureFunctionsAnyGenerated.cross,
        det: _pureFunctionsAnyGenerated.det,
        dotMultiply: _pureFunctionsAnyGenerated.dotMultiply,
        fix: _pureFunctionsAnyGenerated.fix,
        index: _pureFunctionsAnyGenerated.index,
        intersect: _pureFunctionsAnyGenerated.intersect,
        invmod: _pureFunctionsAnyGenerated.invmod,
        lcm: _pureFunctionsAnyGenerated.lcm,
        log1p: _pureFunctionsAnyGenerated.log1p,
        max: _pureFunctionsAnyGenerated.max,
        setCartesian: _pureFunctionsAnyGenerated.setCartesian,
        setDistinct: _pureFunctionsAnyGenerated.setDistinct,
        setIsSubset: _pureFunctionsAnyGenerated.setIsSubset,
        setPowerset: _pureFunctionsAnyGenerated.setPowerset,
        smallerEq: _pureFunctionsAnyGenerated.smallerEq,
        sort: _pureFunctionsAnyGenerated.sort,
        and: _pureFunctionsAnyGenerated.and,
        range: _pureFunctionsAnyGenerated.range,
        row: _pureFunctionsAnyGenerated.row,
        setDifference: _pureFunctionsAnyGenerated.setDifference,
        setMultiplicity: _pureFunctionsAnyGenerated.setMultiplicity,
        setSymDifference: _pureFunctionsAnyGenerated.setSymDifference,
        column: _pureFunctionsAnyGenerated.column,
        inv: _pureFunctionsAnyGenerated.inv,
        lup: _pureFunctionsAnyGenerated.lup,
        pinv: _pureFunctionsAnyGenerated.pinv,
        pow: _pureFunctionsAnyGenerated.pow,
        setIntersect: _pureFunctionsAnyGenerated.setIntersect,
        setUnion: _pureFunctionsAnyGenerated.setUnion,
        sqrtm: _pureFunctionsAnyGenerated.sqrtm,
        vacuumImpedance: _pureFunctionsAnyGenerated.vacuumImpedance,
        wienDisplacement: _pureFunctionsAnyGenerated.wienDisplacement,
        atomicMass: _pureFunctionsAnyGenerated.atomicMass,
        bohrMagneton: _pureFunctionsAnyGenerated.bohrMagneton,
        boltzmann: _pureFunctionsAnyGenerated.boltzmann,
        conductanceQuantum: _pureFunctionsAnyGenerated.conductanceQuantum,
        coulomb: _pureFunctionsAnyGenerated.coulomb,
        deuteronMass: _pureFunctionsAnyGenerated.deuteronMass,
        dotPow: _pureFunctionsAnyGenerated.dotPow,
        electricConstant: _pureFunctionsAnyGenerated.electricConstant,
        elementaryCharge: _pureFunctionsAnyGenerated.elementaryCharge,
        expm: _pureFunctionsAnyGenerated.expm,
        faraday: _pureFunctionsAnyGenerated.faraday,
        fft: _pureFunctionsAnyGenerated.fft,
        gamma: _pureFunctionsAnyGenerated.gamma,
        gravitationConstant: _pureFunctionsAnyGenerated.gravitationConstant,
        hartreeEnergy: _pureFunctionsAnyGenerated.hartreeEnergy,
        ifft: _pureFunctionsAnyGenerated.ifft,
        klitzing: _pureFunctionsAnyGenerated.klitzing,
        loschmidt: _pureFunctionsAnyGenerated.loschmidt,
        magneticConstant: _pureFunctionsAnyGenerated.magneticConstant,
        molarMass: _pureFunctionsAnyGenerated.molarMass,
        molarPlanckConstant: _pureFunctionsAnyGenerated.molarPlanckConstant,
        neutronMass: _pureFunctionsAnyGenerated.neutronMass,
        nuclearMagneton: _pureFunctionsAnyGenerated.nuclearMagneton,
        planckCharge: _pureFunctionsAnyGenerated.planckCharge,
        planckLength: _pureFunctionsAnyGenerated.planckLength,
        planckTemperature: _pureFunctionsAnyGenerated.planckTemperature,
        protonMass: _pureFunctionsAnyGenerated.protonMass,
        quantumOfCirculation: _pureFunctionsAnyGenerated.quantumOfCirculation,
        reducedPlanckConstant: _pureFunctionsAnyGenerated.reducedPlanckConstant,
        rydberg: _pureFunctionsAnyGenerated.rydberg,
        secondRadiation: _pureFunctionsAnyGenerated.secondRadiation,
        speedOfLight: _pureFunctionsAnyGenerated.speedOfLight,
        stefanBoltzmann: _pureFunctionsAnyGenerated.stefanBoltzmann,
        thomsonCrossSection: _pureFunctionsAnyGenerated.thomsonCrossSection,
        avogadro: _pureFunctionsAnyGenerated.avogadro,
        bohrRadius: _pureFunctionsAnyGenerated.bohrRadius,
        createUnit: _pureFunctionsAnyGenerated.createUnit,
        divide: _pureFunctionsAnyGenerated.divide,
        electronMass: _pureFunctionsAnyGenerated.electronMass,
        factorial: _pureFunctionsAnyGenerated.factorial,
        firstRadiation: _pureFunctionsAnyGenerated.firstRadiation,
        gravity: _pureFunctionsAnyGenerated.gravity,
        inverseConductanceQuantum: _pureFunctionsAnyGenerated.inverseConductanceQuantum,
        lusolve: _pureFunctionsAnyGenerated.lusolve,
        magneticFluxQuantum: _pureFunctionsAnyGenerated.magneticFluxQuantum,
        molarMassC12: _pureFunctionsAnyGenerated.molarMassC12,
        multinomial: _pureFunctionsAnyGenerated.multinomial,
        parse: parse2,
        permutations: _pureFunctionsAnyGenerated.permutations,
        planckMass: _pureFunctionsAnyGenerated.planckMass,
        polynomialRoot: _pureFunctionsAnyGenerated.polynomialRoot,
        resolve,
        setSize: _pureFunctionsAnyGenerated.setSize,
        simplifyConstant,
        solveODE: _pureFunctionsAnyGenerated.solveODE,
        stirlingS2: _pureFunctionsAnyGenerated.stirlingS2,
        unit: _pureFunctionsAnyGenerated.unit,
        bellNumbers: _pureFunctionsAnyGenerated.bellNumbers,
        compile,
        eigs: _pureFunctionsAnyGenerated.eigs,
        fermiCoupling: _pureFunctionsAnyGenerated.fermiCoupling,
        gasConstant: _pureFunctionsAnyGenerated.gasConstant,
        kldivergence: _pureFunctionsAnyGenerated.kldivergence,
        mean: _pureFunctionsAnyGenerated.mean,
        molarVolume: _pureFunctionsAnyGenerated.molarVolume,
        planckConstant: _pureFunctionsAnyGenerated.planckConstant,
        quantileSeq: _pureFunctionsAnyGenerated.quantileSeq,
        simplifyCore,
        variance: _pureFunctionsAnyGenerated.variance,
        classicalElectronRadius: _pureFunctionsAnyGenerated.classicalElectronRadius,
        evaluate,
        median: _pureFunctionsAnyGenerated.median,
        simplify,
        symbolicEqual,
        corr: _pureFunctionsAnyGenerated.corr,
        freqz: _pureFunctionsAnyGenerated.freqz,
        leafCount,
        mad: _pureFunctionsAnyGenerated.mad,
        parser,
        rationalize,
        std: _pureFunctionsAnyGenerated.std,
        zeta: _pureFunctionsAnyGenerated.zeta,
        derivative,
        norm: _pureFunctionsAnyGenerated.norm,
        rotationMatrix: _pureFunctionsAnyGenerated.rotationMatrix,
        help,
        planckTime: _pureFunctionsAnyGenerated.planckTime,
        schur: _pureFunctionsAnyGenerated.schur,
        rotate: _pureFunctionsAnyGenerated.rotate,
        sylvester: _pureFunctionsAnyGenerated.sylvester,
        lyap: _pureFunctionsAnyGenerated.lyap,
        config: _configReadonly.config
      });
      (0, _extends2["default"])(mathWithTransform, math, {
        filter: (0, _factoriesAny.createFilterTransform)({
          typed: _pureFunctionsAnyGenerated.typed
        }),
        forEach: (0, _factoriesAny.createForEachTransform)({
          typed: _pureFunctionsAnyGenerated.typed
        }),
        map: (0, _factoriesAny.createMapTransform)({
          typed: _pureFunctionsAnyGenerated.typed
        }),
        apply: (0, _factoriesAny.createApplyTransform)({
          isInteger: _pureFunctionsAnyGenerated.isInteger,
          typed: _pureFunctionsAnyGenerated.typed
        }),
        or: (0, _factoriesAny.createOrTransform)({
          DenseMatrix: _pureFunctionsAnyGenerated.DenseMatrix,
          concat: _pureFunctionsAnyGenerated.concat,
          equalScalar: _pureFunctionsAnyGenerated.equalScalar,
          matrix: _pureFunctionsAnyGenerated.matrix,
          typed: _pureFunctionsAnyGenerated.typed
        }),
        and: (0, _factoriesAny.createAndTransform)({
          add: _pureFunctionsAnyGenerated.add,
          concat: _pureFunctionsAnyGenerated.concat,
          equalScalar: _pureFunctionsAnyGenerated.equalScalar,
          matrix: _pureFunctionsAnyGenerated.matrix,
          not: _pureFunctionsAnyGenerated.not,
          typed: _pureFunctionsAnyGenerated.typed,
          zeros: _pureFunctionsAnyGenerated.zeros
        }),
        concat: (0, _factoriesAny.createConcatTransform)({
          isInteger: _pureFunctionsAnyGenerated.isInteger,
          matrix: _pureFunctionsAnyGenerated.matrix,
          typed: _pureFunctionsAnyGenerated.typed
        }),
        max: (0, _factoriesAny.createMaxTransform)({
          config: _configReadonly.config,
          larger: _pureFunctionsAnyGenerated.larger,
          numeric: _pureFunctionsAnyGenerated.numeric,
          typed: _pureFunctionsAnyGenerated.typed
        }),
        print: (0, _factoriesAny.createPrintTransform)({
          add: _pureFunctionsAnyGenerated.add,
          matrix: _pureFunctionsAnyGenerated.matrix,
          typed: _pureFunctionsAnyGenerated.typed,
          zeros: _pureFunctionsAnyGenerated.zeros
        }),
        bitAnd: (0, _factoriesAny.createBitAndTransform)({
          add: _pureFunctionsAnyGenerated.add,
          concat: _pureFunctionsAnyGenerated.concat,
          equalScalar: _pureFunctionsAnyGenerated.equalScalar,
          matrix: _pureFunctionsAnyGenerated.matrix,
          not: _pureFunctionsAnyGenerated.not,
          typed: _pureFunctionsAnyGenerated.typed,
          zeros: _pureFunctionsAnyGenerated.zeros
        }),
        diff: (0, _factoriesAny.createDiffTransform)({
          bignumber: _pureFunctionsAnyGenerated.bignumber,
          matrix: _pureFunctionsAnyGenerated.matrix,
          number: _pureFunctionsAnyGenerated.number,
          subtract: _pureFunctionsAnyGenerated.subtract,
          typed: _pureFunctionsAnyGenerated.typed
        }),
        min: (0, _factoriesAny.createMinTransform)({
          config: _configReadonly.config,
          numeric: _pureFunctionsAnyGenerated.numeric,
          smaller: _pureFunctionsAnyGenerated.smaller,
          typed: _pureFunctionsAnyGenerated.typed
        }),
        subset: (0, _factoriesAny.createSubsetTransform)({
          add: _pureFunctionsAnyGenerated.add,
          matrix: _pureFunctionsAnyGenerated.matrix,
          typed: _pureFunctionsAnyGenerated.typed,
          zeros: _pureFunctionsAnyGenerated.zeros
        }),
        bitOr: (0, _factoriesAny.createBitOrTransform)({
          DenseMatrix: _pureFunctionsAnyGenerated.DenseMatrix,
          concat: _pureFunctionsAnyGenerated.concat,
          equalScalar: _pureFunctionsAnyGenerated.equalScalar,
          matrix: _pureFunctionsAnyGenerated.matrix,
          typed: _pureFunctionsAnyGenerated.typed
        }),
        cumsum: (0, _factoriesAny.createCumSumTransform)({
          add: _pureFunctionsAnyGenerated.add,
          typed: _pureFunctionsAnyGenerated.typed,
          unaryPlus: _pureFunctionsAnyGenerated.unaryPlus
        }),
        index: (0, _factoriesAny.createIndexTransform)({
          Index: _pureFunctionsAnyGenerated.Index,
          getMatrixDataType: _pureFunctionsAnyGenerated.getMatrixDataType
        }),
        sum: (0, _factoriesAny.createSumTransform)({
          add: _pureFunctionsAnyGenerated.add,
          config: _configReadonly.config,
          numeric: _pureFunctionsAnyGenerated.numeric,
          typed: _pureFunctionsAnyGenerated.typed
        }),
        range: (0, _factoriesAny.createRangeTransform)({
          bignumber: _pureFunctionsAnyGenerated.bignumber,
          matrix: _pureFunctionsAnyGenerated.matrix,
          add: _pureFunctionsAnyGenerated.add,
          config: _configReadonly.config,
          isPositive: _pureFunctionsAnyGenerated.isPositive,
          larger: _pureFunctionsAnyGenerated.larger,
          largerEq: _pureFunctionsAnyGenerated.largerEq,
          smaller: _pureFunctionsAnyGenerated.smaller,
          smallerEq: _pureFunctionsAnyGenerated.smallerEq,
          typed: _pureFunctionsAnyGenerated.typed
        }),
        row: (0, _factoriesAny.createRowTransform)({
          Index: _pureFunctionsAnyGenerated.Index,
          matrix: _pureFunctionsAnyGenerated.matrix,
          range: _pureFunctionsAnyGenerated.range,
          typed: _pureFunctionsAnyGenerated.typed
        }),
        column: (0, _factoriesAny.createColumnTransform)({
          Index: _pureFunctionsAnyGenerated.Index,
          matrix: _pureFunctionsAnyGenerated.matrix,
          range: _pureFunctionsAnyGenerated.range,
          typed: _pureFunctionsAnyGenerated.typed
        }),
        mean: (0, _factoriesAny.createMeanTransform)({
          add: _pureFunctionsAnyGenerated.add,
          divide: _pureFunctionsAnyGenerated.divide,
          typed: _pureFunctionsAnyGenerated.typed
        }),
        quantileSeq: (0, _factoriesAny.createQuantileSeqTransform)({
          add: _pureFunctionsAnyGenerated.add,
          bignumber: _pureFunctionsAnyGenerated.bignumber,
          compare: _pureFunctionsAnyGenerated.compare,
          divide: _pureFunctionsAnyGenerated.divide,
          isInteger: _pureFunctionsAnyGenerated.isInteger,
          larger: _pureFunctionsAnyGenerated.larger,
          multiply: _pureFunctionsAnyGenerated.multiply,
          partitionSelect: _pureFunctionsAnyGenerated.partitionSelect,
          smaller: _pureFunctionsAnyGenerated.smaller,
          smallerEq: _pureFunctionsAnyGenerated.smallerEq,
          subtract: _pureFunctionsAnyGenerated.subtract,
          typed: _pureFunctionsAnyGenerated.typed
        }),
        variance: (0, _factoriesAny.createVarianceTransform)({
          add: _pureFunctionsAnyGenerated.add,
          apply: _pureFunctionsAnyGenerated.apply,
          divide: _pureFunctionsAnyGenerated.divide,
          isNaN: _pureFunctionsAnyGenerated.isNaN,
          multiply: _pureFunctionsAnyGenerated.multiply,
          subtract: _pureFunctionsAnyGenerated.subtract,
          typed: _pureFunctionsAnyGenerated.typed
        }),
        std: (0, _factoriesAny.createStdTransform)({
          map: _pureFunctionsAnyGenerated.map,
          sqrt: _pureFunctionsAnyGenerated.sqrt,
          typed: _pureFunctionsAnyGenerated.typed,
          variance: _pureFunctionsAnyGenerated.variance
        })
      });
      (0, _extends2["default"])(classes, {
        BigNumber: _pureFunctionsAnyGenerated.BigNumber,
        Complex: _pureFunctionsAnyGenerated.Complex,
        Fraction: _pureFunctionsAnyGenerated.Fraction,
        Matrix: _pureFunctionsAnyGenerated.Matrix,
        Node,
        ObjectNode,
        OperatorNode,
        ParenthesisNode,
        Range: _pureFunctionsAnyGenerated.Range,
        RelationalNode,
        ResultSet: _pureFunctionsAnyGenerated.ResultSet,
        ArrayNode,
        BlockNode,
        ConditionalNode,
        ConstantNode,
        DenseMatrix: _pureFunctionsAnyGenerated.DenseMatrix,
        RangeNode,
        Chain,
        FunctionAssignmentNode,
        SparseMatrix: _pureFunctionsAnyGenerated.SparseMatrix,
        IndexNode,
        ImmutableDenseMatrix: _pureFunctionsAnyGenerated.ImmutableDenseMatrix,
        Index: _pureFunctionsAnyGenerated.Index,
        AccessorNode,
        AssignmentNode,
        FibonacciHeap: _pureFunctionsAnyGenerated.FibonacciHeap,
        Spa: _pureFunctionsAnyGenerated.Spa,
        Unit: _pureFunctionsAnyGenerated.Unit,
        SymbolNode,
        FunctionNode,
        Help,
        Parser
      });
      Chain.createProxy(math);
    }
  });

  // node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/entry/typeChecks.js
  var require_typeChecks = __commonJS({
    "node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/entry/typeChecks.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      Object.defineProperty(exports, "isAccessorNode", {
        enumerable: true,
        get: function get() {
          return _is.isAccessorNode;
        }
      });
      Object.defineProperty(exports, "isArray", {
        enumerable: true,
        get: function get() {
          return _is.isArray;
        }
      });
      Object.defineProperty(exports, "isArrayNode", {
        enumerable: true,
        get: function get() {
          return _is.isArrayNode;
        }
      });
      Object.defineProperty(exports, "isAssignmentNode", {
        enumerable: true,
        get: function get() {
          return _is.isAssignmentNode;
        }
      });
      Object.defineProperty(exports, "isBigNumber", {
        enumerable: true,
        get: function get() {
          return _is.isBigNumber;
        }
      });
      Object.defineProperty(exports, "isBlockNode", {
        enumerable: true,
        get: function get() {
          return _is.isBlockNode;
        }
      });
      Object.defineProperty(exports, "isBoolean", {
        enumerable: true,
        get: function get() {
          return _is.isBoolean;
        }
      });
      Object.defineProperty(exports, "isChain", {
        enumerable: true,
        get: function get() {
          return _is.isChain;
        }
      });
      Object.defineProperty(exports, "isCollection", {
        enumerable: true,
        get: function get() {
          return _is.isCollection;
        }
      });
      Object.defineProperty(exports, "isComplex", {
        enumerable: true,
        get: function get() {
          return _is.isComplex;
        }
      });
      Object.defineProperty(exports, "isConditionalNode", {
        enumerable: true,
        get: function get() {
          return _is.isConditionalNode;
        }
      });
      Object.defineProperty(exports, "isConstantNode", {
        enumerable: true,
        get: function get() {
          return _is.isConstantNode;
        }
      });
      Object.defineProperty(exports, "isDate", {
        enumerable: true,
        get: function get() {
          return _is.isDate;
        }
      });
      Object.defineProperty(exports, "isDenseMatrix", {
        enumerable: true,
        get: function get() {
          return _is.isDenseMatrix;
        }
      });
      Object.defineProperty(exports, "isFraction", {
        enumerable: true,
        get: function get() {
          return _is.isFraction;
        }
      });
      Object.defineProperty(exports, "isFunction", {
        enumerable: true,
        get: function get() {
          return _is.isFunction;
        }
      });
      Object.defineProperty(exports, "isFunctionAssignmentNode", {
        enumerable: true,
        get: function get() {
          return _is.isFunctionAssignmentNode;
        }
      });
      Object.defineProperty(exports, "isFunctionNode", {
        enumerable: true,
        get: function get() {
          return _is.isFunctionNode;
        }
      });
      Object.defineProperty(exports, "isHelp", {
        enumerable: true,
        get: function get() {
          return _is.isHelp;
        }
      });
      Object.defineProperty(exports, "isIndex", {
        enumerable: true,
        get: function get() {
          return _is.isIndex;
        }
      });
      Object.defineProperty(exports, "isIndexNode", {
        enumerable: true,
        get: function get() {
          return _is.isIndexNode;
        }
      });
      Object.defineProperty(exports, "isMatrix", {
        enumerable: true,
        get: function get() {
          return _is.isMatrix;
        }
      });
      Object.defineProperty(exports, "isNode", {
        enumerable: true,
        get: function get() {
          return _is.isNode;
        }
      });
      Object.defineProperty(exports, "isNull", {
        enumerable: true,
        get: function get() {
          return _is.isNull;
        }
      });
      Object.defineProperty(exports, "isNumber", {
        enumerable: true,
        get: function get() {
          return _is.isNumber;
        }
      });
      Object.defineProperty(exports, "isObject", {
        enumerable: true,
        get: function get() {
          return _is.isObject;
        }
      });
      Object.defineProperty(exports, "isObjectNode", {
        enumerable: true,
        get: function get() {
          return _is.isObjectNode;
        }
      });
      Object.defineProperty(exports, "isOperatorNode", {
        enumerable: true,
        get: function get() {
          return _is.isOperatorNode;
        }
      });
      Object.defineProperty(exports, "isParenthesisNode", {
        enumerable: true,
        get: function get() {
          return _is.isParenthesisNode;
        }
      });
      Object.defineProperty(exports, "isRange", {
        enumerable: true,
        get: function get() {
          return _is.isRange;
        }
      });
      Object.defineProperty(exports, "isRangeNode", {
        enumerable: true,
        get: function get() {
          return _is.isRangeNode;
        }
      });
      Object.defineProperty(exports, "isRegExp", {
        enumerable: true,
        get: function get() {
          return _is.isRegExp;
        }
      });
      Object.defineProperty(exports, "isRelationalNode", {
        enumerable: true,
        get: function get() {
          return _is.isRelationalNode;
        }
      });
      Object.defineProperty(exports, "isResultSet", {
        enumerable: true,
        get: function get() {
          return _is.isResultSet;
        }
      });
      Object.defineProperty(exports, "isSparseMatrix", {
        enumerable: true,
        get: function get() {
          return _is.isSparseMatrix;
        }
      });
      Object.defineProperty(exports, "isString", {
        enumerable: true,
        get: function get() {
          return _is.isString;
        }
      });
      Object.defineProperty(exports, "isSymbolNode", {
        enumerable: true,
        get: function get() {
          return _is.isSymbolNode;
        }
      });
      Object.defineProperty(exports, "isUndefined", {
        enumerable: true,
        get: function get() {
          return _is.isUndefined;
        }
      });
      Object.defineProperty(exports, "isUnit", {
        enumerable: true,
        get: function get() {
          return _is.isUnit;
        }
      });
      var _is = require_is();
    }
  });

  // node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/entry/dependenciesAny/dependenciesBigNumberClass.generated.js
  var require_dependenciesBigNumberClass_generated = __commonJS({
    "node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/entry/dependenciesAny/dependenciesBigNumberClass.generated.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.BigNumberDependencies = void 0;
      var _factoriesAny = require_factoriesAny();
      var BigNumberDependencies = exports.BigNumberDependencies = {
        createBigNumberClass: _factoriesAny.createBigNumberClass
      };
    }
  });

  // node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/entry/dependenciesAny/dependenciesComplexClass.generated.js
  var require_dependenciesComplexClass_generated = __commonJS({
    "node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/entry/dependenciesAny/dependenciesComplexClass.generated.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.ComplexDependencies = void 0;
      var _factoriesAny = require_factoriesAny();
      var ComplexDependencies = exports.ComplexDependencies = {
        createComplexClass: _factoriesAny.createComplexClass
      };
    }
  });

  // node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/entry/dependenciesAny/dependenciesMatrixClass.generated.js
  var require_dependenciesMatrixClass_generated = __commonJS({
    "node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/entry/dependenciesAny/dependenciesMatrixClass.generated.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.MatrixDependencies = void 0;
      var _factoriesAny = require_factoriesAny();
      var MatrixDependencies = exports.MatrixDependencies = {
        createMatrixClass: _factoriesAny.createMatrixClass
      };
    }
  });

  // node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/entry/dependenciesAny/dependenciesDenseMatrixClass.generated.js
  var require_dependenciesDenseMatrixClass_generated = __commonJS({
    "node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/entry/dependenciesAny/dependenciesDenseMatrixClass.generated.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.DenseMatrixDependencies = void 0;
      var _dependenciesMatrixClassGenerated = require_dependenciesMatrixClass_generated();
      var _factoriesAny = require_factoriesAny();
      var DenseMatrixDependencies = exports.DenseMatrixDependencies = {
        MatrixDependencies: _dependenciesMatrixClassGenerated.MatrixDependencies,
        createDenseMatrixClass: _factoriesAny.createDenseMatrixClass
      };
    }
  });

  // node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/entry/dependenciesAny/dependenciesFractionClass.generated.js
  var require_dependenciesFractionClass_generated = __commonJS({
    "node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/entry/dependenciesAny/dependenciesFractionClass.generated.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.FractionDependencies = void 0;
      var _factoriesAny = require_factoriesAny();
      var FractionDependencies = exports.FractionDependencies = {
        createFractionClass: _factoriesAny.createFractionClass
      };
    }
  });

  // node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/entry/dependenciesAny/dependenciesTyped.generated.js
  var require_dependenciesTyped_generated = __commonJS({
    "node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/entry/dependenciesAny/dependenciesTyped.generated.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.typedDependencies = void 0;
      var _dependenciesBigNumberClassGenerated = require_dependenciesBigNumberClass_generated();
      var _dependenciesComplexClassGenerated = require_dependenciesComplexClass_generated();
      var _dependenciesDenseMatrixClassGenerated = require_dependenciesDenseMatrixClass_generated();
      var _dependenciesFractionClassGenerated = require_dependenciesFractionClass_generated();
      var _factoriesAny = require_factoriesAny();
      var typedDependencies = exports.typedDependencies = {
        BigNumberDependencies: _dependenciesBigNumberClassGenerated.BigNumberDependencies,
        ComplexDependencies: _dependenciesComplexClassGenerated.ComplexDependencies,
        DenseMatrixDependencies: _dependenciesDenseMatrixClassGenerated.DenseMatrixDependencies,
        FractionDependencies: _dependenciesFractionClassGenerated.FractionDependencies,
        createTyped: _factoriesAny.createTyped
      };
    }
  });

  // node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/entry/dependenciesAny/dependenciesAbs.generated.js
  var require_dependenciesAbs_generated = __commonJS({
    "node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/entry/dependenciesAny/dependenciesAbs.generated.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.absDependencies = void 0;
      var _dependenciesTypedGenerated = require_dependenciesTyped_generated();
      var _factoriesAny = require_factoriesAny();
      var absDependencies = exports.absDependencies = {
        typedDependencies: _dependenciesTypedGenerated.typedDependencies,
        createAbs: _factoriesAny.createAbs
      };
    }
  });

  // node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/entry/dependenciesAny/dependenciesNode.generated.js
  var require_dependenciesNode_generated = __commonJS({
    "node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/entry/dependenciesAny/dependenciesNode.generated.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.NodeDependencies = void 0;
      var _factoriesAny = require_factoriesAny();
      var NodeDependencies = exports.NodeDependencies = {
        createNode: _factoriesAny.createNode
      };
    }
  });

  // node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/entry/dependenciesAny/dependenciesEqualScalar.generated.js
  var require_dependenciesEqualScalar_generated = __commonJS({
    "node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/entry/dependenciesAny/dependenciesEqualScalar.generated.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.equalScalarDependencies = void 0;
      var _dependenciesTypedGenerated = require_dependenciesTyped_generated();
      var _factoriesAny = require_factoriesAny();
      var equalScalarDependencies = exports.equalScalarDependencies = {
        typedDependencies: _dependenciesTypedGenerated.typedDependencies,
        createEqualScalar: _factoriesAny.createEqualScalar
      };
    }
  });

  // node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/entry/dependenciesAny/dependenciesSparseMatrixClass.generated.js
  var require_dependenciesSparseMatrixClass_generated = __commonJS({
    "node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/entry/dependenciesAny/dependenciesSparseMatrixClass.generated.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.SparseMatrixDependencies = void 0;
      var _dependenciesMatrixClassGenerated = require_dependenciesMatrixClass_generated();
      var _dependenciesEqualScalarGenerated = require_dependenciesEqualScalar_generated();
      var _dependenciesTypedGenerated = require_dependenciesTyped_generated();
      var _factoriesAny = require_factoriesAny();
      var SparseMatrixDependencies = exports.SparseMatrixDependencies = {
        MatrixDependencies: _dependenciesMatrixClassGenerated.MatrixDependencies,
        equalScalarDependencies: _dependenciesEqualScalarGenerated.equalScalarDependencies,
        typedDependencies: _dependenciesTypedGenerated.typedDependencies,
        createSparseMatrixClass: _factoriesAny.createSparseMatrixClass
      };
    }
  });

  // node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/entry/dependenciesAny/dependenciesAddScalar.generated.js
  var require_dependenciesAddScalar_generated = __commonJS({
    "node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/entry/dependenciesAny/dependenciesAddScalar.generated.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.addScalarDependencies = void 0;
      var _dependenciesTypedGenerated = require_dependenciesTyped_generated();
      var _factoriesAny = require_factoriesAny();
      var addScalarDependencies = exports.addScalarDependencies = {
        typedDependencies: _dependenciesTypedGenerated.typedDependencies,
        createAddScalar: _factoriesAny.createAddScalar
      };
    }
  });

  // node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/entry/dependenciesAny/dependenciesIsInteger.generated.js
  var require_dependenciesIsInteger_generated = __commonJS({
    "node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/entry/dependenciesAny/dependenciesIsInteger.generated.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.isIntegerDependencies = void 0;
      var _dependenciesTypedGenerated = require_dependenciesTyped_generated();
      var _factoriesAny = require_factoriesAny();
      var isIntegerDependencies = exports.isIntegerDependencies = {
        typedDependencies: _dependenciesTypedGenerated.typedDependencies,
        createIsInteger: _factoriesAny.createIsInteger
      };
    }
  });

  // node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/entry/dependenciesAny/dependenciesMatrix.generated.js
  var require_dependenciesMatrix_generated = __commonJS({
    "node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/entry/dependenciesAny/dependenciesMatrix.generated.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.matrixDependencies = void 0;
      var _dependenciesDenseMatrixClassGenerated = require_dependenciesDenseMatrixClass_generated();
      var _dependenciesMatrixClassGenerated = require_dependenciesMatrixClass_generated();
      var _dependenciesSparseMatrixClassGenerated = require_dependenciesSparseMatrixClass_generated();
      var _dependenciesTypedGenerated = require_dependenciesTyped_generated();
      var _factoriesAny = require_factoriesAny();
      var matrixDependencies = exports.matrixDependencies = {
        DenseMatrixDependencies: _dependenciesDenseMatrixClassGenerated.DenseMatrixDependencies,
        MatrixDependencies: _dependenciesMatrixClassGenerated.MatrixDependencies,
        SparseMatrixDependencies: _dependenciesSparseMatrixClassGenerated.SparseMatrixDependencies,
        typedDependencies: _dependenciesTypedGenerated.typedDependencies,
        createMatrix: _factoriesAny.createMatrix
      };
    }
  });

  // node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/entry/dependenciesAny/dependenciesConcat.generated.js
  var require_dependenciesConcat_generated = __commonJS({
    "node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/entry/dependenciesAny/dependenciesConcat.generated.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.concatDependencies = void 0;
      var _dependenciesIsIntegerGenerated = require_dependenciesIsInteger_generated();
      var _dependenciesMatrixGenerated = require_dependenciesMatrix_generated();
      var _dependenciesTypedGenerated = require_dependenciesTyped_generated();
      var _factoriesAny = require_factoriesAny();
      var concatDependencies = exports.concatDependencies = {
        isIntegerDependencies: _dependenciesIsIntegerGenerated.isIntegerDependencies,
        matrixDependencies: _dependenciesMatrixGenerated.matrixDependencies,
        typedDependencies: _dependenciesTypedGenerated.typedDependencies,
        createConcat: _factoriesAny.createConcat
      };
    }
  });

  // node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/entry/dependenciesAny/dependenciesAdd.generated.js
  var require_dependenciesAdd_generated = __commonJS({
    "node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/entry/dependenciesAny/dependenciesAdd.generated.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.addDependencies = void 0;
      var _dependenciesDenseMatrixClassGenerated = require_dependenciesDenseMatrixClass_generated();
      var _dependenciesSparseMatrixClassGenerated = require_dependenciesSparseMatrixClass_generated();
      var _dependenciesAddScalarGenerated = require_dependenciesAddScalar_generated();
      var _dependenciesConcatGenerated = require_dependenciesConcat_generated();
      var _dependenciesEqualScalarGenerated = require_dependenciesEqualScalar_generated();
      var _dependenciesMatrixGenerated = require_dependenciesMatrix_generated();
      var _dependenciesTypedGenerated = require_dependenciesTyped_generated();
      var _factoriesAny = require_factoriesAny();
      var addDependencies = exports.addDependencies = {
        DenseMatrixDependencies: _dependenciesDenseMatrixClassGenerated.DenseMatrixDependencies,
        SparseMatrixDependencies: _dependenciesSparseMatrixClassGenerated.SparseMatrixDependencies,
        addScalarDependencies: _dependenciesAddScalarGenerated.addScalarDependencies,
        concatDependencies: _dependenciesConcatGenerated.concatDependencies,
        equalScalarDependencies: _dependenciesEqualScalarGenerated.equalScalarDependencies,
        matrixDependencies: _dependenciesMatrixGenerated.matrixDependencies,
        typedDependencies: _dependenciesTypedGenerated.typedDependencies,
        createAdd: _factoriesAny.createAdd
      };
    }
  });

  // node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/entry/dependenciesAny/dependenciesZeros.generated.js
  var require_dependenciesZeros_generated = __commonJS({
    "node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/entry/dependenciesAny/dependenciesZeros.generated.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.zerosDependencies = void 0;
      var _dependenciesBigNumberClassGenerated = require_dependenciesBigNumberClass_generated();
      var _dependenciesMatrixGenerated = require_dependenciesMatrix_generated();
      var _dependenciesTypedGenerated = require_dependenciesTyped_generated();
      var _factoriesAny = require_factoriesAny();
      var zerosDependencies = exports.zerosDependencies = {
        BigNumberDependencies: _dependenciesBigNumberClassGenerated.BigNumberDependencies,
        matrixDependencies: _dependenciesMatrixGenerated.matrixDependencies,
        typedDependencies: _dependenciesTypedGenerated.typedDependencies,
        createZeros: _factoriesAny.createZeros
      };
    }
  });

  // node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/entry/dependenciesAny/dependenciesSubset.generated.js
  var require_dependenciesSubset_generated = __commonJS({
    "node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/entry/dependenciesAny/dependenciesSubset.generated.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.subsetDependencies = void 0;
      var _dependenciesAddGenerated = require_dependenciesAdd_generated();
      var _dependenciesMatrixGenerated = require_dependenciesMatrix_generated();
      var _dependenciesTypedGenerated = require_dependenciesTyped_generated();
      var _dependenciesZerosGenerated = require_dependenciesZeros_generated();
      var _factoriesAny = require_factoriesAny();
      var subsetDependencies = exports.subsetDependencies = {
        addDependencies: _dependenciesAddGenerated.addDependencies,
        matrixDependencies: _dependenciesMatrixGenerated.matrixDependencies,
        typedDependencies: _dependenciesTypedGenerated.typedDependencies,
        zerosDependencies: _dependenciesZerosGenerated.zerosDependencies,
        createSubset: _factoriesAny.createSubset
      };
    }
  });

  // node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/entry/dependenciesAny/dependenciesAccessorNode.generated.js
  var require_dependenciesAccessorNode_generated = __commonJS({
    "node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/entry/dependenciesAny/dependenciesAccessorNode.generated.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.AccessorNodeDependencies = void 0;
      var _dependenciesNodeGenerated = require_dependenciesNode_generated();
      var _dependenciesSubsetGenerated = require_dependenciesSubset_generated();
      var _factoriesAny = require_factoriesAny();
      var AccessorNodeDependencies = exports.AccessorNodeDependencies = {
        NodeDependencies: _dependenciesNodeGenerated.NodeDependencies,
        subsetDependencies: _dependenciesSubsetGenerated.subsetDependencies,
        createAccessorNode: _factoriesAny.createAccessorNode
      };
    }
  });

  // node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/entry/dependenciesAny/dependenciesAcos.generated.js
  var require_dependenciesAcos_generated = __commonJS({
    "node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/entry/dependenciesAny/dependenciesAcos.generated.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.acosDependencies = void 0;
      var _dependenciesComplexClassGenerated = require_dependenciesComplexClass_generated();
      var _dependenciesTypedGenerated = require_dependenciesTyped_generated();
      var _factoriesAny = require_factoriesAny();
      var acosDependencies = exports.acosDependencies = {
        ComplexDependencies: _dependenciesComplexClassGenerated.ComplexDependencies,
        typedDependencies: _dependenciesTypedGenerated.typedDependencies,
        createAcos: _factoriesAny.createAcos
      };
    }
  });

  // node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/entry/dependenciesAny/dependenciesAcosh.generated.js
  var require_dependenciesAcosh_generated = __commonJS({
    "node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/entry/dependenciesAny/dependenciesAcosh.generated.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.acoshDependencies = void 0;
      var _dependenciesComplexClassGenerated = require_dependenciesComplexClass_generated();
      var _dependenciesTypedGenerated = require_dependenciesTyped_generated();
      var _factoriesAny = require_factoriesAny();
      var acoshDependencies = exports.acoshDependencies = {
        ComplexDependencies: _dependenciesComplexClassGenerated.ComplexDependencies,
        typedDependencies: _dependenciesTypedGenerated.typedDependencies,
        createAcosh: _factoriesAny.createAcosh
      };
    }
  });

  // node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/entry/dependenciesAny/dependenciesAcot.generated.js
  var require_dependenciesAcot_generated = __commonJS({
    "node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/entry/dependenciesAny/dependenciesAcot.generated.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.acotDependencies = void 0;
      var _dependenciesBigNumberClassGenerated = require_dependenciesBigNumberClass_generated();
      var _dependenciesTypedGenerated = require_dependenciesTyped_generated();
      var _factoriesAny = require_factoriesAny();
      var acotDependencies = exports.acotDependencies = {
        BigNumberDependencies: _dependenciesBigNumberClassGenerated.BigNumberDependencies,
        typedDependencies: _dependenciesTypedGenerated.typedDependencies,
        createAcot: _factoriesAny.createAcot
      };
    }
  });

  // node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/entry/dependenciesAny/dependenciesAcoth.generated.js
  var require_dependenciesAcoth_generated = __commonJS({
    "node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/entry/dependenciesAny/dependenciesAcoth.generated.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.acothDependencies = void 0;
      var _dependenciesBigNumberClassGenerated = require_dependenciesBigNumberClass_generated();
      var _dependenciesComplexClassGenerated = require_dependenciesComplexClass_generated();
      var _dependenciesTypedGenerated = require_dependenciesTyped_generated();
      var _factoriesAny = require_factoriesAny();
      var acothDependencies = exports.acothDependencies = {
        BigNumberDependencies: _dependenciesBigNumberClassGenerated.BigNumberDependencies,
        ComplexDependencies: _dependenciesComplexClassGenerated.ComplexDependencies,
        typedDependencies: _dependenciesTypedGenerated.typedDependencies,
        createAcoth: _factoriesAny.createAcoth
      };
    }
  });

  // node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/entry/dependenciesAny/dependenciesAcsc.generated.js
  var require_dependenciesAcsc_generated = __commonJS({
    "node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/entry/dependenciesAny/dependenciesAcsc.generated.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.acscDependencies = void 0;
      var _dependenciesBigNumberClassGenerated = require_dependenciesBigNumberClass_generated();
      var _dependenciesComplexClassGenerated = require_dependenciesComplexClass_generated();
      var _dependenciesTypedGenerated = require_dependenciesTyped_generated();
      var _factoriesAny = require_factoriesAny();
      var acscDependencies = exports.acscDependencies = {
        BigNumberDependencies: _dependenciesBigNumberClassGenerated.BigNumberDependencies,
        ComplexDependencies: _dependenciesComplexClassGenerated.ComplexDependencies,
        typedDependencies: _dependenciesTypedGenerated.typedDependencies,
        createAcsc: _factoriesAny.createAcsc
      };
    }
  });

  // node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/entry/dependenciesAny/dependenciesAcsch.generated.js
  var require_dependenciesAcsch_generated = __commonJS({
    "node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/entry/dependenciesAny/dependenciesAcsch.generated.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.acschDependencies = void 0;
      var _dependenciesBigNumberClassGenerated = require_dependenciesBigNumberClass_generated();
      var _dependenciesTypedGenerated = require_dependenciesTyped_generated();
      var _factoriesAny = require_factoriesAny();
      var acschDependencies = exports.acschDependencies = {
        BigNumberDependencies: _dependenciesBigNumberClassGenerated.BigNumberDependencies,
        typedDependencies: _dependenciesTypedGenerated.typedDependencies,
        createAcsch: _factoriesAny.createAcsch
      };
    }
  });

  // node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/entry/dependenciesAny/dependenciesNot.generated.js
  var require_dependenciesNot_generated = __commonJS({
    "node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/entry/dependenciesAny/dependenciesNot.generated.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.notDependencies = void 0;
      var _dependenciesTypedGenerated = require_dependenciesTyped_generated();
      var _factoriesAny = require_factoriesAny();
      var notDependencies = exports.notDependencies = {
        typedDependencies: _dependenciesTypedGenerated.typedDependencies,
        createNot: _factoriesAny.createNot
      };
    }
  });

  // node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/entry/dependenciesAny/dependenciesAnd.generated.js
  var require_dependenciesAnd_generated = __commonJS({
    "node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/entry/dependenciesAny/dependenciesAnd.generated.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.andDependencies = void 0;
      var _dependenciesConcatGenerated = require_dependenciesConcat_generated();
      var _dependenciesEqualScalarGenerated = require_dependenciesEqualScalar_generated();
      var _dependenciesMatrixGenerated = require_dependenciesMatrix_generated();
      var _dependenciesNotGenerated = require_dependenciesNot_generated();
      var _dependenciesTypedGenerated = require_dependenciesTyped_generated();
      var _dependenciesZerosGenerated = require_dependenciesZeros_generated();
      var _factoriesAny = require_factoriesAny();
      var andDependencies = exports.andDependencies = {
        concatDependencies: _dependenciesConcatGenerated.concatDependencies,
        equalScalarDependencies: _dependenciesEqualScalarGenerated.equalScalarDependencies,
        matrixDependencies: _dependenciesMatrixGenerated.matrixDependencies,
        notDependencies: _dependenciesNotGenerated.notDependencies,
        typedDependencies: _dependenciesTypedGenerated.typedDependencies,
        zerosDependencies: _dependenciesZerosGenerated.zerosDependencies,
        createAnd: _factoriesAny.createAnd
      };
    }
  });

  // node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/entry/dependenciesAny/dependenciesAndTransform.generated.js
  var require_dependenciesAndTransform_generated = __commonJS({
    "node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/entry/dependenciesAny/dependenciesAndTransform.generated.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.andTransformDependencies = void 0;
      var _dependenciesAddGenerated = require_dependenciesAdd_generated();
      var _dependenciesConcatGenerated = require_dependenciesConcat_generated();
      var _dependenciesEqualScalarGenerated = require_dependenciesEqualScalar_generated();
      var _dependenciesMatrixGenerated = require_dependenciesMatrix_generated();
      var _dependenciesNotGenerated = require_dependenciesNot_generated();
      var _dependenciesTypedGenerated = require_dependenciesTyped_generated();
      var _dependenciesZerosGenerated = require_dependenciesZeros_generated();
      var _factoriesAny = require_factoriesAny();
      var andTransformDependencies = exports.andTransformDependencies = {
        addDependencies: _dependenciesAddGenerated.addDependencies,
        concatDependencies: _dependenciesConcatGenerated.concatDependencies,
        equalScalarDependencies: _dependenciesEqualScalarGenerated.equalScalarDependencies,
        matrixDependencies: _dependenciesMatrixGenerated.matrixDependencies,
        notDependencies: _dependenciesNotGenerated.notDependencies,
        typedDependencies: _dependenciesTypedGenerated.typedDependencies,
        zerosDependencies: _dependenciesZerosGenerated.zerosDependencies,
        createAndTransform: _factoriesAny.createAndTransform
      };
    }
  });

  // node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/entry/dependenciesAny/dependenciesApply.generated.js
  var require_dependenciesApply_generated = __commonJS({
    "node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/entry/dependenciesAny/dependenciesApply.generated.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.applyDependencies = void 0;
      var _dependenciesIsIntegerGenerated = require_dependenciesIsInteger_generated();
      var _dependenciesTypedGenerated = require_dependenciesTyped_generated();
      var _factoriesAny = require_factoriesAny();
      var applyDependencies = exports.applyDependencies = {
        isIntegerDependencies: _dependenciesIsIntegerGenerated.isIntegerDependencies,
        typedDependencies: _dependenciesTypedGenerated.typedDependencies,
        createApply: _factoriesAny.createApply
      };
    }
  });

  // node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/entry/dependenciesAny/dependenciesApplyTransform.generated.js
  var require_dependenciesApplyTransform_generated = __commonJS({
    "node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/entry/dependenciesAny/dependenciesApplyTransform.generated.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.applyTransformDependencies = void 0;
      var _dependenciesIsIntegerGenerated = require_dependenciesIsInteger_generated();
      var _dependenciesTypedGenerated = require_dependenciesTyped_generated();
      var _factoriesAny = require_factoriesAny();
      var applyTransformDependencies = exports.applyTransformDependencies = {
        isIntegerDependencies: _dependenciesIsIntegerGenerated.isIntegerDependencies,
        typedDependencies: _dependenciesTypedGenerated.typedDependencies,
        createApplyTransform: _factoriesAny.createApplyTransform
      };
    }
  });

  // node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/entry/dependenciesAny/dependenciesArg.generated.js
  var require_dependenciesArg_generated = __commonJS({
    "node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/entry/dependenciesAny/dependenciesArg.generated.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.argDependencies = void 0;
      var _dependenciesTypedGenerated = require_dependenciesTyped_generated();
      var _factoriesAny = require_factoriesAny();
      var argDependencies = exports.argDependencies = {
        typedDependencies: _dependenciesTypedGenerated.typedDependencies,
        createArg: _factoriesAny.createArg
      };
    }
  });

  // node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/entry/dependenciesAny/dependenciesArrayNode.generated.js
  var require_dependenciesArrayNode_generated = __commonJS({
    "node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/entry/dependenciesAny/dependenciesArrayNode.generated.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.ArrayNodeDependencies = void 0;
      var _dependenciesNodeGenerated = require_dependenciesNode_generated();
      var _factoriesAny = require_factoriesAny();
      var ArrayNodeDependencies = exports.ArrayNodeDependencies = {
        NodeDependencies: _dependenciesNodeGenerated.NodeDependencies,
        createArrayNode: _factoriesAny.createArrayNode
      };
    }
  });

  // node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/entry/dependenciesAny/dependenciesAsec.generated.js
  var require_dependenciesAsec_generated = __commonJS({
    "node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/entry/dependenciesAny/dependenciesAsec.generated.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.asecDependencies = void 0;
      var _dependenciesBigNumberClassGenerated = require_dependenciesBigNumberClass_generated();
      var _dependenciesComplexClassGenerated = require_dependenciesComplexClass_generated();
      var _dependenciesTypedGenerated = require_dependenciesTyped_generated();
      var _factoriesAny = require_factoriesAny();
      var asecDependencies = exports.asecDependencies = {
        BigNumberDependencies: _dependenciesBigNumberClassGenerated.BigNumberDependencies,
        ComplexDependencies: _dependenciesComplexClassGenerated.ComplexDependencies,
        typedDependencies: _dependenciesTypedGenerated.typedDependencies,
        createAsec: _factoriesAny.createAsec
      };
    }
  });

  // node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/entry/dependenciesAny/dependenciesAsech.generated.js
  var require_dependenciesAsech_generated = __commonJS({
    "node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/entry/dependenciesAny/dependenciesAsech.generated.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.asechDependencies = void 0;
      var _dependenciesBigNumberClassGenerated = require_dependenciesBigNumberClass_generated();
      var _dependenciesComplexClassGenerated = require_dependenciesComplexClass_generated();
      var _dependenciesTypedGenerated = require_dependenciesTyped_generated();
      var _factoriesAny = require_factoriesAny();
      var asechDependencies = exports.asechDependencies = {
        BigNumberDependencies: _dependenciesBigNumberClassGenerated.BigNumberDependencies,
        ComplexDependencies: _dependenciesComplexClassGenerated.ComplexDependencies,
        typedDependencies: _dependenciesTypedGenerated.typedDependencies,
        createAsech: _factoriesAny.createAsech
      };
    }
  });

  // node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/entry/dependenciesAny/dependenciesAsin.generated.js
  var require_dependenciesAsin_generated = __commonJS({
    "node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/entry/dependenciesAny/dependenciesAsin.generated.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.asinDependencies = void 0;
      var _dependenciesComplexClassGenerated = require_dependenciesComplexClass_generated();
      var _dependenciesTypedGenerated = require_dependenciesTyped_generated();
      var _factoriesAny = require_factoriesAny();
      var asinDependencies = exports.asinDependencies = {
        ComplexDependencies: _dependenciesComplexClassGenerated.ComplexDependencies,
        typedDependencies: _dependenciesTypedGenerated.typedDependencies,
        createAsin: _factoriesAny.createAsin
      };
    }
  });

  // node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/entry/dependenciesAny/dependenciesAsinh.generated.js
  var require_dependenciesAsinh_generated = __commonJS({
    "node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/entry/dependenciesAny/dependenciesAsinh.generated.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.asinhDependencies = void 0;
      var _dependenciesTypedGenerated = require_dependenciesTyped_generated();
      var _factoriesAny = require_factoriesAny();
      var asinhDependencies = exports.asinhDependencies = {
        typedDependencies: _dependenciesTypedGenerated.typedDependencies,
        createAsinh: _factoriesAny.createAsinh
      };
    }
  });

  // node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/entry/dependenciesAny/dependenciesAssignmentNode.generated.js
  var require_dependenciesAssignmentNode_generated = __commonJS({
    "node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/entry/dependenciesAny/dependenciesAssignmentNode.generated.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.AssignmentNodeDependencies = void 0;
      var _dependenciesMatrixGenerated = require_dependenciesMatrix_generated();
      var _dependenciesNodeGenerated = require_dependenciesNode_generated();
      var _dependenciesSubsetGenerated = require_dependenciesSubset_generated();
      var _factoriesAny = require_factoriesAny();
      var AssignmentNodeDependencies = exports.AssignmentNodeDependencies = {
        matrixDependencies: _dependenciesMatrixGenerated.matrixDependencies,
        NodeDependencies: _dependenciesNodeGenerated.NodeDependencies,
        subsetDependencies: _dependenciesSubsetGenerated.subsetDependencies,
        createAssignmentNode: _factoriesAny.createAssignmentNode
      };
    }
  });

  // node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/entry/dependenciesAny/dependenciesAtan.generated.js
  var require_dependenciesAtan_generated = __commonJS({
    "node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/entry/dependenciesAny/dependenciesAtan.generated.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.atanDependencies = void 0;
      var _dependenciesTypedGenerated = require_dependenciesTyped_generated();
      var _factoriesAny = require_factoriesAny();
      var atanDependencies = exports.atanDependencies = {
        typedDependencies: _dependenciesTypedGenerated.typedDependencies,
        createAtan: _factoriesAny.createAtan
      };
    }
  });

  // node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/entry/dependenciesAny/dependenciesAtan2.generated.js
  var require_dependenciesAtan2_generated = __commonJS({
    "node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/entry/dependenciesAny/dependenciesAtan2.generated.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.atan2Dependencies = void 0;
      var _dependenciesBigNumberClassGenerated = require_dependenciesBigNumberClass_generated();
      var _dependenciesDenseMatrixClassGenerated = require_dependenciesDenseMatrixClass_generated();
      var _dependenciesConcatGenerated = require_dependenciesConcat_generated();
      var _dependenciesEqualScalarGenerated = require_dependenciesEqualScalar_generated();
      var _dependenciesMatrixGenerated = require_dependenciesMatrix_generated();
      var _dependenciesTypedGenerated = require_dependenciesTyped_generated();
      var _factoriesAny = require_factoriesAny();
      var atan2Dependencies = exports.atan2Dependencies = {
        BigNumberDependencies: _dependenciesBigNumberClassGenerated.BigNumberDependencies,
        DenseMatrixDependencies: _dependenciesDenseMatrixClassGenerated.DenseMatrixDependencies,
        concatDependencies: _dependenciesConcatGenerated.concatDependencies,
        equalScalarDependencies: _dependenciesEqualScalarGenerated.equalScalarDependencies,
        matrixDependencies: _dependenciesMatrixGenerated.matrixDependencies,
        typedDependencies: _dependenciesTypedGenerated.typedDependencies,
        createAtan2: _factoriesAny.createAtan2
      };
    }
  });

  // node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/entry/dependenciesAny/dependenciesAtanh.generated.js
  var require_dependenciesAtanh_generated = __commonJS({
    "node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/entry/dependenciesAny/dependenciesAtanh.generated.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.atanhDependencies = void 0;
      var _dependenciesComplexClassGenerated = require_dependenciesComplexClass_generated();
      var _dependenciesTypedGenerated = require_dependenciesTyped_generated();
      var _factoriesAny = require_factoriesAny();
      var atanhDependencies = exports.atanhDependencies = {
        ComplexDependencies: _dependenciesComplexClassGenerated.ComplexDependencies,
        typedDependencies: _dependenciesTypedGenerated.typedDependencies,
        createAtanh: _factoriesAny.createAtanh
      };
    }
  });

  // node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/entry/dependenciesAny/dependenciesBignumber.generated.js
  var require_dependenciesBignumber_generated = __commonJS({
    "node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/entry/dependenciesAny/dependenciesBignumber.generated.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.bignumberDependencies = void 0;
      var _dependenciesBigNumberClassGenerated = require_dependenciesBigNumberClass_generated();
      var _dependenciesTypedGenerated = require_dependenciesTyped_generated();
      var _factoriesAny = require_factoriesAny();
      var bignumberDependencies = exports.bignumberDependencies = {
        BigNumberDependencies: _dependenciesBigNumberClassGenerated.BigNumberDependencies,
        typedDependencies: _dependenciesTypedGenerated.typedDependencies,
        createBignumber: _factoriesAny.createBignumber
      };
    }
  });

  // node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/entry/dependenciesAny/dependenciesFraction.generated.js
  var require_dependenciesFraction_generated = __commonJS({
    "node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/entry/dependenciesAny/dependenciesFraction.generated.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.fractionDependencies = void 0;
      var _dependenciesFractionClassGenerated = require_dependenciesFractionClass_generated();
      var _dependenciesTypedGenerated = require_dependenciesTyped_generated();
      var _factoriesAny = require_factoriesAny();
      var fractionDependencies = exports.fractionDependencies = {
        FractionDependencies: _dependenciesFractionClassGenerated.FractionDependencies,
        typedDependencies: _dependenciesTypedGenerated.typedDependencies,
        createFraction: _factoriesAny.createFraction
      };
    }
  });

  // node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/entry/dependenciesAny/dependenciesNumber.generated.js
  var require_dependenciesNumber_generated = __commonJS({
    "node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/entry/dependenciesAny/dependenciesNumber.generated.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.numberDependencies = void 0;
      var _dependenciesTypedGenerated = require_dependenciesTyped_generated();
      var _factoriesAny = require_factoriesAny();
      var numberDependencies = exports.numberDependencies = {
        typedDependencies: _dependenciesTypedGenerated.typedDependencies,
        createNumber: _factoriesAny.createNumber
      };
    }
  });

  // node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/entry/dependenciesAny/dependenciesNumeric.generated.js
  var require_dependenciesNumeric_generated = __commonJS({
    "node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/entry/dependenciesAny/dependenciesNumeric.generated.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.numericDependencies = void 0;
      var _dependenciesBignumberGenerated = require_dependenciesBignumber_generated();
      var _dependenciesFractionGenerated = require_dependenciesFraction_generated();
      var _dependenciesNumberGenerated = require_dependenciesNumber_generated();
      var _factoriesAny = require_factoriesAny();
      var numericDependencies = exports.numericDependencies = {
        bignumberDependencies: _dependenciesBignumberGenerated.bignumberDependencies,
        fractionDependencies: _dependenciesFractionGenerated.fractionDependencies,
        numberDependencies: _dependenciesNumberGenerated.numberDependencies,
        createNumeric: _factoriesAny.createNumeric
      };
    }
  });

  // node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/entry/dependenciesAny/dependenciesDivideScalar.generated.js
  var require_dependenciesDivideScalar_generated = __commonJS({
    "node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/entry/dependenciesAny/dependenciesDivideScalar.generated.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.divideScalarDependencies = void 0;
      var _dependenciesNumericGenerated = require_dependenciesNumeric_generated();
      var _dependenciesTypedGenerated = require_dependenciesTyped_generated();
      var _factoriesAny = require_factoriesAny();
      var divideScalarDependencies = exports.divideScalarDependencies = {
        numericDependencies: _dependenciesNumericGenerated.numericDependencies,
        typedDependencies: _dependenciesTypedGenerated.typedDependencies,
        createDivideScalar: _factoriesAny.createDivideScalar
      };
    }
  });

  // node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/entry/dependenciesAny/dependenciesEqual.generated.js
  var require_dependenciesEqual_generated = __commonJS({
    "node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/entry/dependenciesAny/dependenciesEqual.generated.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.equalDependencies = void 0;
      var _dependenciesDenseMatrixClassGenerated = require_dependenciesDenseMatrixClass_generated();
      var _dependenciesConcatGenerated = require_dependenciesConcat_generated();
      var _dependenciesEqualScalarGenerated = require_dependenciesEqualScalar_generated();
      var _dependenciesMatrixGenerated = require_dependenciesMatrix_generated();
      var _dependenciesTypedGenerated = require_dependenciesTyped_generated();
      var _factoriesAny = require_factoriesAny();
      var equalDependencies = exports.equalDependencies = {
        DenseMatrixDependencies: _dependenciesDenseMatrixClassGenerated.DenseMatrixDependencies,
        concatDependencies: _dependenciesConcatGenerated.concatDependencies,
        equalScalarDependencies: _dependenciesEqualScalarGenerated.equalScalarDependencies,
        matrixDependencies: _dependenciesMatrixGenerated.matrixDependencies,
        typedDependencies: _dependenciesTypedGenerated.typedDependencies,
        createEqual: _factoriesAny.createEqual
      };
    }
  });

  // node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/entry/dependenciesAny/dependenciesRound.generated.js
  var require_dependenciesRound_generated = __commonJS({
    "node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/entry/dependenciesAny/dependenciesRound.generated.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.roundDependencies = void 0;
      var _dependenciesBigNumberClassGenerated = require_dependenciesBigNumberClass_generated();
      var _dependenciesDenseMatrixClassGenerated = require_dependenciesDenseMatrixClass_generated();
      var _dependenciesEqualScalarGenerated = require_dependenciesEqualScalar_generated();
      var _dependenciesMatrixGenerated = require_dependenciesMatrix_generated();
      var _dependenciesTypedGenerated = require_dependenciesTyped_generated();
      var _dependenciesZerosGenerated = require_dependenciesZeros_generated();
      var _factoriesAny = require_factoriesAny();
      var roundDependencies = exports.roundDependencies = {
        BigNumberDependencies: _dependenciesBigNumberClassGenerated.BigNumberDependencies,
        DenseMatrixDependencies: _dependenciesDenseMatrixClassGenerated.DenseMatrixDependencies,
        equalScalarDependencies: _dependenciesEqualScalarGenerated.equalScalarDependencies,
        matrixDependencies: _dependenciesMatrixGenerated.matrixDependencies,
        typedDependencies: _dependenciesTypedGenerated.typedDependencies,
        zerosDependencies: _dependenciesZerosGenerated.zerosDependencies,
        createRound: _factoriesAny.createRound
      };
    }
  });

  // node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/entry/dependenciesAny/dependenciesCeil.generated.js
  var require_dependenciesCeil_generated = __commonJS({
    "node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/entry/dependenciesAny/dependenciesCeil.generated.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.ceilDependencies = void 0;
      var _dependenciesDenseMatrixClassGenerated = require_dependenciesDenseMatrixClass_generated();
      var _dependenciesEqualScalarGenerated = require_dependenciesEqualScalar_generated();
      var _dependenciesMatrixGenerated = require_dependenciesMatrix_generated();
      var _dependenciesRoundGenerated = require_dependenciesRound_generated();
      var _dependenciesTypedGenerated = require_dependenciesTyped_generated();
      var _dependenciesZerosGenerated = require_dependenciesZeros_generated();
      var _factoriesAny = require_factoriesAny();
      var ceilDependencies = exports.ceilDependencies = {
        DenseMatrixDependencies: _dependenciesDenseMatrixClassGenerated.DenseMatrixDependencies,
        equalScalarDependencies: _dependenciesEqualScalarGenerated.equalScalarDependencies,
        matrixDependencies: _dependenciesMatrixGenerated.matrixDependencies,
        roundDependencies: _dependenciesRoundGenerated.roundDependencies,
        typedDependencies: _dependenciesTypedGenerated.typedDependencies,
        zerosDependencies: _dependenciesZerosGenerated.zerosDependencies,
        createCeil: _factoriesAny.createCeil
      };
    }
  });

  // node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/entry/dependenciesAny/dependenciesFloor.generated.js
  var require_dependenciesFloor_generated = __commonJS({
    "node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/entry/dependenciesAny/dependenciesFloor.generated.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.floorDependencies = void 0;
      var _dependenciesDenseMatrixClassGenerated = require_dependenciesDenseMatrixClass_generated();
      var _dependenciesEqualScalarGenerated = require_dependenciesEqualScalar_generated();
      var _dependenciesMatrixGenerated = require_dependenciesMatrix_generated();
      var _dependenciesRoundGenerated = require_dependenciesRound_generated();
      var _dependenciesTypedGenerated = require_dependenciesTyped_generated();
      var _dependenciesZerosGenerated = require_dependenciesZeros_generated();
      var _factoriesAny = require_factoriesAny();
      var floorDependencies = exports.floorDependencies = {
        DenseMatrixDependencies: _dependenciesDenseMatrixClassGenerated.DenseMatrixDependencies,
        equalScalarDependencies: _dependenciesEqualScalarGenerated.equalScalarDependencies,
        matrixDependencies: _dependenciesMatrixGenerated.matrixDependencies,
        roundDependencies: _dependenciesRoundGenerated.roundDependencies,
        typedDependencies: _dependenciesTypedGenerated.typedDependencies,
        zerosDependencies: _dependenciesZerosGenerated.zerosDependencies,
        createFloor: _factoriesAny.createFloor
      };
    }
  });

  // node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/entry/dependenciesAny/dependenciesFix.generated.js
  var require_dependenciesFix_generated = __commonJS({
    "node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/entry/dependenciesAny/dependenciesFix.generated.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.fixDependencies = void 0;
      var _dependenciesComplexClassGenerated = require_dependenciesComplexClass_generated();
      var _dependenciesDenseMatrixClassGenerated = require_dependenciesDenseMatrixClass_generated();
      var _dependenciesCeilGenerated = require_dependenciesCeil_generated();
      var _dependenciesEqualScalarGenerated = require_dependenciesEqualScalar_generated();
      var _dependenciesFloorGenerated = require_dependenciesFloor_generated();
      var _dependenciesMatrixGenerated = require_dependenciesMatrix_generated();
      var _dependenciesTypedGenerated = require_dependenciesTyped_generated();
      var _dependenciesZerosGenerated = require_dependenciesZeros_generated();
      var _factoriesAny = require_factoriesAny();
      var fixDependencies = exports.fixDependencies = {
        ComplexDependencies: _dependenciesComplexClassGenerated.ComplexDependencies,
        DenseMatrixDependencies: _dependenciesDenseMatrixClassGenerated.DenseMatrixDependencies,
        ceilDependencies: _dependenciesCeilGenerated.ceilDependencies,
        equalScalarDependencies: _dependenciesEqualScalarGenerated.equalScalarDependencies,
        floorDependencies: _dependenciesFloorGenerated.floorDependencies,
        matrixDependencies: _dependenciesMatrixGenerated.matrixDependencies,
        typedDependencies: _dependenciesTypedGenerated.typedDependencies,
        zerosDependencies: _dependenciesZerosGenerated.zerosDependencies,
        createFix: _factoriesAny.createFix
      };
    }
  });

  // node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/entry/dependenciesAny/dependenciesFormat.generated.js
  var require_dependenciesFormat_generated = __commonJS({
    "node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/entry/dependenciesAny/dependenciesFormat.generated.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.formatDependencies = void 0;
      var _dependenciesTypedGenerated = require_dependenciesTyped_generated();
      var _factoriesAny = require_factoriesAny();
      var formatDependencies = exports.formatDependencies = {
        typedDependencies: _dependenciesTypedGenerated.typedDependencies,
        createFormat: _factoriesAny.createFormat
      };
    }
  });

  // node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/entry/dependenciesAny/dependenciesIsNumeric.generated.js
  var require_dependenciesIsNumeric_generated = __commonJS({
    "node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/entry/dependenciesAny/dependenciesIsNumeric.generated.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.isNumericDependencies = void 0;
      var _dependenciesTypedGenerated = require_dependenciesTyped_generated();
      var _factoriesAny = require_factoriesAny();
      var isNumericDependencies = exports.isNumericDependencies = {
        typedDependencies: _dependenciesTypedGenerated.typedDependencies,
        createIsNumeric: _factoriesAny.createIsNumeric
      };
    }
  });

  // node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/entry/dependenciesAny/dependenciesMultiplyScalar.generated.js
  var require_dependenciesMultiplyScalar_generated = __commonJS({
    "node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/entry/dependenciesAny/dependenciesMultiplyScalar.generated.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.multiplyScalarDependencies = void 0;
      var _dependenciesTypedGenerated = require_dependenciesTyped_generated();
      var _factoriesAny = require_factoriesAny();
      var multiplyScalarDependencies = exports.multiplyScalarDependencies = {
        typedDependencies: _dependenciesTypedGenerated.typedDependencies,
        createMultiplyScalar: _factoriesAny.createMultiplyScalar
      };
    }
  });

  // node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/entry/dependenciesAny/dependenciesIdentity.generated.js
  var require_dependenciesIdentity_generated = __commonJS({
    "node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/entry/dependenciesAny/dependenciesIdentity.generated.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.identityDependencies = void 0;
      var _dependenciesBigNumberClassGenerated = require_dependenciesBigNumberClass_generated();
      var _dependenciesDenseMatrixClassGenerated = require_dependenciesDenseMatrixClass_generated();
      var _dependenciesSparseMatrixClassGenerated = require_dependenciesSparseMatrixClass_generated();
      var _dependenciesMatrixGenerated = require_dependenciesMatrix_generated();
      var _dependenciesTypedGenerated = require_dependenciesTyped_generated();
      var _factoriesAny = require_factoriesAny();
      var identityDependencies = exports.identityDependencies = {
        BigNumberDependencies: _dependenciesBigNumberClassGenerated.BigNumberDependencies,
        DenseMatrixDependencies: _dependenciesDenseMatrixClassGenerated.DenseMatrixDependencies,
        SparseMatrixDependencies: _dependenciesSparseMatrixClassGenerated.SparseMatrixDependencies,
        matrixDependencies: _dependenciesMatrixGenerated.matrixDependencies,
        typedDependencies: _dependenciesTypedGenerated.typedDependencies,
        createIdentity: _factoriesAny.createIdentity
      };
    }
  });

  // node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/entry/dependenciesAny/dependenciesIsZero.generated.js
  var require_dependenciesIsZero_generated = __commonJS({
    "node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/entry/dependenciesAny/dependenciesIsZero.generated.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.isZeroDependencies = void 0;
      var _dependenciesTypedGenerated = require_dependenciesTyped_generated();
      var _factoriesAny = require_factoriesAny();
      var isZeroDependencies = exports.isZeroDependencies = {
        typedDependencies: _dependenciesTypedGenerated.typedDependencies,
        createIsZero: _factoriesAny.createIsZero
      };
    }
  });

  // node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/entry/dependenciesAny/dependenciesConj.generated.js
  var require_dependenciesConj_generated = __commonJS({
    "node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/entry/dependenciesAny/dependenciesConj.generated.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.conjDependencies = void 0;
      var _dependenciesTypedGenerated = require_dependenciesTyped_generated();
      var _factoriesAny = require_factoriesAny();
      var conjDependencies = exports.conjDependencies = {
        typedDependencies: _dependenciesTypedGenerated.typedDependencies,
        createConj: _factoriesAny.createConj
      };
    }
  });

  // node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/entry/dependenciesAny/dependenciesSize.generated.js
  var require_dependenciesSize_generated = __commonJS({
    "node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/entry/dependenciesAny/dependenciesSize.generated.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.sizeDependencies = void 0;
      var _dependenciesMatrixGenerated = require_dependenciesMatrix_generated();
      var _dependenciesTypedGenerated = require_dependenciesTyped_generated();
      var _factoriesAny = require_factoriesAny();
      var sizeDependencies = exports.sizeDependencies = {
        matrixDependencies: _dependenciesMatrixGenerated.matrixDependencies,
        typedDependencies: _dependenciesTypedGenerated.typedDependencies,
        createSize: _factoriesAny.createSize
      };
    }
  });

  // node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/entry/dependenciesAny/dependenciesDot.generated.js
  var require_dependenciesDot_generated = __commonJS({
    "node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/entry/dependenciesAny/dependenciesDot.generated.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.dotDependencies = void 0;
      var _dependenciesAddScalarGenerated = require_dependenciesAddScalar_generated();
      var _dependenciesConjGenerated = require_dependenciesConj_generated();
      var _dependenciesMultiplyScalarGenerated = require_dependenciesMultiplyScalar_generated();
      var _dependenciesSizeGenerated = require_dependenciesSize_generated();
      var _dependenciesTypedGenerated = require_dependenciesTyped_generated();
      var _factoriesAny = require_factoriesAny();
      var dotDependencies = exports.dotDependencies = {
        addScalarDependencies: _dependenciesAddScalarGenerated.addScalarDependencies,
        conjDependencies: _dependenciesConjGenerated.conjDependencies,
        multiplyScalarDependencies: _dependenciesMultiplyScalarGenerated.multiplyScalarDependencies,
        sizeDependencies: _dependenciesSizeGenerated.sizeDependencies,
        typedDependencies: _dependenciesTypedGenerated.typedDependencies,
        createDot: _factoriesAny.createDot
      };
    }
  });

  // node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/entry/dependenciesAny/dependenciesMultiply.generated.js
  var require_dependenciesMultiply_generated = __commonJS({
    "node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/entry/dependenciesAny/dependenciesMultiply.generated.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.multiplyDependencies = void 0;
      var _dependenciesAddScalarGenerated = require_dependenciesAddScalar_generated();
      var _dependenciesDotGenerated = require_dependenciesDot_generated();
      var _dependenciesEqualScalarGenerated = require_dependenciesEqualScalar_generated();
      var _dependenciesMatrixGenerated = require_dependenciesMatrix_generated();
      var _dependenciesMultiplyScalarGenerated = require_dependenciesMultiplyScalar_generated();
      var _dependenciesTypedGenerated = require_dependenciesTyped_generated();
      var _factoriesAny = require_factoriesAny();
      var multiplyDependencies = exports.multiplyDependencies = {
        addScalarDependencies: _dependenciesAddScalarGenerated.addScalarDependencies,
        dotDependencies: _dependenciesDotGenerated.dotDependencies,
        equalScalarDependencies: _dependenciesEqualScalarGenerated.equalScalarDependencies,
        matrixDependencies: _dependenciesMatrixGenerated.matrixDependencies,
        multiplyScalarDependencies: _dependenciesMultiplyScalarGenerated.multiplyScalarDependencies,
        typedDependencies: _dependenciesTypedGenerated.typedDependencies,
        createMultiply: _factoriesAny.createMultiply
      };
    }
  });

  // node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/entry/dependenciesAny/dependenciesSubtractScalar.generated.js
  var require_dependenciesSubtractScalar_generated = __commonJS({
    "node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/entry/dependenciesAny/dependenciesSubtractScalar.generated.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.subtractScalarDependencies = void 0;
      var _dependenciesTypedGenerated = require_dependenciesTyped_generated();
      var _factoriesAny = require_factoriesAny();
      var subtractScalarDependencies = exports.subtractScalarDependencies = {
        typedDependencies: _dependenciesTypedGenerated.typedDependencies,
        createSubtractScalar: _factoriesAny.createSubtractScalar
      };
    }
  });

  // node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/entry/dependenciesAny/dependenciesUnaryMinus.generated.js
  var require_dependenciesUnaryMinus_generated = __commonJS({
    "node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/entry/dependenciesAny/dependenciesUnaryMinus.generated.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.unaryMinusDependencies = void 0;
      var _dependenciesTypedGenerated = require_dependenciesTyped_generated();
      var _factoriesAny = require_factoriesAny();
      var unaryMinusDependencies = exports.unaryMinusDependencies = {
        typedDependencies: _dependenciesTypedGenerated.typedDependencies,
        createUnaryMinus: _factoriesAny.createUnaryMinus
      };
    }
  });

  // node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/entry/dependenciesAny/dependenciesDet.generated.js
  var require_dependenciesDet_generated = __commonJS({
    "node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/entry/dependenciesAny/dependenciesDet.generated.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.detDependencies = void 0;
      var _dependenciesDivideScalarGenerated = require_dependenciesDivideScalar_generated();
      var _dependenciesIsZeroGenerated = require_dependenciesIsZero_generated();
      var _dependenciesMatrixGenerated = require_dependenciesMatrix_generated();
      var _dependenciesMultiplyGenerated = require_dependenciesMultiply_generated();
      var _dependenciesSubtractScalarGenerated = require_dependenciesSubtractScalar_generated();
      var _dependenciesTypedGenerated = require_dependenciesTyped_generated();
      var _dependenciesUnaryMinusGenerated = require_dependenciesUnaryMinus_generated();
      var _factoriesAny = require_factoriesAny();
      var detDependencies = exports.detDependencies = {
        divideScalarDependencies: _dependenciesDivideScalarGenerated.divideScalarDependencies,
        isZeroDependencies: _dependenciesIsZeroGenerated.isZeroDependencies,
        matrixDependencies: _dependenciesMatrixGenerated.matrixDependencies,
        multiplyDependencies: _dependenciesMultiplyGenerated.multiplyDependencies,
        subtractScalarDependencies: _dependenciesSubtractScalarGenerated.subtractScalarDependencies,
        typedDependencies: _dependenciesTypedGenerated.typedDependencies,
        unaryMinusDependencies: _dependenciesUnaryMinusGenerated.unaryMinusDependencies,
        createDet: _factoriesAny.createDet
      };
    }
  });

  // node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/entry/dependenciesAny/dependenciesInv.generated.js
  var require_dependenciesInv_generated = __commonJS({
    "node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/entry/dependenciesAny/dependenciesInv.generated.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.invDependencies = void 0;
      var _dependenciesAbsGenerated = require_dependenciesAbs_generated();
      var _dependenciesAddScalarGenerated = require_dependenciesAddScalar_generated();
      var _dependenciesDetGenerated = require_dependenciesDet_generated();
      var _dependenciesDivideScalarGenerated = require_dependenciesDivideScalar_generated();
      var _dependenciesIdentityGenerated = require_dependenciesIdentity_generated();
      var _dependenciesMatrixGenerated = require_dependenciesMatrix_generated();
      var _dependenciesMultiplyGenerated = require_dependenciesMultiply_generated();
      var _dependenciesTypedGenerated = require_dependenciesTyped_generated();
      var _dependenciesUnaryMinusGenerated = require_dependenciesUnaryMinus_generated();
      var _factoriesAny = require_factoriesAny();
      var invDependencies = exports.invDependencies = {
        absDependencies: _dependenciesAbsGenerated.absDependencies,
        addScalarDependencies: _dependenciesAddScalarGenerated.addScalarDependencies,
        detDependencies: _dependenciesDetGenerated.detDependencies,
        divideScalarDependencies: _dependenciesDivideScalarGenerated.divideScalarDependencies,
        identityDependencies: _dependenciesIdentityGenerated.identityDependencies,
        matrixDependencies: _dependenciesMatrixGenerated.matrixDependencies,
        multiplyDependencies: _dependenciesMultiplyGenerated.multiplyDependencies,
        typedDependencies: _dependenciesTypedGenerated.typedDependencies,
        unaryMinusDependencies: _dependenciesUnaryMinusGenerated.unaryMinusDependencies,
        createInv: _factoriesAny.createInv
      };
    }
  });

  // node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/entry/dependenciesAny/dependenciesPow.generated.js
  var require_dependenciesPow_generated = __commonJS({
    "node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/entry/dependenciesAny/dependenciesPow.generated.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.powDependencies = void 0;
      var _dependenciesComplexClassGenerated = require_dependenciesComplexClass_generated();
      var _dependenciesFractionGenerated = require_dependenciesFraction_generated();
      var _dependenciesIdentityGenerated = require_dependenciesIdentity_generated();
      var _dependenciesInvGenerated = require_dependenciesInv_generated();
      var _dependenciesMatrixGenerated = require_dependenciesMatrix_generated();
      var _dependenciesMultiplyGenerated = require_dependenciesMultiply_generated();
      var _dependenciesNumberGenerated = require_dependenciesNumber_generated();
      var _dependenciesTypedGenerated = require_dependenciesTyped_generated();
      var _factoriesAny = require_factoriesAny();
      var powDependencies = exports.powDependencies = {
        ComplexDependencies: _dependenciesComplexClassGenerated.ComplexDependencies,
        fractionDependencies: _dependenciesFractionGenerated.fractionDependencies,
        identityDependencies: _dependenciesIdentityGenerated.identityDependencies,
        invDependencies: _dependenciesInvGenerated.invDependencies,
        matrixDependencies: _dependenciesMatrixGenerated.matrixDependencies,
        multiplyDependencies: _dependenciesMultiplyGenerated.multiplyDependencies,
        numberDependencies: _dependenciesNumberGenerated.numberDependencies,
        typedDependencies: _dependenciesTypedGenerated.typedDependencies,
        createPow: _factoriesAny.createPow
      };
    }
  });

  // node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/entry/dependenciesAny/dependenciesUnitClass.generated.js
  var require_dependenciesUnitClass_generated = __commonJS({
    "node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/entry/dependenciesAny/dependenciesUnitClass.generated.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.UnitDependencies = void 0;
      var _dependenciesBigNumberClassGenerated = require_dependenciesBigNumberClass_generated();
      var _dependenciesComplexClassGenerated = require_dependenciesComplexClass_generated();
      var _dependenciesFractionClassGenerated = require_dependenciesFractionClass_generated();
      var _dependenciesAbsGenerated = require_dependenciesAbs_generated();
      var _dependenciesAddScalarGenerated = require_dependenciesAddScalar_generated();
      var _dependenciesDivideScalarGenerated = require_dependenciesDivideScalar_generated();
      var _dependenciesEqualGenerated = require_dependenciesEqual_generated();
      var _dependenciesFixGenerated = require_dependenciesFix_generated();
      var _dependenciesFormatGenerated = require_dependenciesFormat_generated();
      var _dependenciesIsNumericGenerated = require_dependenciesIsNumeric_generated();
      var _dependenciesMultiplyScalarGenerated = require_dependenciesMultiplyScalar_generated();
      var _dependenciesNumberGenerated = require_dependenciesNumber_generated();
      var _dependenciesPowGenerated = require_dependenciesPow_generated();
      var _dependenciesRoundGenerated = require_dependenciesRound_generated();
      var _dependenciesSubtractScalarGenerated = require_dependenciesSubtractScalar_generated();
      var _factoriesAny = require_factoriesAny();
      var UnitDependencies = exports.UnitDependencies = {
        BigNumberDependencies: _dependenciesBigNumberClassGenerated.BigNumberDependencies,
        ComplexDependencies: _dependenciesComplexClassGenerated.ComplexDependencies,
        FractionDependencies: _dependenciesFractionClassGenerated.FractionDependencies,
        absDependencies: _dependenciesAbsGenerated.absDependencies,
        addScalarDependencies: _dependenciesAddScalarGenerated.addScalarDependencies,
        divideScalarDependencies: _dependenciesDivideScalarGenerated.divideScalarDependencies,
        equalDependencies: _dependenciesEqualGenerated.equalDependencies,
        fixDependencies: _dependenciesFixGenerated.fixDependencies,
        formatDependencies: _dependenciesFormatGenerated.formatDependencies,
        isNumericDependencies: _dependenciesIsNumericGenerated.isNumericDependencies,
        multiplyScalarDependencies: _dependenciesMultiplyScalarGenerated.multiplyScalarDependencies,
        numberDependencies: _dependenciesNumberGenerated.numberDependencies,
        powDependencies: _dependenciesPowGenerated.powDependencies,
        roundDependencies: _dependenciesRoundGenerated.roundDependencies,
        subtractScalarDependencies: _dependenciesSubtractScalarGenerated.subtractScalarDependencies,
        createUnitClass: _factoriesAny.createUnitClass
      };
    }
  });

  // node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/entry/dependenciesAny/dependenciesAtomicMass.generated.js
  var require_dependenciesAtomicMass_generated = __commonJS({
    "node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/entry/dependenciesAny/dependenciesAtomicMass.generated.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.atomicMassDependencies = void 0;
      var _dependenciesBigNumberClassGenerated = require_dependenciesBigNumberClass_generated();
      var _dependenciesUnitClassGenerated = require_dependenciesUnitClass_generated();
      var _factoriesAny = require_factoriesAny();
      var atomicMassDependencies = exports.atomicMassDependencies = {
        BigNumberDependencies: _dependenciesBigNumberClassGenerated.BigNumberDependencies,
        UnitDependencies: _dependenciesUnitClassGenerated.UnitDependencies,
        createAtomicMass: _factoriesAny.createAtomicMass
      };
    }
  });

  // node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/entry/dependenciesAny/dependenciesAvogadro.generated.js
  var require_dependenciesAvogadro_generated = __commonJS({
    "node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/entry/dependenciesAny/dependenciesAvogadro.generated.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.avogadroDependencies = void 0;
      var _dependenciesBigNumberClassGenerated = require_dependenciesBigNumberClass_generated();
      var _dependenciesUnitClassGenerated = require_dependenciesUnitClass_generated();
      var _factoriesAny = require_factoriesAny();
      var avogadroDependencies = exports.avogadroDependencies = {
        BigNumberDependencies: _dependenciesBigNumberClassGenerated.BigNumberDependencies,
        UnitDependencies: _dependenciesUnitClassGenerated.UnitDependencies,
        createAvogadro: _factoriesAny.createAvogadro
      };
    }
  });

  // node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/entry/dependenciesAny/dependenciesIsNegative.generated.js
  var require_dependenciesIsNegative_generated = __commonJS({
    "node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/entry/dependenciesAny/dependenciesIsNegative.generated.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.isNegativeDependencies = void 0;
      var _dependenciesTypedGenerated = require_dependenciesTyped_generated();
      var _factoriesAny = require_factoriesAny();
      var isNegativeDependencies = exports.isNegativeDependencies = {
        typedDependencies: _dependenciesTypedGenerated.typedDependencies,
        createIsNegative: _factoriesAny.createIsNegative
      };
    }
  });

  // node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/entry/dependenciesAny/dependenciesCombinations.generated.js
  var require_dependenciesCombinations_generated = __commonJS({
    "node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/entry/dependenciesAny/dependenciesCombinations.generated.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.combinationsDependencies = void 0;
      var _dependenciesTypedGenerated = require_dependenciesTyped_generated();
      var _factoriesAny = require_factoriesAny();
      var combinationsDependencies = exports.combinationsDependencies = {
        typedDependencies: _dependenciesTypedGenerated.typedDependencies,
        createCombinations: _factoriesAny.createCombinations
      };
    }
  });

  // node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/entry/dependenciesAny/dependenciesGamma.generated.js
  var require_dependenciesGamma_generated = __commonJS({
    "node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/entry/dependenciesAny/dependenciesGamma.generated.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.gammaDependencies = void 0;
      var _dependenciesBigNumberClassGenerated = require_dependenciesBigNumberClass_generated();
      var _dependenciesComplexClassGenerated = require_dependenciesComplexClass_generated();
      var _dependenciesMultiplyScalarGenerated = require_dependenciesMultiplyScalar_generated();
      var _dependenciesPowGenerated = require_dependenciesPow_generated();
      var _dependenciesTypedGenerated = require_dependenciesTyped_generated();
      var _factoriesAny = require_factoriesAny();
      var gammaDependencies = exports.gammaDependencies = {
        BigNumberDependencies: _dependenciesBigNumberClassGenerated.BigNumberDependencies,
        ComplexDependencies: _dependenciesComplexClassGenerated.ComplexDependencies,
        multiplyScalarDependencies: _dependenciesMultiplyScalarGenerated.multiplyScalarDependencies,
        powDependencies: _dependenciesPowGenerated.powDependencies,
        typedDependencies: _dependenciesTypedGenerated.typedDependencies,
        createGamma: _factoriesAny.createGamma
      };
    }
  });

  // node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/entry/dependenciesAny/dependenciesFactorial.generated.js
  var require_dependenciesFactorial_generated = __commonJS({
    "node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/entry/dependenciesAny/dependenciesFactorial.generated.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.factorialDependencies = void 0;
      var _dependenciesGammaGenerated = require_dependenciesGamma_generated();
      var _dependenciesTypedGenerated = require_dependenciesTyped_generated();
      var _factoriesAny = require_factoriesAny();
      var factorialDependencies = exports.factorialDependencies = {
        gammaDependencies: _dependenciesGammaGenerated.gammaDependencies,
        typedDependencies: _dependenciesTypedGenerated.typedDependencies,
        createFactorial: _factoriesAny.createFactorial
      };
    }
  });

  // node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/entry/dependenciesAny/dependenciesLarger.generated.js
  var require_dependenciesLarger_generated = __commonJS({
    "node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/entry/dependenciesAny/dependenciesLarger.generated.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.largerDependencies = void 0;
      var _dependenciesDenseMatrixClassGenerated = require_dependenciesDenseMatrixClass_generated();
      var _dependenciesConcatGenerated = require_dependenciesConcat_generated();
      var _dependenciesMatrixGenerated = require_dependenciesMatrix_generated();
      var _dependenciesTypedGenerated = require_dependenciesTyped_generated();
      var _factoriesAny = require_factoriesAny();
      var largerDependencies = exports.largerDependencies = {
        DenseMatrixDependencies: _dependenciesDenseMatrixClassGenerated.DenseMatrixDependencies,
        concatDependencies: _dependenciesConcatGenerated.concatDependencies,
        matrixDependencies: _dependenciesMatrixGenerated.matrixDependencies,
        typedDependencies: _dependenciesTypedGenerated.typedDependencies,
        createLarger: _factoriesAny.createLarger
      };
    }
  });

  // node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/entry/dependenciesAny/dependenciesStirlingS2.generated.js
  var require_dependenciesStirlingS2_generated = __commonJS({
    "node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/entry/dependenciesAny/dependenciesStirlingS2.generated.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.stirlingS2Dependencies = void 0;
      var _dependenciesBignumberGenerated = require_dependenciesBignumber_generated();
      var _dependenciesAddScalarGenerated = require_dependenciesAddScalar_generated();
      var _dependenciesCombinationsGenerated = require_dependenciesCombinations_generated();
      var _dependenciesDivideScalarGenerated = require_dependenciesDivideScalar_generated();
      var _dependenciesFactorialGenerated = require_dependenciesFactorial_generated();
      var _dependenciesIsIntegerGenerated = require_dependenciesIsInteger_generated();
      var _dependenciesIsNegativeGenerated = require_dependenciesIsNegative_generated();
      var _dependenciesLargerGenerated = require_dependenciesLarger_generated();
      var _dependenciesMultiplyScalarGenerated = require_dependenciesMultiplyScalar_generated();
      var _dependenciesNumberGenerated = require_dependenciesNumber_generated();
      var _dependenciesPowGenerated = require_dependenciesPow_generated();
      var _dependenciesSubtractScalarGenerated = require_dependenciesSubtractScalar_generated();
      var _dependenciesTypedGenerated = require_dependenciesTyped_generated();
      var _factoriesAny = require_factoriesAny();
      var stirlingS2Dependencies = exports.stirlingS2Dependencies = {
        bignumberDependencies: _dependenciesBignumberGenerated.bignumberDependencies,
        addScalarDependencies: _dependenciesAddScalarGenerated.addScalarDependencies,
        combinationsDependencies: _dependenciesCombinationsGenerated.combinationsDependencies,
        divideScalarDependencies: _dependenciesDivideScalarGenerated.divideScalarDependencies,
        factorialDependencies: _dependenciesFactorialGenerated.factorialDependencies,
        isIntegerDependencies: _dependenciesIsIntegerGenerated.isIntegerDependencies,
        isNegativeDependencies: _dependenciesIsNegativeGenerated.isNegativeDependencies,
        largerDependencies: _dependenciesLargerGenerated.largerDependencies,
        multiplyScalarDependencies: _dependenciesMultiplyScalarGenerated.multiplyScalarDependencies,
        numberDependencies: _dependenciesNumberGenerated.numberDependencies,
        powDependencies: _dependenciesPowGenerated.powDependencies,
        subtractScalarDependencies: _dependenciesSubtractScalarGenerated.subtractScalarDependencies,
        typedDependencies: _dependenciesTypedGenerated.typedDependencies,
        createStirlingS2: _factoriesAny.createStirlingS2
      };
    }
  });

  // node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/entry/dependenciesAny/dependenciesBellNumbers.generated.js
  var require_dependenciesBellNumbers_generated = __commonJS({
    "node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/entry/dependenciesAny/dependenciesBellNumbers.generated.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.bellNumbersDependencies = void 0;
      var _dependenciesAddScalarGenerated = require_dependenciesAddScalar_generated();
      var _dependenciesIsIntegerGenerated = require_dependenciesIsInteger_generated();
      var _dependenciesIsNegativeGenerated = require_dependenciesIsNegative_generated();
      var _dependenciesStirlingS2Generated = require_dependenciesStirlingS2_generated();
      var _dependenciesTypedGenerated = require_dependenciesTyped_generated();
      var _factoriesAny = require_factoriesAny();
      var bellNumbersDependencies = exports.bellNumbersDependencies = {
        addScalarDependencies: _dependenciesAddScalarGenerated.addScalarDependencies,
        isIntegerDependencies: _dependenciesIsIntegerGenerated.isIntegerDependencies,
        isNegativeDependencies: _dependenciesIsNegativeGenerated.isNegativeDependencies,
        stirlingS2Dependencies: _dependenciesStirlingS2Generated.stirlingS2Dependencies,
        typedDependencies: _dependenciesTypedGenerated.typedDependencies,
        createBellNumbers: _factoriesAny.createBellNumbers
      };
    }
  });

  // node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/entry/dependenciesAny/dependenciesBin.generated.js
  var require_dependenciesBin_generated = __commonJS({
    "node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/entry/dependenciesAny/dependenciesBin.generated.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.binDependencies = void 0;
      var _dependenciesFormatGenerated = require_dependenciesFormat_generated();
      var _dependenciesTypedGenerated = require_dependenciesTyped_generated();
      var _factoriesAny = require_factoriesAny();
      var binDependencies = exports.binDependencies = {
        formatDependencies: _dependenciesFormatGenerated.formatDependencies,
        typedDependencies: _dependenciesTypedGenerated.typedDependencies,
        createBin: _factoriesAny.createBin
      };
    }
  });

  // node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/entry/dependenciesAny/dependenciesBitAnd.generated.js
  var require_dependenciesBitAnd_generated = __commonJS({
    "node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/entry/dependenciesAny/dependenciesBitAnd.generated.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.bitAndDependencies = void 0;
      var _dependenciesConcatGenerated = require_dependenciesConcat_generated();
      var _dependenciesEqualScalarGenerated = require_dependenciesEqualScalar_generated();
      var _dependenciesMatrixGenerated = require_dependenciesMatrix_generated();
      var _dependenciesTypedGenerated = require_dependenciesTyped_generated();
      var _factoriesAny = require_factoriesAny();
      var bitAndDependencies = exports.bitAndDependencies = {
        concatDependencies: _dependenciesConcatGenerated.concatDependencies,
        equalScalarDependencies: _dependenciesEqualScalarGenerated.equalScalarDependencies,
        matrixDependencies: _dependenciesMatrixGenerated.matrixDependencies,
        typedDependencies: _dependenciesTypedGenerated.typedDependencies,
        createBitAnd: _factoriesAny.createBitAnd
      };
    }
  });

  // node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/entry/dependenciesAny/dependenciesBitAndTransform.generated.js
  var require_dependenciesBitAndTransform_generated = __commonJS({
    "node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/entry/dependenciesAny/dependenciesBitAndTransform.generated.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.bitAndTransformDependencies = void 0;
      var _dependenciesAddGenerated = require_dependenciesAdd_generated();
      var _dependenciesConcatGenerated = require_dependenciesConcat_generated();
      var _dependenciesEqualScalarGenerated = require_dependenciesEqualScalar_generated();
      var _dependenciesMatrixGenerated = require_dependenciesMatrix_generated();
      var _dependenciesNotGenerated = require_dependenciesNot_generated();
      var _dependenciesTypedGenerated = require_dependenciesTyped_generated();
      var _dependenciesZerosGenerated = require_dependenciesZeros_generated();
      var _factoriesAny = require_factoriesAny();
      var bitAndTransformDependencies = exports.bitAndTransformDependencies = {
        addDependencies: _dependenciesAddGenerated.addDependencies,
        concatDependencies: _dependenciesConcatGenerated.concatDependencies,
        equalScalarDependencies: _dependenciesEqualScalarGenerated.equalScalarDependencies,
        matrixDependencies: _dependenciesMatrixGenerated.matrixDependencies,
        notDependencies: _dependenciesNotGenerated.notDependencies,
        typedDependencies: _dependenciesTypedGenerated.typedDependencies,
        zerosDependencies: _dependenciesZerosGenerated.zerosDependencies,
        createBitAndTransform: _factoriesAny.createBitAndTransform
      };
    }
  });

  // node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/entry/dependenciesAny/dependenciesBitNot.generated.js
  var require_dependenciesBitNot_generated = __commonJS({
    "node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/entry/dependenciesAny/dependenciesBitNot.generated.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.bitNotDependencies = void 0;
      var _dependenciesTypedGenerated = require_dependenciesTyped_generated();
      var _factoriesAny = require_factoriesAny();
      var bitNotDependencies = exports.bitNotDependencies = {
        typedDependencies: _dependenciesTypedGenerated.typedDependencies,
        createBitNot: _factoriesAny.createBitNot
      };
    }
  });

  // node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/entry/dependenciesAny/dependenciesBitOr.generated.js
  var require_dependenciesBitOr_generated = __commonJS({
    "node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/entry/dependenciesAny/dependenciesBitOr.generated.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.bitOrDependencies = void 0;
      var _dependenciesDenseMatrixClassGenerated = require_dependenciesDenseMatrixClass_generated();
      var _dependenciesConcatGenerated = require_dependenciesConcat_generated();
      var _dependenciesEqualScalarGenerated = require_dependenciesEqualScalar_generated();
      var _dependenciesMatrixGenerated = require_dependenciesMatrix_generated();
      var _dependenciesTypedGenerated = require_dependenciesTyped_generated();
      var _factoriesAny = require_factoriesAny();
      var bitOrDependencies = exports.bitOrDependencies = {
        DenseMatrixDependencies: _dependenciesDenseMatrixClassGenerated.DenseMatrixDependencies,
        concatDependencies: _dependenciesConcatGenerated.concatDependencies,
        equalScalarDependencies: _dependenciesEqualScalarGenerated.equalScalarDependencies,
        matrixDependencies: _dependenciesMatrixGenerated.matrixDependencies,
        typedDependencies: _dependenciesTypedGenerated.typedDependencies,
        createBitOr: _factoriesAny.createBitOr
      };
    }
  });

  // node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/entry/dependenciesAny/dependenciesBitOrTransform.generated.js
  var require_dependenciesBitOrTransform_generated = __commonJS({
    "node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/entry/dependenciesAny/dependenciesBitOrTransform.generated.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.bitOrTransformDependencies = void 0;
      var _dependenciesDenseMatrixClassGenerated = require_dependenciesDenseMatrixClass_generated();
      var _dependenciesConcatGenerated = require_dependenciesConcat_generated();
      var _dependenciesEqualScalarGenerated = require_dependenciesEqualScalar_generated();
      var _dependenciesMatrixGenerated = require_dependenciesMatrix_generated();
      var _dependenciesTypedGenerated = require_dependenciesTyped_generated();
      var _factoriesAny = require_factoriesAny();
      var bitOrTransformDependencies = exports.bitOrTransformDependencies = {
        DenseMatrixDependencies: _dependenciesDenseMatrixClassGenerated.DenseMatrixDependencies,
        concatDependencies: _dependenciesConcatGenerated.concatDependencies,
        equalScalarDependencies: _dependenciesEqualScalarGenerated.equalScalarDependencies,
        matrixDependencies: _dependenciesMatrixGenerated.matrixDependencies,
        typedDependencies: _dependenciesTypedGenerated.typedDependencies,
        createBitOrTransform: _factoriesAny.createBitOrTransform
      };
    }
  });

  // node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/entry/dependenciesAny/dependenciesBitXor.generated.js
  var require_dependenciesBitXor_generated = __commonJS({
    "node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/entry/dependenciesAny/dependenciesBitXor.generated.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.bitXorDependencies = void 0;
      var _dependenciesDenseMatrixClassGenerated = require_dependenciesDenseMatrixClass_generated();
      var _dependenciesConcatGenerated = require_dependenciesConcat_generated();
      var _dependenciesMatrixGenerated = require_dependenciesMatrix_generated();
      var _dependenciesTypedGenerated = require_dependenciesTyped_generated();
      var _factoriesAny = require_factoriesAny();
      var bitXorDependencies = exports.bitXorDependencies = {
        DenseMatrixDependencies: _dependenciesDenseMatrixClassGenerated.DenseMatrixDependencies,
        concatDependencies: _dependenciesConcatGenerated.concatDependencies,
        matrixDependencies: _dependenciesMatrixGenerated.matrixDependencies,
        typedDependencies: _dependenciesTypedGenerated.typedDependencies,
        createBitXor: _factoriesAny.createBitXor
      };
    }
  });

  // node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/entry/dependenciesAny/dependenciesResultSet.generated.js
  var require_dependenciesResultSet_generated = __commonJS({
    "node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/entry/dependenciesAny/dependenciesResultSet.generated.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.ResultSetDependencies = void 0;
      var _factoriesAny = require_factoriesAny();
      var ResultSetDependencies = exports.ResultSetDependencies = {
        createResultSet: _factoriesAny.createResultSet
      };
    }
  });

  // node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/entry/dependenciesAny/dependenciesBlockNode.generated.js
  var require_dependenciesBlockNode_generated = __commonJS({
    "node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/entry/dependenciesAny/dependenciesBlockNode.generated.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.BlockNodeDependencies = void 0;
      var _dependenciesNodeGenerated = require_dependenciesNode_generated();
      var _dependenciesResultSetGenerated = require_dependenciesResultSet_generated();
      var _factoriesAny = require_factoriesAny();
      var BlockNodeDependencies = exports.BlockNodeDependencies = {
        NodeDependencies: _dependenciesNodeGenerated.NodeDependencies,
        ResultSetDependencies: _dependenciesResultSetGenerated.ResultSetDependencies,
        createBlockNode: _factoriesAny.createBlockNode
      };
    }
  });

  // node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/entry/dependenciesAny/dependenciesBohrMagneton.generated.js
  var require_dependenciesBohrMagneton_generated = __commonJS({
    "node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/entry/dependenciesAny/dependenciesBohrMagneton.generated.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.bohrMagnetonDependencies = void 0;
      var _dependenciesBigNumberClassGenerated = require_dependenciesBigNumberClass_generated();
      var _dependenciesUnitClassGenerated = require_dependenciesUnitClass_generated();
      var _factoriesAny = require_factoriesAny();
      var bohrMagnetonDependencies = exports.bohrMagnetonDependencies = {
        BigNumberDependencies: _dependenciesBigNumberClassGenerated.BigNumberDependencies,
        UnitDependencies: _dependenciesUnitClassGenerated.UnitDependencies,
        createBohrMagneton: _factoriesAny.createBohrMagneton
      };
    }
  });

  // node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/entry/dependenciesAny/dependenciesBohrRadius.generated.js
  var require_dependenciesBohrRadius_generated = __commonJS({
    "node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/entry/dependenciesAny/dependenciesBohrRadius.generated.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.bohrRadiusDependencies = void 0;
      var _dependenciesBigNumberClassGenerated = require_dependenciesBigNumberClass_generated();
      var _dependenciesUnitClassGenerated = require_dependenciesUnitClass_generated();
      var _factoriesAny = require_factoriesAny();
      var bohrRadiusDependencies = exports.bohrRadiusDependencies = {
        BigNumberDependencies: _dependenciesBigNumberClassGenerated.BigNumberDependencies,
        UnitDependencies: _dependenciesUnitClassGenerated.UnitDependencies,
        createBohrRadius: _factoriesAny.createBohrRadius
      };
    }
  });

  // node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/entry/dependenciesAny/dependenciesBoltzmann.generated.js
  var require_dependenciesBoltzmann_generated = __commonJS({
    "node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/entry/dependenciesAny/dependenciesBoltzmann.generated.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.boltzmannDependencies = void 0;
      var _dependenciesBigNumberClassGenerated = require_dependenciesBigNumberClass_generated();
      var _dependenciesUnitClassGenerated = require_dependenciesUnitClass_generated();
      var _factoriesAny = require_factoriesAny();
      var boltzmannDependencies = exports.boltzmannDependencies = {
        BigNumberDependencies: _dependenciesBigNumberClassGenerated.BigNumberDependencies,
        UnitDependencies: _dependenciesUnitClassGenerated.UnitDependencies,
        createBoltzmann: _factoriesAny.createBoltzmann
      };
    }
  });

  // node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/entry/dependenciesAny/dependenciesBoolean.generated.js
  var require_dependenciesBoolean_generated = __commonJS({
    "node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/entry/dependenciesAny/dependenciesBoolean.generated.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.booleanDependencies = void 0;
      var _dependenciesTypedGenerated = require_dependenciesTyped_generated();
      var _factoriesAny = require_factoriesAny();
      var booleanDependencies = exports.booleanDependencies = {
        typedDependencies: _dependenciesTypedGenerated.typedDependencies,
        createBoolean: _factoriesAny.createBoolean
      };
    }
  });

  // node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/entry/dependenciesAny/dependenciesCatalan.generated.js
  var require_dependenciesCatalan_generated = __commonJS({
    "node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/entry/dependenciesAny/dependenciesCatalan.generated.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.catalanDependencies = void 0;
      var _dependenciesAddScalarGenerated = require_dependenciesAddScalar_generated();
      var _dependenciesCombinationsGenerated = require_dependenciesCombinations_generated();
      var _dependenciesDivideScalarGenerated = require_dependenciesDivideScalar_generated();
      var _dependenciesIsIntegerGenerated = require_dependenciesIsInteger_generated();
      var _dependenciesIsNegativeGenerated = require_dependenciesIsNegative_generated();
      var _dependenciesMultiplyScalarGenerated = require_dependenciesMultiplyScalar_generated();
      var _dependenciesTypedGenerated = require_dependenciesTyped_generated();
      var _factoriesAny = require_factoriesAny();
      var catalanDependencies = exports.catalanDependencies = {
        addScalarDependencies: _dependenciesAddScalarGenerated.addScalarDependencies,
        combinationsDependencies: _dependenciesCombinationsGenerated.combinationsDependencies,
        divideScalarDependencies: _dependenciesDivideScalarGenerated.divideScalarDependencies,
        isIntegerDependencies: _dependenciesIsIntegerGenerated.isIntegerDependencies,
        isNegativeDependencies: _dependenciesIsNegativeGenerated.isNegativeDependencies,
        multiplyScalarDependencies: _dependenciesMultiplyScalarGenerated.multiplyScalarDependencies,
        typedDependencies: _dependenciesTypedGenerated.typedDependencies,
        createCatalan: _factoriesAny.createCatalan
      };
    }
  });

  // node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/entry/dependenciesAny/dependenciesCbrt.generated.js
  var require_dependenciesCbrt_generated = __commonJS({
    "node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/entry/dependenciesAny/dependenciesCbrt.generated.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.cbrtDependencies = void 0;
      var _dependenciesBigNumberClassGenerated = require_dependenciesBigNumberClass_generated();
      var _dependenciesComplexClassGenerated = require_dependenciesComplexClass_generated();
      var _dependenciesFractionClassGenerated = require_dependenciesFractionClass_generated();
      var _dependenciesIsNegativeGenerated = require_dependenciesIsNegative_generated();
      var _dependenciesMatrixGenerated = require_dependenciesMatrix_generated();
      var _dependenciesTypedGenerated = require_dependenciesTyped_generated();
      var _dependenciesUnaryMinusGenerated = require_dependenciesUnaryMinus_generated();
      var _factoriesAny = require_factoriesAny();
      var cbrtDependencies = exports.cbrtDependencies = {
        BigNumberDependencies: _dependenciesBigNumberClassGenerated.BigNumberDependencies,
        ComplexDependencies: _dependenciesComplexClassGenerated.ComplexDependencies,
        FractionDependencies: _dependenciesFractionClassGenerated.FractionDependencies,
        isNegativeDependencies: _dependenciesIsNegativeGenerated.isNegativeDependencies,
        matrixDependencies: _dependenciesMatrixGenerated.matrixDependencies,
        typedDependencies: _dependenciesTypedGenerated.typedDependencies,
        unaryMinusDependencies: _dependenciesUnaryMinusGenerated.unaryMinusDependencies,
        createCbrt: _factoriesAny.createCbrt
      };
    }
  });

  // node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/entry/dependenciesAny/dependenciesChainClass.generated.js
  var require_dependenciesChainClass_generated = __commonJS({
    "node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/entry/dependenciesAny/dependenciesChainClass.generated.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.ChainDependencies = void 0;
      var _dependenciesTypedGenerated = require_dependenciesTyped_generated();
      var _factoriesAny = require_factoriesAny();
      var ChainDependencies = exports.ChainDependencies = {
        typedDependencies: _dependenciesTypedGenerated.typedDependencies,
        createChainClass: _factoriesAny.createChainClass
      };
    }
  });

  // node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/entry/dependenciesAny/dependenciesChain.generated.js
  var require_dependenciesChain_generated = __commonJS({
    "node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/entry/dependenciesAny/dependenciesChain.generated.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.chainDependencies = void 0;
      var _dependenciesChainClassGenerated = require_dependenciesChainClass_generated();
      var _dependenciesTypedGenerated = require_dependenciesTyped_generated();
      var _factoriesAny = require_factoriesAny();
      var chainDependencies = exports.chainDependencies = {
        ChainDependencies: _dependenciesChainClassGenerated.ChainDependencies,
        typedDependencies: _dependenciesTypedGenerated.typedDependencies,
        createChain: _factoriesAny.createChain
      };
    }
  });

  // node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/entry/dependenciesAny/dependenciesClassicalElectronRadius.generated.js
  var require_dependenciesClassicalElectronRadius_generated = __commonJS({
    "node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/entry/dependenciesAny/dependenciesClassicalElectronRadius.generated.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.classicalElectronRadiusDependencies = void 0;
      var _dependenciesBigNumberClassGenerated = require_dependenciesBigNumberClass_generated();
      var _dependenciesUnitClassGenerated = require_dependenciesUnitClass_generated();
      var _factoriesAny = require_factoriesAny();
      var classicalElectronRadiusDependencies = exports.classicalElectronRadiusDependencies = {
        BigNumberDependencies: _dependenciesBigNumberClassGenerated.BigNumberDependencies,
        UnitDependencies: _dependenciesUnitClassGenerated.UnitDependencies,
        createClassicalElectronRadius: _factoriesAny.createClassicalElectronRadius
      };
    }
  });

  // node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/entry/dependenciesAny/dependenciesClone.generated.js
  var require_dependenciesClone_generated = __commonJS({
    "node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/entry/dependenciesAny/dependenciesClone.generated.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.cloneDependencies = void 0;
      var _dependenciesTypedGenerated = require_dependenciesTyped_generated();
      var _factoriesAny = require_factoriesAny();
      var cloneDependencies = exports.cloneDependencies = {
        typedDependencies: _dependenciesTypedGenerated.typedDependencies,
        createClone: _factoriesAny.createClone
      };
    }
  });

  // node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/entry/dependenciesAny/dependenciesSmaller.generated.js
  var require_dependenciesSmaller_generated = __commonJS({
    "node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/entry/dependenciesAny/dependenciesSmaller.generated.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.smallerDependencies = void 0;
      var _dependenciesDenseMatrixClassGenerated = require_dependenciesDenseMatrixClass_generated();
      var _dependenciesConcatGenerated = require_dependenciesConcat_generated();
      var _dependenciesMatrixGenerated = require_dependenciesMatrix_generated();
      var _dependenciesTypedGenerated = require_dependenciesTyped_generated();
      var _factoriesAny = require_factoriesAny();
      var smallerDependencies = exports.smallerDependencies = {
        DenseMatrixDependencies: _dependenciesDenseMatrixClassGenerated.DenseMatrixDependencies,
        concatDependencies: _dependenciesConcatGenerated.concatDependencies,
        matrixDependencies: _dependenciesMatrixGenerated.matrixDependencies,
        typedDependencies: _dependenciesTypedGenerated.typedDependencies,
        createSmaller: _factoriesAny.createSmaller
      };
    }
  });

  // node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/entry/dependenciesAny/dependenciesImmutableDenseMatrixClass.generated.js
  var require_dependenciesImmutableDenseMatrixClass_generated = __commonJS({
    "node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/entry/dependenciesAny/dependenciesImmutableDenseMatrixClass.generated.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.ImmutableDenseMatrixDependencies = void 0;
      var _dependenciesDenseMatrixClassGenerated = require_dependenciesDenseMatrixClass_generated();
      var _dependenciesSmallerGenerated = require_dependenciesSmaller_generated();
      var _factoriesAny = require_factoriesAny();
      var ImmutableDenseMatrixDependencies = exports.ImmutableDenseMatrixDependencies = {
        DenseMatrixDependencies: _dependenciesDenseMatrixClassGenerated.DenseMatrixDependencies,
        smallerDependencies: _dependenciesSmallerGenerated.smallerDependencies,
        createImmutableDenseMatrixClass: _factoriesAny.createImmutableDenseMatrixClass
      };
    }
  });

  // node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/entry/dependenciesAny/dependenciesGetMatrixDataType.generated.js
  var require_dependenciesGetMatrixDataType_generated = __commonJS({
    "node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/entry/dependenciesAny/dependenciesGetMatrixDataType.generated.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.getMatrixDataTypeDependencies = void 0;
      var _dependenciesTypedGenerated = require_dependenciesTyped_generated();
      var _factoriesAny = require_factoriesAny();
      var getMatrixDataTypeDependencies = exports.getMatrixDataTypeDependencies = {
        typedDependencies: _dependenciesTypedGenerated.typedDependencies,
        createGetMatrixDataType: _factoriesAny.createGetMatrixDataType
      };
    }
  });

  // node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/entry/dependenciesAny/dependenciesIndexClass.generated.js
  var require_dependenciesIndexClass_generated = __commonJS({
    "node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/entry/dependenciesAny/dependenciesIndexClass.generated.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.IndexDependencies = void 0;
      var _dependenciesImmutableDenseMatrixClassGenerated = require_dependenciesImmutableDenseMatrixClass_generated();
      var _dependenciesGetMatrixDataTypeGenerated = require_dependenciesGetMatrixDataType_generated();
      var _factoriesAny = require_factoriesAny();
      var IndexDependencies = exports.IndexDependencies = {
        ImmutableDenseMatrixDependencies: _dependenciesImmutableDenseMatrixClassGenerated.ImmutableDenseMatrixDependencies,
        getMatrixDataTypeDependencies: _dependenciesGetMatrixDataTypeGenerated.getMatrixDataTypeDependencies,
        createIndexClass: _factoriesAny.createIndexClass
      };
    }
  });

  // node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/entry/dependenciesAny/dependenciesIsPositive.generated.js
  var require_dependenciesIsPositive_generated = __commonJS({
    "node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/entry/dependenciesAny/dependenciesIsPositive.generated.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.isPositiveDependencies = void 0;
      var _dependenciesTypedGenerated = require_dependenciesTyped_generated();
      var _factoriesAny = require_factoriesAny();
      var isPositiveDependencies = exports.isPositiveDependencies = {
        typedDependencies: _dependenciesTypedGenerated.typedDependencies,
        createIsPositive: _factoriesAny.createIsPositive
      };
    }
  });

  // node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/entry/dependenciesAny/dependenciesLargerEq.generated.js
  var require_dependenciesLargerEq_generated = __commonJS({
    "node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/entry/dependenciesAny/dependenciesLargerEq.generated.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.largerEqDependencies = void 0;
      var _dependenciesDenseMatrixClassGenerated = require_dependenciesDenseMatrixClass_generated();
      var _dependenciesConcatGenerated = require_dependenciesConcat_generated();
      var _dependenciesMatrixGenerated = require_dependenciesMatrix_generated();
      var _dependenciesTypedGenerated = require_dependenciesTyped_generated();
      var _factoriesAny = require_factoriesAny();
      var largerEqDependencies = exports.largerEqDependencies = {
        DenseMatrixDependencies: _dependenciesDenseMatrixClassGenerated.DenseMatrixDependencies,
        concatDependencies: _dependenciesConcatGenerated.concatDependencies,
        matrixDependencies: _dependenciesMatrixGenerated.matrixDependencies,
        typedDependencies: _dependenciesTypedGenerated.typedDependencies,
        createLargerEq: _factoriesAny.createLargerEq
      };
    }
  });

  // node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/entry/dependenciesAny/dependenciesSmallerEq.generated.js
  var require_dependenciesSmallerEq_generated = __commonJS({
    "node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/entry/dependenciesAny/dependenciesSmallerEq.generated.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.smallerEqDependencies = void 0;
      var _dependenciesDenseMatrixClassGenerated = require_dependenciesDenseMatrixClass_generated();
      var _dependenciesConcatGenerated = require_dependenciesConcat_generated();
      var _dependenciesMatrixGenerated = require_dependenciesMatrix_generated();
      var _dependenciesTypedGenerated = require_dependenciesTyped_generated();
      var _factoriesAny = require_factoriesAny();
      var smallerEqDependencies = exports.smallerEqDependencies = {
        DenseMatrixDependencies: _dependenciesDenseMatrixClassGenerated.DenseMatrixDependencies,
        concatDependencies: _dependenciesConcatGenerated.concatDependencies,
        matrixDependencies: _dependenciesMatrixGenerated.matrixDependencies,
        typedDependencies: _dependenciesTypedGenerated.typedDependencies,
        createSmallerEq: _factoriesAny.createSmallerEq
      };
    }
  });

  // node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/entry/dependenciesAny/dependenciesRange.generated.js
  var require_dependenciesRange_generated = __commonJS({
    "node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/entry/dependenciesAny/dependenciesRange.generated.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.rangeDependencies = void 0;
      var _dependenciesBignumberGenerated = require_dependenciesBignumber_generated();
      var _dependenciesMatrixGenerated = require_dependenciesMatrix_generated();
      var _dependenciesAddGenerated = require_dependenciesAdd_generated();
      var _dependenciesIsPositiveGenerated = require_dependenciesIsPositive_generated();
      var _dependenciesLargerGenerated = require_dependenciesLarger_generated();
      var _dependenciesLargerEqGenerated = require_dependenciesLargerEq_generated();
      var _dependenciesSmallerGenerated = require_dependenciesSmaller_generated();
      var _dependenciesSmallerEqGenerated = require_dependenciesSmallerEq_generated();
      var _dependenciesTypedGenerated = require_dependenciesTyped_generated();
      var _factoriesAny = require_factoriesAny();
      var rangeDependencies = exports.rangeDependencies = {
        bignumberDependencies: _dependenciesBignumberGenerated.bignumberDependencies,
        matrixDependencies: _dependenciesMatrixGenerated.matrixDependencies,
        addDependencies: _dependenciesAddGenerated.addDependencies,
        isPositiveDependencies: _dependenciesIsPositiveGenerated.isPositiveDependencies,
        largerDependencies: _dependenciesLargerGenerated.largerDependencies,
        largerEqDependencies: _dependenciesLargerEqGenerated.largerEqDependencies,
        smallerDependencies: _dependenciesSmallerGenerated.smallerDependencies,
        smallerEqDependencies: _dependenciesSmallerEqGenerated.smallerEqDependencies,
        typedDependencies: _dependenciesTypedGenerated.typedDependencies,
        createRange: _factoriesAny.createRange
      };
    }
  });

  // node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/entry/dependenciesAny/dependenciesColumn.generated.js
  var require_dependenciesColumn_generated = __commonJS({
    "node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/entry/dependenciesAny/dependenciesColumn.generated.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.columnDependencies = void 0;
      var _dependenciesIndexClassGenerated = require_dependenciesIndexClass_generated();
      var _dependenciesMatrixGenerated = require_dependenciesMatrix_generated();
      var _dependenciesRangeGenerated = require_dependenciesRange_generated();
      var _dependenciesTypedGenerated = require_dependenciesTyped_generated();
      var _factoriesAny = require_factoriesAny();
      var columnDependencies = exports.columnDependencies = {
        IndexDependencies: _dependenciesIndexClassGenerated.IndexDependencies,
        matrixDependencies: _dependenciesMatrixGenerated.matrixDependencies,
        rangeDependencies: _dependenciesRangeGenerated.rangeDependencies,
        typedDependencies: _dependenciesTypedGenerated.typedDependencies,
        createColumn: _factoriesAny.createColumn
      };
    }
  });

  // node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/entry/dependenciesAny/dependenciesColumnTransform.generated.js
  var require_dependenciesColumnTransform_generated = __commonJS({
    "node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/entry/dependenciesAny/dependenciesColumnTransform.generated.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.columnTransformDependencies = void 0;
      var _dependenciesIndexClassGenerated = require_dependenciesIndexClass_generated();
      var _dependenciesMatrixGenerated = require_dependenciesMatrix_generated();
      var _dependenciesRangeGenerated = require_dependenciesRange_generated();
      var _dependenciesTypedGenerated = require_dependenciesTyped_generated();
      var _factoriesAny = require_factoriesAny();
      var columnTransformDependencies = exports.columnTransformDependencies = {
        IndexDependencies: _dependenciesIndexClassGenerated.IndexDependencies,
        matrixDependencies: _dependenciesMatrixGenerated.matrixDependencies,
        rangeDependencies: _dependenciesRangeGenerated.rangeDependencies,
        typedDependencies: _dependenciesTypedGenerated.typedDependencies,
        createColumnTransform: _factoriesAny.createColumnTransform
      };
    }
  });

  // node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/entry/dependenciesAny/dependenciesCombinationsWithRep.generated.js
  var require_dependenciesCombinationsWithRep_generated = __commonJS({
    "node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/entry/dependenciesAny/dependenciesCombinationsWithRep.generated.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.combinationsWithRepDependencies = void 0;
      var _dependenciesTypedGenerated = require_dependenciesTyped_generated();
      var _factoriesAny = require_factoriesAny();
      var combinationsWithRepDependencies = exports.combinationsWithRepDependencies = {
        typedDependencies: _dependenciesTypedGenerated.typedDependencies,
        createCombinationsWithRep: _factoriesAny.createCombinationsWithRep
      };
    }
  });

  // node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/entry/dependenciesAny/dependenciesCompare.generated.js
  var require_dependenciesCompare_generated = __commonJS({
    "node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/entry/dependenciesAny/dependenciesCompare.generated.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.compareDependencies = void 0;
      var _dependenciesBigNumberClassGenerated = require_dependenciesBigNumberClass_generated();
      var _dependenciesDenseMatrixClassGenerated = require_dependenciesDenseMatrixClass_generated();
      var _dependenciesFractionClassGenerated = require_dependenciesFractionClass_generated();
      var _dependenciesConcatGenerated = require_dependenciesConcat_generated();
      var _dependenciesEqualScalarGenerated = require_dependenciesEqualScalar_generated();
      var _dependenciesMatrixGenerated = require_dependenciesMatrix_generated();
      var _dependenciesTypedGenerated = require_dependenciesTyped_generated();
      var _factoriesAny = require_factoriesAny();
      var compareDependencies = exports.compareDependencies = {
        BigNumberDependencies: _dependenciesBigNumberClassGenerated.BigNumberDependencies,
        DenseMatrixDependencies: _dependenciesDenseMatrixClassGenerated.DenseMatrixDependencies,
        FractionDependencies: _dependenciesFractionClassGenerated.FractionDependencies,
        concatDependencies: _dependenciesConcatGenerated.concatDependencies,
        equalScalarDependencies: _dependenciesEqualScalarGenerated.equalScalarDependencies,
        matrixDependencies: _dependenciesMatrixGenerated.matrixDependencies,
        typedDependencies: _dependenciesTypedGenerated.typedDependencies,
        createCompare: _factoriesAny.createCompare
      };
    }
  });

  // node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/entry/dependenciesAny/dependenciesCompareNatural.generated.js
  var require_dependenciesCompareNatural_generated = __commonJS({
    "node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/entry/dependenciesAny/dependenciesCompareNatural.generated.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.compareNaturalDependencies = void 0;
      var _dependenciesCompareGenerated = require_dependenciesCompare_generated();
      var _dependenciesTypedGenerated = require_dependenciesTyped_generated();
      var _factoriesAny = require_factoriesAny();
      var compareNaturalDependencies = exports.compareNaturalDependencies = {
        compareDependencies: _dependenciesCompareGenerated.compareDependencies,
        typedDependencies: _dependenciesTypedGenerated.typedDependencies,
        createCompareNatural: _factoriesAny.createCompareNatural
      };
    }
  });

  // node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/entry/dependenciesAny/dependenciesCompareText.generated.js
  var require_dependenciesCompareText_generated = __commonJS({
    "node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/entry/dependenciesAny/dependenciesCompareText.generated.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.compareTextDependencies = void 0;
      var _dependenciesConcatGenerated = require_dependenciesConcat_generated();
      var _dependenciesMatrixGenerated = require_dependenciesMatrix_generated();
      var _dependenciesTypedGenerated = require_dependenciesTyped_generated();
      var _factoriesAny = require_factoriesAny();
      var compareTextDependencies = exports.compareTextDependencies = {
        concatDependencies: _dependenciesConcatGenerated.concatDependencies,
        matrixDependencies: _dependenciesMatrixGenerated.matrixDependencies,
        typedDependencies: _dependenciesTypedGenerated.typedDependencies,
        createCompareText: _factoriesAny.createCompareText
      };
    }
  });

  // node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/entry/dependenciesAny/dependenciesConditionalNode.generated.js
  var require_dependenciesConditionalNode_generated = __commonJS({
    "node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/entry/dependenciesAny/dependenciesConditionalNode.generated.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.ConditionalNodeDependencies = void 0;
      var _dependenciesNodeGenerated = require_dependenciesNode_generated();
      var _factoriesAny = require_factoriesAny();
      var ConditionalNodeDependencies = exports.ConditionalNodeDependencies = {
        NodeDependencies: _dependenciesNodeGenerated.NodeDependencies,
        createConditionalNode: _factoriesAny.createConditionalNode
      };
    }
  });

  // node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/entry/dependenciesAny/dependenciesConstantNode.generated.js
  var require_dependenciesConstantNode_generated = __commonJS({
    "node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/entry/dependenciesAny/dependenciesConstantNode.generated.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.ConstantNodeDependencies = void 0;
      var _dependenciesNodeGenerated = require_dependenciesNode_generated();
      var _factoriesAny = require_factoriesAny();
      var ConstantNodeDependencies = exports.ConstantNodeDependencies = {
        NodeDependencies: _dependenciesNodeGenerated.NodeDependencies,
        createConstantNode: _factoriesAny.createConstantNode
      };
    }
  });

  // node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/entry/dependenciesAny/dependenciesFunctionAssignmentNode.generated.js
  var require_dependenciesFunctionAssignmentNode_generated = __commonJS({
    "node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/entry/dependenciesAny/dependenciesFunctionAssignmentNode.generated.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.FunctionAssignmentNodeDependencies = void 0;
      var _dependenciesNodeGenerated = require_dependenciesNode_generated();
      var _dependenciesTypedGenerated = require_dependenciesTyped_generated();
      var _factoriesAny = require_factoriesAny();
      var FunctionAssignmentNodeDependencies = exports.FunctionAssignmentNodeDependencies = {
        NodeDependencies: _dependenciesNodeGenerated.NodeDependencies,
        typedDependencies: _dependenciesTypedGenerated.typedDependencies,
        createFunctionAssignmentNode: _factoriesAny.createFunctionAssignmentNode
      };
    }
  });

  // node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/entry/dependenciesAny/dependenciesSymbolNode.generated.js
  var require_dependenciesSymbolNode_generated = __commonJS({
    "node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/entry/dependenciesAny/dependenciesSymbolNode.generated.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.SymbolNodeDependencies = void 0;
      var _dependenciesUnitClassGenerated = require_dependenciesUnitClass_generated();
      var _dependenciesNodeGenerated = require_dependenciesNode_generated();
      var _factoriesAny = require_factoriesAny();
      var SymbolNodeDependencies = exports.SymbolNodeDependencies = {
        UnitDependencies: _dependenciesUnitClassGenerated.UnitDependencies,
        NodeDependencies: _dependenciesNodeGenerated.NodeDependencies,
        createSymbolNode: _factoriesAny.createSymbolNode
      };
    }
  });

  // node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/entry/dependenciesAny/dependenciesFunctionNode.generated.js
  var require_dependenciesFunctionNode_generated = __commonJS({
    "node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/entry/dependenciesAny/dependenciesFunctionNode.generated.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.FunctionNodeDependencies = void 0;
      var _dependenciesNodeGenerated = require_dependenciesNode_generated();
      var _dependenciesSymbolNodeGenerated = require_dependenciesSymbolNode_generated();
      var _factoriesAny = require_factoriesAny();
      var FunctionNodeDependencies = exports.FunctionNodeDependencies = {
        NodeDependencies: _dependenciesNodeGenerated.NodeDependencies,
        SymbolNodeDependencies: _dependenciesSymbolNodeGenerated.SymbolNodeDependencies,
        createFunctionNode: _factoriesAny.createFunctionNode
      };
    }
  });

  // node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/entry/dependenciesAny/dependenciesIndexNode.generated.js
  var require_dependenciesIndexNode_generated = __commonJS({
    "node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/entry/dependenciesAny/dependenciesIndexNode.generated.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.IndexNodeDependencies = void 0;
      var _dependenciesNodeGenerated = require_dependenciesNode_generated();
      var _dependenciesSizeGenerated = require_dependenciesSize_generated();
      var _factoriesAny = require_factoriesAny();
      var IndexNodeDependencies = exports.IndexNodeDependencies = {
        NodeDependencies: _dependenciesNodeGenerated.NodeDependencies,
        sizeDependencies: _dependenciesSizeGenerated.sizeDependencies,
        createIndexNode: _factoriesAny.createIndexNode
      };
    }
  });

  // node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/entry/dependenciesAny/dependenciesObjectNode.generated.js
  var require_dependenciesObjectNode_generated = __commonJS({
    "node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/entry/dependenciesAny/dependenciesObjectNode.generated.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.ObjectNodeDependencies = void 0;
      var _dependenciesNodeGenerated = require_dependenciesNode_generated();
      var _factoriesAny = require_factoriesAny();
      var ObjectNodeDependencies = exports.ObjectNodeDependencies = {
        NodeDependencies: _dependenciesNodeGenerated.NodeDependencies,
        createObjectNode: _factoriesAny.createObjectNode
      };
    }
  });

  // node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/entry/dependenciesAny/dependenciesOperatorNode.generated.js
  var require_dependenciesOperatorNode_generated = __commonJS({
    "node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/entry/dependenciesAny/dependenciesOperatorNode.generated.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.OperatorNodeDependencies = void 0;
      var _dependenciesNodeGenerated = require_dependenciesNode_generated();
      var _factoriesAny = require_factoriesAny();
      var OperatorNodeDependencies = exports.OperatorNodeDependencies = {
        NodeDependencies: _dependenciesNodeGenerated.NodeDependencies,
        createOperatorNode: _factoriesAny.createOperatorNode
      };
    }
  });

  // node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/entry/dependenciesAny/dependenciesParenthesisNode.generated.js
  var require_dependenciesParenthesisNode_generated = __commonJS({
    "node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/entry/dependenciesAny/dependenciesParenthesisNode.generated.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.ParenthesisNodeDependencies = void 0;
      var _dependenciesNodeGenerated = require_dependenciesNode_generated();
      var _factoriesAny = require_factoriesAny();
      var ParenthesisNodeDependencies = exports.ParenthesisNodeDependencies = {
        NodeDependencies: _dependenciesNodeGenerated.NodeDependencies,
        createParenthesisNode: _factoriesAny.createParenthesisNode
      };
    }
  });

  // node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/entry/dependenciesAny/dependenciesRangeNode.generated.js
  var require_dependenciesRangeNode_generated = __commonJS({
    "node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/entry/dependenciesAny/dependenciesRangeNode.generated.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.RangeNodeDependencies = void 0;
      var _dependenciesNodeGenerated = require_dependenciesNode_generated();
      var _factoriesAny = require_factoriesAny();
      var RangeNodeDependencies = exports.RangeNodeDependencies = {
        NodeDependencies: _dependenciesNodeGenerated.NodeDependencies,
        createRangeNode: _factoriesAny.createRangeNode
      };
    }
  });

  // node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/entry/dependenciesAny/dependenciesRelationalNode.generated.js
  var require_dependenciesRelationalNode_generated = __commonJS({
    "node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/entry/dependenciesAny/dependenciesRelationalNode.generated.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.RelationalNodeDependencies = void 0;
      var _dependenciesNodeGenerated = require_dependenciesNode_generated();
      var _factoriesAny = require_factoriesAny();
      var RelationalNodeDependencies = exports.RelationalNodeDependencies = {
        NodeDependencies: _dependenciesNodeGenerated.NodeDependencies,
        createRelationalNode: _factoriesAny.createRelationalNode
      };
    }
  });

  // node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/entry/dependenciesAny/dependenciesParse.generated.js
  var require_dependenciesParse_generated = __commonJS({
    "node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/entry/dependenciesAny/dependenciesParse.generated.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.parseDependencies = void 0;
      var _dependenciesAccessorNodeGenerated = require_dependenciesAccessorNode_generated();
      var _dependenciesArrayNodeGenerated = require_dependenciesArrayNode_generated();
      var _dependenciesAssignmentNodeGenerated = require_dependenciesAssignmentNode_generated();
      var _dependenciesBlockNodeGenerated = require_dependenciesBlockNode_generated();
      var _dependenciesConditionalNodeGenerated = require_dependenciesConditionalNode_generated();
      var _dependenciesConstantNodeGenerated = require_dependenciesConstantNode_generated();
      var _dependenciesFunctionAssignmentNodeGenerated = require_dependenciesFunctionAssignmentNode_generated();
      var _dependenciesFunctionNodeGenerated = require_dependenciesFunctionNode_generated();
      var _dependenciesIndexNodeGenerated = require_dependenciesIndexNode_generated();
      var _dependenciesObjectNodeGenerated = require_dependenciesObjectNode_generated();
      var _dependenciesOperatorNodeGenerated = require_dependenciesOperatorNode_generated();
      var _dependenciesParenthesisNodeGenerated = require_dependenciesParenthesisNode_generated();
      var _dependenciesRangeNodeGenerated = require_dependenciesRangeNode_generated();
      var _dependenciesRelationalNodeGenerated = require_dependenciesRelationalNode_generated();
      var _dependenciesSymbolNodeGenerated = require_dependenciesSymbolNode_generated();
      var _dependenciesNumericGenerated = require_dependenciesNumeric_generated();
      var _dependenciesTypedGenerated = require_dependenciesTyped_generated();
      var _factoriesAny = require_factoriesAny();
      var parseDependencies = exports.parseDependencies = {
        AccessorNodeDependencies: _dependenciesAccessorNodeGenerated.AccessorNodeDependencies,
        ArrayNodeDependencies: _dependenciesArrayNodeGenerated.ArrayNodeDependencies,
        AssignmentNodeDependencies: _dependenciesAssignmentNodeGenerated.AssignmentNodeDependencies,
        BlockNodeDependencies: _dependenciesBlockNodeGenerated.BlockNodeDependencies,
        ConditionalNodeDependencies: _dependenciesConditionalNodeGenerated.ConditionalNodeDependencies,
        ConstantNodeDependencies: _dependenciesConstantNodeGenerated.ConstantNodeDependencies,
        FunctionAssignmentNodeDependencies: _dependenciesFunctionAssignmentNodeGenerated.FunctionAssignmentNodeDependencies,
        FunctionNodeDependencies: _dependenciesFunctionNodeGenerated.FunctionNodeDependencies,
        IndexNodeDependencies: _dependenciesIndexNodeGenerated.IndexNodeDependencies,
        ObjectNodeDependencies: _dependenciesObjectNodeGenerated.ObjectNodeDependencies,
        OperatorNodeDependencies: _dependenciesOperatorNodeGenerated.OperatorNodeDependencies,
        ParenthesisNodeDependencies: _dependenciesParenthesisNodeGenerated.ParenthesisNodeDependencies,
        RangeNodeDependencies: _dependenciesRangeNodeGenerated.RangeNodeDependencies,
        RelationalNodeDependencies: _dependenciesRelationalNodeGenerated.RelationalNodeDependencies,
        SymbolNodeDependencies: _dependenciesSymbolNodeGenerated.SymbolNodeDependencies,
        numericDependencies: _dependenciesNumericGenerated.numericDependencies,
        typedDependencies: _dependenciesTypedGenerated.typedDependencies,
        createParse: _factoriesAny.createParse
      };
    }
  });

  // node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/entry/dependenciesAny/dependenciesCompile.generated.js
  var require_dependenciesCompile_generated = __commonJS({
    "node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/entry/dependenciesAny/dependenciesCompile.generated.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.compileDependencies = void 0;
      var _dependenciesParseGenerated = require_dependenciesParse_generated();
      var _dependenciesTypedGenerated = require_dependenciesTyped_generated();
      var _factoriesAny = require_factoriesAny();
      var compileDependencies = exports.compileDependencies = {
        parseDependencies: _dependenciesParseGenerated.parseDependencies,
        typedDependencies: _dependenciesTypedGenerated.typedDependencies,
        createCompile: _factoriesAny.createCompile
      };
    }
  });

  // node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/entry/dependenciesAny/dependenciesComplex.generated.js
  var require_dependenciesComplex_generated = __commonJS({
    "node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/entry/dependenciesAny/dependenciesComplex.generated.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.complexDependencies = void 0;
      var _dependenciesComplexClassGenerated = require_dependenciesComplexClass_generated();
      var _dependenciesTypedGenerated = require_dependenciesTyped_generated();
      var _factoriesAny = require_factoriesAny();
      var complexDependencies = exports.complexDependencies = {
        ComplexDependencies: _dependenciesComplexClassGenerated.ComplexDependencies,
        typedDependencies: _dependenciesTypedGenerated.typedDependencies,
        createComplex: _factoriesAny.createComplex
      };
    }
  });

  // node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/entry/dependenciesAny/dependenciesComposition.generated.js
  var require_dependenciesComposition_generated = __commonJS({
    "node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/entry/dependenciesAny/dependenciesComposition.generated.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.compositionDependencies = void 0;
      var _dependenciesAddScalarGenerated = require_dependenciesAddScalar_generated();
      var _dependenciesCombinationsGenerated = require_dependenciesCombinations_generated();
      var _dependenciesIsIntegerGenerated = require_dependenciesIsInteger_generated();
      var _dependenciesIsNegativeGenerated = require_dependenciesIsNegative_generated();
      var _dependenciesIsPositiveGenerated = require_dependenciesIsPositive_generated();
      var _dependenciesLargerGenerated = require_dependenciesLarger_generated();
      var _dependenciesTypedGenerated = require_dependenciesTyped_generated();
      var _factoriesAny = require_factoriesAny();
      var compositionDependencies = exports.compositionDependencies = {
        addScalarDependencies: _dependenciesAddScalarGenerated.addScalarDependencies,
        combinationsDependencies: _dependenciesCombinationsGenerated.combinationsDependencies,
        isIntegerDependencies: _dependenciesIsIntegerGenerated.isIntegerDependencies,
        isNegativeDependencies: _dependenciesIsNegativeGenerated.isNegativeDependencies,
        isPositiveDependencies: _dependenciesIsPositiveGenerated.isPositiveDependencies,
        largerDependencies: _dependenciesLargerGenerated.largerDependencies,
        typedDependencies: _dependenciesTypedGenerated.typedDependencies,
        createComposition: _factoriesAny.createComposition
      };
    }
  });

  // node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/entry/dependenciesAny/dependenciesConcatTransform.generated.js
  var require_dependenciesConcatTransform_generated = __commonJS({
    "node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/entry/dependenciesAny/dependenciesConcatTransform.generated.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.concatTransformDependencies = void 0;
      var _dependenciesIsIntegerGenerated = require_dependenciesIsInteger_generated();
      var _dependenciesMatrixGenerated = require_dependenciesMatrix_generated();
      var _dependenciesTypedGenerated = require_dependenciesTyped_generated();
      var _factoriesAny = require_factoriesAny();
      var concatTransformDependencies = exports.concatTransformDependencies = {
        isIntegerDependencies: _dependenciesIsIntegerGenerated.isIntegerDependencies,
        matrixDependencies: _dependenciesMatrixGenerated.matrixDependencies,
        typedDependencies: _dependenciesTypedGenerated.typedDependencies,
        createConcatTransform: _factoriesAny.createConcatTransform
      };
    }
  });

  // node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/entry/dependenciesAny/dependenciesConductanceQuantum.generated.js
  var require_dependenciesConductanceQuantum_generated = __commonJS({
    "node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/entry/dependenciesAny/dependenciesConductanceQuantum.generated.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.conductanceQuantumDependencies = void 0;
      var _dependenciesBigNumberClassGenerated = require_dependenciesBigNumberClass_generated();
      var _dependenciesUnitClassGenerated = require_dependenciesUnitClass_generated();
      var _factoriesAny = require_factoriesAny();
      var conductanceQuantumDependencies = exports.conductanceQuantumDependencies = {
        BigNumberDependencies: _dependenciesBigNumberClassGenerated.BigNumberDependencies,
        UnitDependencies: _dependenciesUnitClassGenerated.UnitDependencies,
        createConductanceQuantum: _factoriesAny.createConductanceQuantum
      };
    }
  });

  // node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/entry/dependenciesAny/dependenciesDivide.generated.js
  var require_dependenciesDivide_generated = __commonJS({
    "node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/entry/dependenciesAny/dependenciesDivide.generated.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.divideDependencies = void 0;
      var _dependenciesDivideScalarGenerated = require_dependenciesDivideScalar_generated();
      var _dependenciesEqualScalarGenerated = require_dependenciesEqualScalar_generated();
      var _dependenciesInvGenerated = require_dependenciesInv_generated();
      var _dependenciesMatrixGenerated = require_dependenciesMatrix_generated();
      var _dependenciesMultiplyGenerated = require_dependenciesMultiply_generated();
      var _dependenciesTypedGenerated = require_dependenciesTyped_generated();
      var _factoriesAny = require_factoriesAny();
      var divideDependencies = exports.divideDependencies = {
        divideScalarDependencies: _dependenciesDivideScalarGenerated.divideScalarDependencies,
        equalScalarDependencies: _dependenciesEqualScalarGenerated.equalScalarDependencies,
        invDependencies: _dependenciesInvGenerated.invDependencies,
        matrixDependencies: _dependenciesMatrixGenerated.matrixDependencies,
        multiplyDependencies: _dependenciesMultiplyGenerated.multiplyDependencies,
        typedDependencies: _dependenciesTypedGenerated.typedDependencies,
        createDivide: _factoriesAny.createDivide
      };
    }
  });

  // node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/entry/dependenciesAny/dependenciesMean.generated.js
  var require_dependenciesMean_generated = __commonJS({
    "node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/entry/dependenciesAny/dependenciesMean.generated.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.meanDependencies = void 0;
      var _dependenciesAddGenerated = require_dependenciesAdd_generated();
      var _dependenciesDivideGenerated = require_dependenciesDivide_generated();
      var _dependenciesTypedGenerated = require_dependenciesTyped_generated();
      var _factoriesAny = require_factoriesAny();
      var meanDependencies = exports.meanDependencies = {
        addDependencies: _dependenciesAddGenerated.addDependencies,
        divideDependencies: _dependenciesDivideGenerated.divideDependencies,
        typedDependencies: _dependenciesTypedGenerated.typedDependencies,
        createMean: _factoriesAny.createMean
      };
    }
  });

  // node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/entry/dependenciesAny/dependenciesSqrt.generated.js
  var require_dependenciesSqrt_generated = __commonJS({
    "node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/entry/dependenciesAny/dependenciesSqrt.generated.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.sqrtDependencies = void 0;
      var _dependenciesComplexClassGenerated = require_dependenciesComplexClass_generated();
      var _dependenciesTypedGenerated = require_dependenciesTyped_generated();
      var _factoriesAny = require_factoriesAny();
      var sqrtDependencies = exports.sqrtDependencies = {
        ComplexDependencies: _dependenciesComplexClassGenerated.ComplexDependencies,
        typedDependencies: _dependenciesTypedGenerated.typedDependencies,
        createSqrt: _factoriesAny.createSqrt
      };
    }
  });

  // node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/entry/dependenciesAny/dependenciesSubtract.generated.js
  var require_dependenciesSubtract_generated = __commonJS({
    "node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/entry/dependenciesAny/dependenciesSubtract.generated.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.subtractDependencies = void 0;
      var _dependenciesDenseMatrixClassGenerated = require_dependenciesDenseMatrixClass_generated();
      var _dependenciesConcatGenerated = require_dependenciesConcat_generated();
      var _dependenciesEqualScalarGenerated = require_dependenciesEqualScalar_generated();
      var _dependenciesMatrixGenerated = require_dependenciesMatrix_generated();
      var _dependenciesSubtractScalarGenerated = require_dependenciesSubtractScalar_generated();
      var _dependenciesTypedGenerated = require_dependenciesTyped_generated();
      var _dependenciesUnaryMinusGenerated = require_dependenciesUnaryMinus_generated();
      var _factoriesAny = require_factoriesAny();
      var subtractDependencies = exports.subtractDependencies = {
        DenseMatrixDependencies: _dependenciesDenseMatrixClassGenerated.DenseMatrixDependencies,
        concatDependencies: _dependenciesConcatGenerated.concatDependencies,
        equalScalarDependencies: _dependenciesEqualScalarGenerated.equalScalarDependencies,
        matrixDependencies: _dependenciesMatrixGenerated.matrixDependencies,
        subtractScalarDependencies: _dependenciesSubtractScalarGenerated.subtractScalarDependencies,
        typedDependencies: _dependenciesTypedGenerated.typedDependencies,
        unaryMinusDependencies: _dependenciesUnaryMinusGenerated.unaryMinusDependencies,
        createSubtract: _factoriesAny.createSubtract
      };
    }
  });

  // node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/entry/dependenciesAny/dependenciesSum.generated.js
  var require_dependenciesSum_generated = __commonJS({
    "node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/entry/dependenciesAny/dependenciesSum.generated.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.sumDependencies = void 0;
      var _dependenciesAddGenerated = require_dependenciesAdd_generated();
      var _dependenciesNumericGenerated = require_dependenciesNumeric_generated();
      var _dependenciesTypedGenerated = require_dependenciesTyped_generated();
      var _factoriesAny = require_factoriesAny();
      var sumDependencies = exports.sumDependencies = {
        addDependencies: _dependenciesAddGenerated.addDependencies,
        numericDependencies: _dependenciesNumericGenerated.numericDependencies,
        typedDependencies: _dependenciesTypedGenerated.typedDependencies,
        createSum: _factoriesAny.createSum
      };
    }
  });

  // node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/entry/dependenciesAny/dependenciesCorr.generated.js
  var require_dependenciesCorr_generated = __commonJS({
    "node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/entry/dependenciesAny/dependenciesCorr.generated.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.corrDependencies = void 0;
      var _dependenciesAddGenerated = require_dependenciesAdd_generated();
      var _dependenciesDivideGenerated = require_dependenciesDivide_generated();
      var _dependenciesMatrixGenerated = require_dependenciesMatrix_generated();
      var _dependenciesMeanGenerated = require_dependenciesMean_generated();
      var _dependenciesMultiplyGenerated = require_dependenciesMultiply_generated();
      var _dependenciesPowGenerated = require_dependenciesPow_generated();
      var _dependenciesSqrtGenerated = require_dependenciesSqrt_generated();
      var _dependenciesSubtractGenerated = require_dependenciesSubtract_generated();
      var _dependenciesSumGenerated = require_dependenciesSum_generated();
      var _dependenciesTypedGenerated = require_dependenciesTyped_generated();
      var _factoriesAny = require_factoriesAny();
      var corrDependencies = exports.corrDependencies = {
        addDependencies: _dependenciesAddGenerated.addDependencies,
        divideDependencies: _dependenciesDivideGenerated.divideDependencies,
        matrixDependencies: _dependenciesMatrixGenerated.matrixDependencies,
        meanDependencies: _dependenciesMeanGenerated.meanDependencies,
        multiplyDependencies: _dependenciesMultiplyGenerated.multiplyDependencies,
        powDependencies: _dependenciesPowGenerated.powDependencies,
        sqrtDependencies: _dependenciesSqrtGenerated.sqrtDependencies,
        subtractDependencies: _dependenciesSubtractGenerated.subtractDependencies,
        sumDependencies: _dependenciesSumGenerated.sumDependencies,
        typedDependencies: _dependenciesTypedGenerated.typedDependencies,
        createCorr: _factoriesAny.createCorr
      };
    }
  });

  // node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/entry/dependenciesAny/dependenciesCos.generated.js
  var require_dependenciesCos_generated = __commonJS({
    "node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/entry/dependenciesAny/dependenciesCos.generated.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.cosDependencies = void 0;
      var _dependenciesTypedGenerated = require_dependenciesTyped_generated();
      var _factoriesAny = require_factoriesAny();
      var cosDependencies = exports.cosDependencies = {
        typedDependencies: _dependenciesTypedGenerated.typedDependencies,
        createCos: _factoriesAny.createCos
      };
    }
  });

  // node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/entry/dependenciesAny/dependenciesCosh.generated.js
  var require_dependenciesCosh_generated = __commonJS({
    "node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/entry/dependenciesAny/dependenciesCosh.generated.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.coshDependencies = void 0;
      var _dependenciesTypedGenerated = require_dependenciesTyped_generated();
      var _factoriesAny = require_factoriesAny();
      var coshDependencies = exports.coshDependencies = {
        typedDependencies: _dependenciesTypedGenerated.typedDependencies,
        createCosh: _factoriesAny.createCosh
      };
    }
  });

  // node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/entry/dependenciesAny/dependenciesCot.generated.js
  var require_dependenciesCot_generated = __commonJS({
    "node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/entry/dependenciesAny/dependenciesCot.generated.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.cotDependencies = void 0;
      var _dependenciesBigNumberClassGenerated = require_dependenciesBigNumberClass_generated();
      var _dependenciesTypedGenerated = require_dependenciesTyped_generated();
      var _factoriesAny = require_factoriesAny();
      var cotDependencies = exports.cotDependencies = {
        BigNumberDependencies: _dependenciesBigNumberClassGenerated.BigNumberDependencies,
        typedDependencies: _dependenciesTypedGenerated.typedDependencies,
        createCot: _factoriesAny.createCot
      };
    }
  });

  // node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/entry/dependenciesAny/dependenciesCoth.generated.js
  var require_dependenciesCoth_generated = __commonJS({
    "node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/entry/dependenciesAny/dependenciesCoth.generated.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.cothDependencies = void 0;
      var _dependenciesBigNumberClassGenerated = require_dependenciesBigNumberClass_generated();
      var _dependenciesTypedGenerated = require_dependenciesTyped_generated();
      var _factoriesAny = require_factoriesAny();
      var cothDependencies = exports.cothDependencies = {
        BigNumberDependencies: _dependenciesBigNumberClassGenerated.BigNumberDependencies,
        typedDependencies: _dependenciesTypedGenerated.typedDependencies,
        createCoth: _factoriesAny.createCoth
      };
    }
  });

  // node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/entry/dependenciesAny/dependenciesCoulomb.generated.js
  var require_dependenciesCoulomb_generated = __commonJS({
    "node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/entry/dependenciesAny/dependenciesCoulomb.generated.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.coulombDependencies = void 0;
      var _dependenciesBigNumberClassGenerated = require_dependenciesBigNumberClass_generated();
      var _dependenciesUnitClassGenerated = require_dependenciesUnitClass_generated();
      var _factoriesAny = require_factoriesAny();
      var coulombDependencies = exports.coulombDependencies = {
        BigNumberDependencies: _dependenciesBigNumberClassGenerated.BigNumberDependencies,
        UnitDependencies: _dependenciesUnitClassGenerated.UnitDependencies,
        createCoulomb: _factoriesAny.createCoulomb
      };
    }
  });

  // node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/entry/dependenciesAny/dependenciesProd.generated.js
  var require_dependenciesProd_generated = __commonJS({
    "node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/entry/dependenciesAny/dependenciesProd.generated.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.prodDependencies = void 0;
      var _dependenciesMultiplyScalarGenerated = require_dependenciesMultiplyScalar_generated();
      var _dependenciesNumericGenerated = require_dependenciesNumeric_generated();
      var _dependenciesTypedGenerated = require_dependenciesTyped_generated();
      var _factoriesAny = require_factoriesAny();
      var prodDependencies = exports.prodDependencies = {
        multiplyScalarDependencies: _dependenciesMultiplyScalarGenerated.multiplyScalarDependencies,
        numericDependencies: _dependenciesNumericGenerated.numericDependencies,
        typedDependencies: _dependenciesTypedGenerated.typedDependencies,
        createProd: _factoriesAny.createProd
      };
    }
  });

  // node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/entry/dependenciesAny/dependenciesCount.generated.js
  var require_dependenciesCount_generated = __commonJS({
    "node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/entry/dependenciesAny/dependenciesCount.generated.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.countDependencies = void 0;
      var _dependenciesProdGenerated = require_dependenciesProd_generated();
      var _dependenciesSizeGenerated = require_dependenciesSize_generated();
      var _dependenciesTypedGenerated = require_dependenciesTyped_generated();
      var _factoriesAny = require_factoriesAny();
      var countDependencies = exports.countDependencies = {
        prodDependencies: _dependenciesProdGenerated.prodDependencies,
        sizeDependencies: _dependenciesSizeGenerated.sizeDependencies,
        typedDependencies: _dependenciesTypedGenerated.typedDependencies,
        createCount: _factoriesAny.createCount
      };
    }
  });

  // node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/entry/dependenciesAny/dependenciesCreateUnit.generated.js
  var require_dependenciesCreateUnit_generated = __commonJS({
    "node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/entry/dependenciesAny/dependenciesCreateUnit.generated.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.createUnitDependencies = void 0;
      var _dependenciesUnitClassGenerated = require_dependenciesUnitClass_generated();
      var _dependenciesTypedGenerated = require_dependenciesTyped_generated();
      var _factoriesAny = require_factoriesAny();
      var createUnitDependencies = exports.createUnitDependencies = {
        UnitDependencies: _dependenciesUnitClassGenerated.UnitDependencies,
        typedDependencies: _dependenciesTypedGenerated.typedDependencies,
        createCreateUnit: _factoriesAny.createCreateUnit
      };
    }
  });

  // node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/entry/dependenciesAny/dependenciesCross.generated.js
  var require_dependenciesCross_generated = __commonJS({
    "node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/entry/dependenciesAny/dependenciesCross.generated.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.crossDependencies = void 0;
      var _dependenciesMatrixGenerated = require_dependenciesMatrix_generated();
      var _dependenciesMultiplyGenerated = require_dependenciesMultiply_generated();
      var _dependenciesSubtractGenerated = require_dependenciesSubtract_generated();
      var _dependenciesTypedGenerated = require_dependenciesTyped_generated();
      var _factoriesAny = require_factoriesAny();
      var crossDependencies = exports.crossDependencies = {
        matrixDependencies: _dependenciesMatrixGenerated.matrixDependencies,
        multiplyDependencies: _dependenciesMultiplyGenerated.multiplyDependencies,
        subtractDependencies: _dependenciesSubtractGenerated.subtractDependencies,
        typedDependencies: _dependenciesTypedGenerated.typedDependencies,
        createCross: _factoriesAny.createCross
      };
    }
  });

  // node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/entry/dependenciesAny/dependenciesCsc.generated.js
  var require_dependenciesCsc_generated = __commonJS({
    "node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/entry/dependenciesAny/dependenciesCsc.generated.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.cscDependencies = void 0;
      var _dependenciesBigNumberClassGenerated = require_dependenciesBigNumberClass_generated();
      var _dependenciesTypedGenerated = require_dependenciesTyped_generated();
      var _factoriesAny = require_factoriesAny();
      var cscDependencies = exports.cscDependencies = {
        BigNumberDependencies: _dependenciesBigNumberClassGenerated.BigNumberDependencies,
        typedDependencies: _dependenciesTypedGenerated.typedDependencies,
        createCsc: _factoriesAny.createCsc
      };
    }
  });

  // node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/entry/dependenciesAny/dependenciesCsch.generated.js
  var require_dependenciesCsch_generated = __commonJS({
    "node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/entry/dependenciesAny/dependenciesCsch.generated.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.cschDependencies = void 0;
      var _dependenciesBigNumberClassGenerated = require_dependenciesBigNumberClass_generated();
      var _dependenciesTypedGenerated = require_dependenciesTyped_generated();
      var _factoriesAny = require_factoriesAny();
      var cschDependencies = exports.cschDependencies = {
        BigNumberDependencies: _dependenciesBigNumberClassGenerated.BigNumberDependencies,
        typedDependencies: _dependenciesTypedGenerated.typedDependencies,
        createCsch: _factoriesAny.createCsch
      };
    }
  });

  // node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/entry/dependenciesAny/dependenciesTranspose.generated.js
  var require_dependenciesTranspose_generated = __commonJS({
    "node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/entry/dependenciesAny/dependenciesTranspose.generated.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.transposeDependencies = void 0;
      var _dependenciesMatrixGenerated = require_dependenciesMatrix_generated();
      var _dependenciesTypedGenerated = require_dependenciesTyped_generated();
      var _factoriesAny = require_factoriesAny();
      var transposeDependencies = exports.transposeDependencies = {
        matrixDependencies: _dependenciesMatrixGenerated.matrixDependencies,
        typedDependencies: _dependenciesTypedGenerated.typedDependencies,
        createTranspose: _factoriesAny.createTranspose
      };
    }
  });

  // node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/entry/dependenciesAny/dependenciesCtranspose.generated.js
  var require_dependenciesCtranspose_generated = __commonJS({
    "node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/entry/dependenciesAny/dependenciesCtranspose.generated.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.ctransposeDependencies = void 0;
      var _dependenciesConjGenerated = require_dependenciesConj_generated();
      var _dependenciesTransposeGenerated = require_dependenciesTranspose_generated();
      var _dependenciesTypedGenerated = require_dependenciesTyped_generated();
      var _factoriesAny = require_factoriesAny();
      var ctransposeDependencies = exports.ctransposeDependencies = {
        conjDependencies: _dependenciesConjGenerated.conjDependencies,
        transposeDependencies: _dependenciesTransposeGenerated.transposeDependencies,
        typedDependencies: _dependenciesTypedGenerated.typedDependencies,
        createCtranspose: _factoriesAny.createCtranspose
      };
    }
  });

  // node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/entry/dependenciesAny/dependenciesCube.generated.js
  var require_dependenciesCube_generated = __commonJS({
    "node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/entry/dependenciesAny/dependenciesCube.generated.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.cubeDependencies = void 0;
      var _dependenciesTypedGenerated = require_dependenciesTyped_generated();
      var _factoriesAny = require_factoriesAny();
      var cubeDependencies = exports.cubeDependencies = {
        typedDependencies: _dependenciesTypedGenerated.typedDependencies,
        createCube: _factoriesAny.createCube
      };
    }
  });

  // node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/entry/dependenciesAny/dependenciesUnaryPlus.generated.js
  var require_dependenciesUnaryPlus_generated = __commonJS({
    "node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/entry/dependenciesAny/dependenciesUnaryPlus.generated.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.unaryPlusDependencies = void 0;
      var _dependenciesBigNumberClassGenerated = require_dependenciesBigNumberClass_generated();
      var _dependenciesTypedGenerated = require_dependenciesTyped_generated();
      var _factoriesAny = require_factoriesAny();
      var unaryPlusDependencies = exports.unaryPlusDependencies = {
        BigNumberDependencies: _dependenciesBigNumberClassGenerated.BigNumberDependencies,
        typedDependencies: _dependenciesTypedGenerated.typedDependencies,
        createUnaryPlus: _factoriesAny.createUnaryPlus
      };
    }
  });

  // node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/entry/dependenciesAny/dependenciesCumSum.generated.js
  var require_dependenciesCumSum_generated = __commonJS({
    "node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/entry/dependenciesAny/dependenciesCumSum.generated.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.cumsumDependencies = void 0;
      var _dependenciesAddGenerated = require_dependenciesAdd_generated();
      var _dependenciesTypedGenerated = require_dependenciesTyped_generated();
      var _dependenciesUnaryPlusGenerated = require_dependenciesUnaryPlus_generated();
      var _factoriesAny = require_factoriesAny();
      var cumsumDependencies = exports.cumsumDependencies = {
        addDependencies: _dependenciesAddGenerated.addDependencies,
        typedDependencies: _dependenciesTypedGenerated.typedDependencies,
        unaryPlusDependencies: _dependenciesUnaryPlusGenerated.unaryPlusDependencies,
        createCumSum: _factoriesAny.createCumSum
      };
    }
  });

  // node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/entry/dependenciesAny/dependenciesCumSumTransform.generated.js
  var require_dependenciesCumSumTransform_generated = __commonJS({
    "node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/entry/dependenciesAny/dependenciesCumSumTransform.generated.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.cumsumTransformDependencies = void 0;
      var _dependenciesAddGenerated = require_dependenciesAdd_generated();
      var _dependenciesTypedGenerated = require_dependenciesTyped_generated();
      var _dependenciesUnaryPlusGenerated = require_dependenciesUnaryPlus_generated();
      var _factoriesAny = require_factoriesAny();
      var cumsumTransformDependencies = exports.cumsumTransformDependencies = {
        addDependencies: _dependenciesAddGenerated.addDependencies,
        typedDependencies: _dependenciesTypedGenerated.typedDependencies,
        unaryPlusDependencies: _dependenciesUnaryPlusGenerated.unaryPlusDependencies,
        createCumSumTransform: _factoriesAny.createCumSumTransform
      };
    }
  });

  // node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/entry/dependenciesAny/dependenciesDeepEqual.generated.js
  var require_dependenciesDeepEqual_generated = __commonJS({
    "node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/entry/dependenciesAny/dependenciesDeepEqual.generated.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.deepEqualDependencies = void 0;
      var _dependenciesEqualGenerated = require_dependenciesEqual_generated();
      var _dependenciesTypedGenerated = require_dependenciesTyped_generated();
      var _factoriesAny = require_factoriesAny();
      var deepEqualDependencies = exports.deepEqualDependencies = {
        equalDependencies: _dependenciesEqualGenerated.equalDependencies,
        typedDependencies: _dependenciesTypedGenerated.typedDependencies,
        createDeepEqual: _factoriesAny.createDeepEqual
      };
    }
  });

  // node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/entry/dependenciesAny/dependenciesResolve.generated.js
  var require_dependenciesResolve_generated = __commonJS({
    "node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/entry/dependenciesAny/dependenciesResolve.generated.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.resolveDependencies = void 0;
      var _dependenciesConstantNodeGenerated = require_dependenciesConstantNode_generated();
      var _dependenciesFunctionNodeGenerated = require_dependenciesFunctionNode_generated();
      var _dependenciesOperatorNodeGenerated = require_dependenciesOperatorNode_generated();
      var _dependenciesParenthesisNodeGenerated = require_dependenciesParenthesisNode_generated();
      var _dependenciesParseGenerated = require_dependenciesParse_generated();
      var _dependenciesTypedGenerated = require_dependenciesTyped_generated();
      var _factoriesAny = require_factoriesAny();
      var resolveDependencies = exports.resolveDependencies = {
        ConstantNodeDependencies: _dependenciesConstantNodeGenerated.ConstantNodeDependencies,
        FunctionNodeDependencies: _dependenciesFunctionNodeGenerated.FunctionNodeDependencies,
        OperatorNodeDependencies: _dependenciesOperatorNodeGenerated.OperatorNodeDependencies,
        ParenthesisNodeDependencies: _dependenciesParenthesisNodeGenerated.ParenthesisNodeDependencies,
        parseDependencies: _dependenciesParseGenerated.parseDependencies,
        typedDependencies: _dependenciesTypedGenerated.typedDependencies,
        createResolve: _factoriesAny.createResolve
      };
    }
  });

  // node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/entry/dependenciesAny/dependenciesSimplifyConstant.generated.js
  var require_dependenciesSimplifyConstant_generated = __commonJS({
    "node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/entry/dependenciesAny/dependenciesSimplifyConstant.generated.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.simplifyConstantDependencies = void 0;
      var _dependenciesBignumberGenerated = require_dependenciesBignumber_generated();
      var _dependenciesFractionGenerated = require_dependenciesFraction_generated();
      var _dependenciesAccessorNodeGenerated = require_dependenciesAccessorNode_generated();
      var _dependenciesArrayNodeGenerated = require_dependenciesArrayNode_generated();
      var _dependenciesConstantNodeGenerated = require_dependenciesConstantNode_generated();
      var _dependenciesFunctionNodeGenerated = require_dependenciesFunctionNode_generated();
      var _dependenciesIndexNodeGenerated = require_dependenciesIndexNode_generated();
      var _dependenciesObjectNodeGenerated = require_dependenciesObjectNode_generated();
      var _dependenciesOperatorNodeGenerated = require_dependenciesOperatorNode_generated();
      var _dependenciesSymbolNodeGenerated = require_dependenciesSymbolNode_generated();
      var _dependenciesMatrixGenerated = require_dependenciesMatrix_generated();
      var _dependenciesTypedGenerated = require_dependenciesTyped_generated();
      var _factoriesAny = require_factoriesAny();
      var simplifyConstantDependencies = exports.simplifyConstantDependencies = {
        bignumberDependencies: _dependenciesBignumberGenerated.bignumberDependencies,
        fractionDependencies: _dependenciesFractionGenerated.fractionDependencies,
        AccessorNodeDependencies: _dependenciesAccessorNodeGenerated.AccessorNodeDependencies,
        ArrayNodeDependencies: _dependenciesArrayNodeGenerated.ArrayNodeDependencies,
        ConstantNodeDependencies: _dependenciesConstantNodeGenerated.ConstantNodeDependencies,
        FunctionNodeDependencies: _dependenciesFunctionNodeGenerated.FunctionNodeDependencies,
        IndexNodeDependencies: _dependenciesIndexNodeGenerated.IndexNodeDependencies,
        ObjectNodeDependencies: _dependenciesObjectNodeGenerated.ObjectNodeDependencies,
        OperatorNodeDependencies: _dependenciesOperatorNodeGenerated.OperatorNodeDependencies,
        SymbolNodeDependencies: _dependenciesSymbolNodeGenerated.SymbolNodeDependencies,
        matrixDependencies: _dependenciesMatrixGenerated.matrixDependencies,
        typedDependencies: _dependenciesTypedGenerated.typedDependencies,
        createSimplifyConstant: _factoriesAny.createSimplifyConstant
      };
    }
  });

  // node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/entry/dependenciesAny/dependenciesSimplifyCore.generated.js
  var require_dependenciesSimplifyCore_generated = __commonJS({
    "node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/entry/dependenciesAny/dependenciesSimplifyCore.generated.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.simplifyCoreDependencies = void 0;
      var _dependenciesAccessorNodeGenerated = require_dependenciesAccessorNode_generated();
      var _dependenciesArrayNodeGenerated = require_dependenciesArrayNode_generated();
      var _dependenciesConstantNodeGenerated = require_dependenciesConstantNode_generated();
      var _dependenciesFunctionNodeGenerated = require_dependenciesFunctionNode_generated();
      var _dependenciesIndexNodeGenerated = require_dependenciesIndexNode_generated();
      var _dependenciesObjectNodeGenerated = require_dependenciesObjectNode_generated();
      var _dependenciesOperatorNodeGenerated = require_dependenciesOperatorNode_generated();
      var _dependenciesParenthesisNodeGenerated = require_dependenciesParenthesisNode_generated();
      var _dependenciesSymbolNodeGenerated = require_dependenciesSymbolNode_generated();
      var _dependenciesAddGenerated = require_dependenciesAdd_generated();
      var _dependenciesDivideGenerated = require_dependenciesDivide_generated();
      var _dependenciesEqualGenerated = require_dependenciesEqual_generated();
      var _dependenciesIsZeroGenerated = require_dependenciesIsZero_generated();
      var _dependenciesMultiplyGenerated = require_dependenciesMultiply_generated();
      var _dependenciesParseGenerated = require_dependenciesParse_generated();
      var _dependenciesPowGenerated = require_dependenciesPow_generated();
      var _dependenciesSubtractGenerated = require_dependenciesSubtract_generated();
      var _dependenciesTypedGenerated = require_dependenciesTyped_generated();
      var _factoriesAny = require_factoriesAny();
      var simplifyCoreDependencies = exports.simplifyCoreDependencies = {
        AccessorNodeDependencies: _dependenciesAccessorNodeGenerated.AccessorNodeDependencies,
        ArrayNodeDependencies: _dependenciesArrayNodeGenerated.ArrayNodeDependencies,
        ConstantNodeDependencies: _dependenciesConstantNodeGenerated.ConstantNodeDependencies,
        FunctionNodeDependencies: _dependenciesFunctionNodeGenerated.FunctionNodeDependencies,
        IndexNodeDependencies: _dependenciesIndexNodeGenerated.IndexNodeDependencies,
        ObjectNodeDependencies: _dependenciesObjectNodeGenerated.ObjectNodeDependencies,
        OperatorNodeDependencies: _dependenciesOperatorNodeGenerated.OperatorNodeDependencies,
        ParenthesisNodeDependencies: _dependenciesParenthesisNodeGenerated.ParenthesisNodeDependencies,
        SymbolNodeDependencies: _dependenciesSymbolNodeGenerated.SymbolNodeDependencies,
        addDependencies: _dependenciesAddGenerated.addDependencies,
        divideDependencies: _dependenciesDivideGenerated.divideDependencies,
        equalDependencies: _dependenciesEqualGenerated.equalDependencies,
        isZeroDependencies: _dependenciesIsZeroGenerated.isZeroDependencies,
        multiplyDependencies: _dependenciesMultiplyGenerated.multiplyDependencies,
        parseDependencies: _dependenciesParseGenerated.parseDependencies,
        powDependencies: _dependenciesPowGenerated.powDependencies,
        subtractDependencies: _dependenciesSubtractGenerated.subtractDependencies,
        typedDependencies: _dependenciesTypedGenerated.typedDependencies,
        createSimplifyCore: _factoriesAny.createSimplifyCore
      };
    }
  });

  // node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/entry/dependenciesAny/dependenciesSimplify.generated.js
  var require_dependenciesSimplify_generated = __commonJS({
    "node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/entry/dependenciesAny/dependenciesSimplify.generated.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.simplifyDependencies = void 0;
      var _dependenciesBignumberGenerated = require_dependenciesBignumber_generated();
      var _dependenciesFractionGenerated = require_dependenciesFraction_generated();
      var _dependenciesAccessorNodeGenerated = require_dependenciesAccessorNode_generated();
      var _dependenciesArrayNodeGenerated = require_dependenciesArrayNode_generated();
      var _dependenciesConstantNodeGenerated = require_dependenciesConstantNode_generated();
      var _dependenciesFunctionNodeGenerated = require_dependenciesFunctionNode_generated();
      var _dependenciesIndexNodeGenerated = require_dependenciesIndexNode_generated();
      var _dependenciesObjectNodeGenerated = require_dependenciesObjectNode_generated();
      var _dependenciesOperatorNodeGenerated = require_dependenciesOperatorNode_generated();
      var _dependenciesParenthesisNodeGenerated = require_dependenciesParenthesisNode_generated();
      var _dependenciesSymbolNodeGenerated = require_dependenciesSymbolNode_generated();
      var _dependenciesAddGenerated = require_dependenciesAdd_generated();
      var _dependenciesDivideGenerated = require_dependenciesDivide_generated();
      var _dependenciesEqualGenerated = require_dependenciesEqual_generated();
      var _dependenciesIsZeroGenerated = require_dependenciesIsZero_generated();
      var _dependenciesMatrixGenerated = require_dependenciesMatrix_generated();
      var _dependenciesMultiplyGenerated = require_dependenciesMultiply_generated();
      var _dependenciesParseGenerated = require_dependenciesParse_generated();
      var _dependenciesPowGenerated = require_dependenciesPow_generated();
      var _dependenciesResolveGenerated = require_dependenciesResolve_generated();
      var _dependenciesSimplifyConstantGenerated = require_dependenciesSimplifyConstant_generated();
      var _dependenciesSimplifyCoreGenerated = require_dependenciesSimplifyCore_generated();
      var _dependenciesSubtractGenerated = require_dependenciesSubtract_generated();
      var _dependenciesTypedGenerated = require_dependenciesTyped_generated();
      var _factoriesAny = require_factoriesAny();
      var simplifyDependencies = exports.simplifyDependencies = {
        bignumberDependencies: _dependenciesBignumberGenerated.bignumberDependencies,
        fractionDependencies: _dependenciesFractionGenerated.fractionDependencies,
        AccessorNodeDependencies: _dependenciesAccessorNodeGenerated.AccessorNodeDependencies,
        ArrayNodeDependencies: _dependenciesArrayNodeGenerated.ArrayNodeDependencies,
        ConstantNodeDependencies: _dependenciesConstantNodeGenerated.ConstantNodeDependencies,
        FunctionNodeDependencies: _dependenciesFunctionNodeGenerated.FunctionNodeDependencies,
        IndexNodeDependencies: _dependenciesIndexNodeGenerated.IndexNodeDependencies,
        ObjectNodeDependencies: _dependenciesObjectNodeGenerated.ObjectNodeDependencies,
        OperatorNodeDependencies: _dependenciesOperatorNodeGenerated.OperatorNodeDependencies,
        ParenthesisNodeDependencies: _dependenciesParenthesisNodeGenerated.ParenthesisNodeDependencies,
        SymbolNodeDependencies: _dependenciesSymbolNodeGenerated.SymbolNodeDependencies,
        addDependencies: _dependenciesAddGenerated.addDependencies,
        divideDependencies: _dependenciesDivideGenerated.divideDependencies,
        equalDependencies: _dependenciesEqualGenerated.equalDependencies,
        isZeroDependencies: _dependenciesIsZeroGenerated.isZeroDependencies,
        matrixDependencies: _dependenciesMatrixGenerated.matrixDependencies,
        multiplyDependencies: _dependenciesMultiplyGenerated.multiplyDependencies,
        parseDependencies: _dependenciesParseGenerated.parseDependencies,
        powDependencies: _dependenciesPowGenerated.powDependencies,
        resolveDependencies: _dependenciesResolveGenerated.resolveDependencies,
        simplifyConstantDependencies: _dependenciesSimplifyConstantGenerated.simplifyConstantDependencies,
        simplifyCoreDependencies: _dependenciesSimplifyCoreGenerated.simplifyCoreDependencies,
        subtractDependencies: _dependenciesSubtractGenerated.subtractDependencies,
        typedDependencies: _dependenciesTypedGenerated.typedDependencies,
        createSimplify: _factoriesAny.createSimplify
      };
    }
  });

  // node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/entry/dependenciesAny/dependenciesDerivative.generated.js
  var require_dependenciesDerivative_generated = __commonJS({
    "node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/entry/dependenciesAny/dependenciesDerivative.generated.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.derivativeDependencies = void 0;
      var _dependenciesConstantNodeGenerated = require_dependenciesConstantNode_generated();
      var _dependenciesFunctionNodeGenerated = require_dependenciesFunctionNode_generated();
      var _dependenciesOperatorNodeGenerated = require_dependenciesOperatorNode_generated();
      var _dependenciesParenthesisNodeGenerated = require_dependenciesParenthesisNode_generated();
      var _dependenciesSymbolNodeGenerated = require_dependenciesSymbolNode_generated();
      var _dependenciesEqualGenerated = require_dependenciesEqual_generated();
      var _dependenciesIsZeroGenerated = require_dependenciesIsZero_generated();
      var _dependenciesNumericGenerated = require_dependenciesNumeric_generated();
      var _dependenciesParseGenerated = require_dependenciesParse_generated();
      var _dependenciesSimplifyGenerated = require_dependenciesSimplify_generated();
      var _dependenciesTypedGenerated = require_dependenciesTyped_generated();
      var _factoriesAny = require_factoriesAny();
      var derivativeDependencies = exports.derivativeDependencies = {
        ConstantNodeDependencies: _dependenciesConstantNodeGenerated.ConstantNodeDependencies,
        FunctionNodeDependencies: _dependenciesFunctionNodeGenerated.FunctionNodeDependencies,
        OperatorNodeDependencies: _dependenciesOperatorNodeGenerated.OperatorNodeDependencies,
        ParenthesisNodeDependencies: _dependenciesParenthesisNodeGenerated.ParenthesisNodeDependencies,
        SymbolNodeDependencies: _dependenciesSymbolNodeGenerated.SymbolNodeDependencies,
        equalDependencies: _dependenciesEqualGenerated.equalDependencies,
        isZeroDependencies: _dependenciesIsZeroGenerated.isZeroDependencies,
        numericDependencies: _dependenciesNumericGenerated.numericDependencies,
        parseDependencies: _dependenciesParseGenerated.parseDependencies,
        simplifyDependencies: _dependenciesSimplifyGenerated.simplifyDependencies,
        typedDependencies: _dependenciesTypedGenerated.typedDependencies,
        createDerivative: _factoriesAny.createDerivative
      };
    }
  });

  // node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/entry/dependenciesAny/dependenciesDeuteronMass.generated.js
  var require_dependenciesDeuteronMass_generated = __commonJS({
    "node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/entry/dependenciesAny/dependenciesDeuteronMass.generated.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.deuteronMassDependencies = void 0;
      var _dependenciesBigNumberClassGenerated = require_dependenciesBigNumberClass_generated();
      var _dependenciesUnitClassGenerated = require_dependenciesUnitClass_generated();
      var _factoriesAny = require_factoriesAny();
      var deuteronMassDependencies = exports.deuteronMassDependencies = {
        BigNumberDependencies: _dependenciesBigNumberClassGenerated.BigNumberDependencies,
        UnitDependencies: _dependenciesUnitClassGenerated.UnitDependencies,
        createDeuteronMass: _factoriesAny.createDeuteronMass
      };
    }
  });

  // node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/entry/dependenciesAny/dependenciesDiag.generated.js
  var require_dependenciesDiag_generated = __commonJS({
    "node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/entry/dependenciesAny/dependenciesDiag.generated.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.diagDependencies = void 0;
      var _dependenciesDenseMatrixClassGenerated = require_dependenciesDenseMatrixClass_generated();
      var _dependenciesSparseMatrixClassGenerated = require_dependenciesSparseMatrixClass_generated();
      var _dependenciesMatrixGenerated = require_dependenciesMatrix_generated();
      var _dependenciesTypedGenerated = require_dependenciesTyped_generated();
      var _factoriesAny = require_factoriesAny();
      var diagDependencies = exports.diagDependencies = {
        DenseMatrixDependencies: _dependenciesDenseMatrixClassGenerated.DenseMatrixDependencies,
        SparseMatrixDependencies: _dependenciesSparseMatrixClassGenerated.SparseMatrixDependencies,
        matrixDependencies: _dependenciesMatrixGenerated.matrixDependencies,
        typedDependencies: _dependenciesTypedGenerated.typedDependencies,
        createDiag: _factoriesAny.createDiag
      };
    }
  });

  // node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/entry/dependenciesAny/dependenciesDiff.generated.js
  var require_dependenciesDiff_generated = __commonJS({
    "node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/entry/dependenciesAny/dependenciesDiff.generated.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.diffDependencies = void 0;
      var _dependenciesMatrixGenerated = require_dependenciesMatrix_generated();
      var _dependenciesNumberGenerated = require_dependenciesNumber_generated();
      var _dependenciesSubtractGenerated = require_dependenciesSubtract_generated();
      var _dependenciesTypedGenerated = require_dependenciesTyped_generated();
      var _factoriesAny = require_factoriesAny();
      var diffDependencies = exports.diffDependencies = {
        matrixDependencies: _dependenciesMatrixGenerated.matrixDependencies,
        numberDependencies: _dependenciesNumberGenerated.numberDependencies,
        subtractDependencies: _dependenciesSubtractGenerated.subtractDependencies,
        typedDependencies: _dependenciesTypedGenerated.typedDependencies,
        createDiff: _factoriesAny.createDiff
      };
    }
  });

  // node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/entry/dependenciesAny/dependenciesDiffTransform.generated.js
  var require_dependenciesDiffTransform_generated = __commonJS({
    "node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/entry/dependenciesAny/dependenciesDiffTransform.generated.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.diffTransformDependencies = void 0;
      var _dependenciesBignumberGenerated = require_dependenciesBignumber_generated();
      var _dependenciesMatrixGenerated = require_dependenciesMatrix_generated();
      var _dependenciesNumberGenerated = require_dependenciesNumber_generated();
      var _dependenciesSubtractGenerated = require_dependenciesSubtract_generated();
      var _dependenciesTypedGenerated = require_dependenciesTyped_generated();
      var _factoriesAny = require_factoriesAny();
      var diffTransformDependencies = exports.diffTransformDependencies = {
        bignumberDependencies: _dependenciesBignumberGenerated.bignumberDependencies,
        matrixDependencies: _dependenciesMatrixGenerated.matrixDependencies,
        numberDependencies: _dependenciesNumberGenerated.numberDependencies,
        subtractDependencies: _dependenciesSubtractGenerated.subtractDependencies,
        typedDependencies: _dependenciesTypedGenerated.typedDependencies,
        createDiffTransform: _factoriesAny.createDiffTransform
      };
    }
  });

  // node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/entry/dependenciesAny/dependenciesDistance.generated.js
  var require_dependenciesDistance_generated = __commonJS({
    "node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/entry/dependenciesAny/dependenciesDistance.generated.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.distanceDependencies = void 0;
      var _dependenciesAbsGenerated = require_dependenciesAbs_generated();
      var _dependenciesAddScalarGenerated = require_dependenciesAddScalar_generated();
      var _dependenciesDeepEqualGenerated = require_dependenciesDeepEqual_generated();
      var _dependenciesDivideScalarGenerated = require_dependenciesDivideScalar_generated();
      var _dependenciesMultiplyScalarGenerated = require_dependenciesMultiplyScalar_generated();
      var _dependenciesSqrtGenerated = require_dependenciesSqrt_generated();
      var _dependenciesSubtractScalarGenerated = require_dependenciesSubtractScalar_generated();
      var _dependenciesTypedGenerated = require_dependenciesTyped_generated();
      var _factoriesAny = require_factoriesAny();
      var distanceDependencies = exports.distanceDependencies = {
        absDependencies: _dependenciesAbsGenerated.absDependencies,
        addScalarDependencies: _dependenciesAddScalarGenerated.addScalarDependencies,
        deepEqualDependencies: _dependenciesDeepEqualGenerated.deepEqualDependencies,
        divideScalarDependencies: _dependenciesDivideScalarGenerated.divideScalarDependencies,
        multiplyScalarDependencies: _dependenciesMultiplyScalarGenerated.multiplyScalarDependencies,
        sqrtDependencies: _dependenciesSqrtGenerated.sqrtDependencies,
        subtractScalarDependencies: _dependenciesSubtractScalarGenerated.subtractScalarDependencies,
        typedDependencies: _dependenciesTypedGenerated.typedDependencies,
        createDistance: _factoriesAny.createDistance
      };
    }
  });

  // node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/entry/dependenciesAny/dependenciesDotDivide.generated.js
  var require_dependenciesDotDivide_generated = __commonJS({
    "node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/entry/dependenciesAny/dependenciesDotDivide.generated.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.dotDivideDependencies = void 0;
      var _dependenciesDenseMatrixClassGenerated = require_dependenciesDenseMatrixClass_generated();
      var _dependenciesConcatGenerated = require_dependenciesConcat_generated();
      var _dependenciesDivideScalarGenerated = require_dependenciesDivideScalar_generated();
      var _dependenciesEqualScalarGenerated = require_dependenciesEqualScalar_generated();
      var _dependenciesMatrixGenerated = require_dependenciesMatrix_generated();
      var _dependenciesTypedGenerated = require_dependenciesTyped_generated();
      var _factoriesAny = require_factoriesAny();
      var dotDivideDependencies = exports.dotDivideDependencies = {
        DenseMatrixDependencies: _dependenciesDenseMatrixClassGenerated.DenseMatrixDependencies,
        concatDependencies: _dependenciesConcatGenerated.concatDependencies,
        divideScalarDependencies: _dependenciesDivideScalarGenerated.divideScalarDependencies,
        equalScalarDependencies: _dependenciesEqualScalarGenerated.equalScalarDependencies,
        matrixDependencies: _dependenciesMatrixGenerated.matrixDependencies,
        typedDependencies: _dependenciesTypedGenerated.typedDependencies,
        createDotDivide: _factoriesAny.createDotDivide
      };
    }
  });

  // node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/entry/dependenciesAny/dependenciesDotMultiply.generated.js
  var require_dependenciesDotMultiply_generated = __commonJS({
    "node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/entry/dependenciesAny/dependenciesDotMultiply.generated.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.dotMultiplyDependencies = void 0;
      var _dependenciesConcatGenerated = require_dependenciesConcat_generated();
      var _dependenciesEqualScalarGenerated = require_dependenciesEqualScalar_generated();
      var _dependenciesMatrixGenerated = require_dependenciesMatrix_generated();
      var _dependenciesMultiplyScalarGenerated = require_dependenciesMultiplyScalar_generated();
      var _dependenciesTypedGenerated = require_dependenciesTyped_generated();
      var _factoriesAny = require_factoriesAny();
      var dotMultiplyDependencies = exports.dotMultiplyDependencies = {
        concatDependencies: _dependenciesConcatGenerated.concatDependencies,
        equalScalarDependencies: _dependenciesEqualScalarGenerated.equalScalarDependencies,
        matrixDependencies: _dependenciesMatrixGenerated.matrixDependencies,
        multiplyScalarDependencies: _dependenciesMultiplyScalarGenerated.multiplyScalarDependencies,
        typedDependencies: _dependenciesTypedGenerated.typedDependencies,
        createDotMultiply: _factoriesAny.createDotMultiply
      };
    }
  });

  // node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/entry/dependenciesAny/dependenciesDotPow.generated.js
  var require_dependenciesDotPow_generated = __commonJS({
    "node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/entry/dependenciesAny/dependenciesDotPow.generated.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.dotPowDependencies = void 0;
      var _dependenciesDenseMatrixClassGenerated = require_dependenciesDenseMatrixClass_generated();
      var _dependenciesConcatGenerated = require_dependenciesConcat_generated();
      var _dependenciesEqualScalarGenerated = require_dependenciesEqualScalar_generated();
      var _dependenciesMatrixGenerated = require_dependenciesMatrix_generated();
      var _dependenciesPowGenerated = require_dependenciesPow_generated();
      var _dependenciesTypedGenerated = require_dependenciesTyped_generated();
      var _factoriesAny = require_factoriesAny();
      var dotPowDependencies = exports.dotPowDependencies = {
        DenseMatrixDependencies: _dependenciesDenseMatrixClassGenerated.DenseMatrixDependencies,
        concatDependencies: _dependenciesConcatGenerated.concatDependencies,
        equalScalarDependencies: _dependenciesEqualScalarGenerated.equalScalarDependencies,
        matrixDependencies: _dependenciesMatrixGenerated.matrixDependencies,
        powDependencies: _dependenciesPowGenerated.powDependencies,
        typedDependencies: _dependenciesTypedGenerated.typedDependencies,
        createDotPow: _factoriesAny.createDotPow
      };
    }
  });

  // node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/entry/dependenciesAny/dependenciesE.generated.js
  var require_dependenciesE_generated = __commonJS({
    "node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/entry/dependenciesAny/dependenciesE.generated.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.eDependencies = void 0;
      var _dependenciesBigNumberClassGenerated = require_dependenciesBigNumberClass_generated();
      var _factoriesAny = require_factoriesAny();
      var eDependencies = exports.eDependencies = {
        BigNumberDependencies: _dependenciesBigNumberClassGenerated.BigNumberDependencies,
        createE: _factoriesAny.createE
      };
    }
  });

  // node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/entry/dependenciesAny/dependenciesEfimovFactor.generated.js
  var require_dependenciesEfimovFactor_generated = __commonJS({
    "node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/entry/dependenciesAny/dependenciesEfimovFactor.generated.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.efimovFactorDependencies = void 0;
      var _dependenciesBigNumberClassGenerated = require_dependenciesBigNumberClass_generated();
      var _factoriesAny = require_factoriesAny();
      var efimovFactorDependencies = exports.efimovFactorDependencies = {
        BigNumberDependencies: _dependenciesBigNumberClassGenerated.BigNumberDependencies,
        createEfimovFactor: _factoriesAny.createEfimovFactor
      };
    }
  });

  // node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/entry/dependenciesAny/dependenciesFlatten.generated.js
  var require_dependenciesFlatten_generated = __commonJS({
    "node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/entry/dependenciesAny/dependenciesFlatten.generated.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.flattenDependencies = void 0;
      var _dependenciesMatrixGenerated = require_dependenciesMatrix_generated();
      var _dependenciesTypedGenerated = require_dependenciesTyped_generated();
      var _factoriesAny = require_factoriesAny();
      var flattenDependencies = exports.flattenDependencies = {
        matrixDependencies: _dependenciesMatrixGenerated.matrixDependencies,
        typedDependencies: _dependenciesTypedGenerated.typedDependencies,
        createFlatten: _factoriesAny.createFlatten
      };
    }
  });

  // node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/entry/dependenciesAny/dependenciesIm.generated.js
  var require_dependenciesIm_generated = __commonJS({
    "node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/entry/dependenciesAny/dependenciesIm.generated.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.imDependencies = void 0;
      var _dependenciesTypedGenerated = require_dependenciesTyped_generated();
      var _factoriesAny = require_factoriesAny();
      var imDependencies = exports.imDependencies = {
        typedDependencies: _dependenciesTypedGenerated.typedDependencies,
        createIm: _factoriesAny.createIm
      };
    }
  });

  // node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/entry/dependenciesAny/dependenciesMatrixFromColumns.generated.js
  var require_dependenciesMatrixFromColumns_generated = __commonJS({
    "node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/entry/dependenciesAny/dependenciesMatrixFromColumns.generated.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.matrixFromColumnsDependencies = void 0;
      var _dependenciesFlattenGenerated = require_dependenciesFlatten_generated();
      var _dependenciesMatrixGenerated = require_dependenciesMatrix_generated();
      var _dependenciesSizeGenerated = require_dependenciesSize_generated();
      var _dependenciesTypedGenerated = require_dependenciesTyped_generated();
      var _factoriesAny = require_factoriesAny();
      var matrixFromColumnsDependencies = exports.matrixFromColumnsDependencies = {
        flattenDependencies: _dependenciesFlattenGenerated.flattenDependencies,
        matrixDependencies: _dependenciesMatrixGenerated.matrixDependencies,
        sizeDependencies: _dependenciesSizeGenerated.sizeDependencies,
        typedDependencies: _dependenciesTypedGenerated.typedDependencies,
        createMatrixFromColumns: _factoriesAny.createMatrixFromColumns
      };
    }
  });

  // node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/entry/dependenciesAny/dependenciesSign.generated.js
  var require_dependenciesSign_generated = __commonJS({
    "node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/entry/dependenciesAny/dependenciesSign.generated.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.signDependencies = void 0;
      var _dependenciesBigNumberClassGenerated = require_dependenciesBigNumberClass_generated();
      var _dependenciesFractionClassGenerated = require_dependenciesFractionClass_generated();
      var _dependenciesComplexGenerated = require_dependenciesComplex_generated();
      var _dependenciesTypedGenerated = require_dependenciesTyped_generated();
      var _factoriesAny = require_factoriesAny();
      var signDependencies = exports.signDependencies = {
        BigNumberDependencies: _dependenciesBigNumberClassGenerated.BigNumberDependencies,
        FractionDependencies: _dependenciesFractionClassGenerated.FractionDependencies,
        complexDependencies: _dependenciesComplexGenerated.complexDependencies,
        typedDependencies: _dependenciesTypedGenerated.typedDependencies,
        createSign: _factoriesAny.createSign
      };
    }
  });

  // node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/entry/dependenciesAny/dependenciesQr.generated.js
  var require_dependenciesQr_generated = __commonJS({
    "node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/entry/dependenciesAny/dependenciesQr.generated.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.qrDependencies = void 0;
      var _dependenciesAddScalarGenerated = require_dependenciesAddScalar_generated();
      var _dependenciesComplexGenerated = require_dependenciesComplex_generated();
      var _dependenciesConjGenerated = require_dependenciesConj_generated();
      var _dependenciesDivideScalarGenerated = require_dependenciesDivideScalar_generated();
      var _dependenciesEqualGenerated = require_dependenciesEqual_generated();
      var _dependenciesIdentityGenerated = require_dependenciesIdentity_generated();
      var _dependenciesIsZeroGenerated = require_dependenciesIsZero_generated();
      var _dependenciesMatrixGenerated = require_dependenciesMatrix_generated();
      var _dependenciesMultiplyScalarGenerated = require_dependenciesMultiplyScalar_generated();
      var _dependenciesSignGenerated = require_dependenciesSign_generated();
      var _dependenciesSqrtGenerated = require_dependenciesSqrt_generated();
      var _dependenciesSubtractScalarGenerated = require_dependenciesSubtractScalar_generated();
      var _dependenciesTypedGenerated = require_dependenciesTyped_generated();
      var _dependenciesUnaryMinusGenerated = require_dependenciesUnaryMinus_generated();
      var _dependenciesZerosGenerated = require_dependenciesZeros_generated();
      var _factoriesAny = require_factoriesAny();
      var qrDependencies = exports.qrDependencies = {
        addScalarDependencies: _dependenciesAddScalarGenerated.addScalarDependencies,
        complexDependencies: _dependenciesComplexGenerated.complexDependencies,
        conjDependencies: _dependenciesConjGenerated.conjDependencies,
        divideScalarDependencies: _dependenciesDivideScalarGenerated.divideScalarDependencies,
        equalDependencies: _dependenciesEqualGenerated.equalDependencies,
        identityDependencies: _dependenciesIdentityGenerated.identityDependencies,
        isZeroDependencies: _dependenciesIsZeroGenerated.isZeroDependencies,
        matrixDependencies: _dependenciesMatrixGenerated.matrixDependencies,
        multiplyScalarDependencies: _dependenciesMultiplyScalarGenerated.multiplyScalarDependencies,
        signDependencies: _dependenciesSignGenerated.signDependencies,
        sqrtDependencies: _dependenciesSqrtGenerated.sqrtDependencies,
        subtractScalarDependencies: _dependenciesSubtractScalarGenerated.subtractScalarDependencies,
        typedDependencies: _dependenciesTypedGenerated.typedDependencies,
        unaryMinusDependencies: _dependenciesUnaryMinusGenerated.unaryMinusDependencies,
        zerosDependencies: _dependenciesZerosGenerated.zerosDependencies,
        createQr: _factoriesAny.createQr
      };
    }
  });

  // node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/entry/dependenciesAny/dependenciesRe.generated.js
  var require_dependenciesRe_generated = __commonJS({
    "node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/entry/dependenciesAny/dependenciesRe.generated.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.reDependencies = void 0;
      var _dependenciesTypedGenerated = require_dependenciesTyped_generated();
      var _factoriesAny = require_factoriesAny();
      var reDependencies = exports.reDependencies = {
        typedDependencies: _dependenciesTypedGenerated.typedDependencies,
        createRe: _factoriesAny.createRe
      };
    }
  });

  // node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/entry/dependenciesAny/dependenciesReshape.generated.js
  var require_dependenciesReshape_generated = __commonJS({
    "node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/entry/dependenciesAny/dependenciesReshape.generated.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.reshapeDependencies = void 0;
      var _dependenciesIsIntegerGenerated = require_dependenciesIsInteger_generated();
      var _dependenciesMatrixGenerated = require_dependenciesMatrix_generated();
      var _dependenciesTypedGenerated = require_dependenciesTyped_generated();
      var _factoriesAny = require_factoriesAny();
      var reshapeDependencies = exports.reshapeDependencies = {
        isIntegerDependencies: _dependenciesIsIntegerGenerated.isIntegerDependencies,
        matrixDependencies: _dependenciesMatrixGenerated.matrixDependencies,
        typedDependencies: _dependenciesTypedGenerated.typedDependencies,
        createReshape: _factoriesAny.createReshape
      };
    }
  });

  // node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/entry/dependenciesAny/dependenciesSin.generated.js
  var require_dependenciesSin_generated = __commonJS({
    "node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/entry/dependenciesAny/dependenciesSin.generated.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.sinDependencies = void 0;
      var _dependenciesTypedGenerated = require_dependenciesTyped_generated();
      var _factoriesAny = require_factoriesAny();
      var sinDependencies = exports.sinDependencies = {
        typedDependencies: _dependenciesTypedGenerated.typedDependencies,
        createSin: _factoriesAny.createSin
      };
    }
  });

  // node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/entry/dependenciesAny/dependenciesUsolve.generated.js
  var require_dependenciesUsolve_generated = __commonJS({
    "node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/entry/dependenciesAny/dependenciesUsolve.generated.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.usolveDependencies = void 0;
      var _dependenciesDenseMatrixClassGenerated = require_dependenciesDenseMatrixClass_generated();
      var _dependenciesDivideScalarGenerated = require_dependenciesDivideScalar_generated();
      var _dependenciesEqualScalarGenerated = require_dependenciesEqualScalar_generated();
      var _dependenciesMatrixGenerated = require_dependenciesMatrix_generated();
      var _dependenciesMultiplyScalarGenerated = require_dependenciesMultiplyScalar_generated();
      var _dependenciesSubtractScalarGenerated = require_dependenciesSubtractScalar_generated();
      var _dependenciesTypedGenerated = require_dependenciesTyped_generated();
      var _factoriesAny = require_factoriesAny();
      var usolveDependencies = exports.usolveDependencies = {
        DenseMatrixDependencies: _dependenciesDenseMatrixClassGenerated.DenseMatrixDependencies,
        divideScalarDependencies: _dependenciesDivideScalarGenerated.divideScalarDependencies,
        equalScalarDependencies: _dependenciesEqualScalarGenerated.equalScalarDependencies,
        matrixDependencies: _dependenciesMatrixGenerated.matrixDependencies,
        multiplyScalarDependencies: _dependenciesMultiplyScalarGenerated.multiplyScalarDependencies,
        subtractScalarDependencies: _dependenciesSubtractScalarGenerated.subtractScalarDependencies,
        typedDependencies: _dependenciesTypedGenerated.typedDependencies,
        createUsolve: _factoriesAny.createUsolve
      };
    }
  });

  // node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/entry/dependenciesAny/dependenciesUsolveAll.generated.js
  var require_dependenciesUsolveAll_generated = __commonJS({
    "node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/entry/dependenciesAny/dependenciesUsolveAll.generated.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.usolveAllDependencies = void 0;
      var _dependenciesDenseMatrixClassGenerated = require_dependenciesDenseMatrixClass_generated();
      var _dependenciesDivideScalarGenerated = require_dependenciesDivideScalar_generated();
      var _dependenciesEqualScalarGenerated = require_dependenciesEqualScalar_generated();
      var _dependenciesMatrixGenerated = require_dependenciesMatrix_generated();
      var _dependenciesMultiplyScalarGenerated = require_dependenciesMultiplyScalar_generated();
      var _dependenciesSubtractScalarGenerated = require_dependenciesSubtractScalar_generated();
      var _dependenciesTypedGenerated = require_dependenciesTyped_generated();
      var _factoriesAny = require_factoriesAny();
      var usolveAllDependencies = exports.usolveAllDependencies = {
        DenseMatrixDependencies: _dependenciesDenseMatrixClassGenerated.DenseMatrixDependencies,
        divideScalarDependencies: _dependenciesDivideScalarGenerated.divideScalarDependencies,
        equalScalarDependencies: _dependenciesEqualScalarGenerated.equalScalarDependencies,
        matrixDependencies: _dependenciesMatrixGenerated.matrixDependencies,
        multiplyScalarDependencies: _dependenciesMultiplyScalarGenerated.multiplyScalarDependencies,
        subtractScalarDependencies: _dependenciesSubtractScalarGenerated.subtractScalarDependencies,
        typedDependencies: _dependenciesTypedGenerated.typedDependencies,
        createUsolveAll: _factoriesAny.createUsolveAll
      };
    }
  });

  // node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/entry/dependenciesAny/dependenciesEigs.generated.js
  var require_dependenciesEigs_generated = __commonJS({
    "node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/entry/dependenciesAny/dependenciesEigs.generated.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.eigsDependencies = void 0;
      var _dependenciesAbsGenerated = require_dependenciesAbs_generated();
      var _dependenciesAddGenerated = require_dependenciesAdd_generated();
      var _dependenciesAddScalarGenerated = require_dependenciesAddScalar_generated();
      var _dependenciesAtanGenerated = require_dependenciesAtan_generated();
      var _dependenciesBignumberGenerated = require_dependenciesBignumber_generated();
      var _dependenciesColumnGenerated = require_dependenciesColumn_generated();
      var _dependenciesComplexGenerated = require_dependenciesComplex_generated();
      var _dependenciesCosGenerated = require_dependenciesCos_generated();
      var _dependenciesDiagGenerated = require_dependenciesDiag_generated();
      var _dependenciesDivideScalarGenerated = require_dependenciesDivideScalar_generated();
      var _dependenciesDotGenerated = require_dependenciesDot_generated();
      var _dependenciesEqualGenerated = require_dependenciesEqual_generated();
      var _dependenciesFlattenGenerated = require_dependenciesFlatten_generated();
      var _dependenciesImGenerated = require_dependenciesIm_generated();
      var _dependenciesInvGenerated = require_dependenciesInv_generated();
      var _dependenciesLargerGenerated = require_dependenciesLarger_generated();
      var _dependenciesMatrixGenerated = require_dependenciesMatrix_generated();
      var _dependenciesMatrixFromColumnsGenerated = require_dependenciesMatrixFromColumns_generated();
      var _dependenciesMultiplyGenerated = require_dependenciesMultiply_generated();
      var _dependenciesMultiplyScalarGenerated = require_dependenciesMultiplyScalar_generated();
      var _dependenciesNumberGenerated = require_dependenciesNumber_generated();
      var _dependenciesQrGenerated = require_dependenciesQr_generated();
      var _dependenciesReGenerated = require_dependenciesRe_generated();
      var _dependenciesReshapeGenerated = require_dependenciesReshape_generated();
      var _dependenciesSinGenerated = require_dependenciesSin_generated();
      var _dependenciesSizeGenerated = require_dependenciesSize_generated();
      var _dependenciesSmallerGenerated = require_dependenciesSmaller_generated();
      var _dependenciesSqrtGenerated = require_dependenciesSqrt_generated();
      var _dependenciesSubtractGenerated = require_dependenciesSubtract_generated();
      var _dependenciesTypedGenerated = require_dependenciesTyped_generated();
      var _dependenciesUsolveGenerated = require_dependenciesUsolve_generated();
      var _dependenciesUsolveAllGenerated = require_dependenciesUsolveAll_generated();
      var _factoriesAny = require_factoriesAny();
      var eigsDependencies = exports.eigsDependencies = {
        absDependencies: _dependenciesAbsGenerated.absDependencies,
        addDependencies: _dependenciesAddGenerated.addDependencies,
        addScalarDependencies: _dependenciesAddScalarGenerated.addScalarDependencies,
        atanDependencies: _dependenciesAtanGenerated.atanDependencies,
        bignumberDependencies: _dependenciesBignumberGenerated.bignumberDependencies,
        columnDependencies: _dependenciesColumnGenerated.columnDependencies,
        complexDependencies: _dependenciesComplexGenerated.complexDependencies,
        cosDependencies: _dependenciesCosGenerated.cosDependencies,
        diagDependencies: _dependenciesDiagGenerated.diagDependencies,
        divideScalarDependencies: _dependenciesDivideScalarGenerated.divideScalarDependencies,
        dotDependencies: _dependenciesDotGenerated.dotDependencies,
        equalDependencies: _dependenciesEqualGenerated.equalDependencies,
        flattenDependencies: _dependenciesFlattenGenerated.flattenDependencies,
        imDependencies: _dependenciesImGenerated.imDependencies,
        invDependencies: _dependenciesInvGenerated.invDependencies,
        largerDependencies: _dependenciesLargerGenerated.largerDependencies,
        matrixDependencies: _dependenciesMatrixGenerated.matrixDependencies,
        matrixFromColumnsDependencies: _dependenciesMatrixFromColumnsGenerated.matrixFromColumnsDependencies,
        multiplyDependencies: _dependenciesMultiplyGenerated.multiplyDependencies,
        multiplyScalarDependencies: _dependenciesMultiplyScalarGenerated.multiplyScalarDependencies,
        numberDependencies: _dependenciesNumberGenerated.numberDependencies,
        qrDependencies: _dependenciesQrGenerated.qrDependencies,
        reDependencies: _dependenciesReGenerated.reDependencies,
        reshapeDependencies: _dependenciesReshapeGenerated.reshapeDependencies,
        sinDependencies: _dependenciesSinGenerated.sinDependencies,
        sizeDependencies: _dependenciesSizeGenerated.sizeDependencies,
        smallerDependencies: _dependenciesSmallerGenerated.smallerDependencies,
        sqrtDependencies: _dependenciesSqrtGenerated.sqrtDependencies,
        subtractDependencies: _dependenciesSubtractGenerated.subtractDependencies,
        typedDependencies: _dependenciesTypedGenerated.typedDependencies,
        usolveDependencies: _dependenciesUsolveGenerated.usolveDependencies,
        usolveAllDependencies: _dependenciesUsolveAllGenerated.usolveAllDependencies,
        createEigs: _factoriesAny.createEigs
      };
    }
  });

  // node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/entry/dependenciesAny/dependenciesElectricConstant.generated.js
  var require_dependenciesElectricConstant_generated = __commonJS({
    "node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/entry/dependenciesAny/dependenciesElectricConstant.generated.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.electricConstantDependencies = void 0;
      var _dependenciesBigNumberClassGenerated = require_dependenciesBigNumberClass_generated();
      var _dependenciesUnitClassGenerated = require_dependenciesUnitClass_generated();
      var _factoriesAny = require_factoriesAny();
      var electricConstantDependencies = exports.electricConstantDependencies = {
        BigNumberDependencies: _dependenciesBigNumberClassGenerated.BigNumberDependencies,
        UnitDependencies: _dependenciesUnitClassGenerated.UnitDependencies,
        createElectricConstant: _factoriesAny.createElectricConstant
      };
    }
  });

  // node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/entry/dependenciesAny/dependenciesElectronMass.generated.js
  var require_dependenciesElectronMass_generated = __commonJS({
    "node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/entry/dependenciesAny/dependenciesElectronMass.generated.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.electronMassDependencies = void 0;
      var _dependenciesBigNumberClassGenerated = require_dependenciesBigNumberClass_generated();
      var _dependenciesUnitClassGenerated = require_dependenciesUnitClass_generated();
      var _factoriesAny = require_factoriesAny();
      var electronMassDependencies = exports.electronMassDependencies = {
        BigNumberDependencies: _dependenciesBigNumberClassGenerated.BigNumberDependencies,
        UnitDependencies: _dependenciesUnitClassGenerated.UnitDependencies,
        createElectronMass: _factoriesAny.createElectronMass
      };
    }
  });

  // node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/entry/dependenciesAny/dependenciesElementaryCharge.generated.js
  var require_dependenciesElementaryCharge_generated = __commonJS({
    "node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/entry/dependenciesAny/dependenciesElementaryCharge.generated.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.elementaryChargeDependencies = void 0;
      var _dependenciesBigNumberClassGenerated = require_dependenciesBigNumberClass_generated();
      var _dependenciesUnitClassGenerated = require_dependenciesUnitClass_generated();
      var _factoriesAny = require_factoriesAny();
      var elementaryChargeDependencies = exports.elementaryChargeDependencies = {
        BigNumberDependencies: _dependenciesBigNumberClassGenerated.BigNumberDependencies,
        UnitDependencies: _dependenciesUnitClassGenerated.UnitDependencies,
        createElementaryCharge: _factoriesAny.createElementaryCharge
      };
    }
  });

  // node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/entry/dependenciesAny/dependenciesEqualText.generated.js
  var require_dependenciesEqualText_generated = __commonJS({
    "node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/entry/dependenciesAny/dependenciesEqualText.generated.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.equalTextDependencies = void 0;
      var _dependenciesCompareTextGenerated = require_dependenciesCompareText_generated();
      var _dependenciesIsZeroGenerated = require_dependenciesIsZero_generated();
      var _dependenciesTypedGenerated = require_dependenciesTyped_generated();
      var _factoriesAny = require_factoriesAny();
      var equalTextDependencies = exports.equalTextDependencies = {
        compareTextDependencies: _dependenciesCompareTextGenerated.compareTextDependencies,
        isZeroDependencies: _dependenciesIsZeroGenerated.isZeroDependencies,
        typedDependencies: _dependenciesTypedGenerated.typedDependencies,
        createEqualText: _factoriesAny.createEqualText
      };
    }
  });

  // node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/entry/dependenciesAny/dependenciesErf.generated.js
  var require_dependenciesErf_generated = __commonJS({
    "node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/entry/dependenciesAny/dependenciesErf.generated.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.erfDependencies = void 0;
      var _dependenciesTypedGenerated = require_dependenciesTyped_generated();
      var _factoriesAny = require_factoriesAny();
      var erfDependencies = exports.erfDependencies = {
        typedDependencies: _dependenciesTypedGenerated.typedDependencies,
        createErf: _factoriesAny.createErf
      };
    }
  });

  // node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/entry/dependenciesAny/dependenciesEvaluate.generated.js
  var require_dependenciesEvaluate_generated = __commonJS({
    "node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/entry/dependenciesAny/dependenciesEvaluate.generated.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.evaluateDependencies = void 0;
      var _dependenciesParseGenerated = require_dependenciesParse_generated();
      var _dependenciesTypedGenerated = require_dependenciesTyped_generated();
      var _factoriesAny = require_factoriesAny();
      var evaluateDependencies = exports.evaluateDependencies = {
        parseDependencies: _dependenciesParseGenerated.parseDependencies,
        typedDependencies: _dependenciesTypedGenerated.typedDependencies,
        createEvaluate: _factoriesAny.createEvaluate
      };
    }
  });

  // node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/entry/dependenciesAny/dependenciesExp.generated.js
  var require_dependenciesExp_generated = __commonJS({
    "node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/entry/dependenciesAny/dependenciesExp.generated.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.expDependencies = void 0;
      var _dependenciesTypedGenerated = require_dependenciesTyped_generated();
      var _factoriesAny = require_factoriesAny();
      var expDependencies = exports.expDependencies = {
        typedDependencies: _dependenciesTypedGenerated.typedDependencies,
        createExp: _factoriesAny.createExp
      };
    }
  });

  // node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/entry/dependenciesAny/dependenciesExpm.generated.js
  var require_dependenciesExpm_generated = __commonJS({
    "node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/entry/dependenciesAny/dependenciesExpm.generated.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.expmDependencies = void 0;
      var _dependenciesAbsGenerated = require_dependenciesAbs_generated();
      var _dependenciesAddGenerated = require_dependenciesAdd_generated();
      var _dependenciesIdentityGenerated = require_dependenciesIdentity_generated();
      var _dependenciesInvGenerated = require_dependenciesInv_generated();
      var _dependenciesMultiplyGenerated = require_dependenciesMultiply_generated();
      var _dependenciesTypedGenerated = require_dependenciesTyped_generated();
      var _factoriesAny = require_factoriesAny();
      var expmDependencies = exports.expmDependencies = {
        absDependencies: _dependenciesAbsGenerated.absDependencies,
        addDependencies: _dependenciesAddGenerated.addDependencies,
        identityDependencies: _dependenciesIdentityGenerated.identityDependencies,
        invDependencies: _dependenciesInvGenerated.invDependencies,
        multiplyDependencies: _dependenciesMultiplyGenerated.multiplyDependencies,
        typedDependencies: _dependenciesTypedGenerated.typedDependencies,
        createExpm: _factoriesAny.createExpm
      };
    }
  });

  // node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/entry/dependenciesAny/dependenciesExpm1.generated.js
  var require_dependenciesExpm1_generated = __commonJS({
    "node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/entry/dependenciesAny/dependenciesExpm1.generated.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.expm1Dependencies = void 0;
      var _dependenciesComplexClassGenerated = require_dependenciesComplexClass_generated();
      var _dependenciesTypedGenerated = require_dependenciesTyped_generated();
      var _factoriesAny = require_factoriesAny();
      var expm1Dependencies = exports.expm1Dependencies = {
        ComplexDependencies: _dependenciesComplexClassGenerated.ComplexDependencies,
        typedDependencies: _dependenciesTypedGenerated.typedDependencies,
        createExpm1: _factoriesAny.createExpm1
      };
    }
  });

  // node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/entry/dependenciesAny/dependenciesFalse.generated.js
  var require_dependenciesFalse_generated = __commonJS({
    "node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/entry/dependenciesAny/dependenciesFalse.generated.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.falseDependencies = void 0;
      var _factoriesAny = require_factoriesAny();
      var falseDependencies = exports.falseDependencies = {
        createFalse: _factoriesAny.createFalse
      };
    }
  });

  // node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/entry/dependenciesAny/dependenciesFaraday.generated.js
  var require_dependenciesFaraday_generated = __commonJS({
    "node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/entry/dependenciesAny/dependenciesFaraday.generated.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.faradayDependencies = void 0;
      var _dependenciesBigNumberClassGenerated = require_dependenciesBigNumberClass_generated();
      var _dependenciesUnitClassGenerated = require_dependenciesUnitClass_generated();
      var _factoriesAny = require_factoriesAny();
      var faradayDependencies = exports.faradayDependencies = {
        BigNumberDependencies: _dependenciesBigNumberClassGenerated.BigNumberDependencies,
        UnitDependencies: _dependenciesUnitClassGenerated.UnitDependencies,
        createFaraday: _factoriesAny.createFaraday
      };
    }
  });

  // node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/entry/dependenciesAny/dependenciesFermiCoupling.generated.js
  var require_dependenciesFermiCoupling_generated = __commonJS({
    "node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/entry/dependenciesAny/dependenciesFermiCoupling.generated.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.fermiCouplingDependencies = void 0;
      var _dependenciesBigNumberClassGenerated = require_dependenciesBigNumberClass_generated();
      var _dependenciesUnitClassGenerated = require_dependenciesUnitClass_generated();
      var _factoriesAny = require_factoriesAny();
      var fermiCouplingDependencies = exports.fermiCouplingDependencies = {
        BigNumberDependencies: _dependenciesBigNumberClassGenerated.BigNumberDependencies,
        UnitDependencies: _dependenciesUnitClassGenerated.UnitDependencies,
        createFermiCoupling: _factoriesAny.createFermiCoupling
      };
    }
  });

  // node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/entry/dependenciesAny/dependenciesI.generated.js
  var require_dependenciesI_generated = __commonJS({
    "node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/entry/dependenciesAny/dependenciesI.generated.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.iDependencies = void 0;
      var _dependenciesComplexClassGenerated = require_dependenciesComplexClass_generated();
      var _factoriesAny = require_factoriesAny();
      var iDependencies = exports.iDependencies = {
        ComplexDependencies: _dependenciesComplexClassGenerated.ComplexDependencies,
        createI: _factoriesAny.createI
      };
    }
  });

  // node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/entry/dependenciesAny/dependenciesLog2.generated.js
  var require_dependenciesLog2_generated = __commonJS({
    "node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/entry/dependenciesAny/dependenciesLog2.generated.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.log2Dependencies = void 0;
      var _dependenciesComplexClassGenerated = require_dependenciesComplexClass_generated();
      var _dependenciesTypedGenerated = require_dependenciesTyped_generated();
      var _factoriesAny = require_factoriesAny();
      var log2Dependencies = exports.log2Dependencies = {
        ComplexDependencies: _dependenciesComplexClassGenerated.ComplexDependencies,
        typedDependencies: _dependenciesTypedGenerated.typedDependencies,
        createLog2: _factoriesAny.createLog2
      };
    }
  });

  // node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/entry/dependenciesAny/dependenciesTau.generated.js
  var require_dependenciesTau_generated = __commonJS({
    "node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/entry/dependenciesAny/dependenciesTau.generated.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.tauDependencies = void 0;
      var _dependenciesBigNumberClassGenerated = require_dependenciesBigNumberClass_generated();
      var _factoriesAny = require_factoriesAny();
      var tauDependencies = exports.tauDependencies = {
        BigNumberDependencies: _dependenciesBigNumberClassGenerated.BigNumberDependencies,
        createTau: _factoriesAny.createTau
      };
    }
  });

  // node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/entry/dependenciesAny/dependenciesFft.generated.js
  var require_dependenciesFft_generated = __commonJS({
    "node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/entry/dependenciesAny/dependenciesFft.generated.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.fftDependencies = void 0;
      var _dependenciesAddScalarGenerated = require_dependenciesAddScalar_generated();
      var _dependenciesCeilGenerated = require_dependenciesCeil_generated();
      var _dependenciesConjGenerated = require_dependenciesConj_generated();
      var _dependenciesDivideScalarGenerated = require_dependenciesDivideScalar_generated();
      var _dependenciesDotDivideGenerated = require_dependenciesDotDivide_generated();
      var _dependenciesExpGenerated = require_dependenciesExp_generated();
      var _dependenciesIGenerated = require_dependenciesI_generated();
      var _dependenciesLog2Generated = require_dependenciesLog2_generated();
      var _dependenciesMatrixGenerated = require_dependenciesMatrix_generated();
      var _dependenciesMultiplyScalarGenerated = require_dependenciesMultiplyScalar_generated();
      var _dependenciesPowGenerated = require_dependenciesPow_generated();
      var _dependenciesTauGenerated = require_dependenciesTau_generated();
      var _dependenciesTypedGenerated = require_dependenciesTyped_generated();
      var _factoriesAny = require_factoriesAny();
      var fftDependencies = exports.fftDependencies = {
        addScalarDependencies: _dependenciesAddScalarGenerated.addScalarDependencies,
        ceilDependencies: _dependenciesCeilGenerated.ceilDependencies,
        conjDependencies: _dependenciesConjGenerated.conjDependencies,
        divideScalarDependencies: _dependenciesDivideScalarGenerated.divideScalarDependencies,
        dotDivideDependencies: _dependenciesDotDivideGenerated.dotDivideDependencies,
        expDependencies: _dependenciesExpGenerated.expDependencies,
        iDependencies: _dependenciesIGenerated.iDependencies,
        log2Dependencies: _dependenciesLog2Generated.log2Dependencies,
        matrixDependencies: _dependenciesMatrixGenerated.matrixDependencies,
        multiplyScalarDependencies: _dependenciesMultiplyScalarGenerated.multiplyScalarDependencies,
        powDependencies: _dependenciesPowGenerated.powDependencies,
        tauDependencies: _dependenciesTauGenerated.tauDependencies,
        typedDependencies: _dependenciesTypedGenerated.typedDependencies,
        createFft: _factoriesAny.createFft
      };
    }
  });

  // node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/entry/dependenciesAny/dependenciesFibonacciHeapClass.generated.js
  var require_dependenciesFibonacciHeapClass_generated = __commonJS({
    "node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/entry/dependenciesAny/dependenciesFibonacciHeapClass.generated.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.FibonacciHeapDependencies = void 0;
      var _dependenciesLargerGenerated = require_dependenciesLarger_generated();
      var _dependenciesSmallerGenerated = require_dependenciesSmaller_generated();
      var _factoriesAny = require_factoriesAny();
      var FibonacciHeapDependencies = exports.FibonacciHeapDependencies = {
        largerDependencies: _dependenciesLargerGenerated.largerDependencies,
        smallerDependencies: _dependenciesSmallerGenerated.smallerDependencies,
        createFibonacciHeapClass: _factoriesAny.createFibonacciHeapClass
      };
    }
  });

  // node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/entry/dependenciesAny/dependenciesFilter.generated.js
  var require_dependenciesFilter_generated = __commonJS({
    "node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/entry/dependenciesAny/dependenciesFilter.generated.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.filterDependencies = void 0;
      var _dependenciesTypedGenerated = require_dependenciesTyped_generated();
      var _factoriesAny = require_factoriesAny();
      var filterDependencies = exports.filterDependencies = {
        typedDependencies: _dependenciesTypedGenerated.typedDependencies,
        createFilter: _factoriesAny.createFilter
      };
    }
  });

  // node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/entry/dependenciesAny/dependenciesFilterTransform.generated.js
  var require_dependenciesFilterTransform_generated = __commonJS({
    "node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/entry/dependenciesAny/dependenciesFilterTransform.generated.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.filterTransformDependencies = void 0;
      var _dependenciesTypedGenerated = require_dependenciesTyped_generated();
      var _factoriesAny = require_factoriesAny();
      var filterTransformDependencies = exports.filterTransformDependencies = {
        typedDependencies: _dependenciesTypedGenerated.typedDependencies,
        createFilterTransform: _factoriesAny.createFilterTransform
      };
    }
  });

  // node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/entry/dependenciesAny/dependenciesFineStructure.generated.js
  var require_dependenciesFineStructure_generated = __commonJS({
    "node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/entry/dependenciesAny/dependenciesFineStructure.generated.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.fineStructureDependencies = void 0;
      var _dependenciesBigNumberClassGenerated = require_dependenciesBigNumberClass_generated();
      var _factoriesAny = require_factoriesAny();
      var fineStructureDependencies = exports.fineStructureDependencies = {
        BigNumberDependencies: _dependenciesBigNumberClassGenerated.BigNumberDependencies,
        createFineStructure: _factoriesAny.createFineStructure
      };
    }
  });

  // node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/entry/dependenciesAny/dependenciesFirstRadiation.generated.js
  var require_dependenciesFirstRadiation_generated = __commonJS({
    "node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/entry/dependenciesAny/dependenciesFirstRadiation.generated.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.firstRadiationDependencies = void 0;
      var _dependenciesBigNumberClassGenerated = require_dependenciesBigNumberClass_generated();
      var _dependenciesUnitClassGenerated = require_dependenciesUnitClass_generated();
      var _factoriesAny = require_factoriesAny();
      var firstRadiationDependencies = exports.firstRadiationDependencies = {
        BigNumberDependencies: _dependenciesBigNumberClassGenerated.BigNumberDependencies,
        UnitDependencies: _dependenciesUnitClassGenerated.UnitDependencies,
        createFirstRadiation: _factoriesAny.createFirstRadiation
      };
    }
  });

  // node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/entry/dependenciesAny/dependenciesForEach.generated.js
  var require_dependenciesForEach_generated = __commonJS({
    "node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/entry/dependenciesAny/dependenciesForEach.generated.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.forEachDependencies = void 0;
      var _dependenciesTypedGenerated = require_dependenciesTyped_generated();
      var _factoriesAny = require_factoriesAny();
      var forEachDependencies = exports.forEachDependencies = {
        typedDependencies: _dependenciesTypedGenerated.typedDependencies,
        createForEach: _factoriesAny.createForEach
      };
    }
  });

  // node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/entry/dependenciesAny/dependenciesForEachTransform.generated.js
  var require_dependenciesForEachTransform_generated = __commonJS({
    "node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/entry/dependenciesAny/dependenciesForEachTransform.generated.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.forEachTransformDependencies = void 0;
      var _dependenciesTypedGenerated = require_dependenciesTyped_generated();
      var _factoriesAny = require_factoriesAny();
      var forEachTransformDependencies = exports.forEachTransformDependencies = {
        typedDependencies: _dependenciesTypedGenerated.typedDependencies,
        createForEachTransform: _factoriesAny.createForEachTransform
      };
    }
  });

  // node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/entry/dependenciesAny/dependenciesFreqz.generated.js
  var require_dependenciesFreqz_generated = __commonJS({
    "node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/entry/dependenciesAny/dependenciesFreqz.generated.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.freqzDependencies = void 0;
      var _dependenciesComplexClassGenerated = require_dependenciesComplexClass_generated();
      var _dependenciesAddGenerated = require_dependenciesAdd_generated();
      var _dependenciesDivideGenerated = require_dependenciesDivide_generated();
      var _dependenciesMatrixGenerated = require_dependenciesMatrix_generated();
      var _dependenciesMultiplyGenerated = require_dependenciesMultiply_generated();
      var _dependenciesTypedGenerated = require_dependenciesTyped_generated();
      var _factoriesAny = require_factoriesAny();
      var freqzDependencies = exports.freqzDependencies = {
        ComplexDependencies: _dependenciesComplexClassGenerated.ComplexDependencies,
        addDependencies: _dependenciesAddGenerated.addDependencies,
        divideDependencies: _dependenciesDivideGenerated.divideDependencies,
        matrixDependencies: _dependenciesMatrixGenerated.matrixDependencies,
        multiplyDependencies: _dependenciesMultiplyGenerated.multiplyDependencies,
        typedDependencies: _dependenciesTypedGenerated.typedDependencies,
        createFreqz: _factoriesAny.createFreqz
      };
    }
  });

  // node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/entry/dependenciesAny/dependenciesGasConstant.generated.js
  var require_dependenciesGasConstant_generated = __commonJS({
    "node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/entry/dependenciesAny/dependenciesGasConstant.generated.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.gasConstantDependencies = void 0;
      var _dependenciesBigNumberClassGenerated = require_dependenciesBigNumberClass_generated();
      var _dependenciesUnitClassGenerated = require_dependenciesUnitClass_generated();
      var _factoriesAny = require_factoriesAny();
      var gasConstantDependencies = exports.gasConstantDependencies = {
        BigNumberDependencies: _dependenciesBigNumberClassGenerated.BigNumberDependencies,
        UnitDependencies: _dependenciesUnitClassGenerated.UnitDependencies,
        createGasConstant: _factoriesAny.createGasConstant
      };
    }
  });

  // node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/entry/dependenciesAny/dependenciesGcd.generated.js
  var require_dependenciesGcd_generated = __commonJS({
    "node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/entry/dependenciesAny/dependenciesGcd.generated.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.gcdDependencies = void 0;
      var _dependenciesBigNumberClassGenerated = require_dependenciesBigNumberClass_generated();
      var _dependenciesDenseMatrixClassGenerated = require_dependenciesDenseMatrixClass_generated();
      var _dependenciesConcatGenerated = require_dependenciesConcat_generated();
      var _dependenciesEqualScalarGenerated = require_dependenciesEqualScalar_generated();
      var _dependenciesMatrixGenerated = require_dependenciesMatrix_generated();
      var _dependenciesRoundGenerated = require_dependenciesRound_generated();
      var _dependenciesTypedGenerated = require_dependenciesTyped_generated();
      var _dependenciesZerosGenerated = require_dependenciesZeros_generated();
      var _factoriesAny = require_factoriesAny();
      var gcdDependencies = exports.gcdDependencies = {
        BigNumberDependencies: _dependenciesBigNumberClassGenerated.BigNumberDependencies,
        DenseMatrixDependencies: _dependenciesDenseMatrixClassGenerated.DenseMatrixDependencies,
        concatDependencies: _dependenciesConcatGenerated.concatDependencies,
        equalScalarDependencies: _dependenciesEqualScalarGenerated.equalScalarDependencies,
        matrixDependencies: _dependenciesMatrixGenerated.matrixDependencies,
        roundDependencies: _dependenciesRoundGenerated.roundDependencies,
        typedDependencies: _dependenciesTypedGenerated.typedDependencies,
        zerosDependencies: _dependenciesZerosGenerated.zerosDependencies,
        createGcd: _factoriesAny.createGcd
      };
    }
  });

  // node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/entry/dependenciesAny/dependenciesGravitationConstant.generated.js
  var require_dependenciesGravitationConstant_generated = __commonJS({
    "node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/entry/dependenciesAny/dependenciesGravitationConstant.generated.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.gravitationConstantDependencies = void 0;
      var _dependenciesBigNumberClassGenerated = require_dependenciesBigNumberClass_generated();
      var _dependenciesUnitClassGenerated = require_dependenciesUnitClass_generated();
      var _factoriesAny = require_factoriesAny();
      var gravitationConstantDependencies = exports.gravitationConstantDependencies = {
        BigNumberDependencies: _dependenciesBigNumberClassGenerated.BigNumberDependencies,
        UnitDependencies: _dependenciesUnitClassGenerated.UnitDependencies,
        createGravitationConstant: _factoriesAny.createGravitationConstant
      };
    }
  });

  // node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/entry/dependenciesAny/dependenciesGravity.generated.js
  var require_dependenciesGravity_generated = __commonJS({
    "node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/entry/dependenciesAny/dependenciesGravity.generated.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.gravityDependencies = void 0;
      var _dependenciesBigNumberClassGenerated = require_dependenciesBigNumberClass_generated();
      var _dependenciesUnitClassGenerated = require_dependenciesUnitClass_generated();
      var _factoriesAny = require_factoriesAny();
      var gravityDependencies = exports.gravityDependencies = {
        BigNumberDependencies: _dependenciesBigNumberClassGenerated.BigNumberDependencies,
        UnitDependencies: _dependenciesUnitClassGenerated.UnitDependencies,
        createGravity: _factoriesAny.createGravity
      };
    }
  });

  // node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/entry/dependenciesAny/dependenciesHartreeEnergy.generated.js
  var require_dependenciesHartreeEnergy_generated = __commonJS({
    "node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/entry/dependenciesAny/dependenciesHartreeEnergy.generated.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.hartreeEnergyDependencies = void 0;
      var _dependenciesBigNumberClassGenerated = require_dependenciesBigNumberClass_generated();
      var _dependenciesUnitClassGenerated = require_dependenciesUnitClass_generated();
      var _factoriesAny = require_factoriesAny();
      var hartreeEnergyDependencies = exports.hartreeEnergyDependencies = {
        BigNumberDependencies: _dependenciesBigNumberClassGenerated.BigNumberDependencies,
        UnitDependencies: _dependenciesUnitClassGenerated.UnitDependencies,
        createHartreeEnergy: _factoriesAny.createHartreeEnergy
      };
    }
  });

  // node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/entry/dependenciesAny/dependenciesHasNumericValue.generated.js
  var require_dependenciesHasNumericValue_generated = __commonJS({
    "node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/entry/dependenciesAny/dependenciesHasNumericValue.generated.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.hasNumericValueDependencies = void 0;
      var _dependenciesIsNumericGenerated = require_dependenciesIsNumeric_generated();
      var _dependenciesTypedGenerated = require_dependenciesTyped_generated();
      var _factoriesAny = require_factoriesAny();
      var hasNumericValueDependencies = exports.hasNumericValueDependencies = {
        isNumericDependencies: _dependenciesIsNumericGenerated.isNumericDependencies,
        typedDependencies: _dependenciesTypedGenerated.typedDependencies,
        createHasNumericValue: _factoriesAny.createHasNumericValue
      };
    }
  });

  // node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/entry/dependenciesAny/dependenciesHelpClass.generated.js
  var require_dependenciesHelpClass_generated = __commonJS({
    "node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/entry/dependenciesAny/dependenciesHelpClass.generated.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.HelpDependencies = void 0;
      var _dependenciesEvaluateGenerated = require_dependenciesEvaluate_generated();
      var _factoriesAny = require_factoriesAny();
      var HelpDependencies = exports.HelpDependencies = {
        evaluateDependencies: _dependenciesEvaluateGenerated.evaluateDependencies,
        createHelpClass: _factoriesAny.createHelpClass
      };
    }
  });

  // node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/entry/dependenciesAny/dependenciesHelp.generated.js
  var require_dependenciesHelp_generated = __commonJS({
    "node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/entry/dependenciesAny/dependenciesHelp.generated.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.helpDependencies = void 0;
      var _dependenciesHelpClassGenerated = require_dependenciesHelpClass_generated();
      var _dependenciesTypedGenerated = require_dependenciesTyped_generated();
      var _factoriesAny = require_factoriesAny();
      var helpDependencies = exports.helpDependencies = {
        HelpDependencies: _dependenciesHelpClassGenerated.HelpDependencies,
        typedDependencies: _dependenciesTypedGenerated.typedDependencies,
        createHelp: _factoriesAny.createHelp
      };
    }
  });

  // node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/entry/dependenciesAny/dependenciesHex.generated.js
  var require_dependenciesHex_generated = __commonJS({
    "node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/entry/dependenciesAny/dependenciesHex.generated.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.hexDependencies = void 0;
      var _dependenciesFormatGenerated = require_dependenciesFormat_generated();
      var _dependenciesTypedGenerated = require_dependenciesTyped_generated();
      var _factoriesAny = require_factoriesAny();
      var hexDependencies = exports.hexDependencies = {
        formatDependencies: _dependenciesFormatGenerated.formatDependencies,
        typedDependencies: _dependenciesTypedGenerated.typedDependencies,
        createHex: _factoriesAny.createHex
      };
    }
  });

  // node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/entry/dependenciesAny/dependenciesHypot.generated.js
  var require_dependenciesHypot_generated = __commonJS({
    "node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/entry/dependenciesAny/dependenciesHypot.generated.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.hypotDependencies = void 0;
      var _dependenciesAbsGenerated = require_dependenciesAbs_generated();
      var _dependenciesAddScalarGenerated = require_dependenciesAddScalar_generated();
      var _dependenciesDivideScalarGenerated = require_dependenciesDivideScalar_generated();
      var _dependenciesIsPositiveGenerated = require_dependenciesIsPositive_generated();
      var _dependenciesMultiplyScalarGenerated = require_dependenciesMultiplyScalar_generated();
      var _dependenciesSmallerGenerated = require_dependenciesSmaller_generated();
      var _dependenciesSqrtGenerated = require_dependenciesSqrt_generated();
      var _dependenciesTypedGenerated = require_dependenciesTyped_generated();
      var _factoriesAny = require_factoriesAny();
      var hypotDependencies = exports.hypotDependencies = {
        absDependencies: _dependenciesAbsGenerated.absDependencies,
        addScalarDependencies: _dependenciesAddScalarGenerated.addScalarDependencies,
        divideScalarDependencies: _dependenciesDivideScalarGenerated.divideScalarDependencies,
        isPositiveDependencies: _dependenciesIsPositiveGenerated.isPositiveDependencies,
        multiplyScalarDependencies: _dependenciesMultiplyScalarGenerated.multiplyScalarDependencies,
        smallerDependencies: _dependenciesSmallerGenerated.smallerDependencies,
        sqrtDependencies: _dependenciesSqrtGenerated.sqrtDependencies,
        typedDependencies: _dependenciesTypedGenerated.typedDependencies,
        createHypot: _factoriesAny.createHypot
      };
    }
  });

  // node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/entry/dependenciesAny/dependenciesIfft.generated.js
  var require_dependenciesIfft_generated = __commonJS({
    "node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/entry/dependenciesAny/dependenciesIfft.generated.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.ifftDependencies = void 0;
      var _dependenciesConjGenerated = require_dependenciesConj_generated();
      var _dependenciesDotDivideGenerated = require_dependenciesDotDivide_generated();
      var _dependenciesFftGenerated = require_dependenciesFft_generated();
      var _dependenciesTypedGenerated = require_dependenciesTyped_generated();
      var _factoriesAny = require_factoriesAny();
      var ifftDependencies = exports.ifftDependencies = {
        conjDependencies: _dependenciesConjGenerated.conjDependencies,
        dotDivideDependencies: _dependenciesDotDivideGenerated.dotDivideDependencies,
        fftDependencies: _dependenciesFftGenerated.fftDependencies,
        typedDependencies: _dependenciesTypedGenerated.typedDependencies,
        createIfft: _factoriesAny.createIfft
      };
    }
  });

  // node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/entry/dependenciesAny/dependenciesIndex.generated.js
  var require_dependenciesIndex_generated = __commonJS({
    "node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/entry/dependenciesAny/dependenciesIndex.generated.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.indexDependencies = void 0;
      var _dependenciesIndexClassGenerated = require_dependenciesIndexClass_generated();
      var _dependenciesTypedGenerated = require_dependenciesTyped_generated();
      var _factoriesAny = require_factoriesAny();
      var indexDependencies = exports.indexDependencies = {
        IndexDependencies: _dependenciesIndexClassGenerated.IndexDependencies,
        typedDependencies: _dependenciesTypedGenerated.typedDependencies,
        createIndex: _factoriesAny.createIndex
      };
    }
  });

  // node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/entry/dependenciesAny/dependenciesIndexTransform.generated.js
  var require_dependenciesIndexTransform_generated = __commonJS({
    "node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/entry/dependenciesAny/dependenciesIndexTransform.generated.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.indexTransformDependencies = void 0;
      var _dependenciesIndexClassGenerated = require_dependenciesIndexClass_generated();
      var _dependenciesGetMatrixDataTypeGenerated = require_dependenciesGetMatrixDataType_generated();
      var _factoriesAny = require_factoriesAny();
      var indexTransformDependencies = exports.indexTransformDependencies = {
        IndexDependencies: _dependenciesIndexClassGenerated.IndexDependencies,
        getMatrixDataTypeDependencies: _dependenciesGetMatrixDataTypeGenerated.getMatrixDataTypeDependencies,
        createIndexTransform: _factoriesAny.createIndexTransform
      };
    }
  });

  // node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/entry/dependenciesAny/dependenciesInfinity.generated.js
  var require_dependenciesInfinity_generated = __commonJS({
    "node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/entry/dependenciesAny/dependenciesInfinity.generated.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.InfinityDependencies = void 0;
      var _dependenciesBigNumberClassGenerated = require_dependenciesBigNumberClass_generated();
      var _factoriesAny = require_factoriesAny();
      var InfinityDependencies = exports.InfinityDependencies = {
        BigNumberDependencies: _dependenciesBigNumberClassGenerated.BigNumberDependencies,
        createInfinity: _factoriesAny.createInfinity
      };
    }
  });

  // node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/entry/dependenciesAny/dependenciesIntersect.generated.js
  var require_dependenciesIntersect_generated = __commonJS({
    "node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/entry/dependenciesAny/dependenciesIntersect.generated.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.intersectDependencies = void 0;
      var _dependenciesAbsGenerated = require_dependenciesAbs_generated();
      var _dependenciesAddGenerated = require_dependenciesAdd_generated();
      var _dependenciesAddScalarGenerated = require_dependenciesAddScalar_generated();
      var _dependenciesDivideScalarGenerated = require_dependenciesDivideScalar_generated();
      var _dependenciesEqualScalarGenerated = require_dependenciesEqualScalar_generated();
      var _dependenciesFlattenGenerated = require_dependenciesFlatten_generated();
      var _dependenciesIsNumericGenerated = require_dependenciesIsNumeric_generated();
      var _dependenciesIsZeroGenerated = require_dependenciesIsZero_generated();
      var _dependenciesMatrixGenerated = require_dependenciesMatrix_generated();
      var _dependenciesMultiplyGenerated = require_dependenciesMultiply_generated();
      var _dependenciesMultiplyScalarGenerated = require_dependenciesMultiplyScalar_generated();
      var _dependenciesSmallerGenerated = require_dependenciesSmaller_generated();
      var _dependenciesSubtractGenerated = require_dependenciesSubtract_generated();
      var _dependenciesTypedGenerated = require_dependenciesTyped_generated();
      var _factoriesAny = require_factoriesAny();
      var intersectDependencies = exports.intersectDependencies = {
        absDependencies: _dependenciesAbsGenerated.absDependencies,
        addDependencies: _dependenciesAddGenerated.addDependencies,
        addScalarDependencies: _dependenciesAddScalarGenerated.addScalarDependencies,
        divideScalarDependencies: _dependenciesDivideScalarGenerated.divideScalarDependencies,
        equalScalarDependencies: _dependenciesEqualScalarGenerated.equalScalarDependencies,
        flattenDependencies: _dependenciesFlattenGenerated.flattenDependencies,
        isNumericDependencies: _dependenciesIsNumericGenerated.isNumericDependencies,
        isZeroDependencies: _dependenciesIsZeroGenerated.isZeroDependencies,
        matrixDependencies: _dependenciesMatrixGenerated.matrixDependencies,
        multiplyDependencies: _dependenciesMultiplyGenerated.multiplyDependencies,
        multiplyScalarDependencies: _dependenciesMultiplyScalarGenerated.multiplyScalarDependencies,
        smallerDependencies: _dependenciesSmallerGenerated.smallerDependencies,
        subtractDependencies: _dependenciesSubtractGenerated.subtractDependencies,
        typedDependencies: _dependenciesTypedGenerated.typedDependencies,
        createIntersect: _factoriesAny.createIntersect
      };
    }
  });

  // node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/entry/dependenciesAny/dependenciesInverseConductanceQuantum.generated.js
  var require_dependenciesInverseConductanceQuantum_generated = __commonJS({
    "node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/entry/dependenciesAny/dependenciesInverseConductanceQuantum.generated.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.inverseConductanceQuantumDependencies = void 0;
      var _dependenciesBigNumberClassGenerated = require_dependenciesBigNumberClass_generated();
      var _dependenciesUnitClassGenerated = require_dependenciesUnitClass_generated();
      var _factoriesAny = require_factoriesAny();
      var inverseConductanceQuantumDependencies = exports.inverseConductanceQuantumDependencies = {
        BigNumberDependencies: _dependenciesBigNumberClassGenerated.BigNumberDependencies,
        UnitDependencies: _dependenciesUnitClassGenerated.UnitDependencies,
        createInverseConductanceQuantum: _factoriesAny.createInverseConductanceQuantum
      };
    }
  });

  // node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/entry/dependenciesAny/dependenciesMod.generated.js
  var require_dependenciesMod_generated = __commonJS({
    "node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/entry/dependenciesAny/dependenciesMod.generated.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.modDependencies = void 0;
      var _dependenciesDenseMatrixClassGenerated = require_dependenciesDenseMatrixClass_generated();
      var _dependenciesConcatGenerated = require_dependenciesConcat_generated();
      var _dependenciesEqualScalarGenerated = require_dependenciesEqualScalar_generated();
      var _dependenciesMatrixGenerated = require_dependenciesMatrix_generated();
      var _dependenciesRoundGenerated = require_dependenciesRound_generated();
      var _dependenciesTypedGenerated = require_dependenciesTyped_generated();
      var _dependenciesZerosGenerated = require_dependenciesZeros_generated();
      var _factoriesAny = require_factoriesAny();
      var modDependencies = exports.modDependencies = {
        DenseMatrixDependencies: _dependenciesDenseMatrixClassGenerated.DenseMatrixDependencies,
        concatDependencies: _dependenciesConcatGenerated.concatDependencies,
        equalScalarDependencies: _dependenciesEqualScalarGenerated.equalScalarDependencies,
        matrixDependencies: _dependenciesMatrixGenerated.matrixDependencies,
        roundDependencies: _dependenciesRoundGenerated.roundDependencies,
        typedDependencies: _dependenciesTypedGenerated.typedDependencies,
        zerosDependencies: _dependenciesZerosGenerated.zerosDependencies,
        createMod: _factoriesAny.createMod
      };
    }
  });

  // node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/entry/dependenciesAny/dependenciesXgcd.generated.js
  var require_dependenciesXgcd_generated = __commonJS({
    "node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/entry/dependenciesAny/dependenciesXgcd.generated.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.xgcdDependencies = void 0;
      var _dependenciesBigNumberClassGenerated = require_dependenciesBigNumberClass_generated();
      var _dependenciesMatrixGenerated = require_dependenciesMatrix_generated();
      var _dependenciesTypedGenerated = require_dependenciesTyped_generated();
      var _factoriesAny = require_factoriesAny();
      var xgcdDependencies = exports.xgcdDependencies = {
        BigNumberDependencies: _dependenciesBigNumberClassGenerated.BigNumberDependencies,
        matrixDependencies: _dependenciesMatrixGenerated.matrixDependencies,
        typedDependencies: _dependenciesTypedGenerated.typedDependencies,
        createXgcd: _factoriesAny.createXgcd
      };
    }
  });

  // node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/entry/dependenciesAny/dependenciesInvmod.generated.js
  var require_dependenciesInvmod_generated = __commonJS({
    "node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/entry/dependenciesAny/dependenciesInvmod.generated.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.invmodDependencies = void 0;
      var _dependenciesBigNumberClassGenerated = require_dependenciesBigNumberClass_generated();
      var _dependenciesAddGenerated = require_dependenciesAdd_generated();
      var _dependenciesEqualGenerated = require_dependenciesEqual_generated();
      var _dependenciesIsIntegerGenerated = require_dependenciesIsInteger_generated();
      var _dependenciesModGenerated = require_dependenciesMod_generated();
      var _dependenciesSmallerGenerated = require_dependenciesSmaller_generated();
      var _dependenciesTypedGenerated = require_dependenciesTyped_generated();
      var _dependenciesXgcdGenerated = require_dependenciesXgcd_generated();
      var _factoriesAny = require_factoriesAny();
      var invmodDependencies = exports.invmodDependencies = {
        BigNumberDependencies: _dependenciesBigNumberClassGenerated.BigNumberDependencies,
        addDependencies: _dependenciesAddGenerated.addDependencies,
        equalDependencies: _dependenciesEqualGenerated.equalDependencies,
        isIntegerDependencies: _dependenciesIsIntegerGenerated.isIntegerDependencies,
        modDependencies: _dependenciesModGenerated.modDependencies,
        smallerDependencies: _dependenciesSmallerGenerated.smallerDependencies,
        typedDependencies: _dependenciesTypedGenerated.typedDependencies,
        xgcdDependencies: _dependenciesXgcdGenerated.xgcdDependencies,
        createInvmod: _factoriesAny.createInvmod
      };
    }
  });

  // node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/entry/dependenciesAny/dependenciesIsNaN.generated.js
  var require_dependenciesIsNaN_generated = __commonJS({
    "node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/entry/dependenciesAny/dependenciesIsNaN.generated.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.isNaNDependencies = void 0;
      var _dependenciesTypedGenerated = require_dependenciesTyped_generated();
      var _factoriesAny = require_factoriesAny();
      var isNaNDependencies = exports.isNaNDependencies = {
        typedDependencies: _dependenciesTypedGenerated.typedDependencies,
        createIsNaN: _factoriesAny.createIsNaN
      };
    }
  });

  // node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/entry/dependenciesAny/dependenciesIsPrime.generated.js
  var require_dependenciesIsPrime_generated = __commonJS({
    "node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/entry/dependenciesAny/dependenciesIsPrime.generated.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.isPrimeDependencies = void 0;
      var _dependenciesTypedGenerated = require_dependenciesTyped_generated();
      var _factoriesAny = require_factoriesAny();
      var isPrimeDependencies = exports.isPrimeDependencies = {
        typedDependencies: _dependenciesTypedGenerated.typedDependencies,
        createIsPrime: _factoriesAny.createIsPrime
      };
    }
  });

  // node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/entry/dependenciesAny/dependenciesLog.generated.js
  var require_dependenciesLog_generated = __commonJS({
    "node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/entry/dependenciesAny/dependenciesLog.generated.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.logDependencies = void 0;
      var _dependenciesComplexClassGenerated = require_dependenciesComplexClass_generated();
      var _dependenciesDivideScalarGenerated = require_dependenciesDivideScalar_generated();
      var _dependenciesTypedGenerated = require_dependenciesTyped_generated();
      var _factoriesAny = require_factoriesAny();
      var logDependencies = exports.logDependencies = {
        ComplexDependencies: _dependenciesComplexClassGenerated.ComplexDependencies,
        divideScalarDependencies: _dependenciesDivideScalarGenerated.divideScalarDependencies,
        typedDependencies: _dependenciesTypedGenerated.typedDependencies,
        createLog: _factoriesAny.createLog
      };
    }
  });

  // node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/entry/dependenciesAny/dependenciesMap.generated.js
  var require_dependenciesMap_generated = __commonJS({
    "node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/entry/dependenciesAny/dependenciesMap.generated.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.mapDependencies = void 0;
      var _dependenciesTypedGenerated = require_dependenciesTyped_generated();
      var _factoriesAny = require_factoriesAny();
      var mapDependencies = exports.mapDependencies = {
        typedDependencies: _dependenciesTypedGenerated.typedDependencies,
        createMap: _factoriesAny.createMap
      };
    }
  });

  // node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/entry/dependenciesAny/dependenciesKldivergence.generated.js
  var require_dependenciesKldivergence_generated = __commonJS({
    "node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/entry/dependenciesAny/dependenciesKldivergence.generated.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.kldivergenceDependencies = void 0;
      var _dependenciesDivideGenerated = require_dependenciesDivide_generated();
      var _dependenciesDotDivideGenerated = require_dependenciesDotDivide_generated();
      var _dependenciesIsNumericGenerated = require_dependenciesIsNumeric_generated();
      var _dependenciesLogGenerated = require_dependenciesLog_generated();
      var _dependenciesMapGenerated = require_dependenciesMap_generated();
      var _dependenciesMatrixGenerated = require_dependenciesMatrix_generated();
      var _dependenciesMultiplyGenerated = require_dependenciesMultiply_generated();
      var _dependenciesSumGenerated = require_dependenciesSum_generated();
      var _dependenciesTypedGenerated = require_dependenciesTyped_generated();
      var _factoriesAny = require_factoriesAny();
      var kldivergenceDependencies = exports.kldivergenceDependencies = {
        divideDependencies: _dependenciesDivideGenerated.divideDependencies,
        dotDivideDependencies: _dependenciesDotDivideGenerated.dotDivideDependencies,
        isNumericDependencies: _dependenciesIsNumericGenerated.isNumericDependencies,
        logDependencies: _dependenciesLogGenerated.logDependencies,
        mapDependencies: _dependenciesMapGenerated.mapDependencies,
        matrixDependencies: _dependenciesMatrixGenerated.matrixDependencies,
        multiplyDependencies: _dependenciesMultiplyGenerated.multiplyDependencies,
        sumDependencies: _dependenciesSumGenerated.sumDependencies,
        typedDependencies: _dependenciesTypedGenerated.typedDependencies,
        createKldivergence: _factoriesAny.createKldivergence
      };
    }
  });

  // node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/entry/dependenciesAny/dependenciesKlitzing.generated.js
  var require_dependenciesKlitzing_generated = __commonJS({
    "node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/entry/dependenciesAny/dependenciesKlitzing.generated.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.klitzingDependencies = void 0;
      var _dependenciesBigNumberClassGenerated = require_dependenciesBigNumberClass_generated();
      var _dependenciesUnitClassGenerated = require_dependenciesUnitClass_generated();
      var _factoriesAny = require_factoriesAny();
      var klitzingDependencies = exports.klitzingDependencies = {
        BigNumberDependencies: _dependenciesBigNumberClassGenerated.BigNumberDependencies,
        UnitDependencies: _dependenciesUnitClassGenerated.UnitDependencies,
        createKlitzing: _factoriesAny.createKlitzing
      };
    }
  });

  // node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/entry/dependenciesAny/dependenciesKron.generated.js
  var require_dependenciesKron_generated = __commonJS({
    "node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/entry/dependenciesAny/dependenciesKron.generated.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.kronDependencies = void 0;
      var _dependenciesMatrixGenerated = require_dependenciesMatrix_generated();
      var _dependenciesMultiplyScalarGenerated = require_dependenciesMultiplyScalar_generated();
      var _dependenciesTypedGenerated = require_dependenciesTyped_generated();
      var _factoriesAny = require_factoriesAny();
      var kronDependencies = exports.kronDependencies = {
        matrixDependencies: _dependenciesMatrixGenerated.matrixDependencies,
        multiplyScalarDependencies: _dependenciesMultiplyScalarGenerated.multiplyScalarDependencies,
        typedDependencies: _dependenciesTypedGenerated.typedDependencies,
        createKron: _factoriesAny.createKron
      };
    }
  });

  // node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/entry/dependenciesAny/dependenciesLN10.generated.js
  var require_dependenciesLN10_generated = __commonJS({
    "node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/entry/dependenciesAny/dependenciesLN10.generated.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.LN10Dependencies = void 0;
      var _dependenciesBigNumberClassGenerated = require_dependenciesBigNumberClass_generated();
      var _factoriesAny = require_factoriesAny();
      var LN10Dependencies = exports.LN10Dependencies = {
        BigNumberDependencies: _dependenciesBigNumberClassGenerated.BigNumberDependencies,
        createLN10: _factoriesAny.createLN10
      };
    }
  });

  // node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/entry/dependenciesAny/dependenciesLN2.generated.js
  var require_dependenciesLN2_generated = __commonJS({
    "node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/entry/dependenciesAny/dependenciesLN2.generated.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.LN2Dependencies = void 0;
      var _dependenciesBigNumberClassGenerated = require_dependenciesBigNumberClass_generated();
      var _factoriesAny = require_factoriesAny();
      var LN2Dependencies = exports.LN2Dependencies = {
        BigNumberDependencies: _dependenciesBigNumberClassGenerated.BigNumberDependencies,
        createLN2: _factoriesAny.createLN2
      };
    }
  });

  // node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/entry/dependenciesAny/dependenciesLOG10E.generated.js
  var require_dependenciesLOG10E_generated = __commonJS({
    "node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/entry/dependenciesAny/dependenciesLOG10E.generated.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.LOG10EDependencies = void 0;
      var _dependenciesBigNumberClassGenerated = require_dependenciesBigNumberClass_generated();
      var _factoriesAny = require_factoriesAny();
      var LOG10EDependencies = exports.LOG10EDependencies = {
        BigNumberDependencies: _dependenciesBigNumberClassGenerated.BigNumberDependencies,
        createLOG10E: _factoriesAny.createLOG10E
      };
    }
  });

  // node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/entry/dependenciesAny/dependenciesLOG2E.generated.js
  var require_dependenciesLOG2E_generated = __commonJS({
    "node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/entry/dependenciesAny/dependenciesLOG2E.generated.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.LOG2EDependencies = void 0;
      var _dependenciesBigNumberClassGenerated = require_dependenciesBigNumberClass_generated();
      var _factoriesAny = require_factoriesAny();
      var LOG2EDependencies = exports.LOG2EDependencies = {
        BigNumberDependencies: _dependenciesBigNumberClassGenerated.BigNumberDependencies,
        createLOG2E: _factoriesAny.createLOG2E
      };
    }
  });

  // node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/entry/dependenciesAny/dependenciesLcm.generated.js
  var require_dependenciesLcm_generated = __commonJS({
    "node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/entry/dependenciesAny/dependenciesLcm.generated.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.lcmDependencies = void 0;
      var _dependenciesConcatGenerated = require_dependenciesConcat_generated();
      var _dependenciesEqualScalarGenerated = require_dependenciesEqualScalar_generated();
      var _dependenciesMatrixGenerated = require_dependenciesMatrix_generated();
      var _dependenciesTypedGenerated = require_dependenciesTyped_generated();
      var _factoriesAny = require_factoriesAny();
      var lcmDependencies = exports.lcmDependencies = {
        concatDependencies: _dependenciesConcatGenerated.concatDependencies,
        equalScalarDependencies: _dependenciesEqualScalarGenerated.equalScalarDependencies,
        matrixDependencies: _dependenciesMatrixGenerated.matrixDependencies,
        typedDependencies: _dependenciesTypedGenerated.typedDependencies,
        createLcm: _factoriesAny.createLcm
      };
    }
  });

  // node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/entry/dependenciesAny/dependenciesLeafCount.generated.js
  var require_dependenciesLeafCount_generated = __commonJS({
    "node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/entry/dependenciesAny/dependenciesLeafCount.generated.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.leafCountDependencies = void 0;
      var _dependenciesParseGenerated = require_dependenciesParse_generated();
      var _dependenciesTypedGenerated = require_dependenciesTyped_generated();
      var _factoriesAny = require_factoriesAny();
      var leafCountDependencies = exports.leafCountDependencies = {
        parseDependencies: _dependenciesParseGenerated.parseDependencies,
        typedDependencies: _dependenciesTypedGenerated.typedDependencies,
        createLeafCount: _factoriesAny.createLeafCount
      };
    }
  });

  // node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/entry/dependenciesAny/dependenciesLeftShift.generated.js
  var require_dependenciesLeftShift_generated = __commonJS({
    "node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/entry/dependenciesAny/dependenciesLeftShift.generated.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.leftShiftDependencies = void 0;
      var _dependenciesDenseMatrixClassGenerated = require_dependenciesDenseMatrixClass_generated();
      var _dependenciesConcatGenerated = require_dependenciesConcat_generated();
      var _dependenciesEqualScalarGenerated = require_dependenciesEqualScalar_generated();
      var _dependenciesMatrixGenerated = require_dependenciesMatrix_generated();
      var _dependenciesTypedGenerated = require_dependenciesTyped_generated();
      var _dependenciesZerosGenerated = require_dependenciesZeros_generated();
      var _factoriesAny = require_factoriesAny();
      var leftShiftDependencies = exports.leftShiftDependencies = {
        DenseMatrixDependencies: _dependenciesDenseMatrixClassGenerated.DenseMatrixDependencies,
        concatDependencies: _dependenciesConcatGenerated.concatDependencies,
        equalScalarDependencies: _dependenciesEqualScalarGenerated.equalScalarDependencies,
        matrixDependencies: _dependenciesMatrixGenerated.matrixDependencies,
        typedDependencies: _dependenciesTypedGenerated.typedDependencies,
        zerosDependencies: _dependenciesZerosGenerated.zerosDependencies,
        createLeftShift: _factoriesAny.createLeftShift
      };
    }
  });

  // node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/entry/dependenciesAny/dependenciesLgamma.generated.js
  var require_dependenciesLgamma_generated = __commonJS({
    "node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/entry/dependenciesAny/dependenciesLgamma.generated.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.lgammaDependencies = void 0;
      var _dependenciesComplexClassGenerated = require_dependenciesComplexClass_generated();
      var _dependenciesTypedGenerated = require_dependenciesTyped_generated();
      var _factoriesAny = require_factoriesAny();
      var lgammaDependencies = exports.lgammaDependencies = {
        ComplexDependencies: _dependenciesComplexClassGenerated.ComplexDependencies,
        typedDependencies: _dependenciesTypedGenerated.typedDependencies,
        createLgamma: _factoriesAny.createLgamma
      };
    }
  });

  // node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/entry/dependenciesAny/dependenciesLog10.generated.js
  var require_dependenciesLog10_generated = __commonJS({
    "node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/entry/dependenciesAny/dependenciesLog10.generated.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.log10Dependencies = void 0;
      var _dependenciesComplexClassGenerated = require_dependenciesComplexClass_generated();
      var _dependenciesTypedGenerated = require_dependenciesTyped_generated();
      var _factoriesAny = require_factoriesAny();
      var log10Dependencies = exports.log10Dependencies = {
        ComplexDependencies: _dependenciesComplexClassGenerated.ComplexDependencies,
        typedDependencies: _dependenciesTypedGenerated.typedDependencies,
        createLog10: _factoriesAny.createLog10
      };
    }
  });

  // node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/entry/dependenciesAny/dependenciesLog1p.generated.js
  var require_dependenciesLog1p_generated = __commonJS({
    "node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/entry/dependenciesAny/dependenciesLog1p.generated.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.log1pDependencies = void 0;
      var _dependenciesComplexClassGenerated = require_dependenciesComplexClass_generated();
      var _dependenciesDivideScalarGenerated = require_dependenciesDivideScalar_generated();
      var _dependenciesLogGenerated = require_dependenciesLog_generated();
      var _dependenciesTypedGenerated = require_dependenciesTyped_generated();
      var _factoriesAny = require_factoriesAny();
      var log1pDependencies = exports.log1pDependencies = {
        ComplexDependencies: _dependenciesComplexClassGenerated.ComplexDependencies,
        divideScalarDependencies: _dependenciesDivideScalarGenerated.divideScalarDependencies,
        logDependencies: _dependenciesLogGenerated.logDependencies,
        typedDependencies: _dependenciesTypedGenerated.typedDependencies,
        createLog1p: _factoriesAny.createLog1p
      };
    }
  });

  // node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/entry/dependenciesAny/dependenciesLoschmidt.generated.js
  var require_dependenciesLoschmidt_generated = __commonJS({
    "node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/entry/dependenciesAny/dependenciesLoschmidt.generated.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.loschmidtDependencies = void 0;
      var _dependenciesBigNumberClassGenerated = require_dependenciesBigNumberClass_generated();
      var _dependenciesUnitClassGenerated = require_dependenciesUnitClass_generated();
      var _factoriesAny = require_factoriesAny();
      var loschmidtDependencies = exports.loschmidtDependencies = {
        BigNumberDependencies: _dependenciesBigNumberClassGenerated.BigNumberDependencies,
        UnitDependencies: _dependenciesUnitClassGenerated.UnitDependencies,
        createLoschmidt: _factoriesAny.createLoschmidt
      };
    }
  });

  // node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/entry/dependenciesAny/dependenciesLsolve.generated.js
  var require_dependenciesLsolve_generated = __commonJS({
    "node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/entry/dependenciesAny/dependenciesLsolve.generated.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.lsolveDependencies = void 0;
      var _dependenciesDenseMatrixClassGenerated = require_dependenciesDenseMatrixClass_generated();
      var _dependenciesDivideScalarGenerated = require_dependenciesDivideScalar_generated();
      var _dependenciesEqualScalarGenerated = require_dependenciesEqualScalar_generated();
      var _dependenciesMatrixGenerated = require_dependenciesMatrix_generated();
      var _dependenciesMultiplyScalarGenerated = require_dependenciesMultiplyScalar_generated();
      var _dependenciesSubtractScalarGenerated = require_dependenciesSubtractScalar_generated();
      var _dependenciesTypedGenerated = require_dependenciesTyped_generated();
      var _factoriesAny = require_factoriesAny();
      var lsolveDependencies = exports.lsolveDependencies = {
        DenseMatrixDependencies: _dependenciesDenseMatrixClassGenerated.DenseMatrixDependencies,
        divideScalarDependencies: _dependenciesDivideScalarGenerated.divideScalarDependencies,
        equalScalarDependencies: _dependenciesEqualScalarGenerated.equalScalarDependencies,
        matrixDependencies: _dependenciesMatrixGenerated.matrixDependencies,
        multiplyScalarDependencies: _dependenciesMultiplyScalarGenerated.multiplyScalarDependencies,
        subtractScalarDependencies: _dependenciesSubtractScalarGenerated.subtractScalarDependencies,
        typedDependencies: _dependenciesTypedGenerated.typedDependencies,
        createLsolve: _factoriesAny.createLsolve
      };
    }
  });

  // node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/entry/dependenciesAny/dependenciesLsolveAll.generated.js
  var require_dependenciesLsolveAll_generated = __commonJS({
    "node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/entry/dependenciesAny/dependenciesLsolveAll.generated.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.lsolveAllDependencies = void 0;
      var _dependenciesDenseMatrixClassGenerated = require_dependenciesDenseMatrixClass_generated();
      var _dependenciesDivideScalarGenerated = require_dependenciesDivideScalar_generated();
      var _dependenciesEqualScalarGenerated = require_dependenciesEqualScalar_generated();
      var _dependenciesMatrixGenerated = require_dependenciesMatrix_generated();
      var _dependenciesMultiplyScalarGenerated = require_dependenciesMultiplyScalar_generated();
      var _dependenciesSubtractScalarGenerated = require_dependenciesSubtractScalar_generated();
      var _dependenciesTypedGenerated = require_dependenciesTyped_generated();
      var _factoriesAny = require_factoriesAny();
      var lsolveAllDependencies = exports.lsolveAllDependencies = {
        DenseMatrixDependencies: _dependenciesDenseMatrixClassGenerated.DenseMatrixDependencies,
        divideScalarDependencies: _dependenciesDivideScalarGenerated.divideScalarDependencies,
        equalScalarDependencies: _dependenciesEqualScalarGenerated.equalScalarDependencies,
        matrixDependencies: _dependenciesMatrixGenerated.matrixDependencies,
        multiplyScalarDependencies: _dependenciesMultiplyScalarGenerated.multiplyScalarDependencies,
        subtractScalarDependencies: _dependenciesSubtractScalarGenerated.subtractScalarDependencies,
        typedDependencies: _dependenciesTypedGenerated.typedDependencies,
        createLsolveAll: _factoriesAny.createLsolveAll
      };
    }
  });

  // node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/entry/dependenciesAny/dependenciesSpaClass.generated.js
  var require_dependenciesSpaClass_generated = __commonJS({
    "node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/entry/dependenciesAny/dependenciesSpaClass.generated.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.SpaDependencies = void 0;
      var _dependenciesFibonacciHeapClassGenerated = require_dependenciesFibonacciHeapClass_generated();
      var _dependenciesAddScalarGenerated = require_dependenciesAddScalar_generated();
      var _dependenciesEqualScalarGenerated = require_dependenciesEqualScalar_generated();
      var _factoriesAny = require_factoriesAny();
      var SpaDependencies = exports.SpaDependencies = {
        FibonacciHeapDependencies: _dependenciesFibonacciHeapClassGenerated.FibonacciHeapDependencies,
        addScalarDependencies: _dependenciesAddScalarGenerated.addScalarDependencies,
        equalScalarDependencies: _dependenciesEqualScalarGenerated.equalScalarDependencies,
        createSpaClass: _factoriesAny.createSpaClass
      };
    }
  });

  // node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/entry/dependenciesAny/dependenciesLup.generated.js
  var require_dependenciesLup_generated = __commonJS({
    "node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/entry/dependenciesAny/dependenciesLup.generated.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.lupDependencies = void 0;
      var _dependenciesDenseMatrixClassGenerated = require_dependenciesDenseMatrixClass_generated();
      var _dependenciesSpaClassGenerated = require_dependenciesSpaClass_generated();
      var _dependenciesSparseMatrixClassGenerated = require_dependenciesSparseMatrixClass_generated();
      var _dependenciesAbsGenerated = require_dependenciesAbs_generated();
      var _dependenciesAddScalarGenerated = require_dependenciesAddScalar_generated();
      var _dependenciesDivideScalarGenerated = require_dependenciesDivideScalar_generated();
      var _dependenciesEqualScalarGenerated = require_dependenciesEqualScalar_generated();
      var _dependenciesLargerGenerated = require_dependenciesLarger_generated();
      var _dependenciesMatrixGenerated = require_dependenciesMatrix_generated();
      var _dependenciesMultiplyScalarGenerated = require_dependenciesMultiplyScalar_generated();
      var _dependenciesSubtractScalarGenerated = require_dependenciesSubtractScalar_generated();
      var _dependenciesTypedGenerated = require_dependenciesTyped_generated();
      var _dependenciesUnaryMinusGenerated = require_dependenciesUnaryMinus_generated();
      var _factoriesAny = require_factoriesAny();
      var lupDependencies = exports.lupDependencies = {
        DenseMatrixDependencies: _dependenciesDenseMatrixClassGenerated.DenseMatrixDependencies,
        SpaDependencies: _dependenciesSpaClassGenerated.SpaDependencies,
        SparseMatrixDependencies: _dependenciesSparseMatrixClassGenerated.SparseMatrixDependencies,
        absDependencies: _dependenciesAbsGenerated.absDependencies,
        addScalarDependencies: _dependenciesAddScalarGenerated.addScalarDependencies,
        divideScalarDependencies: _dependenciesDivideScalarGenerated.divideScalarDependencies,
        equalScalarDependencies: _dependenciesEqualScalarGenerated.equalScalarDependencies,
        largerDependencies: _dependenciesLargerGenerated.largerDependencies,
        matrixDependencies: _dependenciesMatrixGenerated.matrixDependencies,
        multiplyScalarDependencies: _dependenciesMultiplyScalarGenerated.multiplyScalarDependencies,
        subtractScalarDependencies: _dependenciesSubtractScalarGenerated.subtractScalarDependencies,
        typedDependencies: _dependenciesTypedGenerated.typedDependencies,
        unaryMinusDependencies: _dependenciesUnaryMinusGenerated.unaryMinusDependencies,
        createLup: _factoriesAny.createLup
      };
    }
  });

  // node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/entry/dependenciesAny/dependenciesSlu.generated.js
  var require_dependenciesSlu_generated = __commonJS({
    "node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/entry/dependenciesAny/dependenciesSlu.generated.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.sluDependencies = void 0;
      var _dependenciesSparseMatrixClassGenerated = require_dependenciesSparseMatrixClass_generated();
      var _dependenciesAbsGenerated = require_dependenciesAbs_generated();
      var _dependenciesAddGenerated = require_dependenciesAdd_generated();
      var _dependenciesDivideScalarGenerated = require_dependenciesDivideScalar_generated();
      var _dependenciesLargerGenerated = require_dependenciesLarger_generated();
      var _dependenciesLargerEqGenerated = require_dependenciesLargerEq_generated();
      var _dependenciesMultiplyGenerated = require_dependenciesMultiply_generated();
      var _dependenciesSubtractGenerated = require_dependenciesSubtract_generated();
      var _dependenciesTransposeGenerated = require_dependenciesTranspose_generated();
      var _dependenciesTypedGenerated = require_dependenciesTyped_generated();
      var _factoriesAny = require_factoriesAny();
      var sluDependencies = exports.sluDependencies = {
        SparseMatrixDependencies: _dependenciesSparseMatrixClassGenerated.SparseMatrixDependencies,
        absDependencies: _dependenciesAbsGenerated.absDependencies,
        addDependencies: _dependenciesAddGenerated.addDependencies,
        divideScalarDependencies: _dependenciesDivideScalarGenerated.divideScalarDependencies,
        largerDependencies: _dependenciesLargerGenerated.largerDependencies,
        largerEqDependencies: _dependenciesLargerEqGenerated.largerEqDependencies,
        multiplyDependencies: _dependenciesMultiplyGenerated.multiplyDependencies,
        subtractDependencies: _dependenciesSubtractGenerated.subtractDependencies,
        transposeDependencies: _dependenciesTransposeGenerated.transposeDependencies,
        typedDependencies: _dependenciesTypedGenerated.typedDependencies,
        createSlu: _factoriesAny.createSlu
      };
    }
  });

  // node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/entry/dependenciesAny/dependenciesLusolve.generated.js
  var require_dependenciesLusolve_generated = __commonJS({
    "node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/entry/dependenciesAny/dependenciesLusolve.generated.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.lusolveDependencies = void 0;
      var _dependenciesDenseMatrixClassGenerated = require_dependenciesDenseMatrixClass_generated();
      var _dependenciesLsolveGenerated = require_dependenciesLsolve_generated();
      var _dependenciesLupGenerated = require_dependenciesLup_generated();
      var _dependenciesMatrixGenerated = require_dependenciesMatrix_generated();
      var _dependenciesSluGenerated = require_dependenciesSlu_generated();
      var _dependenciesTypedGenerated = require_dependenciesTyped_generated();
      var _dependenciesUsolveGenerated = require_dependenciesUsolve_generated();
      var _factoriesAny = require_factoriesAny();
      var lusolveDependencies = exports.lusolveDependencies = {
        DenseMatrixDependencies: _dependenciesDenseMatrixClassGenerated.DenseMatrixDependencies,
        lsolveDependencies: _dependenciesLsolveGenerated.lsolveDependencies,
        lupDependencies: _dependenciesLupGenerated.lupDependencies,
        matrixDependencies: _dependenciesMatrixGenerated.matrixDependencies,
        sluDependencies: _dependenciesSluGenerated.sluDependencies,
        typedDependencies: _dependenciesTypedGenerated.typedDependencies,
        usolveDependencies: _dependenciesUsolveGenerated.usolveDependencies,
        createLusolve: _factoriesAny.createLusolve
      };
    }
  });

  // node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/entry/dependenciesAny/dependenciesNorm.generated.js
  var require_dependenciesNorm_generated = __commonJS({
    "node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/entry/dependenciesAny/dependenciesNorm.generated.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.normDependencies = void 0;
      var _dependenciesAbsGenerated = require_dependenciesAbs_generated();
      var _dependenciesAddGenerated = require_dependenciesAdd_generated();
      var _dependenciesConjGenerated = require_dependenciesConj_generated();
      var _dependenciesCtransposeGenerated = require_dependenciesCtranspose_generated();
      var _dependenciesEigsGenerated = require_dependenciesEigs_generated();
      var _dependenciesEqualScalarGenerated = require_dependenciesEqualScalar_generated();
      var _dependenciesLargerGenerated = require_dependenciesLarger_generated();
      var _dependenciesMatrixGenerated = require_dependenciesMatrix_generated();
      var _dependenciesMultiplyGenerated = require_dependenciesMultiply_generated();
      var _dependenciesPowGenerated = require_dependenciesPow_generated();
      var _dependenciesSmallerGenerated = require_dependenciesSmaller_generated();
      var _dependenciesSqrtGenerated = require_dependenciesSqrt_generated();
      var _dependenciesTypedGenerated = require_dependenciesTyped_generated();
      var _factoriesAny = require_factoriesAny();
      var normDependencies = exports.normDependencies = {
        absDependencies: _dependenciesAbsGenerated.absDependencies,
        addDependencies: _dependenciesAddGenerated.addDependencies,
        conjDependencies: _dependenciesConjGenerated.conjDependencies,
        ctransposeDependencies: _dependenciesCtransposeGenerated.ctransposeDependencies,
        eigsDependencies: _dependenciesEigsGenerated.eigsDependencies,
        equalScalarDependencies: _dependenciesEqualScalarGenerated.equalScalarDependencies,
        largerDependencies: _dependenciesLargerGenerated.largerDependencies,
        matrixDependencies: _dependenciesMatrixGenerated.matrixDependencies,
        multiplyDependencies: _dependenciesMultiplyGenerated.multiplyDependencies,
        powDependencies: _dependenciesPowGenerated.powDependencies,
        smallerDependencies: _dependenciesSmallerGenerated.smallerDependencies,
        sqrtDependencies: _dependenciesSqrtGenerated.sqrtDependencies,
        typedDependencies: _dependenciesTypedGenerated.typedDependencies,
        createNorm: _factoriesAny.createNorm
      };
    }
  });

  // node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/entry/dependenciesAny/dependenciesSchur.generated.js
  var require_dependenciesSchur_generated = __commonJS({
    "node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/entry/dependenciesAny/dependenciesSchur.generated.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.schurDependencies = void 0;
      var _dependenciesIdentityGenerated = require_dependenciesIdentity_generated();
      var _dependenciesMatrixGenerated = require_dependenciesMatrix_generated();
      var _dependenciesMultiplyGenerated = require_dependenciesMultiply_generated();
      var _dependenciesNormGenerated = require_dependenciesNorm_generated();
      var _dependenciesQrGenerated = require_dependenciesQr_generated();
      var _dependenciesSubtractGenerated = require_dependenciesSubtract_generated();
      var _dependenciesTypedGenerated = require_dependenciesTyped_generated();
      var _factoriesAny = require_factoriesAny();
      var schurDependencies = exports.schurDependencies = {
        identityDependencies: _dependenciesIdentityGenerated.identityDependencies,
        matrixDependencies: _dependenciesMatrixGenerated.matrixDependencies,
        multiplyDependencies: _dependenciesMultiplyGenerated.multiplyDependencies,
        normDependencies: _dependenciesNormGenerated.normDependencies,
        qrDependencies: _dependenciesQrGenerated.qrDependencies,
        subtractDependencies: _dependenciesSubtractGenerated.subtractDependencies,
        typedDependencies: _dependenciesTypedGenerated.typedDependencies,
        createSchur: _factoriesAny.createSchur
      };
    }
  });

  // node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/entry/dependenciesAny/dependenciesSylvester.generated.js
  var require_dependenciesSylvester_generated = __commonJS({
    "node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/entry/dependenciesAny/dependenciesSylvester.generated.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.sylvesterDependencies = void 0;
      var _dependenciesAbsGenerated = require_dependenciesAbs_generated();
      var _dependenciesAddGenerated = require_dependenciesAdd_generated();
      var _dependenciesConcatGenerated = require_dependenciesConcat_generated();
      var _dependenciesIdentityGenerated = require_dependenciesIdentity_generated();
      var _dependenciesIndexGenerated = require_dependenciesIndex_generated();
      var _dependenciesLusolveGenerated = require_dependenciesLusolve_generated();
      var _dependenciesMatrixGenerated = require_dependenciesMatrix_generated();
      var _dependenciesMatrixFromColumnsGenerated = require_dependenciesMatrixFromColumns_generated();
      var _dependenciesMultiplyGenerated = require_dependenciesMultiply_generated();
      var _dependenciesRangeGenerated = require_dependenciesRange_generated();
      var _dependenciesSchurGenerated = require_dependenciesSchur_generated();
      var _dependenciesSubsetGenerated = require_dependenciesSubset_generated();
      var _dependenciesSubtractGenerated = require_dependenciesSubtract_generated();
      var _dependenciesTransposeGenerated = require_dependenciesTranspose_generated();
      var _dependenciesTypedGenerated = require_dependenciesTyped_generated();
      var _factoriesAny = require_factoriesAny();
      var sylvesterDependencies = exports.sylvesterDependencies = {
        absDependencies: _dependenciesAbsGenerated.absDependencies,
        addDependencies: _dependenciesAddGenerated.addDependencies,
        concatDependencies: _dependenciesConcatGenerated.concatDependencies,
        identityDependencies: _dependenciesIdentityGenerated.identityDependencies,
        indexDependencies: _dependenciesIndexGenerated.indexDependencies,
        lusolveDependencies: _dependenciesLusolveGenerated.lusolveDependencies,
        matrixDependencies: _dependenciesMatrixGenerated.matrixDependencies,
        matrixFromColumnsDependencies: _dependenciesMatrixFromColumnsGenerated.matrixFromColumnsDependencies,
        multiplyDependencies: _dependenciesMultiplyGenerated.multiplyDependencies,
        rangeDependencies: _dependenciesRangeGenerated.rangeDependencies,
        schurDependencies: _dependenciesSchurGenerated.schurDependencies,
        subsetDependencies: _dependenciesSubsetGenerated.subsetDependencies,
        subtractDependencies: _dependenciesSubtractGenerated.subtractDependencies,
        transposeDependencies: _dependenciesTransposeGenerated.transposeDependencies,
        typedDependencies: _dependenciesTypedGenerated.typedDependencies,
        createSylvester: _factoriesAny.createSylvester
      };
    }
  });

  // node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/entry/dependenciesAny/dependenciesLyap.generated.js
  var require_dependenciesLyap_generated = __commonJS({
    "node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/entry/dependenciesAny/dependenciesLyap.generated.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.lyapDependencies = void 0;
      var _dependenciesMatrixGenerated = require_dependenciesMatrix_generated();
      var _dependenciesMultiplyGenerated = require_dependenciesMultiply_generated();
      var _dependenciesSylvesterGenerated = require_dependenciesSylvester_generated();
      var _dependenciesTransposeGenerated = require_dependenciesTranspose_generated();
      var _dependenciesTypedGenerated = require_dependenciesTyped_generated();
      var _factoriesAny = require_factoriesAny();
      var lyapDependencies = exports.lyapDependencies = {
        matrixDependencies: _dependenciesMatrixGenerated.matrixDependencies,
        multiplyDependencies: _dependenciesMultiplyGenerated.multiplyDependencies,
        sylvesterDependencies: _dependenciesSylvesterGenerated.sylvesterDependencies,
        transposeDependencies: _dependenciesTransposeGenerated.transposeDependencies,
        typedDependencies: _dependenciesTypedGenerated.typedDependencies,
        createLyap: _factoriesAny.createLyap
      };
    }
  });

  // node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/entry/dependenciesAny/dependenciesPartitionSelect.generated.js
  var require_dependenciesPartitionSelect_generated = __commonJS({
    "node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/entry/dependenciesAny/dependenciesPartitionSelect.generated.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.partitionSelectDependencies = void 0;
      var _dependenciesCompareGenerated = require_dependenciesCompare_generated();
      var _dependenciesIsNaNGenerated = require_dependenciesIsNaN_generated();
      var _dependenciesIsNumericGenerated = require_dependenciesIsNumeric_generated();
      var _dependenciesTypedGenerated = require_dependenciesTyped_generated();
      var _factoriesAny = require_factoriesAny();
      var partitionSelectDependencies = exports.partitionSelectDependencies = {
        compareDependencies: _dependenciesCompareGenerated.compareDependencies,
        isNaNDependencies: _dependenciesIsNaNGenerated.isNaNDependencies,
        isNumericDependencies: _dependenciesIsNumericGenerated.isNumericDependencies,
        typedDependencies: _dependenciesTypedGenerated.typedDependencies,
        createPartitionSelect: _factoriesAny.createPartitionSelect
      };
    }
  });

  // node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/entry/dependenciesAny/dependenciesMedian.generated.js
  var require_dependenciesMedian_generated = __commonJS({
    "node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/entry/dependenciesAny/dependenciesMedian.generated.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.medianDependencies = void 0;
      var _dependenciesAddGenerated = require_dependenciesAdd_generated();
      var _dependenciesCompareGenerated = require_dependenciesCompare_generated();
      var _dependenciesDivideGenerated = require_dependenciesDivide_generated();
      var _dependenciesPartitionSelectGenerated = require_dependenciesPartitionSelect_generated();
      var _dependenciesTypedGenerated = require_dependenciesTyped_generated();
      var _factoriesAny = require_factoriesAny();
      var medianDependencies = exports.medianDependencies = {
        addDependencies: _dependenciesAddGenerated.addDependencies,
        compareDependencies: _dependenciesCompareGenerated.compareDependencies,
        divideDependencies: _dependenciesDivideGenerated.divideDependencies,
        partitionSelectDependencies: _dependenciesPartitionSelectGenerated.partitionSelectDependencies,
        typedDependencies: _dependenciesTypedGenerated.typedDependencies,
        createMedian: _factoriesAny.createMedian
      };
    }
  });

  // node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/entry/dependenciesAny/dependenciesMad.generated.js
  var require_dependenciesMad_generated = __commonJS({
    "node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/entry/dependenciesAny/dependenciesMad.generated.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.madDependencies = void 0;
      var _dependenciesAbsGenerated = require_dependenciesAbs_generated();
      var _dependenciesMapGenerated = require_dependenciesMap_generated();
      var _dependenciesMedianGenerated = require_dependenciesMedian_generated();
      var _dependenciesSubtractGenerated = require_dependenciesSubtract_generated();
      var _dependenciesTypedGenerated = require_dependenciesTyped_generated();
      var _factoriesAny = require_factoriesAny();
      var madDependencies = exports.madDependencies = {
        absDependencies: _dependenciesAbsGenerated.absDependencies,
        mapDependencies: _dependenciesMapGenerated.mapDependencies,
        medianDependencies: _dependenciesMedianGenerated.medianDependencies,
        subtractDependencies: _dependenciesSubtractGenerated.subtractDependencies,
        typedDependencies: _dependenciesTypedGenerated.typedDependencies,
        createMad: _factoriesAny.createMad
      };
    }
  });

  // node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/entry/dependenciesAny/dependenciesMagneticConstant.generated.js
  var require_dependenciesMagneticConstant_generated = __commonJS({
    "node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/entry/dependenciesAny/dependenciesMagneticConstant.generated.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.magneticConstantDependencies = void 0;
      var _dependenciesBigNumberClassGenerated = require_dependenciesBigNumberClass_generated();
      var _dependenciesUnitClassGenerated = require_dependenciesUnitClass_generated();
      var _factoriesAny = require_factoriesAny();
      var magneticConstantDependencies = exports.magneticConstantDependencies = {
        BigNumberDependencies: _dependenciesBigNumberClassGenerated.BigNumberDependencies,
        UnitDependencies: _dependenciesUnitClassGenerated.UnitDependencies,
        createMagneticConstant: _factoriesAny.createMagneticConstant
      };
    }
  });

  // node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/entry/dependenciesAny/dependenciesMagneticFluxQuantum.generated.js
  var require_dependenciesMagneticFluxQuantum_generated = __commonJS({
    "node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/entry/dependenciesAny/dependenciesMagneticFluxQuantum.generated.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.magneticFluxQuantumDependencies = void 0;
      var _dependenciesBigNumberClassGenerated = require_dependenciesBigNumberClass_generated();
      var _dependenciesUnitClassGenerated = require_dependenciesUnitClass_generated();
      var _factoriesAny = require_factoriesAny();
      var magneticFluxQuantumDependencies = exports.magneticFluxQuantumDependencies = {
        BigNumberDependencies: _dependenciesBigNumberClassGenerated.BigNumberDependencies,
        UnitDependencies: _dependenciesUnitClassGenerated.UnitDependencies,
        createMagneticFluxQuantum: _factoriesAny.createMagneticFluxQuantum
      };
    }
  });

  // node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/entry/dependenciesAny/dependenciesMapTransform.generated.js
  var require_dependenciesMapTransform_generated = __commonJS({
    "node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/entry/dependenciesAny/dependenciesMapTransform.generated.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.mapTransformDependencies = void 0;
      var _dependenciesTypedGenerated = require_dependenciesTyped_generated();
      var _factoriesAny = require_factoriesAny();
      var mapTransformDependencies = exports.mapTransformDependencies = {
        typedDependencies: _dependenciesTypedGenerated.typedDependencies,
        createMapTransform: _factoriesAny.createMapTransform
      };
    }
  });

  // node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/entry/dependenciesAny/dependenciesMatrixFromFunction.generated.js
  var require_dependenciesMatrixFromFunction_generated = __commonJS({
    "node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/entry/dependenciesAny/dependenciesMatrixFromFunction.generated.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.matrixFromFunctionDependencies = void 0;
      var _dependenciesIsZeroGenerated = require_dependenciesIsZero_generated();
      var _dependenciesMatrixGenerated = require_dependenciesMatrix_generated();
      var _dependenciesTypedGenerated = require_dependenciesTyped_generated();
      var _factoriesAny = require_factoriesAny();
      var matrixFromFunctionDependencies = exports.matrixFromFunctionDependencies = {
        isZeroDependencies: _dependenciesIsZeroGenerated.isZeroDependencies,
        matrixDependencies: _dependenciesMatrixGenerated.matrixDependencies,
        typedDependencies: _dependenciesTypedGenerated.typedDependencies,
        createMatrixFromFunction: _factoriesAny.createMatrixFromFunction
      };
    }
  });

  // node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/entry/dependenciesAny/dependenciesMatrixFromRows.generated.js
  var require_dependenciesMatrixFromRows_generated = __commonJS({
    "node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/entry/dependenciesAny/dependenciesMatrixFromRows.generated.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.matrixFromRowsDependencies = void 0;
      var _dependenciesFlattenGenerated = require_dependenciesFlatten_generated();
      var _dependenciesMatrixGenerated = require_dependenciesMatrix_generated();
      var _dependenciesSizeGenerated = require_dependenciesSize_generated();
      var _dependenciesTypedGenerated = require_dependenciesTyped_generated();
      var _factoriesAny = require_factoriesAny();
      var matrixFromRowsDependencies = exports.matrixFromRowsDependencies = {
        flattenDependencies: _dependenciesFlattenGenerated.flattenDependencies,
        matrixDependencies: _dependenciesMatrixGenerated.matrixDependencies,
        sizeDependencies: _dependenciesSizeGenerated.sizeDependencies,
        typedDependencies: _dependenciesTypedGenerated.typedDependencies,
        createMatrixFromRows: _factoriesAny.createMatrixFromRows
      };
    }
  });

  // node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/entry/dependenciesAny/dependenciesMax.generated.js
  var require_dependenciesMax_generated = __commonJS({
    "node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/entry/dependenciesAny/dependenciesMax.generated.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.maxDependencies = void 0;
      var _dependenciesLargerGenerated = require_dependenciesLarger_generated();
      var _dependenciesNumericGenerated = require_dependenciesNumeric_generated();
      var _dependenciesTypedGenerated = require_dependenciesTyped_generated();
      var _factoriesAny = require_factoriesAny();
      var maxDependencies = exports.maxDependencies = {
        largerDependencies: _dependenciesLargerGenerated.largerDependencies,
        numericDependencies: _dependenciesNumericGenerated.numericDependencies,
        typedDependencies: _dependenciesTypedGenerated.typedDependencies,
        createMax: _factoriesAny.createMax
      };
    }
  });

  // node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/entry/dependenciesAny/dependenciesMaxTransform.generated.js
  var require_dependenciesMaxTransform_generated = __commonJS({
    "node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/entry/dependenciesAny/dependenciesMaxTransform.generated.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.maxTransformDependencies = void 0;
      var _dependenciesLargerGenerated = require_dependenciesLarger_generated();
      var _dependenciesNumericGenerated = require_dependenciesNumeric_generated();
      var _dependenciesTypedGenerated = require_dependenciesTyped_generated();
      var _factoriesAny = require_factoriesAny();
      var maxTransformDependencies = exports.maxTransformDependencies = {
        largerDependencies: _dependenciesLargerGenerated.largerDependencies,
        numericDependencies: _dependenciesNumericGenerated.numericDependencies,
        typedDependencies: _dependenciesTypedGenerated.typedDependencies,
        createMaxTransform: _factoriesAny.createMaxTransform
      };
    }
  });

  // node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/entry/dependenciesAny/dependenciesMeanTransform.generated.js
  var require_dependenciesMeanTransform_generated = __commonJS({
    "node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/entry/dependenciesAny/dependenciesMeanTransform.generated.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.meanTransformDependencies = void 0;
      var _dependenciesAddGenerated = require_dependenciesAdd_generated();
      var _dependenciesDivideGenerated = require_dependenciesDivide_generated();
      var _dependenciesTypedGenerated = require_dependenciesTyped_generated();
      var _factoriesAny = require_factoriesAny();
      var meanTransformDependencies = exports.meanTransformDependencies = {
        addDependencies: _dependenciesAddGenerated.addDependencies,
        divideDependencies: _dependenciesDivideGenerated.divideDependencies,
        typedDependencies: _dependenciesTypedGenerated.typedDependencies,
        createMeanTransform: _factoriesAny.createMeanTransform
      };
    }
  });

  // node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/entry/dependenciesAny/dependenciesMin.generated.js
  var require_dependenciesMin_generated = __commonJS({
    "node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/entry/dependenciesAny/dependenciesMin.generated.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.minDependencies = void 0;
      var _dependenciesNumericGenerated = require_dependenciesNumeric_generated();
      var _dependenciesSmallerGenerated = require_dependenciesSmaller_generated();
      var _dependenciesTypedGenerated = require_dependenciesTyped_generated();
      var _factoriesAny = require_factoriesAny();
      var minDependencies = exports.minDependencies = {
        numericDependencies: _dependenciesNumericGenerated.numericDependencies,
        smallerDependencies: _dependenciesSmallerGenerated.smallerDependencies,
        typedDependencies: _dependenciesTypedGenerated.typedDependencies,
        createMin: _factoriesAny.createMin
      };
    }
  });

  // node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/entry/dependenciesAny/dependenciesMinTransform.generated.js
  var require_dependenciesMinTransform_generated = __commonJS({
    "node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/entry/dependenciesAny/dependenciesMinTransform.generated.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.minTransformDependencies = void 0;
      var _dependenciesNumericGenerated = require_dependenciesNumeric_generated();
      var _dependenciesSmallerGenerated = require_dependenciesSmaller_generated();
      var _dependenciesTypedGenerated = require_dependenciesTyped_generated();
      var _factoriesAny = require_factoriesAny();
      var minTransformDependencies = exports.minTransformDependencies = {
        numericDependencies: _dependenciesNumericGenerated.numericDependencies,
        smallerDependencies: _dependenciesSmallerGenerated.smallerDependencies,
        typedDependencies: _dependenciesTypedGenerated.typedDependencies,
        createMinTransform: _factoriesAny.createMinTransform
      };
    }
  });

  // node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/entry/dependenciesAny/dependenciesMode.generated.js
  var require_dependenciesMode_generated = __commonJS({
    "node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/entry/dependenciesAny/dependenciesMode.generated.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.modeDependencies = void 0;
      var _dependenciesIsNaNGenerated = require_dependenciesIsNaN_generated();
      var _dependenciesIsNumericGenerated = require_dependenciesIsNumeric_generated();
      var _dependenciesTypedGenerated = require_dependenciesTyped_generated();
      var _factoriesAny = require_factoriesAny();
      var modeDependencies = exports.modeDependencies = {
        isNaNDependencies: _dependenciesIsNaNGenerated.isNaNDependencies,
        isNumericDependencies: _dependenciesIsNumericGenerated.isNumericDependencies,
        typedDependencies: _dependenciesTypedGenerated.typedDependencies,
        createMode: _factoriesAny.createMode
      };
    }
  });

  // node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/entry/dependenciesAny/dependenciesMolarMass.generated.js
  var require_dependenciesMolarMass_generated = __commonJS({
    "node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/entry/dependenciesAny/dependenciesMolarMass.generated.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.molarMassDependencies = void 0;
      var _dependenciesBigNumberClassGenerated = require_dependenciesBigNumberClass_generated();
      var _dependenciesUnitClassGenerated = require_dependenciesUnitClass_generated();
      var _factoriesAny = require_factoriesAny();
      var molarMassDependencies = exports.molarMassDependencies = {
        BigNumberDependencies: _dependenciesBigNumberClassGenerated.BigNumberDependencies,
        UnitDependencies: _dependenciesUnitClassGenerated.UnitDependencies,
        createMolarMass: _factoriesAny.createMolarMass
      };
    }
  });

  // node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/entry/dependenciesAny/dependenciesMolarMassC12.generated.js
  var require_dependenciesMolarMassC12_generated = __commonJS({
    "node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/entry/dependenciesAny/dependenciesMolarMassC12.generated.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.molarMassC12Dependencies = void 0;
      var _dependenciesBigNumberClassGenerated = require_dependenciesBigNumberClass_generated();
      var _dependenciesUnitClassGenerated = require_dependenciesUnitClass_generated();
      var _factoriesAny = require_factoriesAny();
      var molarMassC12Dependencies = exports.molarMassC12Dependencies = {
        BigNumberDependencies: _dependenciesBigNumberClassGenerated.BigNumberDependencies,
        UnitDependencies: _dependenciesUnitClassGenerated.UnitDependencies,
        createMolarMassC12: _factoriesAny.createMolarMassC12
      };
    }
  });

  // node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/entry/dependenciesAny/dependenciesMolarPlanckConstant.generated.js
  var require_dependenciesMolarPlanckConstant_generated = __commonJS({
    "node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/entry/dependenciesAny/dependenciesMolarPlanckConstant.generated.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.molarPlanckConstantDependencies = void 0;
      var _dependenciesBigNumberClassGenerated = require_dependenciesBigNumberClass_generated();
      var _dependenciesUnitClassGenerated = require_dependenciesUnitClass_generated();
      var _factoriesAny = require_factoriesAny();
      var molarPlanckConstantDependencies = exports.molarPlanckConstantDependencies = {
        BigNumberDependencies: _dependenciesBigNumberClassGenerated.BigNumberDependencies,
        UnitDependencies: _dependenciesUnitClassGenerated.UnitDependencies,
        createMolarPlanckConstant: _factoriesAny.createMolarPlanckConstant
      };
    }
  });

  // node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/entry/dependenciesAny/dependenciesMolarVolume.generated.js
  var require_dependenciesMolarVolume_generated = __commonJS({
    "node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/entry/dependenciesAny/dependenciesMolarVolume.generated.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.molarVolumeDependencies = void 0;
      var _dependenciesBigNumberClassGenerated = require_dependenciesBigNumberClass_generated();
      var _dependenciesUnitClassGenerated = require_dependenciesUnitClass_generated();
      var _factoriesAny = require_factoriesAny();
      var molarVolumeDependencies = exports.molarVolumeDependencies = {
        BigNumberDependencies: _dependenciesBigNumberClassGenerated.BigNumberDependencies,
        UnitDependencies: _dependenciesUnitClassGenerated.UnitDependencies,
        createMolarVolume: _factoriesAny.createMolarVolume
      };
    }
  });

  // node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/entry/dependenciesAny/dependenciesMultinomial.generated.js
  var require_dependenciesMultinomial_generated = __commonJS({
    "node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/entry/dependenciesAny/dependenciesMultinomial.generated.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.multinomialDependencies = void 0;
      var _dependenciesAddGenerated = require_dependenciesAdd_generated();
      var _dependenciesDivideGenerated = require_dependenciesDivide_generated();
      var _dependenciesFactorialGenerated = require_dependenciesFactorial_generated();
      var _dependenciesIsIntegerGenerated = require_dependenciesIsInteger_generated();
      var _dependenciesIsPositiveGenerated = require_dependenciesIsPositive_generated();
      var _dependenciesMultiplyGenerated = require_dependenciesMultiply_generated();
      var _dependenciesTypedGenerated = require_dependenciesTyped_generated();
      var _factoriesAny = require_factoriesAny();
      var multinomialDependencies = exports.multinomialDependencies = {
        addDependencies: _dependenciesAddGenerated.addDependencies,
        divideDependencies: _dependenciesDivideGenerated.divideDependencies,
        factorialDependencies: _dependenciesFactorialGenerated.factorialDependencies,
        isIntegerDependencies: _dependenciesIsIntegerGenerated.isIntegerDependencies,
        isPositiveDependencies: _dependenciesIsPositiveGenerated.isPositiveDependencies,
        multiplyDependencies: _dependenciesMultiplyGenerated.multiplyDependencies,
        typedDependencies: _dependenciesTypedGenerated.typedDependencies,
        createMultinomial: _factoriesAny.createMultinomial
      };
    }
  });

  // node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/entry/dependenciesAny/dependenciesNaN.generated.js
  var require_dependenciesNaN_generated = __commonJS({
    "node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/entry/dependenciesAny/dependenciesNaN.generated.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.NaNDependencies = void 0;
      var _dependenciesBigNumberClassGenerated = require_dependenciesBigNumberClass_generated();
      var _factoriesAny = require_factoriesAny();
      var NaNDependencies = exports.NaNDependencies = {
        BigNumberDependencies: _dependenciesBigNumberClassGenerated.BigNumberDependencies,
        createNaN: _factoriesAny.createNaN
      };
    }
  });

  // node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/entry/dependenciesAny/dependenciesNeutronMass.generated.js
  var require_dependenciesNeutronMass_generated = __commonJS({
    "node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/entry/dependenciesAny/dependenciesNeutronMass.generated.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.neutronMassDependencies = void 0;
      var _dependenciesBigNumberClassGenerated = require_dependenciesBigNumberClass_generated();
      var _dependenciesUnitClassGenerated = require_dependenciesUnitClass_generated();
      var _factoriesAny = require_factoriesAny();
      var neutronMassDependencies = exports.neutronMassDependencies = {
        BigNumberDependencies: _dependenciesBigNumberClassGenerated.BigNumberDependencies,
        UnitDependencies: _dependenciesUnitClassGenerated.UnitDependencies,
        createNeutronMass: _factoriesAny.createNeutronMass
      };
    }
  });

  // node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/entry/dependenciesAny/dependenciesNthRoot.generated.js
  var require_dependenciesNthRoot_generated = __commonJS({
    "node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/entry/dependenciesAny/dependenciesNthRoot.generated.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.nthRootDependencies = void 0;
      var _dependenciesBigNumberClassGenerated = require_dependenciesBigNumberClass_generated();
      var _dependenciesConcatGenerated = require_dependenciesConcat_generated();
      var _dependenciesEqualScalarGenerated = require_dependenciesEqualScalar_generated();
      var _dependenciesMatrixGenerated = require_dependenciesMatrix_generated();
      var _dependenciesTypedGenerated = require_dependenciesTyped_generated();
      var _factoriesAny = require_factoriesAny();
      var nthRootDependencies = exports.nthRootDependencies = {
        BigNumberDependencies: _dependenciesBigNumberClassGenerated.BigNumberDependencies,
        concatDependencies: _dependenciesConcatGenerated.concatDependencies,
        equalScalarDependencies: _dependenciesEqualScalarGenerated.equalScalarDependencies,
        matrixDependencies: _dependenciesMatrixGenerated.matrixDependencies,
        typedDependencies: _dependenciesTypedGenerated.typedDependencies,
        createNthRoot: _factoriesAny.createNthRoot
      };
    }
  });

  // node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/entry/dependenciesAny/dependenciesNthRoots.generated.js
  var require_dependenciesNthRoots_generated = __commonJS({
    "node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/entry/dependenciesAny/dependenciesNthRoots.generated.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.nthRootsDependencies = void 0;
      var _dependenciesComplexClassGenerated = require_dependenciesComplexClass_generated();
      var _dependenciesDivideScalarGenerated = require_dependenciesDivideScalar_generated();
      var _dependenciesTypedGenerated = require_dependenciesTyped_generated();
      var _factoriesAny = require_factoriesAny();
      var nthRootsDependencies = exports.nthRootsDependencies = {
        ComplexDependencies: _dependenciesComplexClassGenerated.ComplexDependencies,
        divideScalarDependencies: _dependenciesDivideScalarGenerated.divideScalarDependencies,
        typedDependencies: _dependenciesTypedGenerated.typedDependencies,
        createNthRoots: _factoriesAny.createNthRoots
      };
    }
  });

  // node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/entry/dependenciesAny/dependenciesNuclearMagneton.generated.js
  var require_dependenciesNuclearMagneton_generated = __commonJS({
    "node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/entry/dependenciesAny/dependenciesNuclearMagneton.generated.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.nuclearMagnetonDependencies = void 0;
      var _dependenciesBigNumberClassGenerated = require_dependenciesBigNumberClass_generated();
      var _dependenciesUnitClassGenerated = require_dependenciesUnitClass_generated();
      var _factoriesAny = require_factoriesAny();
      var nuclearMagnetonDependencies = exports.nuclearMagnetonDependencies = {
        BigNumberDependencies: _dependenciesBigNumberClassGenerated.BigNumberDependencies,
        UnitDependencies: _dependenciesUnitClassGenerated.UnitDependencies,
        createNuclearMagneton: _factoriesAny.createNuclearMagneton
      };
    }
  });

  // node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/entry/dependenciesAny/dependenciesNull.generated.js
  var require_dependenciesNull_generated = __commonJS({
    "node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/entry/dependenciesAny/dependenciesNull.generated.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.nullDependencies = void 0;
      var _factoriesAny = require_factoriesAny();
      var nullDependencies = exports.nullDependencies = {
        createNull: _factoriesAny.createNull
      };
    }
  });

  // node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/entry/dependenciesAny/dependenciesOct.generated.js
  var require_dependenciesOct_generated = __commonJS({
    "node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/entry/dependenciesAny/dependenciesOct.generated.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.octDependencies = void 0;
      var _dependenciesFormatGenerated = require_dependenciesFormat_generated();
      var _dependenciesTypedGenerated = require_dependenciesTyped_generated();
      var _factoriesAny = require_factoriesAny();
      var octDependencies = exports.octDependencies = {
        formatDependencies: _dependenciesFormatGenerated.formatDependencies,
        typedDependencies: _dependenciesTypedGenerated.typedDependencies,
        createOct: _factoriesAny.createOct
      };
    }
  });

  // node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/entry/dependenciesAny/dependenciesOnes.generated.js
  var require_dependenciesOnes_generated = __commonJS({
    "node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/entry/dependenciesAny/dependenciesOnes.generated.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.onesDependencies = void 0;
      var _dependenciesBigNumberClassGenerated = require_dependenciesBigNumberClass_generated();
      var _dependenciesMatrixGenerated = require_dependenciesMatrix_generated();
      var _dependenciesTypedGenerated = require_dependenciesTyped_generated();
      var _factoriesAny = require_factoriesAny();
      var onesDependencies = exports.onesDependencies = {
        BigNumberDependencies: _dependenciesBigNumberClassGenerated.BigNumberDependencies,
        matrixDependencies: _dependenciesMatrixGenerated.matrixDependencies,
        typedDependencies: _dependenciesTypedGenerated.typedDependencies,
        createOnes: _factoriesAny.createOnes
      };
    }
  });

  // node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/entry/dependenciesAny/dependenciesOr.generated.js
  var require_dependenciesOr_generated = __commonJS({
    "node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/entry/dependenciesAny/dependenciesOr.generated.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.orDependencies = void 0;
      var _dependenciesDenseMatrixClassGenerated = require_dependenciesDenseMatrixClass_generated();
      var _dependenciesConcatGenerated = require_dependenciesConcat_generated();
      var _dependenciesEqualScalarGenerated = require_dependenciesEqualScalar_generated();
      var _dependenciesMatrixGenerated = require_dependenciesMatrix_generated();
      var _dependenciesTypedGenerated = require_dependenciesTyped_generated();
      var _factoriesAny = require_factoriesAny();
      var orDependencies = exports.orDependencies = {
        DenseMatrixDependencies: _dependenciesDenseMatrixClassGenerated.DenseMatrixDependencies,
        concatDependencies: _dependenciesConcatGenerated.concatDependencies,
        equalScalarDependencies: _dependenciesEqualScalarGenerated.equalScalarDependencies,
        matrixDependencies: _dependenciesMatrixGenerated.matrixDependencies,
        typedDependencies: _dependenciesTypedGenerated.typedDependencies,
        createOr: _factoriesAny.createOr
      };
    }
  });

  // node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/entry/dependenciesAny/dependenciesOrTransform.generated.js
  var require_dependenciesOrTransform_generated = __commonJS({
    "node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/entry/dependenciesAny/dependenciesOrTransform.generated.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.orTransformDependencies = void 0;
      var _dependenciesDenseMatrixClassGenerated = require_dependenciesDenseMatrixClass_generated();
      var _dependenciesConcatGenerated = require_dependenciesConcat_generated();
      var _dependenciesEqualScalarGenerated = require_dependenciesEqualScalar_generated();
      var _dependenciesMatrixGenerated = require_dependenciesMatrix_generated();
      var _dependenciesTypedGenerated = require_dependenciesTyped_generated();
      var _factoriesAny = require_factoriesAny();
      var orTransformDependencies = exports.orTransformDependencies = {
        DenseMatrixDependencies: _dependenciesDenseMatrixClassGenerated.DenseMatrixDependencies,
        concatDependencies: _dependenciesConcatGenerated.concatDependencies,
        equalScalarDependencies: _dependenciesEqualScalarGenerated.equalScalarDependencies,
        matrixDependencies: _dependenciesMatrixGenerated.matrixDependencies,
        typedDependencies: _dependenciesTypedGenerated.typedDependencies,
        createOrTransform: _factoriesAny.createOrTransform
      };
    }
  });

  // node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/entry/dependenciesAny/dependenciesParserClass.generated.js
  var require_dependenciesParserClass_generated = __commonJS({
    "node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/entry/dependenciesAny/dependenciesParserClass.generated.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.ParserDependencies = void 0;
      var _dependenciesEvaluateGenerated = require_dependenciesEvaluate_generated();
      var _factoriesAny = require_factoriesAny();
      var ParserDependencies = exports.ParserDependencies = {
        evaluateDependencies: _dependenciesEvaluateGenerated.evaluateDependencies,
        createParserClass: _factoriesAny.createParserClass
      };
    }
  });

  // node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/entry/dependenciesAny/dependenciesParser.generated.js
  var require_dependenciesParser_generated = __commonJS({
    "node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/entry/dependenciesAny/dependenciesParser.generated.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.parserDependencies = void 0;
      var _dependenciesParserClassGenerated = require_dependenciesParserClass_generated();
      var _dependenciesTypedGenerated = require_dependenciesTyped_generated();
      var _factoriesAny = require_factoriesAny();
      var parserDependencies = exports.parserDependencies = {
        ParserDependencies: _dependenciesParserClassGenerated.ParserDependencies,
        typedDependencies: _dependenciesTypedGenerated.typedDependencies,
        createParser: _factoriesAny.createParser
      };
    }
  });

  // node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/entry/dependenciesAny/dependenciesPermutations.generated.js
  var require_dependenciesPermutations_generated = __commonJS({
    "node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/entry/dependenciesAny/dependenciesPermutations.generated.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.permutationsDependencies = void 0;
      var _dependenciesFactorialGenerated = require_dependenciesFactorial_generated();
      var _dependenciesTypedGenerated = require_dependenciesTyped_generated();
      var _factoriesAny = require_factoriesAny();
      var permutationsDependencies = exports.permutationsDependencies = {
        factorialDependencies: _dependenciesFactorialGenerated.factorialDependencies,
        typedDependencies: _dependenciesTypedGenerated.typedDependencies,
        createPermutations: _factoriesAny.createPermutations
      };
    }
  });

  // node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/entry/dependenciesAny/dependenciesPhi.generated.js
  var require_dependenciesPhi_generated = __commonJS({
    "node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/entry/dependenciesAny/dependenciesPhi.generated.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.phiDependencies = void 0;
      var _dependenciesBigNumberClassGenerated = require_dependenciesBigNumberClass_generated();
      var _factoriesAny = require_factoriesAny();
      var phiDependencies = exports.phiDependencies = {
        BigNumberDependencies: _dependenciesBigNumberClassGenerated.BigNumberDependencies,
        createPhi: _factoriesAny.createPhi
      };
    }
  });

  // node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/entry/dependenciesAny/dependenciesPi.generated.js
  var require_dependenciesPi_generated = __commonJS({
    "node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/entry/dependenciesAny/dependenciesPi.generated.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.piDependencies = void 0;
      var _dependenciesBigNumberClassGenerated = require_dependenciesBigNumberClass_generated();
      var _factoriesAny = require_factoriesAny();
      var piDependencies = exports.piDependencies = {
        BigNumberDependencies: _dependenciesBigNumberClassGenerated.BigNumberDependencies,
        createPi: _factoriesAny.createPi
      };
    }
  });

  // node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/entry/dependenciesAny/dependenciesPickRandom.generated.js
  var require_dependenciesPickRandom_generated = __commonJS({
    "node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/entry/dependenciesAny/dependenciesPickRandom.generated.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.pickRandomDependencies = void 0;
      var _dependenciesTypedGenerated = require_dependenciesTyped_generated();
      var _factoriesAny = require_factoriesAny();
      var pickRandomDependencies = exports.pickRandomDependencies = {
        typedDependencies: _dependenciesTypedGenerated.typedDependencies,
        createPickRandom: _factoriesAny.createPickRandom
      };
    }
  });

  // node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/entry/dependenciesAny/dependenciesPinv.generated.js
  var require_dependenciesPinv_generated = __commonJS({
    "node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/entry/dependenciesAny/dependenciesPinv.generated.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.pinvDependencies = void 0;
      var _dependenciesComplexClassGenerated = require_dependenciesComplexClass_generated();
      var _dependenciesAddGenerated = require_dependenciesAdd_generated();
      var _dependenciesCtransposeGenerated = require_dependenciesCtranspose_generated();
      var _dependenciesDeepEqualGenerated = require_dependenciesDeepEqual_generated();
      var _dependenciesDivideScalarGenerated = require_dependenciesDivideScalar_generated();
      var _dependenciesDotGenerated = require_dependenciesDot_generated();
      var _dependenciesDotDivideGenerated = require_dependenciesDotDivide_generated();
      var _dependenciesEqualGenerated = require_dependenciesEqual_generated();
      var _dependenciesInvGenerated = require_dependenciesInv_generated();
      var _dependenciesMatrixGenerated = require_dependenciesMatrix_generated();
      var _dependenciesMultiplyGenerated = require_dependenciesMultiply_generated();
      var _dependenciesTypedGenerated = require_dependenciesTyped_generated();
      var _factoriesAny = require_factoriesAny();
      var pinvDependencies = exports.pinvDependencies = {
        ComplexDependencies: _dependenciesComplexClassGenerated.ComplexDependencies,
        addDependencies: _dependenciesAddGenerated.addDependencies,
        ctransposeDependencies: _dependenciesCtransposeGenerated.ctransposeDependencies,
        deepEqualDependencies: _dependenciesDeepEqualGenerated.deepEqualDependencies,
        divideScalarDependencies: _dependenciesDivideScalarGenerated.divideScalarDependencies,
        dotDependencies: _dependenciesDotGenerated.dotDependencies,
        dotDivideDependencies: _dependenciesDotDivideGenerated.dotDivideDependencies,
        equalDependencies: _dependenciesEqualGenerated.equalDependencies,
        invDependencies: _dependenciesInvGenerated.invDependencies,
        matrixDependencies: _dependenciesMatrixGenerated.matrixDependencies,
        multiplyDependencies: _dependenciesMultiplyGenerated.multiplyDependencies,
        typedDependencies: _dependenciesTypedGenerated.typedDependencies,
        createPinv: _factoriesAny.createPinv
      };
    }
  });

  // node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/entry/dependenciesAny/dependenciesPlanckCharge.generated.js
  var require_dependenciesPlanckCharge_generated = __commonJS({
    "node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/entry/dependenciesAny/dependenciesPlanckCharge.generated.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.planckChargeDependencies = void 0;
      var _dependenciesBigNumberClassGenerated = require_dependenciesBigNumberClass_generated();
      var _dependenciesUnitClassGenerated = require_dependenciesUnitClass_generated();
      var _factoriesAny = require_factoriesAny();
      var planckChargeDependencies = exports.planckChargeDependencies = {
        BigNumberDependencies: _dependenciesBigNumberClassGenerated.BigNumberDependencies,
        UnitDependencies: _dependenciesUnitClassGenerated.UnitDependencies,
        createPlanckCharge: _factoriesAny.createPlanckCharge
      };
    }
  });

  // node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/entry/dependenciesAny/dependenciesPlanckConstant.generated.js
  var require_dependenciesPlanckConstant_generated = __commonJS({
    "node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/entry/dependenciesAny/dependenciesPlanckConstant.generated.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.planckConstantDependencies = void 0;
      var _dependenciesBigNumberClassGenerated = require_dependenciesBigNumberClass_generated();
      var _dependenciesUnitClassGenerated = require_dependenciesUnitClass_generated();
      var _factoriesAny = require_factoriesAny();
      var planckConstantDependencies = exports.planckConstantDependencies = {
        BigNumberDependencies: _dependenciesBigNumberClassGenerated.BigNumberDependencies,
        UnitDependencies: _dependenciesUnitClassGenerated.UnitDependencies,
        createPlanckConstant: _factoriesAny.createPlanckConstant
      };
    }
  });

  // node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/entry/dependenciesAny/dependenciesPlanckLength.generated.js
  var require_dependenciesPlanckLength_generated = __commonJS({
    "node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/entry/dependenciesAny/dependenciesPlanckLength.generated.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.planckLengthDependencies = void 0;
      var _dependenciesBigNumberClassGenerated = require_dependenciesBigNumberClass_generated();
      var _dependenciesUnitClassGenerated = require_dependenciesUnitClass_generated();
      var _factoriesAny = require_factoriesAny();
      var planckLengthDependencies = exports.planckLengthDependencies = {
        BigNumberDependencies: _dependenciesBigNumberClassGenerated.BigNumberDependencies,
        UnitDependencies: _dependenciesUnitClassGenerated.UnitDependencies,
        createPlanckLength: _factoriesAny.createPlanckLength
      };
    }
  });

  // node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/entry/dependenciesAny/dependenciesPlanckMass.generated.js
  var require_dependenciesPlanckMass_generated = __commonJS({
    "node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/entry/dependenciesAny/dependenciesPlanckMass.generated.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.planckMassDependencies = void 0;
      var _dependenciesBigNumberClassGenerated = require_dependenciesBigNumberClass_generated();
      var _dependenciesUnitClassGenerated = require_dependenciesUnitClass_generated();
      var _factoriesAny = require_factoriesAny();
      var planckMassDependencies = exports.planckMassDependencies = {
        BigNumberDependencies: _dependenciesBigNumberClassGenerated.BigNumberDependencies,
        UnitDependencies: _dependenciesUnitClassGenerated.UnitDependencies,
        createPlanckMass: _factoriesAny.createPlanckMass
      };
    }
  });

  // node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/entry/dependenciesAny/dependenciesPlanckTemperature.generated.js
  var require_dependenciesPlanckTemperature_generated = __commonJS({
    "node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/entry/dependenciesAny/dependenciesPlanckTemperature.generated.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.planckTemperatureDependencies = void 0;
      var _dependenciesBigNumberClassGenerated = require_dependenciesBigNumberClass_generated();
      var _dependenciesUnitClassGenerated = require_dependenciesUnitClass_generated();
      var _factoriesAny = require_factoriesAny();
      var planckTemperatureDependencies = exports.planckTemperatureDependencies = {
        BigNumberDependencies: _dependenciesBigNumberClassGenerated.BigNumberDependencies,
        UnitDependencies: _dependenciesUnitClassGenerated.UnitDependencies,
        createPlanckTemperature: _factoriesAny.createPlanckTemperature
      };
    }
  });

  // node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/entry/dependenciesAny/dependenciesPlanckTime.generated.js
  var require_dependenciesPlanckTime_generated = __commonJS({
    "node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/entry/dependenciesAny/dependenciesPlanckTime.generated.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.planckTimeDependencies = void 0;
      var _dependenciesBigNumberClassGenerated = require_dependenciesBigNumberClass_generated();
      var _dependenciesUnitClassGenerated = require_dependenciesUnitClass_generated();
      var _factoriesAny = require_factoriesAny();
      var planckTimeDependencies = exports.planckTimeDependencies = {
        BigNumberDependencies: _dependenciesBigNumberClassGenerated.BigNumberDependencies,
        UnitDependencies: _dependenciesUnitClassGenerated.UnitDependencies,
        createPlanckTime: _factoriesAny.createPlanckTime
      };
    }
  });

  // node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/entry/dependenciesAny/dependenciesTypeOf.generated.js
  var require_dependenciesTypeOf_generated = __commonJS({
    "node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/entry/dependenciesAny/dependenciesTypeOf.generated.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.typeOfDependencies = void 0;
      var _dependenciesTypedGenerated = require_dependenciesTyped_generated();
      var _factoriesAny = require_factoriesAny();
      var typeOfDependencies = exports.typeOfDependencies = {
        typedDependencies: _dependenciesTypedGenerated.typedDependencies,
        createTypeOf: _factoriesAny.createTypeOf
      };
    }
  });

  // node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/entry/dependenciesAny/dependenciesPolynomialRoot.generated.js
  var require_dependenciesPolynomialRoot_generated = __commonJS({
    "node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/entry/dependenciesAny/dependenciesPolynomialRoot.generated.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.polynomialRootDependencies = void 0;
      var _dependenciesAddGenerated = require_dependenciesAdd_generated();
      var _dependenciesCbrtGenerated = require_dependenciesCbrt_generated();
      var _dependenciesDivideGenerated = require_dependenciesDivide_generated();
      var _dependenciesEqualScalarGenerated = require_dependenciesEqualScalar_generated();
      var _dependenciesImGenerated = require_dependenciesIm_generated();
      var _dependenciesIsZeroGenerated = require_dependenciesIsZero_generated();
      var _dependenciesMultiplyGenerated = require_dependenciesMultiply_generated();
      var _dependenciesReGenerated = require_dependenciesRe_generated();
      var _dependenciesSqrtGenerated = require_dependenciesSqrt_generated();
      var _dependenciesSubtractGenerated = require_dependenciesSubtract_generated();
      var _dependenciesTypeOfGenerated = require_dependenciesTypeOf_generated();
      var _dependenciesTypedGenerated = require_dependenciesTyped_generated();
      var _dependenciesUnaryMinusGenerated = require_dependenciesUnaryMinus_generated();
      var _factoriesAny = require_factoriesAny();
      var polynomialRootDependencies = exports.polynomialRootDependencies = {
        addDependencies: _dependenciesAddGenerated.addDependencies,
        cbrtDependencies: _dependenciesCbrtGenerated.cbrtDependencies,
        divideDependencies: _dependenciesDivideGenerated.divideDependencies,
        equalScalarDependencies: _dependenciesEqualScalarGenerated.equalScalarDependencies,
        imDependencies: _dependenciesImGenerated.imDependencies,
        isZeroDependencies: _dependenciesIsZeroGenerated.isZeroDependencies,
        multiplyDependencies: _dependenciesMultiplyGenerated.multiplyDependencies,
        reDependencies: _dependenciesReGenerated.reDependencies,
        sqrtDependencies: _dependenciesSqrtGenerated.sqrtDependencies,
        subtractDependencies: _dependenciesSubtractGenerated.subtractDependencies,
        typeOfDependencies: _dependenciesTypeOfGenerated.typeOfDependencies,
        typedDependencies: _dependenciesTypedGenerated.typedDependencies,
        unaryMinusDependencies: _dependenciesUnaryMinusGenerated.unaryMinusDependencies,
        createPolynomialRoot: _factoriesAny.createPolynomialRoot
      };
    }
  });

  // node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/entry/dependenciesAny/dependenciesPrint.generated.js
  var require_dependenciesPrint_generated = __commonJS({
    "node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/entry/dependenciesAny/dependenciesPrint.generated.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.printDependencies = void 0;
      var _dependenciesTypedGenerated = require_dependenciesTyped_generated();
      var _factoriesAny = require_factoriesAny();
      var printDependencies = exports.printDependencies = {
        typedDependencies: _dependenciesTypedGenerated.typedDependencies,
        createPrint: _factoriesAny.createPrint
      };
    }
  });

  // node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/entry/dependenciesAny/dependenciesPrintTransform.generated.js
  var require_dependenciesPrintTransform_generated = __commonJS({
    "node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/entry/dependenciesAny/dependenciesPrintTransform.generated.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.printTransformDependencies = void 0;
      var _dependenciesAddGenerated = require_dependenciesAdd_generated();
      var _dependenciesMatrixGenerated = require_dependenciesMatrix_generated();
      var _dependenciesTypedGenerated = require_dependenciesTyped_generated();
      var _dependenciesZerosGenerated = require_dependenciesZeros_generated();
      var _factoriesAny = require_factoriesAny();
      var printTransformDependencies = exports.printTransformDependencies = {
        addDependencies: _dependenciesAddGenerated.addDependencies,
        matrixDependencies: _dependenciesMatrixGenerated.matrixDependencies,
        typedDependencies: _dependenciesTypedGenerated.typedDependencies,
        zerosDependencies: _dependenciesZerosGenerated.zerosDependencies,
        createPrintTransform: _factoriesAny.createPrintTransform
      };
    }
  });

  // node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/entry/dependenciesAny/dependenciesProtonMass.generated.js
  var require_dependenciesProtonMass_generated = __commonJS({
    "node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/entry/dependenciesAny/dependenciesProtonMass.generated.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.protonMassDependencies = void 0;
      var _dependenciesBigNumberClassGenerated = require_dependenciesBigNumberClass_generated();
      var _dependenciesUnitClassGenerated = require_dependenciesUnitClass_generated();
      var _factoriesAny = require_factoriesAny();
      var protonMassDependencies = exports.protonMassDependencies = {
        BigNumberDependencies: _dependenciesBigNumberClassGenerated.BigNumberDependencies,
        UnitDependencies: _dependenciesUnitClassGenerated.UnitDependencies,
        createProtonMass: _factoriesAny.createProtonMass
      };
    }
  });

  // node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/entry/dependenciesAny/dependenciesQuantileSeq.generated.js
  var require_dependenciesQuantileSeq_generated = __commonJS({
    "node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/entry/dependenciesAny/dependenciesQuantileSeq.generated.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.quantileSeqDependencies = void 0;
      var _dependenciesBignumberGenerated = require_dependenciesBignumber_generated();
      var _dependenciesAddGenerated = require_dependenciesAdd_generated();
      var _dependenciesCompareGenerated = require_dependenciesCompare_generated();
      var _dependenciesDivideGenerated = require_dependenciesDivide_generated();
      var _dependenciesIsIntegerGenerated = require_dependenciesIsInteger_generated();
      var _dependenciesLargerGenerated = require_dependenciesLarger_generated();
      var _dependenciesMultiplyGenerated = require_dependenciesMultiply_generated();
      var _dependenciesPartitionSelectGenerated = require_dependenciesPartitionSelect_generated();
      var _dependenciesSmallerGenerated = require_dependenciesSmaller_generated();
      var _dependenciesSmallerEqGenerated = require_dependenciesSmallerEq_generated();
      var _dependenciesSubtractGenerated = require_dependenciesSubtract_generated();
      var _dependenciesTypedGenerated = require_dependenciesTyped_generated();
      var _factoriesAny = require_factoriesAny();
      var quantileSeqDependencies = exports.quantileSeqDependencies = {
        bignumberDependencies: _dependenciesBignumberGenerated.bignumberDependencies,
        addDependencies: _dependenciesAddGenerated.addDependencies,
        compareDependencies: _dependenciesCompareGenerated.compareDependencies,
        divideDependencies: _dependenciesDivideGenerated.divideDependencies,
        isIntegerDependencies: _dependenciesIsIntegerGenerated.isIntegerDependencies,
        largerDependencies: _dependenciesLargerGenerated.largerDependencies,
        multiplyDependencies: _dependenciesMultiplyGenerated.multiplyDependencies,
        partitionSelectDependencies: _dependenciesPartitionSelectGenerated.partitionSelectDependencies,
        smallerDependencies: _dependenciesSmallerGenerated.smallerDependencies,
        smallerEqDependencies: _dependenciesSmallerEqGenerated.smallerEqDependencies,
        subtractDependencies: _dependenciesSubtractGenerated.subtractDependencies,
        typedDependencies: _dependenciesTypedGenerated.typedDependencies,
        createQuantileSeq: _factoriesAny.createQuantileSeq
      };
    }
  });

  // node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/entry/dependenciesAny/dependenciesQuantileSeqTransform.generated.js
  var require_dependenciesQuantileSeqTransform_generated = __commonJS({
    "node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/entry/dependenciesAny/dependenciesQuantileSeqTransform.generated.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.quantileSeqTransformDependencies = void 0;
      var _dependenciesAddGenerated = require_dependenciesAdd_generated();
      var _dependenciesBignumberGenerated = require_dependenciesBignumber_generated();
      var _dependenciesCompareGenerated = require_dependenciesCompare_generated();
      var _dependenciesDivideGenerated = require_dependenciesDivide_generated();
      var _dependenciesIsIntegerGenerated = require_dependenciesIsInteger_generated();
      var _dependenciesLargerGenerated = require_dependenciesLarger_generated();
      var _dependenciesMultiplyGenerated = require_dependenciesMultiply_generated();
      var _dependenciesPartitionSelectGenerated = require_dependenciesPartitionSelect_generated();
      var _dependenciesSmallerGenerated = require_dependenciesSmaller_generated();
      var _dependenciesSmallerEqGenerated = require_dependenciesSmallerEq_generated();
      var _dependenciesSubtractGenerated = require_dependenciesSubtract_generated();
      var _dependenciesTypedGenerated = require_dependenciesTyped_generated();
      var _factoriesAny = require_factoriesAny();
      var quantileSeqTransformDependencies = exports.quantileSeqTransformDependencies = {
        addDependencies: _dependenciesAddGenerated.addDependencies,
        bignumberDependencies: _dependenciesBignumberGenerated.bignumberDependencies,
        compareDependencies: _dependenciesCompareGenerated.compareDependencies,
        divideDependencies: _dependenciesDivideGenerated.divideDependencies,
        isIntegerDependencies: _dependenciesIsIntegerGenerated.isIntegerDependencies,
        largerDependencies: _dependenciesLargerGenerated.largerDependencies,
        multiplyDependencies: _dependenciesMultiplyGenerated.multiplyDependencies,
        partitionSelectDependencies: _dependenciesPartitionSelectGenerated.partitionSelectDependencies,
        smallerDependencies: _dependenciesSmallerGenerated.smallerDependencies,
        smallerEqDependencies: _dependenciesSmallerEqGenerated.smallerEqDependencies,
        subtractDependencies: _dependenciesSubtractGenerated.subtractDependencies,
        typedDependencies: _dependenciesTypedGenerated.typedDependencies,
        createQuantileSeqTransform: _factoriesAny.createQuantileSeqTransform
      };
    }
  });

  // node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/entry/dependenciesAny/dependenciesQuantumOfCirculation.generated.js
  var require_dependenciesQuantumOfCirculation_generated = __commonJS({
    "node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/entry/dependenciesAny/dependenciesQuantumOfCirculation.generated.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.quantumOfCirculationDependencies = void 0;
      var _dependenciesBigNumberClassGenerated = require_dependenciesBigNumberClass_generated();
      var _dependenciesUnitClassGenerated = require_dependenciesUnitClass_generated();
      var _factoriesAny = require_factoriesAny();
      var quantumOfCirculationDependencies = exports.quantumOfCirculationDependencies = {
        BigNumberDependencies: _dependenciesBigNumberClassGenerated.BigNumberDependencies,
        UnitDependencies: _dependenciesUnitClassGenerated.UnitDependencies,
        createQuantumOfCirculation: _factoriesAny.createQuantumOfCirculation
      };
    }
  });

  // node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/entry/dependenciesAny/dependenciesRandom.generated.js
  var require_dependenciesRandom_generated = __commonJS({
    "node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/entry/dependenciesAny/dependenciesRandom.generated.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.randomDependencies = void 0;
      var _dependenciesTypedGenerated = require_dependenciesTyped_generated();
      var _factoriesAny = require_factoriesAny();
      var randomDependencies = exports.randomDependencies = {
        typedDependencies: _dependenciesTypedGenerated.typedDependencies,
        createRandom: _factoriesAny.createRandom
      };
    }
  });

  // node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/entry/dependenciesAny/dependenciesRandomInt.generated.js
  var require_dependenciesRandomInt_generated = __commonJS({
    "node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/entry/dependenciesAny/dependenciesRandomInt.generated.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.randomIntDependencies = void 0;
      var _dependenciesTypedGenerated = require_dependenciesTyped_generated();
      var _factoriesAny = require_factoriesAny();
      var randomIntDependencies = exports.randomIntDependencies = {
        typedDependencies: _dependenciesTypedGenerated.typedDependencies,
        createRandomInt: _factoriesAny.createRandomInt
      };
    }
  });

  // node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/entry/dependenciesAny/dependenciesRangeClass.generated.js
  var require_dependenciesRangeClass_generated = __commonJS({
    "node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/entry/dependenciesAny/dependenciesRangeClass.generated.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.RangeDependencies = void 0;
      var _factoriesAny = require_factoriesAny();
      var RangeDependencies = exports.RangeDependencies = {
        createRangeClass: _factoriesAny.createRangeClass
      };
    }
  });

  // node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/entry/dependenciesAny/dependenciesRangeTransform.generated.js
  var require_dependenciesRangeTransform_generated = __commonJS({
    "node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/entry/dependenciesAny/dependenciesRangeTransform.generated.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.rangeTransformDependencies = void 0;
      var _dependenciesBignumberGenerated = require_dependenciesBignumber_generated();
      var _dependenciesMatrixGenerated = require_dependenciesMatrix_generated();
      var _dependenciesAddGenerated = require_dependenciesAdd_generated();
      var _dependenciesIsPositiveGenerated = require_dependenciesIsPositive_generated();
      var _dependenciesLargerGenerated = require_dependenciesLarger_generated();
      var _dependenciesLargerEqGenerated = require_dependenciesLargerEq_generated();
      var _dependenciesSmallerGenerated = require_dependenciesSmaller_generated();
      var _dependenciesSmallerEqGenerated = require_dependenciesSmallerEq_generated();
      var _dependenciesTypedGenerated = require_dependenciesTyped_generated();
      var _factoriesAny = require_factoriesAny();
      var rangeTransformDependencies = exports.rangeTransformDependencies = {
        bignumberDependencies: _dependenciesBignumberGenerated.bignumberDependencies,
        matrixDependencies: _dependenciesMatrixGenerated.matrixDependencies,
        addDependencies: _dependenciesAddGenerated.addDependencies,
        isPositiveDependencies: _dependenciesIsPositiveGenerated.isPositiveDependencies,
        largerDependencies: _dependenciesLargerGenerated.largerDependencies,
        largerEqDependencies: _dependenciesLargerEqGenerated.largerEqDependencies,
        smallerDependencies: _dependenciesSmallerGenerated.smallerDependencies,
        smallerEqDependencies: _dependenciesSmallerEqGenerated.smallerEqDependencies,
        typedDependencies: _dependenciesTypedGenerated.typedDependencies,
        createRangeTransform: _factoriesAny.createRangeTransform
      };
    }
  });

  // node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/entry/dependenciesAny/dependenciesRationalize.generated.js
  var require_dependenciesRationalize_generated = __commonJS({
    "node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/entry/dependenciesAny/dependenciesRationalize.generated.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.rationalizeDependencies = void 0;
      var _dependenciesBignumberGenerated = require_dependenciesBignumber_generated();
      var _dependenciesFractionGenerated = require_dependenciesFraction_generated();
      var _dependenciesAccessorNodeGenerated = require_dependenciesAccessorNode_generated();
      var _dependenciesArrayNodeGenerated = require_dependenciesArrayNode_generated();
      var _dependenciesConstantNodeGenerated = require_dependenciesConstantNode_generated();
      var _dependenciesFunctionNodeGenerated = require_dependenciesFunctionNode_generated();
      var _dependenciesIndexNodeGenerated = require_dependenciesIndexNode_generated();
      var _dependenciesObjectNodeGenerated = require_dependenciesObjectNode_generated();
      var _dependenciesOperatorNodeGenerated = require_dependenciesOperatorNode_generated();
      var _dependenciesParenthesisNodeGenerated = require_dependenciesParenthesisNode_generated();
      var _dependenciesSymbolNodeGenerated = require_dependenciesSymbolNode_generated();
      var _dependenciesAddGenerated = require_dependenciesAdd_generated();
      var _dependenciesDivideGenerated = require_dependenciesDivide_generated();
      var _dependenciesEqualGenerated = require_dependenciesEqual_generated();
      var _dependenciesIsZeroGenerated = require_dependenciesIsZero_generated();
      var _dependenciesMatrixGenerated = require_dependenciesMatrix_generated();
      var _dependenciesMultiplyGenerated = require_dependenciesMultiply_generated();
      var _dependenciesParseGenerated = require_dependenciesParse_generated();
      var _dependenciesPowGenerated = require_dependenciesPow_generated();
      var _dependenciesSimplifyGenerated = require_dependenciesSimplify_generated();
      var _dependenciesSimplifyConstantGenerated = require_dependenciesSimplifyConstant_generated();
      var _dependenciesSimplifyCoreGenerated = require_dependenciesSimplifyCore_generated();
      var _dependenciesSubtractGenerated = require_dependenciesSubtract_generated();
      var _dependenciesTypedGenerated = require_dependenciesTyped_generated();
      var _factoriesAny = require_factoriesAny();
      var rationalizeDependencies = exports.rationalizeDependencies = {
        bignumberDependencies: _dependenciesBignumberGenerated.bignumberDependencies,
        fractionDependencies: _dependenciesFractionGenerated.fractionDependencies,
        AccessorNodeDependencies: _dependenciesAccessorNodeGenerated.AccessorNodeDependencies,
        ArrayNodeDependencies: _dependenciesArrayNodeGenerated.ArrayNodeDependencies,
        ConstantNodeDependencies: _dependenciesConstantNodeGenerated.ConstantNodeDependencies,
        FunctionNodeDependencies: _dependenciesFunctionNodeGenerated.FunctionNodeDependencies,
        IndexNodeDependencies: _dependenciesIndexNodeGenerated.IndexNodeDependencies,
        ObjectNodeDependencies: _dependenciesObjectNodeGenerated.ObjectNodeDependencies,
        OperatorNodeDependencies: _dependenciesOperatorNodeGenerated.OperatorNodeDependencies,
        ParenthesisNodeDependencies: _dependenciesParenthesisNodeGenerated.ParenthesisNodeDependencies,
        SymbolNodeDependencies: _dependenciesSymbolNodeGenerated.SymbolNodeDependencies,
        addDependencies: _dependenciesAddGenerated.addDependencies,
        divideDependencies: _dependenciesDivideGenerated.divideDependencies,
        equalDependencies: _dependenciesEqualGenerated.equalDependencies,
        isZeroDependencies: _dependenciesIsZeroGenerated.isZeroDependencies,
        matrixDependencies: _dependenciesMatrixGenerated.matrixDependencies,
        multiplyDependencies: _dependenciesMultiplyGenerated.multiplyDependencies,
        parseDependencies: _dependenciesParseGenerated.parseDependencies,
        powDependencies: _dependenciesPowGenerated.powDependencies,
        simplifyDependencies: _dependenciesSimplifyGenerated.simplifyDependencies,
        simplifyConstantDependencies: _dependenciesSimplifyConstantGenerated.simplifyConstantDependencies,
        simplifyCoreDependencies: _dependenciesSimplifyCoreGenerated.simplifyCoreDependencies,
        subtractDependencies: _dependenciesSubtractGenerated.subtractDependencies,
        typedDependencies: _dependenciesTypedGenerated.typedDependencies,
        createRationalize: _factoriesAny.createRationalize
      };
    }
  });

  // node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/entry/dependenciesAny/dependenciesReducedPlanckConstant.generated.js
  var require_dependenciesReducedPlanckConstant_generated = __commonJS({
    "node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/entry/dependenciesAny/dependenciesReducedPlanckConstant.generated.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.reducedPlanckConstantDependencies = void 0;
      var _dependenciesBigNumberClassGenerated = require_dependenciesBigNumberClass_generated();
      var _dependenciesUnitClassGenerated = require_dependenciesUnitClass_generated();
      var _factoriesAny = require_factoriesAny();
      var reducedPlanckConstantDependencies = exports.reducedPlanckConstantDependencies = {
        BigNumberDependencies: _dependenciesBigNumberClassGenerated.BigNumberDependencies,
        UnitDependencies: _dependenciesUnitClassGenerated.UnitDependencies,
        createReducedPlanckConstant: _factoriesAny.createReducedPlanckConstant
      };
    }
  });

  // node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/entry/dependenciesAny/dependenciesReplacer.generated.js
  var require_dependenciesReplacer_generated = __commonJS({
    "node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/entry/dependenciesAny/dependenciesReplacer.generated.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.replacerDependencies = void 0;
      var _factoriesAny = require_factoriesAny();
      var replacerDependencies = exports.replacerDependencies = {
        createReplacer: _factoriesAny.createReplacer
      };
    }
  });

  // node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/entry/dependenciesAny/dependenciesResize.generated.js
  var require_dependenciesResize_generated = __commonJS({
    "node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/entry/dependenciesAny/dependenciesResize.generated.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.resizeDependencies = void 0;
      var _dependenciesMatrixGenerated = require_dependenciesMatrix_generated();
      var _factoriesAny = require_factoriesAny();
      var resizeDependencies = exports.resizeDependencies = {
        matrixDependencies: _dependenciesMatrixGenerated.matrixDependencies,
        createResize: _factoriesAny.createResize
      };
    }
  });

  // node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/entry/dependenciesAny/dependenciesReviver.generated.js
  var require_dependenciesReviver_generated = __commonJS({
    "node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/entry/dependenciesAny/dependenciesReviver.generated.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.reviverDependencies = void 0;
      var _factoriesAny = require_factoriesAny();
      var reviverDependencies = exports.reviverDependencies = {
        createReviver: _factoriesAny.createReviver
      };
    }
  });

  // node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/entry/dependenciesAny/dependenciesRightArithShift.generated.js
  var require_dependenciesRightArithShift_generated = __commonJS({
    "node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/entry/dependenciesAny/dependenciesRightArithShift.generated.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.rightArithShiftDependencies = void 0;
      var _dependenciesDenseMatrixClassGenerated = require_dependenciesDenseMatrixClass_generated();
      var _dependenciesConcatGenerated = require_dependenciesConcat_generated();
      var _dependenciesEqualScalarGenerated = require_dependenciesEqualScalar_generated();
      var _dependenciesMatrixGenerated = require_dependenciesMatrix_generated();
      var _dependenciesTypedGenerated = require_dependenciesTyped_generated();
      var _dependenciesZerosGenerated = require_dependenciesZeros_generated();
      var _factoriesAny = require_factoriesAny();
      var rightArithShiftDependencies = exports.rightArithShiftDependencies = {
        DenseMatrixDependencies: _dependenciesDenseMatrixClassGenerated.DenseMatrixDependencies,
        concatDependencies: _dependenciesConcatGenerated.concatDependencies,
        equalScalarDependencies: _dependenciesEqualScalarGenerated.equalScalarDependencies,
        matrixDependencies: _dependenciesMatrixGenerated.matrixDependencies,
        typedDependencies: _dependenciesTypedGenerated.typedDependencies,
        zerosDependencies: _dependenciesZerosGenerated.zerosDependencies,
        createRightArithShift: _factoriesAny.createRightArithShift
      };
    }
  });

  // node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/entry/dependenciesAny/dependenciesRightLogShift.generated.js
  var require_dependenciesRightLogShift_generated = __commonJS({
    "node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/entry/dependenciesAny/dependenciesRightLogShift.generated.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.rightLogShiftDependencies = void 0;
      var _dependenciesDenseMatrixClassGenerated = require_dependenciesDenseMatrixClass_generated();
      var _dependenciesConcatGenerated = require_dependenciesConcat_generated();
      var _dependenciesEqualScalarGenerated = require_dependenciesEqualScalar_generated();
      var _dependenciesMatrixGenerated = require_dependenciesMatrix_generated();
      var _dependenciesTypedGenerated = require_dependenciesTyped_generated();
      var _dependenciesZerosGenerated = require_dependenciesZeros_generated();
      var _factoriesAny = require_factoriesAny();
      var rightLogShiftDependencies = exports.rightLogShiftDependencies = {
        DenseMatrixDependencies: _dependenciesDenseMatrixClassGenerated.DenseMatrixDependencies,
        concatDependencies: _dependenciesConcatGenerated.concatDependencies,
        equalScalarDependencies: _dependenciesEqualScalarGenerated.equalScalarDependencies,
        matrixDependencies: _dependenciesMatrixGenerated.matrixDependencies,
        typedDependencies: _dependenciesTypedGenerated.typedDependencies,
        zerosDependencies: _dependenciesZerosGenerated.zerosDependencies,
        createRightLogShift: _factoriesAny.createRightLogShift
      };
    }
  });

  // node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/entry/dependenciesAny/dependenciesRotationMatrix.generated.js
  var require_dependenciesRotationMatrix_generated = __commonJS({
    "node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/entry/dependenciesAny/dependenciesRotationMatrix.generated.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.rotationMatrixDependencies = void 0;
      var _dependenciesBigNumberClassGenerated = require_dependenciesBigNumberClass_generated();
      var _dependenciesDenseMatrixClassGenerated = require_dependenciesDenseMatrixClass_generated();
      var _dependenciesSparseMatrixClassGenerated = require_dependenciesSparseMatrixClass_generated();
      var _dependenciesAddScalarGenerated = require_dependenciesAddScalar_generated();
      var _dependenciesCosGenerated = require_dependenciesCos_generated();
      var _dependenciesMatrixGenerated = require_dependenciesMatrix_generated();
      var _dependenciesMultiplyScalarGenerated = require_dependenciesMultiplyScalar_generated();
      var _dependenciesNormGenerated = require_dependenciesNorm_generated();
      var _dependenciesSinGenerated = require_dependenciesSin_generated();
      var _dependenciesTypedGenerated = require_dependenciesTyped_generated();
      var _dependenciesUnaryMinusGenerated = require_dependenciesUnaryMinus_generated();
      var _factoriesAny = require_factoriesAny();
      var rotationMatrixDependencies = exports.rotationMatrixDependencies = {
        BigNumberDependencies: _dependenciesBigNumberClassGenerated.BigNumberDependencies,
        DenseMatrixDependencies: _dependenciesDenseMatrixClassGenerated.DenseMatrixDependencies,
        SparseMatrixDependencies: _dependenciesSparseMatrixClassGenerated.SparseMatrixDependencies,
        addScalarDependencies: _dependenciesAddScalarGenerated.addScalarDependencies,
        cosDependencies: _dependenciesCosGenerated.cosDependencies,
        matrixDependencies: _dependenciesMatrixGenerated.matrixDependencies,
        multiplyScalarDependencies: _dependenciesMultiplyScalarGenerated.multiplyScalarDependencies,
        normDependencies: _dependenciesNormGenerated.normDependencies,
        sinDependencies: _dependenciesSinGenerated.sinDependencies,
        typedDependencies: _dependenciesTypedGenerated.typedDependencies,
        unaryMinusDependencies: _dependenciesUnaryMinusGenerated.unaryMinusDependencies,
        createRotationMatrix: _factoriesAny.createRotationMatrix
      };
    }
  });

  // node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/entry/dependenciesAny/dependenciesRotate.generated.js
  var require_dependenciesRotate_generated = __commonJS({
    "node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/entry/dependenciesAny/dependenciesRotate.generated.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.rotateDependencies = void 0;
      var _dependenciesMultiplyGenerated = require_dependenciesMultiply_generated();
      var _dependenciesRotationMatrixGenerated = require_dependenciesRotationMatrix_generated();
      var _dependenciesTypedGenerated = require_dependenciesTyped_generated();
      var _factoriesAny = require_factoriesAny();
      var rotateDependencies = exports.rotateDependencies = {
        multiplyDependencies: _dependenciesMultiplyGenerated.multiplyDependencies,
        rotationMatrixDependencies: _dependenciesRotationMatrixGenerated.rotationMatrixDependencies,
        typedDependencies: _dependenciesTypedGenerated.typedDependencies,
        createRotate: _factoriesAny.createRotate
      };
    }
  });

  // node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/entry/dependenciesAny/dependenciesRow.generated.js
  var require_dependenciesRow_generated = __commonJS({
    "node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/entry/dependenciesAny/dependenciesRow.generated.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.rowDependencies = void 0;
      var _dependenciesIndexClassGenerated = require_dependenciesIndexClass_generated();
      var _dependenciesMatrixGenerated = require_dependenciesMatrix_generated();
      var _dependenciesRangeGenerated = require_dependenciesRange_generated();
      var _dependenciesTypedGenerated = require_dependenciesTyped_generated();
      var _factoriesAny = require_factoriesAny();
      var rowDependencies = exports.rowDependencies = {
        IndexDependencies: _dependenciesIndexClassGenerated.IndexDependencies,
        matrixDependencies: _dependenciesMatrixGenerated.matrixDependencies,
        rangeDependencies: _dependenciesRangeGenerated.rangeDependencies,
        typedDependencies: _dependenciesTypedGenerated.typedDependencies,
        createRow: _factoriesAny.createRow
      };
    }
  });

  // node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/entry/dependenciesAny/dependenciesRowTransform.generated.js
  var require_dependenciesRowTransform_generated = __commonJS({
    "node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/entry/dependenciesAny/dependenciesRowTransform.generated.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.rowTransformDependencies = void 0;
      var _dependenciesIndexClassGenerated = require_dependenciesIndexClass_generated();
      var _dependenciesMatrixGenerated = require_dependenciesMatrix_generated();
      var _dependenciesRangeGenerated = require_dependenciesRange_generated();
      var _dependenciesTypedGenerated = require_dependenciesTyped_generated();
      var _factoriesAny = require_factoriesAny();
      var rowTransformDependencies = exports.rowTransformDependencies = {
        IndexDependencies: _dependenciesIndexClassGenerated.IndexDependencies,
        matrixDependencies: _dependenciesMatrixGenerated.matrixDependencies,
        rangeDependencies: _dependenciesRangeGenerated.rangeDependencies,
        typedDependencies: _dependenciesTypedGenerated.typedDependencies,
        createRowTransform: _factoriesAny.createRowTransform
      };
    }
  });

  // node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/entry/dependenciesAny/dependenciesRydberg.generated.js
  var require_dependenciesRydberg_generated = __commonJS({
    "node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/entry/dependenciesAny/dependenciesRydberg.generated.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.rydbergDependencies = void 0;
      var _dependenciesBigNumberClassGenerated = require_dependenciesBigNumberClass_generated();
      var _dependenciesUnitClassGenerated = require_dependenciesUnitClass_generated();
      var _factoriesAny = require_factoriesAny();
      var rydbergDependencies = exports.rydbergDependencies = {
        BigNumberDependencies: _dependenciesBigNumberClassGenerated.BigNumberDependencies,
        UnitDependencies: _dependenciesUnitClassGenerated.UnitDependencies,
        createRydberg: _factoriesAny.createRydberg
      };
    }
  });

  // node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/entry/dependenciesAny/dependenciesSQRT1_2.generated.js
  var require_dependenciesSQRT1_2_generated = __commonJS({
    "node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/entry/dependenciesAny/dependenciesSQRT1_2.generated.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.SQRT1_2Dependencies = void 0;
      var _dependenciesBigNumberClassGenerated = require_dependenciesBigNumberClass_generated();
      var _factoriesAny = require_factoriesAny();
      var SQRT1_2Dependencies = exports.SQRT1_2Dependencies = {
        // eslint-disable-line camelcase
        BigNumberDependencies: _dependenciesBigNumberClassGenerated.BigNumberDependencies,
        createSQRT1_2: _factoriesAny.createSQRT1_2
      };
    }
  });

  // node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/entry/dependenciesAny/dependenciesSQRT2.generated.js
  var require_dependenciesSQRT2_generated = __commonJS({
    "node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/entry/dependenciesAny/dependenciesSQRT2.generated.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.SQRT2Dependencies = void 0;
      var _dependenciesBigNumberClassGenerated = require_dependenciesBigNumberClass_generated();
      var _factoriesAny = require_factoriesAny();
      var SQRT2Dependencies = exports.SQRT2Dependencies = {
        BigNumberDependencies: _dependenciesBigNumberClassGenerated.BigNumberDependencies,
        createSQRT2: _factoriesAny.createSQRT2
      };
    }
  });

  // node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/entry/dependenciesAny/dependenciesSackurTetrode.generated.js
  var require_dependenciesSackurTetrode_generated = __commonJS({
    "node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/entry/dependenciesAny/dependenciesSackurTetrode.generated.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.sackurTetrodeDependencies = void 0;
      var _dependenciesBigNumberClassGenerated = require_dependenciesBigNumberClass_generated();
      var _factoriesAny = require_factoriesAny();
      var sackurTetrodeDependencies = exports.sackurTetrodeDependencies = {
        BigNumberDependencies: _dependenciesBigNumberClassGenerated.BigNumberDependencies,
        createSackurTetrode: _factoriesAny.createSackurTetrode
      };
    }
  });

  // node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/entry/dependenciesAny/dependenciesSec.generated.js
  var require_dependenciesSec_generated = __commonJS({
    "node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/entry/dependenciesAny/dependenciesSec.generated.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.secDependencies = void 0;
      var _dependenciesBigNumberClassGenerated = require_dependenciesBigNumberClass_generated();
      var _dependenciesTypedGenerated = require_dependenciesTyped_generated();
      var _factoriesAny = require_factoriesAny();
      var secDependencies = exports.secDependencies = {
        BigNumberDependencies: _dependenciesBigNumberClassGenerated.BigNumberDependencies,
        typedDependencies: _dependenciesTypedGenerated.typedDependencies,
        createSec: _factoriesAny.createSec
      };
    }
  });

  // node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/entry/dependenciesAny/dependenciesSech.generated.js
  var require_dependenciesSech_generated = __commonJS({
    "node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/entry/dependenciesAny/dependenciesSech.generated.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.sechDependencies = void 0;
      var _dependenciesBigNumberClassGenerated = require_dependenciesBigNumberClass_generated();
      var _dependenciesTypedGenerated = require_dependenciesTyped_generated();
      var _factoriesAny = require_factoriesAny();
      var sechDependencies = exports.sechDependencies = {
        BigNumberDependencies: _dependenciesBigNumberClassGenerated.BigNumberDependencies,
        typedDependencies: _dependenciesTypedGenerated.typedDependencies,
        createSech: _factoriesAny.createSech
      };
    }
  });

  // node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/entry/dependenciesAny/dependenciesSecondRadiation.generated.js
  var require_dependenciesSecondRadiation_generated = __commonJS({
    "node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/entry/dependenciesAny/dependenciesSecondRadiation.generated.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.secondRadiationDependencies = void 0;
      var _dependenciesBigNumberClassGenerated = require_dependenciesBigNumberClass_generated();
      var _dependenciesUnitClassGenerated = require_dependenciesUnitClass_generated();
      var _factoriesAny = require_factoriesAny();
      var secondRadiationDependencies = exports.secondRadiationDependencies = {
        BigNumberDependencies: _dependenciesBigNumberClassGenerated.BigNumberDependencies,
        UnitDependencies: _dependenciesUnitClassGenerated.UnitDependencies,
        createSecondRadiation: _factoriesAny.createSecondRadiation
      };
    }
  });

  // node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/entry/dependenciesAny/dependenciesSetCartesian.generated.js
  var require_dependenciesSetCartesian_generated = __commonJS({
    "node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/entry/dependenciesAny/dependenciesSetCartesian.generated.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.setCartesianDependencies = void 0;
      var _dependenciesDenseMatrixClassGenerated = require_dependenciesDenseMatrixClass_generated();
      var _dependenciesIndexClassGenerated = require_dependenciesIndexClass_generated();
      var _dependenciesCompareNaturalGenerated = require_dependenciesCompareNatural_generated();
      var _dependenciesSizeGenerated = require_dependenciesSize_generated();
      var _dependenciesSubsetGenerated = require_dependenciesSubset_generated();
      var _dependenciesTypedGenerated = require_dependenciesTyped_generated();
      var _factoriesAny = require_factoriesAny();
      var setCartesianDependencies = exports.setCartesianDependencies = {
        DenseMatrixDependencies: _dependenciesDenseMatrixClassGenerated.DenseMatrixDependencies,
        IndexDependencies: _dependenciesIndexClassGenerated.IndexDependencies,
        compareNaturalDependencies: _dependenciesCompareNaturalGenerated.compareNaturalDependencies,
        sizeDependencies: _dependenciesSizeGenerated.sizeDependencies,
        subsetDependencies: _dependenciesSubsetGenerated.subsetDependencies,
        typedDependencies: _dependenciesTypedGenerated.typedDependencies,
        createSetCartesian: _factoriesAny.createSetCartesian
      };
    }
  });

  // node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/entry/dependenciesAny/dependenciesSetDifference.generated.js
  var require_dependenciesSetDifference_generated = __commonJS({
    "node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/entry/dependenciesAny/dependenciesSetDifference.generated.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.setDifferenceDependencies = void 0;
      var _dependenciesDenseMatrixClassGenerated = require_dependenciesDenseMatrixClass_generated();
      var _dependenciesIndexClassGenerated = require_dependenciesIndexClass_generated();
      var _dependenciesCompareNaturalGenerated = require_dependenciesCompareNatural_generated();
      var _dependenciesSizeGenerated = require_dependenciesSize_generated();
      var _dependenciesSubsetGenerated = require_dependenciesSubset_generated();
      var _dependenciesTypedGenerated = require_dependenciesTyped_generated();
      var _factoriesAny = require_factoriesAny();
      var setDifferenceDependencies = exports.setDifferenceDependencies = {
        DenseMatrixDependencies: _dependenciesDenseMatrixClassGenerated.DenseMatrixDependencies,
        IndexDependencies: _dependenciesIndexClassGenerated.IndexDependencies,
        compareNaturalDependencies: _dependenciesCompareNaturalGenerated.compareNaturalDependencies,
        sizeDependencies: _dependenciesSizeGenerated.sizeDependencies,
        subsetDependencies: _dependenciesSubsetGenerated.subsetDependencies,
        typedDependencies: _dependenciesTypedGenerated.typedDependencies,
        createSetDifference: _factoriesAny.createSetDifference
      };
    }
  });

  // node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/entry/dependenciesAny/dependenciesSetDistinct.generated.js
  var require_dependenciesSetDistinct_generated = __commonJS({
    "node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/entry/dependenciesAny/dependenciesSetDistinct.generated.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.setDistinctDependencies = void 0;
      var _dependenciesDenseMatrixClassGenerated = require_dependenciesDenseMatrixClass_generated();
      var _dependenciesIndexClassGenerated = require_dependenciesIndexClass_generated();
      var _dependenciesCompareNaturalGenerated = require_dependenciesCompareNatural_generated();
      var _dependenciesSizeGenerated = require_dependenciesSize_generated();
      var _dependenciesSubsetGenerated = require_dependenciesSubset_generated();
      var _dependenciesTypedGenerated = require_dependenciesTyped_generated();
      var _factoriesAny = require_factoriesAny();
      var setDistinctDependencies = exports.setDistinctDependencies = {
        DenseMatrixDependencies: _dependenciesDenseMatrixClassGenerated.DenseMatrixDependencies,
        IndexDependencies: _dependenciesIndexClassGenerated.IndexDependencies,
        compareNaturalDependencies: _dependenciesCompareNaturalGenerated.compareNaturalDependencies,
        sizeDependencies: _dependenciesSizeGenerated.sizeDependencies,
        subsetDependencies: _dependenciesSubsetGenerated.subsetDependencies,
        typedDependencies: _dependenciesTypedGenerated.typedDependencies,
        createSetDistinct: _factoriesAny.createSetDistinct
      };
    }
  });

  // node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/entry/dependenciesAny/dependenciesSetIntersect.generated.js
  var require_dependenciesSetIntersect_generated = __commonJS({
    "node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/entry/dependenciesAny/dependenciesSetIntersect.generated.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.setIntersectDependencies = void 0;
      var _dependenciesDenseMatrixClassGenerated = require_dependenciesDenseMatrixClass_generated();
      var _dependenciesIndexClassGenerated = require_dependenciesIndexClass_generated();
      var _dependenciesCompareNaturalGenerated = require_dependenciesCompareNatural_generated();
      var _dependenciesSizeGenerated = require_dependenciesSize_generated();
      var _dependenciesSubsetGenerated = require_dependenciesSubset_generated();
      var _dependenciesTypedGenerated = require_dependenciesTyped_generated();
      var _factoriesAny = require_factoriesAny();
      var setIntersectDependencies = exports.setIntersectDependencies = {
        DenseMatrixDependencies: _dependenciesDenseMatrixClassGenerated.DenseMatrixDependencies,
        IndexDependencies: _dependenciesIndexClassGenerated.IndexDependencies,
        compareNaturalDependencies: _dependenciesCompareNaturalGenerated.compareNaturalDependencies,
        sizeDependencies: _dependenciesSizeGenerated.sizeDependencies,
        subsetDependencies: _dependenciesSubsetGenerated.subsetDependencies,
        typedDependencies: _dependenciesTypedGenerated.typedDependencies,
        createSetIntersect: _factoriesAny.createSetIntersect
      };
    }
  });

  // node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/entry/dependenciesAny/dependenciesSetIsSubset.generated.js
  var require_dependenciesSetIsSubset_generated = __commonJS({
    "node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/entry/dependenciesAny/dependenciesSetIsSubset.generated.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.setIsSubsetDependencies = void 0;
      var _dependenciesIndexClassGenerated = require_dependenciesIndexClass_generated();
      var _dependenciesCompareNaturalGenerated = require_dependenciesCompareNatural_generated();
      var _dependenciesSizeGenerated = require_dependenciesSize_generated();
      var _dependenciesSubsetGenerated = require_dependenciesSubset_generated();
      var _dependenciesTypedGenerated = require_dependenciesTyped_generated();
      var _factoriesAny = require_factoriesAny();
      var setIsSubsetDependencies = exports.setIsSubsetDependencies = {
        IndexDependencies: _dependenciesIndexClassGenerated.IndexDependencies,
        compareNaturalDependencies: _dependenciesCompareNaturalGenerated.compareNaturalDependencies,
        sizeDependencies: _dependenciesSizeGenerated.sizeDependencies,
        subsetDependencies: _dependenciesSubsetGenerated.subsetDependencies,
        typedDependencies: _dependenciesTypedGenerated.typedDependencies,
        createSetIsSubset: _factoriesAny.createSetIsSubset
      };
    }
  });

  // node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/entry/dependenciesAny/dependenciesSetMultiplicity.generated.js
  var require_dependenciesSetMultiplicity_generated = __commonJS({
    "node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/entry/dependenciesAny/dependenciesSetMultiplicity.generated.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.setMultiplicityDependencies = void 0;
      var _dependenciesIndexClassGenerated = require_dependenciesIndexClass_generated();
      var _dependenciesCompareNaturalGenerated = require_dependenciesCompareNatural_generated();
      var _dependenciesSizeGenerated = require_dependenciesSize_generated();
      var _dependenciesSubsetGenerated = require_dependenciesSubset_generated();
      var _dependenciesTypedGenerated = require_dependenciesTyped_generated();
      var _factoriesAny = require_factoriesAny();
      var setMultiplicityDependencies = exports.setMultiplicityDependencies = {
        IndexDependencies: _dependenciesIndexClassGenerated.IndexDependencies,
        compareNaturalDependencies: _dependenciesCompareNaturalGenerated.compareNaturalDependencies,
        sizeDependencies: _dependenciesSizeGenerated.sizeDependencies,
        subsetDependencies: _dependenciesSubsetGenerated.subsetDependencies,
        typedDependencies: _dependenciesTypedGenerated.typedDependencies,
        createSetMultiplicity: _factoriesAny.createSetMultiplicity
      };
    }
  });

  // node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/entry/dependenciesAny/dependenciesSetPowerset.generated.js
  var require_dependenciesSetPowerset_generated = __commonJS({
    "node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/entry/dependenciesAny/dependenciesSetPowerset.generated.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.setPowersetDependencies = void 0;
      var _dependenciesIndexClassGenerated = require_dependenciesIndexClass_generated();
      var _dependenciesCompareNaturalGenerated = require_dependenciesCompareNatural_generated();
      var _dependenciesSizeGenerated = require_dependenciesSize_generated();
      var _dependenciesSubsetGenerated = require_dependenciesSubset_generated();
      var _dependenciesTypedGenerated = require_dependenciesTyped_generated();
      var _factoriesAny = require_factoriesAny();
      var setPowersetDependencies = exports.setPowersetDependencies = {
        IndexDependencies: _dependenciesIndexClassGenerated.IndexDependencies,
        compareNaturalDependencies: _dependenciesCompareNaturalGenerated.compareNaturalDependencies,
        sizeDependencies: _dependenciesSizeGenerated.sizeDependencies,
        subsetDependencies: _dependenciesSubsetGenerated.subsetDependencies,
        typedDependencies: _dependenciesTypedGenerated.typedDependencies,
        createSetPowerset: _factoriesAny.createSetPowerset
      };
    }
  });

  // node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/entry/dependenciesAny/dependenciesSetSize.generated.js
  var require_dependenciesSetSize_generated = __commonJS({
    "node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/entry/dependenciesAny/dependenciesSetSize.generated.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.setSizeDependencies = void 0;
      var _dependenciesCompareNaturalGenerated = require_dependenciesCompareNatural_generated();
      var _dependenciesTypedGenerated = require_dependenciesTyped_generated();
      var _factoriesAny = require_factoriesAny();
      var setSizeDependencies = exports.setSizeDependencies = {
        compareNaturalDependencies: _dependenciesCompareNaturalGenerated.compareNaturalDependencies,
        typedDependencies: _dependenciesTypedGenerated.typedDependencies,
        createSetSize: _factoriesAny.createSetSize
      };
    }
  });

  // node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/entry/dependenciesAny/dependenciesSetSymDifference.generated.js
  var require_dependenciesSetSymDifference_generated = __commonJS({
    "node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/entry/dependenciesAny/dependenciesSetSymDifference.generated.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.setSymDifferenceDependencies = void 0;
      var _dependenciesIndexClassGenerated = require_dependenciesIndexClass_generated();
      var _dependenciesConcatGenerated = require_dependenciesConcat_generated();
      var _dependenciesSetDifferenceGenerated = require_dependenciesSetDifference_generated();
      var _dependenciesSizeGenerated = require_dependenciesSize_generated();
      var _dependenciesSubsetGenerated = require_dependenciesSubset_generated();
      var _dependenciesTypedGenerated = require_dependenciesTyped_generated();
      var _factoriesAny = require_factoriesAny();
      var setSymDifferenceDependencies = exports.setSymDifferenceDependencies = {
        IndexDependencies: _dependenciesIndexClassGenerated.IndexDependencies,
        concatDependencies: _dependenciesConcatGenerated.concatDependencies,
        setDifferenceDependencies: _dependenciesSetDifferenceGenerated.setDifferenceDependencies,
        sizeDependencies: _dependenciesSizeGenerated.sizeDependencies,
        subsetDependencies: _dependenciesSubsetGenerated.subsetDependencies,
        typedDependencies: _dependenciesTypedGenerated.typedDependencies,
        createSetSymDifference: _factoriesAny.createSetSymDifference
      };
    }
  });

  // node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/entry/dependenciesAny/dependenciesSetUnion.generated.js
  var require_dependenciesSetUnion_generated = __commonJS({
    "node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/entry/dependenciesAny/dependenciesSetUnion.generated.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.setUnionDependencies = void 0;
      var _dependenciesIndexClassGenerated = require_dependenciesIndexClass_generated();
      var _dependenciesConcatGenerated = require_dependenciesConcat_generated();
      var _dependenciesSetIntersectGenerated = require_dependenciesSetIntersect_generated();
      var _dependenciesSetSymDifferenceGenerated = require_dependenciesSetSymDifference_generated();
      var _dependenciesSizeGenerated = require_dependenciesSize_generated();
      var _dependenciesSubsetGenerated = require_dependenciesSubset_generated();
      var _dependenciesTypedGenerated = require_dependenciesTyped_generated();
      var _factoriesAny = require_factoriesAny();
      var setUnionDependencies = exports.setUnionDependencies = {
        IndexDependencies: _dependenciesIndexClassGenerated.IndexDependencies,
        concatDependencies: _dependenciesConcatGenerated.concatDependencies,
        setIntersectDependencies: _dependenciesSetIntersectGenerated.setIntersectDependencies,
        setSymDifferenceDependencies: _dependenciesSetSymDifferenceGenerated.setSymDifferenceDependencies,
        sizeDependencies: _dependenciesSizeGenerated.sizeDependencies,
        subsetDependencies: _dependenciesSubsetGenerated.subsetDependencies,
        typedDependencies: _dependenciesTypedGenerated.typedDependencies,
        createSetUnion: _factoriesAny.createSetUnion
      };
    }
  });

  // node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/entry/dependenciesAny/dependenciesSinh.generated.js
  var require_dependenciesSinh_generated = __commonJS({
    "node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/entry/dependenciesAny/dependenciesSinh.generated.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.sinhDependencies = void 0;
      var _dependenciesTypedGenerated = require_dependenciesTyped_generated();
      var _factoriesAny = require_factoriesAny();
      var sinhDependencies = exports.sinhDependencies = {
        typedDependencies: _dependenciesTypedGenerated.typedDependencies,
        createSinh: _factoriesAny.createSinh
      };
    }
  });

  // node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/entry/dependenciesAny/dependenciesSolveODE.generated.js
  var require_dependenciesSolveODE_generated = __commonJS({
    "node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/entry/dependenciesAny/dependenciesSolveODE.generated.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.solveODEDependencies = void 0;
      var _dependenciesAbsGenerated = require_dependenciesAbs_generated();
      var _dependenciesAddGenerated = require_dependenciesAdd_generated();
      var _dependenciesBignumberGenerated = require_dependenciesBignumber_generated();
      var _dependenciesDivideGenerated = require_dependenciesDivide_generated();
      var _dependenciesIsNegativeGenerated = require_dependenciesIsNegative_generated();
      var _dependenciesIsPositiveGenerated = require_dependenciesIsPositive_generated();
      var _dependenciesLargerGenerated = require_dependenciesLarger_generated();
      var _dependenciesMapGenerated = require_dependenciesMap_generated();
      var _dependenciesMatrixGenerated = require_dependenciesMatrix_generated();
      var _dependenciesMaxGenerated = require_dependenciesMax_generated();
      var _dependenciesMultiplyGenerated = require_dependenciesMultiply_generated();
      var _dependenciesSmallerGenerated = require_dependenciesSmaller_generated();
      var _dependenciesSubtractGenerated = require_dependenciesSubtract_generated();
      var _dependenciesTypedGenerated = require_dependenciesTyped_generated();
      var _dependenciesUnaryMinusGenerated = require_dependenciesUnaryMinus_generated();
      var _factoriesAny = require_factoriesAny();
      var solveODEDependencies = exports.solveODEDependencies = {
        absDependencies: _dependenciesAbsGenerated.absDependencies,
        addDependencies: _dependenciesAddGenerated.addDependencies,
        bignumberDependencies: _dependenciesBignumberGenerated.bignumberDependencies,
        divideDependencies: _dependenciesDivideGenerated.divideDependencies,
        isNegativeDependencies: _dependenciesIsNegativeGenerated.isNegativeDependencies,
        isPositiveDependencies: _dependenciesIsPositiveGenerated.isPositiveDependencies,
        largerDependencies: _dependenciesLargerGenerated.largerDependencies,
        mapDependencies: _dependenciesMapGenerated.mapDependencies,
        matrixDependencies: _dependenciesMatrixGenerated.matrixDependencies,
        maxDependencies: _dependenciesMaxGenerated.maxDependencies,
        multiplyDependencies: _dependenciesMultiplyGenerated.multiplyDependencies,
        smallerDependencies: _dependenciesSmallerGenerated.smallerDependencies,
        subtractDependencies: _dependenciesSubtractGenerated.subtractDependencies,
        typedDependencies: _dependenciesTypedGenerated.typedDependencies,
        unaryMinusDependencies: _dependenciesUnaryMinusGenerated.unaryMinusDependencies,
        createSolveODE: _factoriesAny.createSolveODE
      };
    }
  });

  // node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/entry/dependenciesAny/dependenciesSort.generated.js
  var require_dependenciesSort_generated = __commonJS({
    "node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/entry/dependenciesAny/dependenciesSort.generated.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.sortDependencies = void 0;
      var _dependenciesCompareGenerated = require_dependenciesCompare_generated();
      var _dependenciesCompareNaturalGenerated = require_dependenciesCompareNatural_generated();
      var _dependenciesMatrixGenerated = require_dependenciesMatrix_generated();
      var _dependenciesTypedGenerated = require_dependenciesTyped_generated();
      var _factoriesAny = require_factoriesAny();
      var sortDependencies = exports.sortDependencies = {
        compareDependencies: _dependenciesCompareGenerated.compareDependencies,
        compareNaturalDependencies: _dependenciesCompareNaturalGenerated.compareNaturalDependencies,
        matrixDependencies: _dependenciesMatrixGenerated.matrixDependencies,
        typedDependencies: _dependenciesTypedGenerated.typedDependencies,
        createSort: _factoriesAny.createSort
      };
    }
  });

  // node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/entry/dependenciesAny/dependenciesSparse.generated.js
  var require_dependenciesSparse_generated = __commonJS({
    "node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/entry/dependenciesAny/dependenciesSparse.generated.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.sparseDependencies = void 0;
      var _dependenciesSparseMatrixClassGenerated = require_dependenciesSparseMatrixClass_generated();
      var _dependenciesTypedGenerated = require_dependenciesTyped_generated();
      var _factoriesAny = require_factoriesAny();
      var sparseDependencies = exports.sparseDependencies = {
        SparseMatrixDependencies: _dependenciesSparseMatrixClassGenerated.SparseMatrixDependencies,
        typedDependencies: _dependenciesTypedGenerated.typedDependencies,
        createSparse: _factoriesAny.createSparse
      };
    }
  });

  // node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/entry/dependenciesAny/dependenciesSpeedOfLight.generated.js
  var require_dependenciesSpeedOfLight_generated = __commonJS({
    "node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/entry/dependenciesAny/dependenciesSpeedOfLight.generated.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.speedOfLightDependencies = void 0;
      var _dependenciesBigNumberClassGenerated = require_dependenciesBigNumberClass_generated();
      var _dependenciesUnitClassGenerated = require_dependenciesUnitClass_generated();
      var _factoriesAny = require_factoriesAny();
      var speedOfLightDependencies = exports.speedOfLightDependencies = {
        BigNumberDependencies: _dependenciesBigNumberClassGenerated.BigNumberDependencies,
        UnitDependencies: _dependenciesUnitClassGenerated.UnitDependencies,
        createSpeedOfLight: _factoriesAny.createSpeedOfLight
      };
    }
  });

  // node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/entry/dependenciesAny/dependenciesSplitUnit.generated.js
  var require_dependenciesSplitUnit_generated = __commonJS({
    "node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/entry/dependenciesAny/dependenciesSplitUnit.generated.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.splitUnitDependencies = void 0;
      var _dependenciesTypedGenerated = require_dependenciesTyped_generated();
      var _factoriesAny = require_factoriesAny();
      var splitUnitDependencies = exports.splitUnitDependencies = {
        typedDependencies: _dependenciesTypedGenerated.typedDependencies,
        createSplitUnit: _factoriesAny.createSplitUnit
      };
    }
  });

  // node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/entry/dependenciesAny/dependenciesSqrtm.generated.js
  var require_dependenciesSqrtm_generated = __commonJS({
    "node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/entry/dependenciesAny/dependenciesSqrtm.generated.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.sqrtmDependencies = void 0;
      var _dependenciesAbsGenerated = require_dependenciesAbs_generated();
      var _dependenciesAddGenerated = require_dependenciesAdd_generated();
      var _dependenciesIdentityGenerated = require_dependenciesIdentity_generated();
      var _dependenciesInvGenerated = require_dependenciesInv_generated();
      var _dependenciesMapGenerated = require_dependenciesMap_generated();
      var _dependenciesMaxGenerated = require_dependenciesMax_generated();
      var _dependenciesMultiplyGenerated = require_dependenciesMultiply_generated();
      var _dependenciesSizeGenerated = require_dependenciesSize_generated();
      var _dependenciesSqrtGenerated = require_dependenciesSqrt_generated();
      var _dependenciesSubtractGenerated = require_dependenciesSubtract_generated();
      var _dependenciesTypedGenerated = require_dependenciesTyped_generated();
      var _factoriesAny = require_factoriesAny();
      var sqrtmDependencies = exports.sqrtmDependencies = {
        absDependencies: _dependenciesAbsGenerated.absDependencies,
        addDependencies: _dependenciesAddGenerated.addDependencies,
        identityDependencies: _dependenciesIdentityGenerated.identityDependencies,
        invDependencies: _dependenciesInvGenerated.invDependencies,
        mapDependencies: _dependenciesMapGenerated.mapDependencies,
        maxDependencies: _dependenciesMaxGenerated.maxDependencies,
        multiplyDependencies: _dependenciesMultiplyGenerated.multiplyDependencies,
        sizeDependencies: _dependenciesSizeGenerated.sizeDependencies,
        sqrtDependencies: _dependenciesSqrtGenerated.sqrtDependencies,
        subtractDependencies: _dependenciesSubtractGenerated.subtractDependencies,
        typedDependencies: _dependenciesTypedGenerated.typedDependencies,
        createSqrtm: _factoriesAny.createSqrtm
      };
    }
  });

  // node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/entry/dependenciesAny/dependenciesSquare.generated.js
  var require_dependenciesSquare_generated = __commonJS({
    "node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/entry/dependenciesAny/dependenciesSquare.generated.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.squareDependencies = void 0;
      var _dependenciesTypedGenerated = require_dependenciesTyped_generated();
      var _factoriesAny = require_factoriesAny();
      var squareDependencies = exports.squareDependencies = {
        typedDependencies: _dependenciesTypedGenerated.typedDependencies,
        createSquare: _factoriesAny.createSquare
      };
    }
  });

  // node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/entry/dependenciesAny/dependenciesSqueeze.generated.js
  var require_dependenciesSqueeze_generated = __commonJS({
    "node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/entry/dependenciesAny/dependenciesSqueeze.generated.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.squeezeDependencies = void 0;
      var _dependenciesMatrixGenerated = require_dependenciesMatrix_generated();
      var _dependenciesTypedGenerated = require_dependenciesTyped_generated();
      var _factoriesAny = require_factoriesAny();
      var squeezeDependencies = exports.squeezeDependencies = {
        matrixDependencies: _dependenciesMatrixGenerated.matrixDependencies,
        typedDependencies: _dependenciesTypedGenerated.typedDependencies,
        createSqueeze: _factoriesAny.createSqueeze
      };
    }
  });

  // node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/entry/dependenciesAny/dependenciesVariance.generated.js
  var require_dependenciesVariance_generated = __commonJS({
    "node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/entry/dependenciesAny/dependenciesVariance.generated.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.varianceDependencies = void 0;
      var _dependenciesAddGenerated = require_dependenciesAdd_generated();
      var _dependenciesApplyGenerated = require_dependenciesApply_generated();
      var _dependenciesDivideGenerated = require_dependenciesDivide_generated();
      var _dependenciesIsNaNGenerated = require_dependenciesIsNaN_generated();
      var _dependenciesMultiplyGenerated = require_dependenciesMultiply_generated();
      var _dependenciesSubtractGenerated = require_dependenciesSubtract_generated();
      var _dependenciesTypedGenerated = require_dependenciesTyped_generated();
      var _factoriesAny = require_factoriesAny();
      var varianceDependencies = exports.varianceDependencies = {
        addDependencies: _dependenciesAddGenerated.addDependencies,
        applyDependencies: _dependenciesApplyGenerated.applyDependencies,
        divideDependencies: _dependenciesDivideGenerated.divideDependencies,
        isNaNDependencies: _dependenciesIsNaNGenerated.isNaNDependencies,
        multiplyDependencies: _dependenciesMultiplyGenerated.multiplyDependencies,
        subtractDependencies: _dependenciesSubtractGenerated.subtractDependencies,
        typedDependencies: _dependenciesTypedGenerated.typedDependencies,
        createVariance: _factoriesAny.createVariance
      };
    }
  });

  // node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/entry/dependenciesAny/dependenciesStd.generated.js
  var require_dependenciesStd_generated = __commonJS({
    "node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/entry/dependenciesAny/dependenciesStd.generated.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.stdDependencies = void 0;
      var _dependenciesMapGenerated = require_dependenciesMap_generated();
      var _dependenciesSqrtGenerated = require_dependenciesSqrt_generated();
      var _dependenciesTypedGenerated = require_dependenciesTyped_generated();
      var _dependenciesVarianceGenerated = require_dependenciesVariance_generated();
      var _factoriesAny = require_factoriesAny();
      var stdDependencies = exports.stdDependencies = {
        mapDependencies: _dependenciesMapGenerated.mapDependencies,
        sqrtDependencies: _dependenciesSqrtGenerated.sqrtDependencies,
        typedDependencies: _dependenciesTypedGenerated.typedDependencies,
        varianceDependencies: _dependenciesVarianceGenerated.varianceDependencies,
        createStd: _factoriesAny.createStd
      };
    }
  });

  // node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/entry/dependenciesAny/dependenciesStdTransform.generated.js
  var require_dependenciesStdTransform_generated = __commonJS({
    "node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/entry/dependenciesAny/dependenciesStdTransform.generated.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.stdTransformDependencies = void 0;
      var _dependenciesMapGenerated = require_dependenciesMap_generated();
      var _dependenciesSqrtGenerated = require_dependenciesSqrt_generated();
      var _dependenciesTypedGenerated = require_dependenciesTyped_generated();
      var _dependenciesVarianceGenerated = require_dependenciesVariance_generated();
      var _factoriesAny = require_factoriesAny();
      var stdTransformDependencies = exports.stdTransformDependencies = {
        mapDependencies: _dependenciesMapGenerated.mapDependencies,
        sqrtDependencies: _dependenciesSqrtGenerated.sqrtDependencies,
        typedDependencies: _dependenciesTypedGenerated.typedDependencies,
        varianceDependencies: _dependenciesVarianceGenerated.varianceDependencies,
        createStdTransform: _factoriesAny.createStdTransform
      };
    }
  });

  // node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/entry/dependenciesAny/dependenciesStefanBoltzmann.generated.js
  var require_dependenciesStefanBoltzmann_generated = __commonJS({
    "node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/entry/dependenciesAny/dependenciesStefanBoltzmann.generated.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.stefanBoltzmannDependencies = void 0;
      var _dependenciesBigNumberClassGenerated = require_dependenciesBigNumberClass_generated();
      var _dependenciesUnitClassGenerated = require_dependenciesUnitClass_generated();
      var _factoriesAny = require_factoriesAny();
      var stefanBoltzmannDependencies = exports.stefanBoltzmannDependencies = {
        BigNumberDependencies: _dependenciesBigNumberClassGenerated.BigNumberDependencies,
        UnitDependencies: _dependenciesUnitClassGenerated.UnitDependencies,
        createStefanBoltzmann: _factoriesAny.createStefanBoltzmann
      };
    }
  });

  // node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/entry/dependenciesAny/dependenciesString.generated.js
  var require_dependenciesString_generated = __commonJS({
    "node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/entry/dependenciesAny/dependenciesString.generated.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.stringDependencies = void 0;
      var _dependenciesTypedGenerated = require_dependenciesTyped_generated();
      var _factoriesAny = require_factoriesAny();
      var stringDependencies = exports.stringDependencies = {
        typedDependencies: _dependenciesTypedGenerated.typedDependencies,
        createString: _factoriesAny.createString
      };
    }
  });

  // node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/entry/dependenciesAny/dependenciesSubsetTransform.generated.js
  var require_dependenciesSubsetTransform_generated = __commonJS({
    "node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/entry/dependenciesAny/dependenciesSubsetTransform.generated.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.subsetTransformDependencies = void 0;
      var _dependenciesAddGenerated = require_dependenciesAdd_generated();
      var _dependenciesMatrixGenerated = require_dependenciesMatrix_generated();
      var _dependenciesTypedGenerated = require_dependenciesTyped_generated();
      var _dependenciesZerosGenerated = require_dependenciesZeros_generated();
      var _factoriesAny = require_factoriesAny();
      var subsetTransformDependencies = exports.subsetTransformDependencies = {
        addDependencies: _dependenciesAddGenerated.addDependencies,
        matrixDependencies: _dependenciesMatrixGenerated.matrixDependencies,
        typedDependencies: _dependenciesTypedGenerated.typedDependencies,
        zerosDependencies: _dependenciesZerosGenerated.zerosDependencies,
        createSubsetTransform: _factoriesAny.createSubsetTransform
      };
    }
  });

  // node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/entry/dependenciesAny/dependenciesSumTransform.generated.js
  var require_dependenciesSumTransform_generated = __commonJS({
    "node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/entry/dependenciesAny/dependenciesSumTransform.generated.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.sumTransformDependencies = void 0;
      var _dependenciesAddGenerated = require_dependenciesAdd_generated();
      var _dependenciesNumericGenerated = require_dependenciesNumeric_generated();
      var _dependenciesTypedGenerated = require_dependenciesTyped_generated();
      var _factoriesAny = require_factoriesAny();
      var sumTransformDependencies = exports.sumTransformDependencies = {
        addDependencies: _dependenciesAddGenerated.addDependencies,
        numericDependencies: _dependenciesNumericGenerated.numericDependencies,
        typedDependencies: _dependenciesTypedGenerated.typedDependencies,
        createSumTransform: _factoriesAny.createSumTransform
      };
    }
  });

  // node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/entry/dependenciesAny/dependenciesSymbolicEqual.generated.js
  var require_dependenciesSymbolicEqual_generated = __commonJS({
    "node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/entry/dependenciesAny/dependenciesSymbolicEqual.generated.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.symbolicEqualDependencies = void 0;
      var _dependenciesOperatorNodeGenerated = require_dependenciesOperatorNode_generated();
      var _dependenciesParseGenerated = require_dependenciesParse_generated();
      var _dependenciesSimplifyGenerated = require_dependenciesSimplify_generated();
      var _dependenciesTypedGenerated = require_dependenciesTyped_generated();
      var _factoriesAny = require_factoriesAny();
      var symbolicEqualDependencies = exports.symbolicEqualDependencies = {
        OperatorNodeDependencies: _dependenciesOperatorNodeGenerated.OperatorNodeDependencies,
        parseDependencies: _dependenciesParseGenerated.parseDependencies,
        simplifyDependencies: _dependenciesSimplifyGenerated.simplifyDependencies,
        typedDependencies: _dependenciesTypedGenerated.typedDependencies,
        createSymbolicEqual: _factoriesAny.createSymbolicEqual
      };
    }
  });

  // node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/entry/dependenciesAny/dependenciesTan.generated.js
  var require_dependenciesTan_generated = __commonJS({
    "node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/entry/dependenciesAny/dependenciesTan.generated.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.tanDependencies = void 0;
      var _dependenciesTypedGenerated = require_dependenciesTyped_generated();
      var _factoriesAny = require_factoriesAny();
      var tanDependencies = exports.tanDependencies = {
        typedDependencies: _dependenciesTypedGenerated.typedDependencies,
        createTan: _factoriesAny.createTan
      };
    }
  });

  // node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/entry/dependenciesAny/dependenciesTanh.generated.js
  var require_dependenciesTanh_generated = __commonJS({
    "node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/entry/dependenciesAny/dependenciesTanh.generated.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.tanhDependencies = void 0;
      var _dependenciesTypedGenerated = require_dependenciesTyped_generated();
      var _factoriesAny = require_factoriesAny();
      var tanhDependencies = exports.tanhDependencies = {
        typedDependencies: _dependenciesTypedGenerated.typedDependencies,
        createTanh: _factoriesAny.createTanh
      };
    }
  });

  // node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/entry/dependenciesAny/dependenciesThomsonCrossSection.generated.js
  var require_dependenciesThomsonCrossSection_generated = __commonJS({
    "node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/entry/dependenciesAny/dependenciesThomsonCrossSection.generated.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.thomsonCrossSectionDependencies = void 0;
      var _dependenciesBigNumberClassGenerated = require_dependenciesBigNumberClass_generated();
      var _dependenciesUnitClassGenerated = require_dependenciesUnitClass_generated();
      var _factoriesAny = require_factoriesAny();
      var thomsonCrossSectionDependencies = exports.thomsonCrossSectionDependencies = {
        BigNumberDependencies: _dependenciesBigNumberClassGenerated.BigNumberDependencies,
        UnitDependencies: _dependenciesUnitClassGenerated.UnitDependencies,
        createThomsonCrossSection: _factoriesAny.createThomsonCrossSection
      };
    }
  });

  // node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/entry/dependenciesAny/dependenciesTo.generated.js
  var require_dependenciesTo_generated = __commonJS({
    "node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/entry/dependenciesAny/dependenciesTo.generated.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.toDependencies = void 0;
      var _dependenciesConcatGenerated = require_dependenciesConcat_generated();
      var _dependenciesMatrixGenerated = require_dependenciesMatrix_generated();
      var _dependenciesTypedGenerated = require_dependenciesTyped_generated();
      var _factoriesAny = require_factoriesAny();
      var toDependencies = exports.toDependencies = {
        concatDependencies: _dependenciesConcatGenerated.concatDependencies,
        matrixDependencies: _dependenciesMatrixGenerated.matrixDependencies,
        typedDependencies: _dependenciesTypedGenerated.typedDependencies,
        createTo: _factoriesAny.createTo
      };
    }
  });

  // node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/entry/dependenciesAny/dependenciesTrace.generated.js
  var require_dependenciesTrace_generated = __commonJS({
    "node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/entry/dependenciesAny/dependenciesTrace.generated.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.traceDependencies = void 0;
      var _dependenciesAddGenerated = require_dependenciesAdd_generated();
      var _dependenciesMatrixGenerated = require_dependenciesMatrix_generated();
      var _dependenciesTypedGenerated = require_dependenciesTyped_generated();
      var _factoriesAny = require_factoriesAny();
      var traceDependencies = exports.traceDependencies = {
        addDependencies: _dependenciesAddGenerated.addDependencies,
        matrixDependencies: _dependenciesMatrixGenerated.matrixDependencies,
        typedDependencies: _dependenciesTypedGenerated.typedDependencies,
        createTrace: _factoriesAny.createTrace
      };
    }
  });

  // node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/entry/dependenciesAny/dependenciesTrue.generated.js
  var require_dependenciesTrue_generated = __commonJS({
    "node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/entry/dependenciesAny/dependenciesTrue.generated.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.trueDependencies = void 0;
      var _factoriesAny = require_factoriesAny();
      var trueDependencies = exports.trueDependencies = {
        createTrue: _factoriesAny.createTrue
      };
    }
  });

  // node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/entry/dependenciesAny/dependenciesUnequal.generated.js
  var require_dependenciesUnequal_generated = __commonJS({
    "node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/entry/dependenciesAny/dependenciesUnequal.generated.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.unequalDependencies = void 0;
      var _dependenciesDenseMatrixClassGenerated = require_dependenciesDenseMatrixClass_generated();
      var _dependenciesConcatGenerated = require_dependenciesConcat_generated();
      var _dependenciesEqualScalarGenerated = require_dependenciesEqualScalar_generated();
      var _dependenciesMatrixGenerated = require_dependenciesMatrix_generated();
      var _dependenciesTypedGenerated = require_dependenciesTyped_generated();
      var _factoriesAny = require_factoriesAny();
      var unequalDependencies = exports.unequalDependencies = {
        DenseMatrixDependencies: _dependenciesDenseMatrixClassGenerated.DenseMatrixDependencies,
        concatDependencies: _dependenciesConcatGenerated.concatDependencies,
        equalScalarDependencies: _dependenciesEqualScalarGenerated.equalScalarDependencies,
        matrixDependencies: _dependenciesMatrixGenerated.matrixDependencies,
        typedDependencies: _dependenciesTypedGenerated.typedDependencies,
        createUnequal: _factoriesAny.createUnequal
      };
    }
  });

  // node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/entry/dependenciesAny/dependenciesUnitFunction.generated.js
  var require_dependenciesUnitFunction_generated = __commonJS({
    "node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/entry/dependenciesAny/dependenciesUnitFunction.generated.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.unitDependencies = void 0;
      var _dependenciesUnitClassGenerated = require_dependenciesUnitClass_generated();
      var _dependenciesTypedGenerated = require_dependenciesTyped_generated();
      var _factoriesAny = require_factoriesAny();
      var unitDependencies = exports.unitDependencies = {
        UnitDependencies: _dependenciesUnitClassGenerated.UnitDependencies,
        typedDependencies: _dependenciesTypedGenerated.typedDependencies,
        createUnitFunction: _factoriesAny.createUnitFunction
      };
    }
  });

  // node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/entry/dependenciesAny/dependenciesUppercaseE.generated.js
  var require_dependenciesUppercaseE_generated = __commonJS({
    "node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/entry/dependenciesAny/dependenciesUppercaseE.generated.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.EDependencies = void 0;
      var _dependenciesEGenerated = require_dependenciesE_generated();
      var _factoriesAny = require_factoriesAny();
      var EDependencies = exports.EDependencies = {
        eDependencies: _dependenciesEGenerated.eDependencies,
        createUppercaseE: _factoriesAny.createUppercaseE
      };
    }
  });

  // node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/entry/dependenciesAny/dependenciesUppercasePi.generated.js
  var require_dependenciesUppercasePi_generated = __commonJS({
    "node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/entry/dependenciesAny/dependenciesUppercasePi.generated.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.PIDependencies = void 0;
      var _dependenciesPiGenerated = require_dependenciesPi_generated();
      var _factoriesAny = require_factoriesAny();
      var PIDependencies = exports.PIDependencies = {
        piDependencies: _dependenciesPiGenerated.piDependencies,
        createUppercasePi: _factoriesAny.createUppercasePi
      };
    }
  });

  // node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/entry/dependenciesAny/dependenciesVacuumImpedance.generated.js
  var require_dependenciesVacuumImpedance_generated = __commonJS({
    "node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/entry/dependenciesAny/dependenciesVacuumImpedance.generated.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.vacuumImpedanceDependencies = void 0;
      var _dependenciesBigNumberClassGenerated = require_dependenciesBigNumberClass_generated();
      var _dependenciesUnitClassGenerated = require_dependenciesUnitClass_generated();
      var _factoriesAny = require_factoriesAny();
      var vacuumImpedanceDependencies = exports.vacuumImpedanceDependencies = {
        BigNumberDependencies: _dependenciesBigNumberClassGenerated.BigNumberDependencies,
        UnitDependencies: _dependenciesUnitClassGenerated.UnitDependencies,
        createVacuumImpedance: _factoriesAny.createVacuumImpedance
      };
    }
  });

  // node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/entry/dependenciesAny/dependenciesVarianceTransform.generated.js
  var require_dependenciesVarianceTransform_generated = __commonJS({
    "node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/entry/dependenciesAny/dependenciesVarianceTransform.generated.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.varianceTransformDependencies = void 0;
      var _dependenciesAddGenerated = require_dependenciesAdd_generated();
      var _dependenciesApplyGenerated = require_dependenciesApply_generated();
      var _dependenciesDivideGenerated = require_dependenciesDivide_generated();
      var _dependenciesIsNaNGenerated = require_dependenciesIsNaN_generated();
      var _dependenciesMultiplyGenerated = require_dependenciesMultiply_generated();
      var _dependenciesSubtractGenerated = require_dependenciesSubtract_generated();
      var _dependenciesTypedGenerated = require_dependenciesTyped_generated();
      var _factoriesAny = require_factoriesAny();
      var varianceTransformDependencies = exports.varianceTransformDependencies = {
        addDependencies: _dependenciesAddGenerated.addDependencies,
        applyDependencies: _dependenciesApplyGenerated.applyDependencies,
        divideDependencies: _dependenciesDivideGenerated.divideDependencies,
        isNaNDependencies: _dependenciesIsNaNGenerated.isNaNDependencies,
        multiplyDependencies: _dependenciesMultiplyGenerated.multiplyDependencies,
        subtractDependencies: _dependenciesSubtractGenerated.subtractDependencies,
        typedDependencies: _dependenciesTypedGenerated.typedDependencies,
        createVarianceTransform: _factoriesAny.createVarianceTransform
      };
    }
  });

  // node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/entry/dependenciesAny/dependenciesVersion.generated.js
  var require_dependenciesVersion_generated = __commonJS({
    "node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/entry/dependenciesAny/dependenciesVersion.generated.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.versionDependencies = void 0;
      var _factoriesAny = require_factoriesAny();
      var versionDependencies = exports.versionDependencies = {
        createVersion: _factoriesAny.createVersion
      };
    }
  });

  // node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/entry/dependenciesAny/dependenciesWeakMixingAngle.generated.js
  var require_dependenciesWeakMixingAngle_generated = __commonJS({
    "node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/entry/dependenciesAny/dependenciesWeakMixingAngle.generated.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.weakMixingAngleDependencies = void 0;
      var _dependenciesBigNumberClassGenerated = require_dependenciesBigNumberClass_generated();
      var _factoriesAny = require_factoriesAny();
      var weakMixingAngleDependencies = exports.weakMixingAngleDependencies = {
        BigNumberDependencies: _dependenciesBigNumberClassGenerated.BigNumberDependencies,
        createWeakMixingAngle: _factoriesAny.createWeakMixingAngle
      };
    }
  });

  // node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/entry/dependenciesAny/dependenciesWienDisplacement.generated.js
  var require_dependenciesWienDisplacement_generated = __commonJS({
    "node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/entry/dependenciesAny/dependenciesWienDisplacement.generated.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.wienDisplacementDependencies = void 0;
      var _dependenciesBigNumberClassGenerated = require_dependenciesBigNumberClass_generated();
      var _dependenciesUnitClassGenerated = require_dependenciesUnitClass_generated();
      var _factoriesAny = require_factoriesAny();
      var wienDisplacementDependencies = exports.wienDisplacementDependencies = {
        BigNumberDependencies: _dependenciesBigNumberClassGenerated.BigNumberDependencies,
        UnitDependencies: _dependenciesUnitClassGenerated.UnitDependencies,
        createWienDisplacement: _factoriesAny.createWienDisplacement
      };
    }
  });

  // node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/entry/dependenciesAny/dependenciesXor.generated.js
  var require_dependenciesXor_generated = __commonJS({
    "node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/entry/dependenciesAny/dependenciesXor.generated.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.xorDependencies = void 0;
      var _dependenciesDenseMatrixClassGenerated = require_dependenciesDenseMatrixClass_generated();
      var _dependenciesConcatGenerated = require_dependenciesConcat_generated();
      var _dependenciesMatrixGenerated = require_dependenciesMatrix_generated();
      var _dependenciesTypedGenerated = require_dependenciesTyped_generated();
      var _factoriesAny = require_factoriesAny();
      var xorDependencies = exports.xorDependencies = {
        DenseMatrixDependencies: _dependenciesDenseMatrixClassGenerated.DenseMatrixDependencies,
        concatDependencies: _dependenciesConcatGenerated.concatDependencies,
        matrixDependencies: _dependenciesMatrixGenerated.matrixDependencies,
        typedDependencies: _dependenciesTypedGenerated.typedDependencies,
        createXor: _factoriesAny.createXor
      };
    }
  });

  // node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/entry/dependenciesAny/dependenciesZeta.generated.js
  var require_dependenciesZeta_generated = __commonJS({
    "node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/entry/dependenciesAny/dependenciesZeta.generated.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.zetaDependencies = void 0;
      var _dependenciesBigNumberClassGenerated = require_dependenciesBigNumberClass_generated();
      var _dependenciesComplexClassGenerated = require_dependenciesComplexClass_generated();
      var _dependenciesAddGenerated = require_dependenciesAdd_generated();
      var _dependenciesDivideGenerated = require_dependenciesDivide_generated();
      var _dependenciesEqualGenerated = require_dependenciesEqual_generated();
      var _dependenciesFactorialGenerated = require_dependenciesFactorial_generated();
      var _dependenciesGammaGenerated = require_dependenciesGamma_generated();
      var _dependenciesIsNegativeGenerated = require_dependenciesIsNegative_generated();
      var _dependenciesMultiplyGenerated = require_dependenciesMultiply_generated();
      var _dependenciesPiGenerated = require_dependenciesPi_generated();
      var _dependenciesPowGenerated = require_dependenciesPow_generated();
      var _dependenciesSinGenerated = require_dependenciesSin_generated();
      var _dependenciesSmallerEqGenerated = require_dependenciesSmallerEq_generated();
      var _dependenciesSubtractGenerated = require_dependenciesSubtract_generated();
      var _dependenciesTypedGenerated = require_dependenciesTyped_generated();
      var _factoriesAny = require_factoriesAny();
      var zetaDependencies = exports.zetaDependencies = {
        BigNumberDependencies: _dependenciesBigNumberClassGenerated.BigNumberDependencies,
        ComplexDependencies: _dependenciesComplexClassGenerated.ComplexDependencies,
        addDependencies: _dependenciesAddGenerated.addDependencies,
        divideDependencies: _dependenciesDivideGenerated.divideDependencies,
        equalDependencies: _dependenciesEqualGenerated.equalDependencies,
        factorialDependencies: _dependenciesFactorialGenerated.factorialDependencies,
        gammaDependencies: _dependenciesGammaGenerated.gammaDependencies,
        isNegativeDependencies: _dependenciesIsNegativeGenerated.isNegativeDependencies,
        multiplyDependencies: _dependenciesMultiplyGenerated.multiplyDependencies,
        piDependencies: _dependenciesPiGenerated.piDependencies,
        powDependencies: _dependenciesPowGenerated.powDependencies,
        sinDependencies: _dependenciesSinGenerated.sinDependencies,
        smallerEqDependencies: _dependenciesSmallerEqGenerated.smallerEqDependencies,
        subtractDependencies: _dependenciesSubtractGenerated.subtractDependencies,
        typedDependencies: _dependenciesTypedGenerated.typedDependencies,
        createZeta: _factoriesAny.createZeta
      };
    }
  });

  // node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/entry/dependenciesAny/dependenciesZpk2tf.generated.js
  var require_dependenciesZpk2tf_generated = __commonJS({
    "node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/entry/dependenciesAny/dependenciesZpk2tf.generated.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.zpk2tfDependencies = void 0;
      var _dependenciesComplexClassGenerated = require_dependenciesComplexClass_generated();
      var _dependenciesAddGenerated = require_dependenciesAdd_generated();
      var _dependenciesMultiplyGenerated = require_dependenciesMultiply_generated();
      var _dependenciesNumberGenerated = require_dependenciesNumber_generated();
      var _dependenciesTypedGenerated = require_dependenciesTyped_generated();
      var _factoriesAny = require_factoriesAny();
      var zpk2tfDependencies = exports.zpk2tfDependencies = {
        ComplexDependencies: _dependenciesComplexClassGenerated.ComplexDependencies,
        addDependencies: _dependenciesAddGenerated.addDependencies,
        multiplyDependencies: _dependenciesMultiplyGenerated.multiplyDependencies,
        numberDependencies: _dependenciesNumberGenerated.numberDependencies,
        typedDependencies: _dependenciesTypedGenerated.typedDependencies,
        createZpk2tf: _factoriesAny.createZpk2tf
      };
    }
  });

  // node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/entry/allFactoriesAny.js
  var require_allFactoriesAny = __commonJS({
    "node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/entry/allFactoriesAny.js"(exports) {
      "use strict";
      var _typeof = require_typeof();
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.all = void 0;
      var allFactories = _interopRequireWildcard(require_factoriesAny());
      function _getRequireWildcardCache(e) {
        if ("function" != typeof WeakMap) return null;
        var r = /* @__PURE__ */ new WeakMap(), t = /* @__PURE__ */ new WeakMap();
        return (_getRequireWildcardCache = function _getRequireWildcardCache2(e2) {
          return e2 ? t : r;
        })(e);
      }
      function _interopRequireWildcard(e, r) {
        if (!r && e && e.__esModule) return e;
        if (null === e || "object" != _typeof(e) && "function" != typeof e) return { "default": e };
        var t = _getRequireWildcardCache(r);
        if (t && t.has(e)) return t.get(e);
        var n = { __proto__: null }, a = Object.defineProperty && Object.getOwnPropertyDescriptor;
        for (var u in e) if ("default" !== u && {}.hasOwnProperty.call(e, u)) {
          var i = a ? Object.getOwnPropertyDescriptor(e, u) : null;
          i && (i.get || i.set) ? Object.defineProperty(n, u, i) : n[u] = e[u];
        }
        return n["default"] = e, t && t.set(e, n), n;
      }
      var all = exports.all = allFactories;
    }
  });

  // node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/entry/dependenciesAny.generated.js
  var require_dependenciesAny_generated = __commonJS({
    "node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/entry/dependenciesAny.generated.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      Object.defineProperty(exports, "AccessorNodeDependencies", {
        enumerable: true,
        get: function get() {
          return _dependenciesAccessorNodeGenerated.AccessorNodeDependencies;
        }
      });
      Object.defineProperty(exports, "ArrayNodeDependencies", {
        enumerable: true,
        get: function get() {
          return _dependenciesArrayNodeGenerated.ArrayNodeDependencies;
        }
      });
      Object.defineProperty(exports, "AssignmentNodeDependencies", {
        enumerable: true,
        get: function get() {
          return _dependenciesAssignmentNodeGenerated.AssignmentNodeDependencies;
        }
      });
      Object.defineProperty(exports, "BigNumberDependencies", {
        enumerable: true,
        get: function get() {
          return _dependenciesBigNumberClassGenerated.BigNumberDependencies;
        }
      });
      Object.defineProperty(exports, "BlockNodeDependencies", {
        enumerable: true,
        get: function get() {
          return _dependenciesBlockNodeGenerated.BlockNodeDependencies;
        }
      });
      Object.defineProperty(exports, "ChainDependencies", {
        enumerable: true,
        get: function get() {
          return _dependenciesChainClassGenerated.ChainDependencies;
        }
      });
      Object.defineProperty(exports, "ComplexDependencies", {
        enumerable: true,
        get: function get() {
          return _dependenciesComplexClassGenerated.ComplexDependencies;
        }
      });
      Object.defineProperty(exports, "ConditionalNodeDependencies", {
        enumerable: true,
        get: function get() {
          return _dependenciesConditionalNodeGenerated.ConditionalNodeDependencies;
        }
      });
      Object.defineProperty(exports, "ConstantNodeDependencies", {
        enumerable: true,
        get: function get() {
          return _dependenciesConstantNodeGenerated.ConstantNodeDependencies;
        }
      });
      Object.defineProperty(exports, "DenseMatrixDependencies", {
        enumerable: true,
        get: function get() {
          return _dependenciesDenseMatrixClassGenerated.DenseMatrixDependencies;
        }
      });
      Object.defineProperty(exports, "EDependencies", {
        enumerable: true,
        get: function get() {
          return _dependenciesUppercaseEGenerated.EDependencies;
        }
      });
      Object.defineProperty(exports, "FibonacciHeapDependencies", {
        enumerable: true,
        get: function get() {
          return _dependenciesFibonacciHeapClassGenerated.FibonacciHeapDependencies;
        }
      });
      Object.defineProperty(exports, "FractionDependencies", {
        enumerable: true,
        get: function get() {
          return _dependenciesFractionClassGenerated.FractionDependencies;
        }
      });
      Object.defineProperty(exports, "FunctionAssignmentNodeDependencies", {
        enumerable: true,
        get: function get() {
          return _dependenciesFunctionAssignmentNodeGenerated.FunctionAssignmentNodeDependencies;
        }
      });
      Object.defineProperty(exports, "FunctionNodeDependencies", {
        enumerable: true,
        get: function get() {
          return _dependenciesFunctionNodeGenerated.FunctionNodeDependencies;
        }
      });
      Object.defineProperty(exports, "HelpDependencies", {
        enumerable: true,
        get: function get() {
          return _dependenciesHelpClassGenerated.HelpDependencies;
        }
      });
      Object.defineProperty(exports, "ImmutableDenseMatrixDependencies", {
        enumerable: true,
        get: function get() {
          return _dependenciesImmutableDenseMatrixClassGenerated.ImmutableDenseMatrixDependencies;
        }
      });
      Object.defineProperty(exports, "IndexDependencies", {
        enumerable: true,
        get: function get() {
          return _dependenciesIndexClassGenerated.IndexDependencies;
        }
      });
      Object.defineProperty(exports, "IndexNodeDependencies", {
        enumerable: true,
        get: function get() {
          return _dependenciesIndexNodeGenerated.IndexNodeDependencies;
        }
      });
      Object.defineProperty(exports, "InfinityDependencies", {
        enumerable: true,
        get: function get() {
          return _dependenciesInfinityGenerated.InfinityDependencies;
        }
      });
      Object.defineProperty(exports, "LN10Dependencies", {
        enumerable: true,
        get: function get() {
          return _dependenciesLN10Generated.LN10Dependencies;
        }
      });
      Object.defineProperty(exports, "LN2Dependencies", {
        enumerable: true,
        get: function get() {
          return _dependenciesLN2Generated.LN2Dependencies;
        }
      });
      Object.defineProperty(exports, "LOG10EDependencies", {
        enumerable: true,
        get: function get() {
          return _dependenciesLOG10EGenerated.LOG10EDependencies;
        }
      });
      Object.defineProperty(exports, "LOG2EDependencies", {
        enumerable: true,
        get: function get() {
          return _dependenciesLOG2EGenerated.LOG2EDependencies;
        }
      });
      Object.defineProperty(exports, "MatrixDependencies", {
        enumerable: true,
        get: function get() {
          return _dependenciesMatrixClassGenerated.MatrixDependencies;
        }
      });
      Object.defineProperty(exports, "NaNDependencies", {
        enumerable: true,
        get: function get() {
          return _dependenciesNaNGenerated.NaNDependencies;
        }
      });
      Object.defineProperty(exports, "NodeDependencies", {
        enumerable: true,
        get: function get() {
          return _dependenciesNodeGenerated.NodeDependencies;
        }
      });
      Object.defineProperty(exports, "ObjectNodeDependencies", {
        enumerable: true,
        get: function get() {
          return _dependenciesObjectNodeGenerated.ObjectNodeDependencies;
        }
      });
      Object.defineProperty(exports, "OperatorNodeDependencies", {
        enumerable: true,
        get: function get() {
          return _dependenciesOperatorNodeGenerated.OperatorNodeDependencies;
        }
      });
      Object.defineProperty(exports, "PIDependencies", {
        enumerable: true,
        get: function get() {
          return _dependenciesUppercasePiGenerated.PIDependencies;
        }
      });
      Object.defineProperty(exports, "ParenthesisNodeDependencies", {
        enumerable: true,
        get: function get() {
          return _dependenciesParenthesisNodeGenerated.ParenthesisNodeDependencies;
        }
      });
      Object.defineProperty(exports, "ParserDependencies", {
        enumerable: true,
        get: function get() {
          return _dependenciesParserClassGenerated.ParserDependencies;
        }
      });
      Object.defineProperty(exports, "RangeDependencies", {
        enumerable: true,
        get: function get() {
          return _dependenciesRangeClassGenerated.RangeDependencies;
        }
      });
      Object.defineProperty(exports, "RangeNodeDependencies", {
        enumerable: true,
        get: function get() {
          return _dependenciesRangeNodeGenerated.RangeNodeDependencies;
        }
      });
      Object.defineProperty(exports, "RelationalNodeDependencies", {
        enumerable: true,
        get: function get() {
          return _dependenciesRelationalNodeGenerated.RelationalNodeDependencies;
        }
      });
      Object.defineProperty(exports, "ResultSetDependencies", {
        enumerable: true,
        get: function get() {
          return _dependenciesResultSetGenerated.ResultSetDependencies;
        }
      });
      Object.defineProperty(exports, "SQRT1_2Dependencies", {
        enumerable: true,
        get: function get() {
          return _dependenciesSQRT1_2Generated.SQRT1_2Dependencies;
        }
      });
      Object.defineProperty(exports, "SQRT2Dependencies", {
        enumerable: true,
        get: function get() {
          return _dependenciesSQRT2Generated.SQRT2Dependencies;
        }
      });
      Object.defineProperty(exports, "SpaDependencies", {
        enumerable: true,
        get: function get() {
          return _dependenciesSpaClassGenerated.SpaDependencies;
        }
      });
      Object.defineProperty(exports, "SparseMatrixDependencies", {
        enumerable: true,
        get: function get() {
          return _dependenciesSparseMatrixClassGenerated.SparseMatrixDependencies;
        }
      });
      Object.defineProperty(exports, "SymbolNodeDependencies", {
        enumerable: true,
        get: function get() {
          return _dependenciesSymbolNodeGenerated.SymbolNodeDependencies;
        }
      });
      Object.defineProperty(exports, "UnitDependencies", {
        enumerable: true,
        get: function get() {
          return _dependenciesUnitClassGenerated.UnitDependencies;
        }
      });
      Object.defineProperty(exports, "absDependencies", {
        enumerable: true,
        get: function get() {
          return _dependenciesAbsGenerated.absDependencies;
        }
      });
      Object.defineProperty(exports, "acosDependencies", {
        enumerable: true,
        get: function get() {
          return _dependenciesAcosGenerated.acosDependencies;
        }
      });
      Object.defineProperty(exports, "acoshDependencies", {
        enumerable: true,
        get: function get() {
          return _dependenciesAcoshGenerated.acoshDependencies;
        }
      });
      Object.defineProperty(exports, "acotDependencies", {
        enumerable: true,
        get: function get() {
          return _dependenciesAcotGenerated.acotDependencies;
        }
      });
      Object.defineProperty(exports, "acothDependencies", {
        enumerable: true,
        get: function get() {
          return _dependenciesAcothGenerated.acothDependencies;
        }
      });
      Object.defineProperty(exports, "acscDependencies", {
        enumerable: true,
        get: function get() {
          return _dependenciesAcscGenerated.acscDependencies;
        }
      });
      Object.defineProperty(exports, "acschDependencies", {
        enumerable: true,
        get: function get() {
          return _dependenciesAcschGenerated.acschDependencies;
        }
      });
      Object.defineProperty(exports, "addDependencies", {
        enumerable: true,
        get: function get() {
          return _dependenciesAddGenerated.addDependencies;
        }
      });
      Object.defineProperty(exports, "addScalarDependencies", {
        enumerable: true,
        get: function get() {
          return _dependenciesAddScalarGenerated.addScalarDependencies;
        }
      });
      Object.defineProperty(exports, "all", {
        enumerable: true,
        get: function get() {
          return _allFactoriesAny.all;
        }
      });
      Object.defineProperty(exports, "andDependencies", {
        enumerable: true,
        get: function get() {
          return _dependenciesAndGenerated.andDependencies;
        }
      });
      Object.defineProperty(exports, "andTransformDependencies", {
        enumerable: true,
        get: function get() {
          return _dependenciesAndTransformGenerated.andTransformDependencies;
        }
      });
      Object.defineProperty(exports, "applyDependencies", {
        enumerable: true,
        get: function get() {
          return _dependenciesApplyGenerated.applyDependencies;
        }
      });
      Object.defineProperty(exports, "applyTransformDependencies", {
        enumerable: true,
        get: function get() {
          return _dependenciesApplyTransformGenerated.applyTransformDependencies;
        }
      });
      Object.defineProperty(exports, "argDependencies", {
        enumerable: true,
        get: function get() {
          return _dependenciesArgGenerated.argDependencies;
        }
      });
      Object.defineProperty(exports, "asecDependencies", {
        enumerable: true,
        get: function get() {
          return _dependenciesAsecGenerated.asecDependencies;
        }
      });
      Object.defineProperty(exports, "asechDependencies", {
        enumerable: true,
        get: function get() {
          return _dependenciesAsechGenerated.asechDependencies;
        }
      });
      Object.defineProperty(exports, "asinDependencies", {
        enumerable: true,
        get: function get() {
          return _dependenciesAsinGenerated.asinDependencies;
        }
      });
      Object.defineProperty(exports, "asinhDependencies", {
        enumerable: true,
        get: function get() {
          return _dependenciesAsinhGenerated.asinhDependencies;
        }
      });
      Object.defineProperty(exports, "atan2Dependencies", {
        enumerable: true,
        get: function get() {
          return _dependenciesAtan2Generated.atan2Dependencies;
        }
      });
      Object.defineProperty(exports, "atanDependencies", {
        enumerable: true,
        get: function get() {
          return _dependenciesAtanGenerated.atanDependencies;
        }
      });
      Object.defineProperty(exports, "atanhDependencies", {
        enumerable: true,
        get: function get() {
          return _dependenciesAtanhGenerated.atanhDependencies;
        }
      });
      Object.defineProperty(exports, "atomicMassDependencies", {
        enumerable: true,
        get: function get() {
          return _dependenciesAtomicMassGenerated.atomicMassDependencies;
        }
      });
      Object.defineProperty(exports, "avogadroDependencies", {
        enumerable: true,
        get: function get() {
          return _dependenciesAvogadroGenerated.avogadroDependencies;
        }
      });
      Object.defineProperty(exports, "bellNumbersDependencies", {
        enumerable: true,
        get: function get() {
          return _dependenciesBellNumbersGenerated.bellNumbersDependencies;
        }
      });
      Object.defineProperty(exports, "bignumberDependencies", {
        enumerable: true,
        get: function get() {
          return _dependenciesBignumberGenerated.bignumberDependencies;
        }
      });
      Object.defineProperty(exports, "binDependencies", {
        enumerable: true,
        get: function get() {
          return _dependenciesBinGenerated.binDependencies;
        }
      });
      Object.defineProperty(exports, "bitAndDependencies", {
        enumerable: true,
        get: function get() {
          return _dependenciesBitAndGenerated.bitAndDependencies;
        }
      });
      Object.defineProperty(exports, "bitAndTransformDependencies", {
        enumerable: true,
        get: function get() {
          return _dependenciesBitAndTransformGenerated.bitAndTransformDependencies;
        }
      });
      Object.defineProperty(exports, "bitNotDependencies", {
        enumerable: true,
        get: function get() {
          return _dependenciesBitNotGenerated.bitNotDependencies;
        }
      });
      Object.defineProperty(exports, "bitOrDependencies", {
        enumerable: true,
        get: function get() {
          return _dependenciesBitOrGenerated.bitOrDependencies;
        }
      });
      Object.defineProperty(exports, "bitOrTransformDependencies", {
        enumerable: true,
        get: function get() {
          return _dependenciesBitOrTransformGenerated.bitOrTransformDependencies;
        }
      });
      Object.defineProperty(exports, "bitXorDependencies", {
        enumerable: true,
        get: function get() {
          return _dependenciesBitXorGenerated.bitXorDependencies;
        }
      });
      Object.defineProperty(exports, "bohrMagnetonDependencies", {
        enumerable: true,
        get: function get() {
          return _dependenciesBohrMagnetonGenerated.bohrMagnetonDependencies;
        }
      });
      Object.defineProperty(exports, "bohrRadiusDependencies", {
        enumerable: true,
        get: function get() {
          return _dependenciesBohrRadiusGenerated.bohrRadiusDependencies;
        }
      });
      Object.defineProperty(exports, "boltzmannDependencies", {
        enumerable: true,
        get: function get() {
          return _dependenciesBoltzmannGenerated.boltzmannDependencies;
        }
      });
      Object.defineProperty(exports, "booleanDependencies", {
        enumerable: true,
        get: function get() {
          return _dependenciesBooleanGenerated.booleanDependencies;
        }
      });
      Object.defineProperty(exports, "catalanDependencies", {
        enumerable: true,
        get: function get() {
          return _dependenciesCatalanGenerated.catalanDependencies;
        }
      });
      Object.defineProperty(exports, "cbrtDependencies", {
        enumerable: true,
        get: function get() {
          return _dependenciesCbrtGenerated.cbrtDependencies;
        }
      });
      Object.defineProperty(exports, "ceilDependencies", {
        enumerable: true,
        get: function get() {
          return _dependenciesCeilGenerated.ceilDependencies;
        }
      });
      Object.defineProperty(exports, "chainDependencies", {
        enumerable: true,
        get: function get() {
          return _dependenciesChainGenerated.chainDependencies;
        }
      });
      Object.defineProperty(exports, "classicalElectronRadiusDependencies", {
        enumerable: true,
        get: function get() {
          return _dependenciesClassicalElectronRadiusGenerated.classicalElectronRadiusDependencies;
        }
      });
      Object.defineProperty(exports, "cloneDependencies", {
        enumerable: true,
        get: function get() {
          return _dependenciesCloneGenerated.cloneDependencies;
        }
      });
      Object.defineProperty(exports, "columnDependencies", {
        enumerable: true,
        get: function get() {
          return _dependenciesColumnGenerated.columnDependencies;
        }
      });
      Object.defineProperty(exports, "columnTransformDependencies", {
        enumerable: true,
        get: function get() {
          return _dependenciesColumnTransformGenerated.columnTransformDependencies;
        }
      });
      Object.defineProperty(exports, "combinationsDependencies", {
        enumerable: true,
        get: function get() {
          return _dependenciesCombinationsGenerated.combinationsDependencies;
        }
      });
      Object.defineProperty(exports, "combinationsWithRepDependencies", {
        enumerable: true,
        get: function get() {
          return _dependenciesCombinationsWithRepGenerated.combinationsWithRepDependencies;
        }
      });
      Object.defineProperty(exports, "compareDependencies", {
        enumerable: true,
        get: function get() {
          return _dependenciesCompareGenerated.compareDependencies;
        }
      });
      Object.defineProperty(exports, "compareNaturalDependencies", {
        enumerable: true,
        get: function get() {
          return _dependenciesCompareNaturalGenerated.compareNaturalDependencies;
        }
      });
      Object.defineProperty(exports, "compareTextDependencies", {
        enumerable: true,
        get: function get() {
          return _dependenciesCompareTextGenerated.compareTextDependencies;
        }
      });
      Object.defineProperty(exports, "compileDependencies", {
        enumerable: true,
        get: function get() {
          return _dependenciesCompileGenerated.compileDependencies;
        }
      });
      Object.defineProperty(exports, "complexDependencies", {
        enumerable: true,
        get: function get() {
          return _dependenciesComplexGenerated.complexDependencies;
        }
      });
      Object.defineProperty(exports, "compositionDependencies", {
        enumerable: true,
        get: function get() {
          return _dependenciesCompositionGenerated.compositionDependencies;
        }
      });
      Object.defineProperty(exports, "concatDependencies", {
        enumerable: true,
        get: function get() {
          return _dependenciesConcatGenerated.concatDependencies;
        }
      });
      Object.defineProperty(exports, "concatTransformDependencies", {
        enumerable: true,
        get: function get() {
          return _dependenciesConcatTransformGenerated.concatTransformDependencies;
        }
      });
      Object.defineProperty(exports, "conductanceQuantumDependencies", {
        enumerable: true,
        get: function get() {
          return _dependenciesConductanceQuantumGenerated.conductanceQuantumDependencies;
        }
      });
      Object.defineProperty(exports, "conjDependencies", {
        enumerable: true,
        get: function get() {
          return _dependenciesConjGenerated.conjDependencies;
        }
      });
      Object.defineProperty(exports, "corrDependencies", {
        enumerable: true,
        get: function get() {
          return _dependenciesCorrGenerated.corrDependencies;
        }
      });
      Object.defineProperty(exports, "cosDependencies", {
        enumerable: true,
        get: function get() {
          return _dependenciesCosGenerated.cosDependencies;
        }
      });
      Object.defineProperty(exports, "coshDependencies", {
        enumerable: true,
        get: function get() {
          return _dependenciesCoshGenerated.coshDependencies;
        }
      });
      Object.defineProperty(exports, "cotDependencies", {
        enumerable: true,
        get: function get() {
          return _dependenciesCotGenerated.cotDependencies;
        }
      });
      Object.defineProperty(exports, "cothDependencies", {
        enumerable: true,
        get: function get() {
          return _dependenciesCothGenerated.cothDependencies;
        }
      });
      Object.defineProperty(exports, "coulombDependencies", {
        enumerable: true,
        get: function get() {
          return _dependenciesCoulombGenerated.coulombDependencies;
        }
      });
      Object.defineProperty(exports, "countDependencies", {
        enumerable: true,
        get: function get() {
          return _dependenciesCountGenerated.countDependencies;
        }
      });
      Object.defineProperty(exports, "createUnitDependencies", {
        enumerable: true,
        get: function get() {
          return _dependenciesCreateUnitGenerated.createUnitDependencies;
        }
      });
      Object.defineProperty(exports, "crossDependencies", {
        enumerable: true,
        get: function get() {
          return _dependenciesCrossGenerated.crossDependencies;
        }
      });
      Object.defineProperty(exports, "cscDependencies", {
        enumerable: true,
        get: function get() {
          return _dependenciesCscGenerated.cscDependencies;
        }
      });
      Object.defineProperty(exports, "cschDependencies", {
        enumerable: true,
        get: function get() {
          return _dependenciesCschGenerated.cschDependencies;
        }
      });
      Object.defineProperty(exports, "ctransposeDependencies", {
        enumerable: true,
        get: function get() {
          return _dependenciesCtransposeGenerated.ctransposeDependencies;
        }
      });
      Object.defineProperty(exports, "cubeDependencies", {
        enumerable: true,
        get: function get() {
          return _dependenciesCubeGenerated.cubeDependencies;
        }
      });
      Object.defineProperty(exports, "cumsumDependencies", {
        enumerable: true,
        get: function get() {
          return _dependenciesCumSumGenerated.cumsumDependencies;
        }
      });
      Object.defineProperty(exports, "cumsumTransformDependencies", {
        enumerable: true,
        get: function get() {
          return _dependenciesCumSumTransformGenerated.cumsumTransformDependencies;
        }
      });
      Object.defineProperty(exports, "deepEqualDependencies", {
        enumerable: true,
        get: function get() {
          return _dependenciesDeepEqualGenerated.deepEqualDependencies;
        }
      });
      Object.defineProperty(exports, "derivativeDependencies", {
        enumerable: true,
        get: function get() {
          return _dependenciesDerivativeGenerated.derivativeDependencies;
        }
      });
      Object.defineProperty(exports, "detDependencies", {
        enumerable: true,
        get: function get() {
          return _dependenciesDetGenerated.detDependencies;
        }
      });
      Object.defineProperty(exports, "deuteronMassDependencies", {
        enumerable: true,
        get: function get() {
          return _dependenciesDeuteronMassGenerated.deuteronMassDependencies;
        }
      });
      Object.defineProperty(exports, "diagDependencies", {
        enumerable: true,
        get: function get() {
          return _dependenciesDiagGenerated.diagDependencies;
        }
      });
      Object.defineProperty(exports, "diffDependencies", {
        enumerable: true,
        get: function get() {
          return _dependenciesDiffGenerated.diffDependencies;
        }
      });
      Object.defineProperty(exports, "diffTransformDependencies", {
        enumerable: true,
        get: function get() {
          return _dependenciesDiffTransformGenerated.diffTransformDependencies;
        }
      });
      Object.defineProperty(exports, "distanceDependencies", {
        enumerable: true,
        get: function get() {
          return _dependenciesDistanceGenerated.distanceDependencies;
        }
      });
      Object.defineProperty(exports, "divideDependencies", {
        enumerable: true,
        get: function get() {
          return _dependenciesDivideGenerated.divideDependencies;
        }
      });
      Object.defineProperty(exports, "divideScalarDependencies", {
        enumerable: true,
        get: function get() {
          return _dependenciesDivideScalarGenerated.divideScalarDependencies;
        }
      });
      Object.defineProperty(exports, "dotDependencies", {
        enumerable: true,
        get: function get() {
          return _dependenciesDotGenerated.dotDependencies;
        }
      });
      Object.defineProperty(exports, "dotDivideDependencies", {
        enumerable: true,
        get: function get() {
          return _dependenciesDotDivideGenerated.dotDivideDependencies;
        }
      });
      Object.defineProperty(exports, "dotMultiplyDependencies", {
        enumerable: true,
        get: function get() {
          return _dependenciesDotMultiplyGenerated.dotMultiplyDependencies;
        }
      });
      Object.defineProperty(exports, "dotPowDependencies", {
        enumerable: true,
        get: function get() {
          return _dependenciesDotPowGenerated.dotPowDependencies;
        }
      });
      Object.defineProperty(exports, "eDependencies", {
        enumerable: true,
        get: function get() {
          return _dependenciesEGenerated.eDependencies;
        }
      });
      Object.defineProperty(exports, "efimovFactorDependencies", {
        enumerable: true,
        get: function get() {
          return _dependenciesEfimovFactorGenerated.efimovFactorDependencies;
        }
      });
      Object.defineProperty(exports, "eigsDependencies", {
        enumerable: true,
        get: function get() {
          return _dependenciesEigsGenerated.eigsDependencies;
        }
      });
      Object.defineProperty(exports, "electricConstantDependencies", {
        enumerable: true,
        get: function get() {
          return _dependenciesElectricConstantGenerated.electricConstantDependencies;
        }
      });
      Object.defineProperty(exports, "electronMassDependencies", {
        enumerable: true,
        get: function get() {
          return _dependenciesElectronMassGenerated.electronMassDependencies;
        }
      });
      Object.defineProperty(exports, "elementaryChargeDependencies", {
        enumerable: true,
        get: function get() {
          return _dependenciesElementaryChargeGenerated.elementaryChargeDependencies;
        }
      });
      Object.defineProperty(exports, "equalDependencies", {
        enumerable: true,
        get: function get() {
          return _dependenciesEqualGenerated.equalDependencies;
        }
      });
      Object.defineProperty(exports, "equalScalarDependencies", {
        enumerable: true,
        get: function get() {
          return _dependenciesEqualScalarGenerated.equalScalarDependencies;
        }
      });
      Object.defineProperty(exports, "equalTextDependencies", {
        enumerable: true,
        get: function get() {
          return _dependenciesEqualTextGenerated.equalTextDependencies;
        }
      });
      Object.defineProperty(exports, "erfDependencies", {
        enumerable: true,
        get: function get() {
          return _dependenciesErfGenerated.erfDependencies;
        }
      });
      Object.defineProperty(exports, "evaluateDependencies", {
        enumerable: true,
        get: function get() {
          return _dependenciesEvaluateGenerated.evaluateDependencies;
        }
      });
      Object.defineProperty(exports, "expDependencies", {
        enumerable: true,
        get: function get() {
          return _dependenciesExpGenerated.expDependencies;
        }
      });
      Object.defineProperty(exports, "expm1Dependencies", {
        enumerable: true,
        get: function get() {
          return _dependenciesExpm1Generated.expm1Dependencies;
        }
      });
      Object.defineProperty(exports, "expmDependencies", {
        enumerable: true,
        get: function get() {
          return _dependenciesExpmGenerated.expmDependencies;
        }
      });
      Object.defineProperty(exports, "factorialDependencies", {
        enumerable: true,
        get: function get() {
          return _dependenciesFactorialGenerated.factorialDependencies;
        }
      });
      Object.defineProperty(exports, "falseDependencies", {
        enumerable: true,
        get: function get() {
          return _dependenciesFalseGenerated.falseDependencies;
        }
      });
      Object.defineProperty(exports, "faradayDependencies", {
        enumerable: true,
        get: function get() {
          return _dependenciesFaradayGenerated.faradayDependencies;
        }
      });
      Object.defineProperty(exports, "fermiCouplingDependencies", {
        enumerable: true,
        get: function get() {
          return _dependenciesFermiCouplingGenerated.fermiCouplingDependencies;
        }
      });
      Object.defineProperty(exports, "fftDependencies", {
        enumerable: true,
        get: function get() {
          return _dependenciesFftGenerated.fftDependencies;
        }
      });
      Object.defineProperty(exports, "filterDependencies", {
        enumerable: true,
        get: function get() {
          return _dependenciesFilterGenerated.filterDependencies;
        }
      });
      Object.defineProperty(exports, "filterTransformDependencies", {
        enumerable: true,
        get: function get() {
          return _dependenciesFilterTransformGenerated.filterTransformDependencies;
        }
      });
      Object.defineProperty(exports, "fineStructureDependencies", {
        enumerable: true,
        get: function get() {
          return _dependenciesFineStructureGenerated.fineStructureDependencies;
        }
      });
      Object.defineProperty(exports, "firstRadiationDependencies", {
        enumerable: true,
        get: function get() {
          return _dependenciesFirstRadiationGenerated.firstRadiationDependencies;
        }
      });
      Object.defineProperty(exports, "fixDependencies", {
        enumerable: true,
        get: function get() {
          return _dependenciesFixGenerated.fixDependencies;
        }
      });
      Object.defineProperty(exports, "flattenDependencies", {
        enumerable: true,
        get: function get() {
          return _dependenciesFlattenGenerated.flattenDependencies;
        }
      });
      Object.defineProperty(exports, "floorDependencies", {
        enumerable: true,
        get: function get() {
          return _dependenciesFloorGenerated.floorDependencies;
        }
      });
      Object.defineProperty(exports, "forEachDependencies", {
        enumerable: true,
        get: function get() {
          return _dependenciesForEachGenerated.forEachDependencies;
        }
      });
      Object.defineProperty(exports, "forEachTransformDependencies", {
        enumerable: true,
        get: function get() {
          return _dependenciesForEachTransformGenerated.forEachTransformDependencies;
        }
      });
      Object.defineProperty(exports, "formatDependencies", {
        enumerable: true,
        get: function get() {
          return _dependenciesFormatGenerated.formatDependencies;
        }
      });
      Object.defineProperty(exports, "fractionDependencies", {
        enumerable: true,
        get: function get() {
          return _dependenciesFractionGenerated.fractionDependencies;
        }
      });
      Object.defineProperty(exports, "freqzDependencies", {
        enumerable: true,
        get: function get() {
          return _dependenciesFreqzGenerated.freqzDependencies;
        }
      });
      Object.defineProperty(exports, "gammaDependencies", {
        enumerable: true,
        get: function get() {
          return _dependenciesGammaGenerated.gammaDependencies;
        }
      });
      Object.defineProperty(exports, "gasConstantDependencies", {
        enumerable: true,
        get: function get() {
          return _dependenciesGasConstantGenerated.gasConstantDependencies;
        }
      });
      Object.defineProperty(exports, "gcdDependencies", {
        enumerable: true,
        get: function get() {
          return _dependenciesGcdGenerated.gcdDependencies;
        }
      });
      Object.defineProperty(exports, "getMatrixDataTypeDependencies", {
        enumerable: true,
        get: function get() {
          return _dependenciesGetMatrixDataTypeGenerated.getMatrixDataTypeDependencies;
        }
      });
      Object.defineProperty(exports, "gravitationConstantDependencies", {
        enumerable: true,
        get: function get() {
          return _dependenciesGravitationConstantGenerated.gravitationConstantDependencies;
        }
      });
      Object.defineProperty(exports, "gravityDependencies", {
        enumerable: true,
        get: function get() {
          return _dependenciesGravityGenerated.gravityDependencies;
        }
      });
      Object.defineProperty(exports, "hartreeEnergyDependencies", {
        enumerable: true,
        get: function get() {
          return _dependenciesHartreeEnergyGenerated.hartreeEnergyDependencies;
        }
      });
      Object.defineProperty(exports, "hasNumericValueDependencies", {
        enumerable: true,
        get: function get() {
          return _dependenciesHasNumericValueGenerated.hasNumericValueDependencies;
        }
      });
      Object.defineProperty(exports, "helpDependencies", {
        enumerable: true,
        get: function get() {
          return _dependenciesHelpGenerated.helpDependencies;
        }
      });
      Object.defineProperty(exports, "hexDependencies", {
        enumerable: true,
        get: function get() {
          return _dependenciesHexGenerated.hexDependencies;
        }
      });
      Object.defineProperty(exports, "hypotDependencies", {
        enumerable: true,
        get: function get() {
          return _dependenciesHypotGenerated.hypotDependencies;
        }
      });
      Object.defineProperty(exports, "iDependencies", {
        enumerable: true,
        get: function get() {
          return _dependenciesIGenerated.iDependencies;
        }
      });
      Object.defineProperty(exports, "identityDependencies", {
        enumerable: true,
        get: function get() {
          return _dependenciesIdentityGenerated.identityDependencies;
        }
      });
      Object.defineProperty(exports, "ifftDependencies", {
        enumerable: true,
        get: function get() {
          return _dependenciesIfftGenerated.ifftDependencies;
        }
      });
      Object.defineProperty(exports, "imDependencies", {
        enumerable: true,
        get: function get() {
          return _dependenciesImGenerated.imDependencies;
        }
      });
      Object.defineProperty(exports, "indexDependencies", {
        enumerable: true,
        get: function get() {
          return _dependenciesIndexGenerated.indexDependencies;
        }
      });
      Object.defineProperty(exports, "indexTransformDependencies", {
        enumerable: true,
        get: function get() {
          return _dependenciesIndexTransformGenerated.indexTransformDependencies;
        }
      });
      Object.defineProperty(exports, "intersectDependencies", {
        enumerable: true,
        get: function get() {
          return _dependenciesIntersectGenerated.intersectDependencies;
        }
      });
      Object.defineProperty(exports, "invDependencies", {
        enumerable: true,
        get: function get() {
          return _dependenciesInvGenerated.invDependencies;
        }
      });
      Object.defineProperty(exports, "inverseConductanceQuantumDependencies", {
        enumerable: true,
        get: function get() {
          return _dependenciesInverseConductanceQuantumGenerated.inverseConductanceQuantumDependencies;
        }
      });
      Object.defineProperty(exports, "invmodDependencies", {
        enumerable: true,
        get: function get() {
          return _dependenciesInvmodGenerated.invmodDependencies;
        }
      });
      Object.defineProperty(exports, "isIntegerDependencies", {
        enumerable: true,
        get: function get() {
          return _dependenciesIsIntegerGenerated.isIntegerDependencies;
        }
      });
      Object.defineProperty(exports, "isNaNDependencies", {
        enumerable: true,
        get: function get() {
          return _dependenciesIsNaNGenerated.isNaNDependencies;
        }
      });
      Object.defineProperty(exports, "isNegativeDependencies", {
        enumerable: true,
        get: function get() {
          return _dependenciesIsNegativeGenerated.isNegativeDependencies;
        }
      });
      Object.defineProperty(exports, "isNumericDependencies", {
        enumerable: true,
        get: function get() {
          return _dependenciesIsNumericGenerated.isNumericDependencies;
        }
      });
      Object.defineProperty(exports, "isPositiveDependencies", {
        enumerable: true,
        get: function get() {
          return _dependenciesIsPositiveGenerated.isPositiveDependencies;
        }
      });
      Object.defineProperty(exports, "isPrimeDependencies", {
        enumerable: true,
        get: function get() {
          return _dependenciesIsPrimeGenerated.isPrimeDependencies;
        }
      });
      Object.defineProperty(exports, "isZeroDependencies", {
        enumerable: true,
        get: function get() {
          return _dependenciesIsZeroGenerated.isZeroDependencies;
        }
      });
      Object.defineProperty(exports, "kldivergenceDependencies", {
        enumerable: true,
        get: function get() {
          return _dependenciesKldivergenceGenerated.kldivergenceDependencies;
        }
      });
      Object.defineProperty(exports, "klitzingDependencies", {
        enumerable: true,
        get: function get() {
          return _dependenciesKlitzingGenerated.klitzingDependencies;
        }
      });
      Object.defineProperty(exports, "kronDependencies", {
        enumerable: true,
        get: function get() {
          return _dependenciesKronGenerated.kronDependencies;
        }
      });
      Object.defineProperty(exports, "largerDependencies", {
        enumerable: true,
        get: function get() {
          return _dependenciesLargerGenerated.largerDependencies;
        }
      });
      Object.defineProperty(exports, "largerEqDependencies", {
        enumerable: true,
        get: function get() {
          return _dependenciesLargerEqGenerated.largerEqDependencies;
        }
      });
      Object.defineProperty(exports, "lcmDependencies", {
        enumerable: true,
        get: function get() {
          return _dependenciesLcmGenerated.lcmDependencies;
        }
      });
      Object.defineProperty(exports, "leafCountDependencies", {
        enumerable: true,
        get: function get() {
          return _dependenciesLeafCountGenerated.leafCountDependencies;
        }
      });
      Object.defineProperty(exports, "leftShiftDependencies", {
        enumerable: true,
        get: function get() {
          return _dependenciesLeftShiftGenerated.leftShiftDependencies;
        }
      });
      Object.defineProperty(exports, "lgammaDependencies", {
        enumerable: true,
        get: function get() {
          return _dependenciesLgammaGenerated.lgammaDependencies;
        }
      });
      Object.defineProperty(exports, "log10Dependencies", {
        enumerable: true,
        get: function get() {
          return _dependenciesLog10Generated.log10Dependencies;
        }
      });
      Object.defineProperty(exports, "log1pDependencies", {
        enumerable: true,
        get: function get() {
          return _dependenciesLog1pGenerated.log1pDependencies;
        }
      });
      Object.defineProperty(exports, "log2Dependencies", {
        enumerable: true,
        get: function get() {
          return _dependenciesLog2Generated.log2Dependencies;
        }
      });
      Object.defineProperty(exports, "logDependencies", {
        enumerable: true,
        get: function get() {
          return _dependenciesLogGenerated.logDependencies;
        }
      });
      Object.defineProperty(exports, "loschmidtDependencies", {
        enumerable: true,
        get: function get() {
          return _dependenciesLoschmidtGenerated.loschmidtDependencies;
        }
      });
      Object.defineProperty(exports, "lsolveAllDependencies", {
        enumerable: true,
        get: function get() {
          return _dependenciesLsolveAllGenerated.lsolveAllDependencies;
        }
      });
      Object.defineProperty(exports, "lsolveDependencies", {
        enumerable: true,
        get: function get() {
          return _dependenciesLsolveGenerated.lsolveDependencies;
        }
      });
      Object.defineProperty(exports, "lupDependencies", {
        enumerable: true,
        get: function get() {
          return _dependenciesLupGenerated.lupDependencies;
        }
      });
      Object.defineProperty(exports, "lusolveDependencies", {
        enumerable: true,
        get: function get() {
          return _dependenciesLusolveGenerated.lusolveDependencies;
        }
      });
      Object.defineProperty(exports, "lyapDependencies", {
        enumerable: true,
        get: function get() {
          return _dependenciesLyapGenerated.lyapDependencies;
        }
      });
      Object.defineProperty(exports, "madDependencies", {
        enumerable: true,
        get: function get() {
          return _dependenciesMadGenerated.madDependencies;
        }
      });
      Object.defineProperty(exports, "magneticConstantDependencies", {
        enumerable: true,
        get: function get() {
          return _dependenciesMagneticConstantGenerated.magneticConstantDependencies;
        }
      });
      Object.defineProperty(exports, "magneticFluxQuantumDependencies", {
        enumerable: true,
        get: function get() {
          return _dependenciesMagneticFluxQuantumGenerated.magneticFluxQuantumDependencies;
        }
      });
      Object.defineProperty(exports, "mapDependencies", {
        enumerable: true,
        get: function get() {
          return _dependenciesMapGenerated.mapDependencies;
        }
      });
      Object.defineProperty(exports, "mapTransformDependencies", {
        enumerable: true,
        get: function get() {
          return _dependenciesMapTransformGenerated.mapTransformDependencies;
        }
      });
      Object.defineProperty(exports, "matrixDependencies", {
        enumerable: true,
        get: function get() {
          return _dependenciesMatrixGenerated.matrixDependencies;
        }
      });
      Object.defineProperty(exports, "matrixFromColumnsDependencies", {
        enumerable: true,
        get: function get() {
          return _dependenciesMatrixFromColumnsGenerated.matrixFromColumnsDependencies;
        }
      });
      Object.defineProperty(exports, "matrixFromFunctionDependencies", {
        enumerable: true,
        get: function get() {
          return _dependenciesMatrixFromFunctionGenerated.matrixFromFunctionDependencies;
        }
      });
      Object.defineProperty(exports, "matrixFromRowsDependencies", {
        enumerable: true,
        get: function get() {
          return _dependenciesMatrixFromRowsGenerated.matrixFromRowsDependencies;
        }
      });
      Object.defineProperty(exports, "maxDependencies", {
        enumerable: true,
        get: function get() {
          return _dependenciesMaxGenerated.maxDependencies;
        }
      });
      Object.defineProperty(exports, "maxTransformDependencies", {
        enumerable: true,
        get: function get() {
          return _dependenciesMaxTransformGenerated.maxTransformDependencies;
        }
      });
      Object.defineProperty(exports, "meanDependencies", {
        enumerable: true,
        get: function get() {
          return _dependenciesMeanGenerated.meanDependencies;
        }
      });
      Object.defineProperty(exports, "meanTransformDependencies", {
        enumerable: true,
        get: function get() {
          return _dependenciesMeanTransformGenerated.meanTransformDependencies;
        }
      });
      Object.defineProperty(exports, "medianDependencies", {
        enumerable: true,
        get: function get() {
          return _dependenciesMedianGenerated.medianDependencies;
        }
      });
      Object.defineProperty(exports, "minDependencies", {
        enumerable: true,
        get: function get() {
          return _dependenciesMinGenerated.minDependencies;
        }
      });
      Object.defineProperty(exports, "minTransformDependencies", {
        enumerable: true,
        get: function get() {
          return _dependenciesMinTransformGenerated.minTransformDependencies;
        }
      });
      Object.defineProperty(exports, "modDependencies", {
        enumerable: true,
        get: function get() {
          return _dependenciesModGenerated.modDependencies;
        }
      });
      Object.defineProperty(exports, "modeDependencies", {
        enumerable: true,
        get: function get() {
          return _dependenciesModeGenerated.modeDependencies;
        }
      });
      Object.defineProperty(exports, "molarMassC12Dependencies", {
        enumerable: true,
        get: function get() {
          return _dependenciesMolarMassC12Generated.molarMassC12Dependencies;
        }
      });
      Object.defineProperty(exports, "molarMassDependencies", {
        enumerable: true,
        get: function get() {
          return _dependenciesMolarMassGenerated.molarMassDependencies;
        }
      });
      Object.defineProperty(exports, "molarPlanckConstantDependencies", {
        enumerable: true,
        get: function get() {
          return _dependenciesMolarPlanckConstantGenerated.molarPlanckConstantDependencies;
        }
      });
      Object.defineProperty(exports, "molarVolumeDependencies", {
        enumerable: true,
        get: function get() {
          return _dependenciesMolarVolumeGenerated.molarVolumeDependencies;
        }
      });
      Object.defineProperty(exports, "multinomialDependencies", {
        enumerable: true,
        get: function get() {
          return _dependenciesMultinomialGenerated.multinomialDependencies;
        }
      });
      Object.defineProperty(exports, "multiplyDependencies", {
        enumerable: true,
        get: function get() {
          return _dependenciesMultiplyGenerated.multiplyDependencies;
        }
      });
      Object.defineProperty(exports, "multiplyScalarDependencies", {
        enumerable: true,
        get: function get() {
          return _dependenciesMultiplyScalarGenerated.multiplyScalarDependencies;
        }
      });
      Object.defineProperty(exports, "neutronMassDependencies", {
        enumerable: true,
        get: function get() {
          return _dependenciesNeutronMassGenerated.neutronMassDependencies;
        }
      });
      Object.defineProperty(exports, "normDependencies", {
        enumerable: true,
        get: function get() {
          return _dependenciesNormGenerated.normDependencies;
        }
      });
      Object.defineProperty(exports, "notDependencies", {
        enumerable: true,
        get: function get() {
          return _dependenciesNotGenerated.notDependencies;
        }
      });
      Object.defineProperty(exports, "nthRootDependencies", {
        enumerable: true,
        get: function get() {
          return _dependenciesNthRootGenerated.nthRootDependencies;
        }
      });
      Object.defineProperty(exports, "nthRootsDependencies", {
        enumerable: true,
        get: function get() {
          return _dependenciesNthRootsGenerated.nthRootsDependencies;
        }
      });
      Object.defineProperty(exports, "nuclearMagnetonDependencies", {
        enumerable: true,
        get: function get() {
          return _dependenciesNuclearMagnetonGenerated.nuclearMagnetonDependencies;
        }
      });
      Object.defineProperty(exports, "nullDependencies", {
        enumerable: true,
        get: function get() {
          return _dependenciesNullGenerated.nullDependencies;
        }
      });
      Object.defineProperty(exports, "numberDependencies", {
        enumerable: true,
        get: function get() {
          return _dependenciesNumberGenerated.numberDependencies;
        }
      });
      Object.defineProperty(exports, "numericDependencies", {
        enumerable: true,
        get: function get() {
          return _dependenciesNumericGenerated.numericDependencies;
        }
      });
      Object.defineProperty(exports, "octDependencies", {
        enumerable: true,
        get: function get() {
          return _dependenciesOctGenerated.octDependencies;
        }
      });
      Object.defineProperty(exports, "onesDependencies", {
        enumerable: true,
        get: function get() {
          return _dependenciesOnesGenerated.onesDependencies;
        }
      });
      Object.defineProperty(exports, "orDependencies", {
        enumerable: true,
        get: function get() {
          return _dependenciesOrGenerated.orDependencies;
        }
      });
      Object.defineProperty(exports, "orTransformDependencies", {
        enumerable: true,
        get: function get() {
          return _dependenciesOrTransformGenerated.orTransformDependencies;
        }
      });
      Object.defineProperty(exports, "parseDependencies", {
        enumerable: true,
        get: function get() {
          return _dependenciesParseGenerated.parseDependencies;
        }
      });
      Object.defineProperty(exports, "parserDependencies", {
        enumerable: true,
        get: function get() {
          return _dependenciesParserGenerated.parserDependencies;
        }
      });
      Object.defineProperty(exports, "partitionSelectDependencies", {
        enumerable: true,
        get: function get() {
          return _dependenciesPartitionSelectGenerated.partitionSelectDependencies;
        }
      });
      Object.defineProperty(exports, "permutationsDependencies", {
        enumerable: true,
        get: function get() {
          return _dependenciesPermutationsGenerated.permutationsDependencies;
        }
      });
      Object.defineProperty(exports, "phiDependencies", {
        enumerable: true,
        get: function get() {
          return _dependenciesPhiGenerated.phiDependencies;
        }
      });
      Object.defineProperty(exports, "piDependencies", {
        enumerable: true,
        get: function get() {
          return _dependenciesPiGenerated.piDependencies;
        }
      });
      Object.defineProperty(exports, "pickRandomDependencies", {
        enumerable: true,
        get: function get() {
          return _dependenciesPickRandomGenerated.pickRandomDependencies;
        }
      });
      Object.defineProperty(exports, "pinvDependencies", {
        enumerable: true,
        get: function get() {
          return _dependenciesPinvGenerated.pinvDependencies;
        }
      });
      Object.defineProperty(exports, "planckChargeDependencies", {
        enumerable: true,
        get: function get() {
          return _dependenciesPlanckChargeGenerated.planckChargeDependencies;
        }
      });
      Object.defineProperty(exports, "planckConstantDependencies", {
        enumerable: true,
        get: function get() {
          return _dependenciesPlanckConstantGenerated.planckConstantDependencies;
        }
      });
      Object.defineProperty(exports, "planckLengthDependencies", {
        enumerable: true,
        get: function get() {
          return _dependenciesPlanckLengthGenerated.planckLengthDependencies;
        }
      });
      Object.defineProperty(exports, "planckMassDependencies", {
        enumerable: true,
        get: function get() {
          return _dependenciesPlanckMassGenerated.planckMassDependencies;
        }
      });
      Object.defineProperty(exports, "planckTemperatureDependencies", {
        enumerable: true,
        get: function get() {
          return _dependenciesPlanckTemperatureGenerated.planckTemperatureDependencies;
        }
      });
      Object.defineProperty(exports, "planckTimeDependencies", {
        enumerable: true,
        get: function get() {
          return _dependenciesPlanckTimeGenerated.planckTimeDependencies;
        }
      });
      Object.defineProperty(exports, "polynomialRootDependencies", {
        enumerable: true,
        get: function get() {
          return _dependenciesPolynomialRootGenerated.polynomialRootDependencies;
        }
      });
      Object.defineProperty(exports, "powDependencies", {
        enumerable: true,
        get: function get() {
          return _dependenciesPowGenerated.powDependencies;
        }
      });
      Object.defineProperty(exports, "printDependencies", {
        enumerable: true,
        get: function get() {
          return _dependenciesPrintGenerated.printDependencies;
        }
      });
      Object.defineProperty(exports, "printTransformDependencies", {
        enumerable: true,
        get: function get() {
          return _dependenciesPrintTransformGenerated.printTransformDependencies;
        }
      });
      Object.defineProperty(exports, "prodDependencies", {
        enumerable: true,
        get: function get() {
          return _dependenciesProdGenerated.prodDependencies;
        }
      });
      Object.defineProperty(exports, "protonMassDependencies", {
        enumerable: true,
        get: function get() {
          return _dependenciesProtonMassGenerated.protonMassDependencies;
        }
      });
      Object.defineProperty(exports, "qrDependencies", {
        enumerable: true,
        get: function get() {
          return _dependenciesQrGenerated.qrDependencies;
        }
      });
      Object.defineProperty(exports, "quantileSeqDependencies", {
        enumerable: true,
        get: function get() {
          return _dependenciesQuantileSeqGenerated.quantileSeqDependencies;
        }
      });
      Object.defineProperty(exports, "quantileSeqTransformDependencies", {
        enumerable: true,
        get: function get() {
          return _dependenciesQuantileSeqTransformGenerated.quantileSeqTransformDependencies;
        }
      });
      Object.defineProperty(exports, "quantumOfCirculationDependencies", {
        enumerable: true,
        get: function get() {
          return _dependenciesQuantumOfCirculationGenerated.quantumOfCirculationDependencies;
        }
      });
      Object.defineProperty(exports, "randomDependencies", {
        enumerable: true,
        get: function get() {
          return _dependenciesRandomGenerated.randomDependencies;
        }
      });
      Object.defineProperty(exports, "randomIntDependencies", {
        enumerable: true,
        get: function get() {
          return _dependenciesRandomIntGenerated.randomIntDependencies;
        }
      });
      Object.defineProperty(exports, "rangeDependencies", {
        enumerable: true,
        get: function get() {
          return _dependenciesRangeGenerated.rangeDependencies;
        }
      });
      Object.defineProperty(exports, "rangeTransformDependencies", {
        enumerable: true,
        get: function get() {
          return _dependenciesRangeTransformGenerated.rangeTransformDependencies;
        }
      });
      Object.defineProperty(exports, "rationalizeDependencies", {
        enumerable: true,
        get: function get() {
          return _dependenciesRationalizeGenerated.rationalizeDependencies;
        }
      });
      Object.defineProperty(exports, "reDependencies", {
        enumerable: true,
        get: function get() {
          return _dependenciesReGenerated.reDependencies;
        }
      });
      Object.defineProperty(exports, "reducedPlanckConstantDependencies", {
        enumerable: true,
        get: function get() {
          return _dependenciesReducedPlanckConstantGenerated.reducedPlanckConstantDependencies;
        }
      });
      Object.defineProperty(exports, "replacerDependencies", {
        enumerable: true,
        get: function get() {
          return _dependenciesReplacerGenerated.replacerDependencies;
        }
      });
      Object.defineProperty(exports, "reshapeDependencies", {
        enumerable: true,
        get: function get() {
          return _dependenciesReshapeGenerated.reshapeDependencies;
        }
      });
      Object.defineProperty(exports, "resizeDependencies", {
        enumerable: true,
        get: function get() {
          return _dependenciesResizeGenerated.resizeDependencies;
        }
      });
      Object.defineProperty(exports, "resolveDependencies", {
        enumerable: true,
        get: function get() {
          return _dependenciesResolveGenerated.resolveDependencies;
        }
      });
      Object.defineProperty(exports, "reviverDependencies", {
        enumerable: true,
        get: function get() {
          return _dependenciesReviverGenerated.reviverDependencies;
        }
      });
      Object.defineProperty(exports, "rightArithShiftDependencies", {
        enumerable: true,
        get: function get() {
          return _dependenciesRightArithShiftGenerated.rightArithShiftDependencies;
        }
      });
      Object.defineProperty(exports, "rightLogShiftDependencies", {
        enumerable: true,
        get: function get() {
          return _dependenciesRightLogShiftGenerated.rightLogShiftDependencies;
        }
      });
      Object.defineProperty(exports, "rotateDependencies", {
        enumerable: true,
        get: function get() {
          return _dependenciesRotateGenerated.rotateDependencies;
        }
      });
      Object.defineProperty(exports, "rotationMatrixDependencies", {
        enumerable: true,
        get: function get() {
          return _dependenciesRotationMatrixGenerated.rotationMatrixDependencies;
        }
      });
      Object.defineProperty(exports, "roundDependencies", {
        enumerable: true,
        get: function get() {
          return _dependenciesRoundGenerated.roundDependencies;
        }
      });
      Object.defineProperty(exports, "rowDependencies", {
        enumerable: true,
        get: function get() {
          return _dependenciesRowGenerated.rowDependencies;
        }
      });
      Object.defineProperty(exports, "rowTransformDependencies", {
        enumerable: true,
        get: function get() {
          return _dependenciesRowTransformGenerated.rowTransformDependencies;
        }
      });
      Object.defineProperty(exports, "rydbergDependencies", {
        enumerable: true,
        get: function get() {
          return _dependenciesRydbergGenerated.rydbergDependencies;
        }
      });
      Object.defineProperty(exports, "sackurTetrodeDependencies", {
        enumerable: true,
        get: function get() {
          return _dependenciesSackurTetrodeGenerated.sackurTetrodeDependencies;
        }
      });
      Object.defineProperty(exports, "schurDependencies", {
        enumerable: true,
        get: function get() {
          return _dependenciesSchurGenerated.schurDependencies;
        }
      });
      Object.defineProperty(exports, "secDependencies", {
        enumerable: true,
        get: function get() {
          return _dependenciesSecGenerated.secDependencies;
        }
      });
      Object.defineProperty(exports, "sechDependencies", {
        enumerable: true,
        get: function get() {
          return _dependenciesSechGenerated.sechDependencies;
        }
      });
      Object.defineProperty(exports, "secondRadiationDependencies", {
        enumerable: true,
        get: function get() {
          return _dependenciesSecondRadiationGenerated.secondRadiationDependencies;
        }
      });
      Object.defineProperty(exports, "setCartesianDependencies", {
        enumerable: true,
        get: function get() {
          return _dependenciesSetCartesianGenerated.setCartesianDependencies;
        }
      });
      Object.defineProperty(exports, "setDifferenceDependencies", {
        enumerable: true,
        get: function get() {
          return _dependenciesSetDifferenceGenerated.setDifferenceDependencies;
        }
      });
      Object.defineProperty(exports, "setDistinctDependencies", {
        enumerable: true,
        get: function get() {
          return _dependenciesSetDistinctGenerated.setDistinctDependencies;
        }
      });
      Object.defineProperty(exports, "setIntersectDependencies", {
        enumerable: true,
        get: function get() {
          return _dependenciesSetIntersectGenerated.setIntersectDependencies;
        }
      });
      Object.defineProperty(exports, "setIsSubsetDependencies", {
        enumerable: true,
        get: function get() {
          return _dependenciesSetIsSubsetGenerated.setIsSubsetDependencies;
        }
      });
      Object.defineProperty(exports, "setMultiplicityDependencies", {
        enumerable: true,
        get: function get() {
          return _dependenciesSetMultiplicityGenerated.setMultiplicityDependencies;
        }
      });
      Object.defineProperty(exports, "setPowersetDependencies", {
        enumerable: true,
        get: function get() {
          return _dependenciesSetPowersetGenerated.setPowersetDependencies;
        }
      });
      Object.defineProperty(exports, "setSizeDependencies", {
        enumerable: true,
        get: function get() {
          return _dependenciesSetSizeGenerated.setSizeDependencies;
        }
      });
      Object.defineProperty(exports, "setSymDifferenceDependencies", {
        enumerable: true,
        get: function get() {
          return _dependenciesSetSymDifferenceGenerated.setSymDifferenceDependencies;
        }
      });
      Object.defineProperty(exports, "setUnionDependencies", {
        enumerable: true,
        get: function get() {
          return _dependenciesSetUnionGenerated.setUnionDependencies;
        }
      });
      Object.defineProperty(exports, "signDependencies", {
        enumerable: true,
        get: function get() {
          return _dependenciesSignGenerated.signDependencies;
        }
      });
      Object.defineProperty(exports, "simplifyConstantDependencies", {
        enumerable: true,
        get: function get() {
          return _dependenciesSimplifyConstantGenerated.simplifyConstantDependencies;
        }
      });
      Object.defineProperty(exports, "simplifyCoreDependencies", {
        enumerable: true,
        get: function get() {
          return _dependenciesSimplifyCoreGenerated.simplifyCoreDependencies;
        }
      });
      Object.defineProperty(exports, "simplifyDependencies", {
        enumerable: true,
        get: function get() {
          return _dependenciesSimplifyGenerated.simplifyDependencies;
        }
      });
      Object.defineProperty(exports, "sinDependencies", {
        enumerable: true,
        get: function get() {
          return _dependenciesSinGenerated.sinDependencies;
        }
      });
      Object.defineProperty(exports, "sinhDependencies", {
        enumerable: true,
        get: function get() {
          return _dependenciesSinhGenerated.sinhDependencies;
        }
      });
      Object.defineProperty(exports, "sizeDependencies", {
        enumerable: true,
        get: function get() {
          return _dependenciesSizeGenerated.sizeDependencies;
        }
      });
      Object.defineProperty(exports, "sluDependencies", {
        enumerable: true,
        get: function get() {
          return _dependenciesSluGenerated.sluDependencies;
        }
      });
      Object.defineProperty(exports, "smallerDependencies", {
        enumerable: true,
        get: function get() {
          return _dependenciesSmallerGenerated.smallerDependencies;
        }
      });
      Object.defineProperty(exports, "smallerEqDependencies", {
        enumerable: true,
        get: function get() {
          return _dependenciesSmallerEqGenerated.smallerEqDependencies;
        }
      });
      Object.defineProperty(exports, "solveODEDependencies", {
        enumerable: true,
        get: function get() {
          return _dependenciesSolveODEGenerated.solveODEDependencies;
        }
      });
      Object.defineProperty(exports, "sortDependencies", {
        enumerable: true,
        get: function get() {
          return _dependenciesSortGenerated.sortDependencies;
        }
      });
      Object.defineProperty(exports, "sparseDependencies", {
        enumerable: true,
        get: function get() {
          return _dependenciesSparseGenerated.sparseDependencies;
        }
      });
      Object.defineProperty(exports, "speedOfLightDependencies", {
        enumerable: true,
        get: function get() {
          return _dependenciesSpeedOfLightGenerated.speedOfLightDependencies;
        }
      });
      Object.defineProperty(exports, "splitUnitDependencies", {
        enumerable: true,
        get: function get() {
          return _dependenciesSplitUnitGenerated.splitUnitDependencies;
        }
      });
      Object.defineProperty(exports, "sqrtDependencies", {
        enumerable: true,
        get: function get() {
          return _dependenciesSqrtGenerated.sqrtDependencies;
        }
      });
      Object.defineProperty(exports, "sqrtmDependencies", {
        enumerable: true,
        get: function get() {
          return _dependenciesSqrtmGenerated.sqrtmDependencies;
        }
      });
      Object.defineProperty(exports, "squareDependencies", {
        enumerable: true,
        get: function get() {
          return _dependenciesSquareGenerated.squareDependencies;
        }
      });
      Object.defineProperty(exports, "squeezeDependencies", {
        enumerable: true,
        get: function get() {
          return _dependenciesSqueezeGenerated.squeezeDependencies;
        }
      });
      Object.defineProperty(exports, "stdDependencies", {
        enumerable: true,
        get: function get() {
          return _dependenciesStdGenerated.stdDependencies;
        }
      });
      Object.defineProperty(exports, "stdTransformDependencies", {
        enumerable: true,
        get: function get() {
          return _dependenciesStdTransformGenerated.stdTransformDependencies;
        }
      });
      Object.defineProperty(exports, "stefanBoltzmannDependencies", {
        enumerable: true,
        get: function get() {
          return _dependenciesStefanBoltzmannGenerated.stefanBoltzmannDependencies;
        }
      });
      Object.defineProperty(exports, "stirlingS2Dependencies", {
        enumerable: true,
        get: function get() {
          return _dependenciesStirlingS2Generated.stirlingS2Dependencies;
        }
      });
      Object.defineProperty(exports, "stringDependencies", {
        enumerable: true,
        get: function get() {
          return _dependenciesStringGenerated.stringDependencies;
        }
      });
      Object.defineProperty(exports, "subsetDependencies", {
        enumerable: true,
        get: function get() {
          return _dependenciesSubsetGenerated.subsetDependencies;
        }
      });
      Object.defineProperty(exports, "subsetTransformDependencies", {
        enumerable: true,
        get: function get() {
          return _dependenciesSubsetTransformGenerated.subsetTransformDependencies;
        }
      });
      Object.defineProperty(exports, "subtractDependencies", {
        enumerable: true,
        get: function get() {
          return _dependenciesSubtractGenerated.subtractDependencies;
        }
      });
      Object.defineProperty(exports, "subtractScalarDependencies", {
        enumerable: true,
        get: function get() {
          return _dependenciesSubtractScalarGenerated.subtractScalarDependencies;
        }
      });
      Object.defineProperty(exports, "sumDependencies", {
        enumerable: true,
        get: function get() {
          return _dependenciesSumGenerated.sumDependencies;
        }
      });
      Object.defineProperty(exports, "sumTransformDependencies", {
        enumerable: true,
        get: function get() {
          return _dependenciesSumTransformGenerated.sumTransformDependencies;
        }
      });
      Object.defineProperty(exports, "sylvesterDependencies", {
        enumerable: true,
        get: function get() {
          return _dependenciesSylvesterGenerated.sylvesterDependencies;
        }
      });
      Object.defineProperty(exports, "symbolicEqualDependencies", {
        enumerable: true,
        get: function get() {
          return _dependenciesSymbolicEqualGenerated.symbolicEqualDependencies;
        }
      });
      Object.defineProperty(exports, "tanDependencies", {
        enumerable: true,
        get: function get() {
          return _dependenciesTanGenerated.tanDependencies;
        }
      });
      Object.defineProperty(exports, "tanhDependencies", {
        enumerable: true,
        get: function get() {
          return _dependenciesTanhGenerated.tanhDependencies;
        }
      });
      Object.defineProperty(exports, "tauDependencies", {
        enumerable: true,
        get: function get() {
          return _dependenciesTauGenerated.tauDependencies;
        }
      });
      Object.defineProperty(exports, "thomsonCrossSectionDependencies", {
        enumerable: true,
        get: function get() {
          return _dependenciesThomsonCrossSectionGenerated.thomsonCrossSectionDependencies;
        }
      });
      Object.defineProperty(exports, "toDependencies", {
        enumerable: true,
        get: function get() {
          return _dependenciesToGenerated.toDependencies;
        }
      });
      Object.defineProperty(exports, "traceDependencies", {
        enumerable: true,
        get: function get() {
          return _dependenciesTraceGenerated.traceDependencies;
        }
      });
      Object.defineProperty(exports, "transposeDependencies", {
        enumerable: true,
        get: function get() {
          return _dependenciesTransposeGenerated.transposeDependencies;
        }
      });
      Object.defineProperty(exports, "trueDependencies", {
        enumerable: true,
        get: function get() {
          return _dependenciesTrueGenerated.trueDependencies;
        }
      });
      Object.defineProperty(exports, "typeOfDependencies", {
        enumerable: true,
        get: function get() {
          return _dependenciesTypeOfGenerated.typeOfDependencies;
        }
      });
      Object.defineProperty(exports, "typedDependencies", {
        enumerable: true,
        get: function get() {
          return _dependenciesTypedGenerated.typedDependencies;
        }
      });
      Object.defineProperty(exports, "unaryMinusDependencies", {
        enumerable: true,
        get: function get() {
          return _dependenciesUnaryMinusGenerated.unaryMinusDependencies;
        }
      });
      Object.defineProperty(exports, "unaryPlusDependencies", {
        enumerable: true,
        get: function get() {
          return _dependenciesUnaryPlusGenerated.unaryPlusDependencies;
        }
      });
      Object.defineProperty(exports, "unequalDependencies", {
        enumerable: true,
        get: function get() {
          return _dependenciesUnequalGenerated.unequalDependencies;
        }
      });
      Object.defineProperty(exports, "unitDependencies", {
        enumerable: true,
        get: function get() {
          return _dependenciesUnitFunctionGenerated.unitDependencies;
        }
      });
      Object.defineProperty(exports, "usolveAllDependencies", {
        enumerable: true,
        get: function get() {
          return _dependenciesUsolveAllGenerated.usolveAllDependencies;
        }
      });
      Object.defineProperty(exports, "usolveDependencies", {
        enumerable: true,
        get: function get() {
          return _dependenciesUsolveGenerated.usolveDependencies;
        }
      });
      Object.defineProperty(exports, "vacuumImpedanceDependencies", {
        enumerable: true,
        get: function get() {
          return _dependenciesVacuumImpedanceGenerated.vacuumImpedanceDependencies;
        }
      });
      Object.defineProperty(exports, "varianceDependencies", {
        enumerable: true,
        get: function get() {
          return _dependenciesVarianceGenerated.varianceDependencies;
        }
      });
      Object.defineProperty(exports, "varianceTransformDependencies", {
        enumerable: true,
        get: function get() {
          return _dependenciesVarianceTransformGenerated.varianceTransformDependencies;
        }
      });
      Object.defineProperty(exports, "versionDependencies", {
        enumerable: true,
        get: function get() {
          return _dependenciesVersionGenerated.versionDependencies;
        }
      });
      Object.defineProperty(exports, "weakMixingAngleDependencies", {
        enumerable: true,
        get: function get() {
          return _dependenciesWeakMixingAngleGenerated.weakMixingAngleDependencies;
        }
      });
      Object.defineProperty(exports, "wienDisplacementDependencies", {
        enumerable: true,
        get: function get() {
          return _dependenciesWienDisplacementGenerated.wienDisplacementDependencies;
        }
      });
      Object.defineProperty(exports, "xgcdDependencies", {
        enumerable: true,
        get: function get() {
          return _dependenciesXgcdGenerated.xgcdDependencies;
        }
      });
      Object.defineProperty(exports, "xorDependencies", {
        enumerable: true,
        get: function get() {
          return _dependenciesXorGenerated.xorDependencies;
        }
      });
      Object.defineProperty(exports, "zerosDependencies", {
        enumerable: true,
        get: function get() {
          return _dependenciesZerosGenerated.zerosDependencies;
        }
      });
      Object.defineProperty(exports, "zetaDependencies", {
        enumerable: true,
        get: function get() {
          return _dependenciesZetaGenerated.zetaDependencies;
        }
      });
      Object.defineProperty(exports, "zpk2tfDependencies", {
        enumerable: true,
        get: function get() {
          return _dependenciesZpk2tfGenerated.zpk2tfDependencies;
        }
      });
      var _dependenciesAbsGenerated = require_dependenciesAbs_generated();
      var _dependenciesAccessorNodeGenerated = require_dependenciesAccessorNode_generated();
      var _dependenciesAcosGenerated = require_dependenciesAcos_generated();
      var _dependenciesAcoshGenerated = require_dependenciesAcosh_generated();
      var _dependenciesAcotGenerated = require_dependenciesAcot_generated();
      var _dependenciesAcothGenerated = require_dependenciesAcoth_generated();
      var _dependenciesAcscGenerated = require_dependenciesAcsc_generated();
      var _dependenciesAcschGenerated = require_dependenciesAcsch_generated();
      var _dependenciesAddGenerated = require_dependenciesAdd_generated();
      var _dependenciesAddScalarGenerated = require_dependenciesAddScalar_generated();
      var _dependenciesAndGenerated = require_dependenciesAnd_generated();
      var _dependenciesAndTransformGenerated = require_dependenciesAndTransform_generated();
      var _dependenciesApplyGenerated = require_dependenciesApply_generated();
      var _dependenciesApplyTransformGenerated = require_dependenciesApplyTransform_generated();
      var _dependenciesArgGenerated = require_dependenciesArg_generated();
      var _dependenciesArrayNodeGenerated = require_dependenciesArrayNode_generated();
      var _dependenciesAsecGenerated = require_dependenciesAsec_generated();
      var _dependenciesAsechGenerated = require_dependenciesAsech_generated();
      var _dependenciesAsinGenerated = require_dependenciesAsin_generated();
      var _dependenciesAsinhGenerated = require_dependenciesAsinh_generated();
      var _dependenciesAssignmentNodeGenerated = require_dependenciesAssignmentNode_generated();
      var _dependenciesAtanGenerated = require_dependenciesAtan_generated();
      var _dependenciesAtan2Generated = require_dependenciesAtan2_generated();
      var _dependenciesAtanhGenerated = require_dependenciesAtanh_generated();
      var _dependenciesAtomicMassGenerated = require_dependenciesAtomicMass_generated();
      var _dependenciesAvogadroGenerated = require_dependenciesAvogadro_generated();
      var _dependenciesBellNumbersGenerated = require_dependenciesBellNumbers_generated();
      var _dependenciesBigNumberClassGenerated = require_dependenciesBigNumberClass_generated();
      var _dependenciesBignumberGenerated = require_dependenciesBignumber_generated();
      var _dependenciesBinGenerated = require_dependenciesBin_generated();
      var _dependenciesBitAndGenerated = require_dependenciesBitAnd_generated();
      var _dependenciesBitAndTransformGenerated = require_dependenciesBitAndTransform_generated();
      var _dependenciesBitNotGenerated = require_dependenciesBitNot_generated();
      var _dependenciesBitOrGenerated = require_dependenciesBitOr_generated();
      var _dependenciesBitOrTransformGenerated = require_dependenciesBitOrTransform_generated();
      var _dependenciesBitXorGenerated = require_dependenciesBitXor_generated();
      var _dependenciesBlockNodeGenerated = require_dependenciesBlockNode_generated();
      var _dependenciesBohrMagnetonGenerated = require_dependenciesBohrMagneton_generated();
      var _dependenciesBohrRadiusGenerated = require_dependenciesBohrRadius_generated();
      var _dependenciesBoltzmannGenerated = require_dependenciesBoltzmann_generated();
      var _dependenciesBooleanGenerated = require_dependenciesBoolean_generated();
      var _dependenciesCatalanGenerated = require_dependenciesCatalan_generated();
      var _dependenciesCbrtGenerated = require_dependenciesCbrt_generated();
      var _dependenciesCeilGenerated = require_dependenciesCeil_generated();
      var _dependenciesChainGenerated = require_dependenciesChain_generated();
      var _dependenciesChainClassGenerated = require_dependenciesChainClass_generated();
      var _dependenciesClassicalElectronRadiusGenerated = require_dependenciesClassicalElectronRadius_generated();
      var _dependenciesCloneGenerated = require_dependenciesClone_generated();
      var _dependenciesColumnGenerated = require_dependenciesColumn_generated();
      var _dependenciesColumnTransformGenerated = require_dependenciesColumnTransform_generated();
      var _dependenciesCombinationsGenerated = require_dependenciesCombinations_generated();
      var _dependenciesCombinationsWithRepGenerated = require_dependenciesCombinationsWithRep_generated();
      var _dependenciesCompareGenerated = require_dependenciesCompare_generated();
      var _dependenciesCompareNaturalGenerated = require_dependenciesCompareNatural_generated();
      var _dependenciesCompareTextGenerated = require_dependenciesCompareText_generated();
      var _dependenciesCompileGenerated = require_dependenciesCompile_generated();
      var _dependenciesComplexGenerated = require_dependenciesComplex_generated();
      var _dependenciesComplexClassGenerated = require_dependenciesComplexClass_generated();
      var _dependenciesCompositionGenerated = require_dependenciesComposition_generated();
      var _dependenciesConcatGenerated = require_dependenciesConcat_generated();
      var _dependenciesConcatTransformGenerated = require_dependenciesConcatTransform_generated();
      var _dependenciesConditionalNodeGenerated = require_dependenciesConditionalNode_generated();
      var _dependenciesConductanceQuantumGenerated = require_dependenciesConductanceQuantum_generated();
      var _dependenciesConjGenerated = require_dependenciesConj_generated();
      var _dependenciesConstantNodeGenerated = require_dependenciesConstantNode_generated();
      var _dependenciesCorrGenerated = require_dependenciesCorr_generated();
      var _dependenciesCosGenerated = require_dependenciesCos_generated();
      var _dependenciesCoshGenerated = require_dependenciesCosh_generated();
      var _dependenciesCotGenerated = require_dependenciesCot_generated();
      var _dependenciesCothGenerated = require_dependenciesCoth_generated();
      var _dependenciesCoulombGenerated = require_dependenciesCoulomb_generated();
      var _dependenciesCountGenerated = require_dependenciesCount_generated();
      var _dependenciesCreateUnitGenerated = require_dependenciesCreateUnit_generated();
      var _dependenciesCrossGenerated = require_dependenciesCross_generated();
      var _dependenciesCscGenerated = require_dependenciesCsc_generated();
      var _dependenciesCschGenerated = require_dependenciesCsch_generated();
      var _dependenciesCtransposeGenerated = require_dependenciesCtranspose_generated();
      var _dependenciesCubeGenerated = require_dependenciesCube_generated();
      var _dependenciesCumSumGenerated = require_dependenciesCumSum_generated();
      var _dependenciesCumSumTransformGenerated = require_dependenciesCumSumTransform_generated();
      var _dependenciesDeepEqualGenerated = require_dependenciesDeepEqual_generated();
      var _dependenciesDenseMatrixClassGenerated = require_dependenciesDenseMatrixClass_generated();
      var _dependenciesDerivativeGenerated = require_dependenciesDerivative_generated();
      var _dependenciesDetGenerated = require_dependenciesDet_generated();
      var _dependenciesDeuteronMassGenerated = require_dependenciesDeuteronMass_generated();
      var _dependenciesDiagGenerated = require_dependenciesDiag_generated();
      var _dependenciesDiffGenerated = require_dependenciesDiff_generated();
      var _dependenciesDiffTransformGenerated = require_dependenciesDiffTransform_generated();
      var _dependenciesDistanceGenerated = require_dependenciesDistance_generated();
      var _dependenciesDivideGenerated = require_dependenciesDivide_generated();
      var _dependenciesDivideScalarGenerated = require_dependenciesDivideScalar_generated();
      var _dependenciesDotGenerated = require_dependenciesDot_generated();
      var _dependenciesDotDivideGenerated = require_dependenciesDotDivide_generated();
      var _dependenciesDotMultiplyGenerated = require_dependenciesDotMultiply_generated();
      var _dependenciesDotPowGenerated = require_dependenciesDotPow_generated();
      var _dependenciesEGenerated = require_dependenciesE_generated();
      var _dependenciesEfimovFactorGenerated = require_dependenciesEfimovFactor_generated();
      var _dependenciesEigsGenerated = require_dependenciesEigs_generated();
      var _dependenciesElectricConstantGenerated = require_dependenciesElectricConstant_generated();
      var _dependenciesElectronMassGenerated = require_dependenciesElectronMass_generated();
      var _dependenciesElementaryChargeGenerated = require_dependenciesElementaryCharge_generated();
      var _dependenciesEqualGenerated = require_dependenciesEqual_generated();
      var _dependenciesEqualScalarGenerated = require_dependenciesEqualScalar_generated();
      var _dependenciesEqualTextGenerated = require_dependenciesEqualText_generated();
      var _dependenciesErfGenerated = require_dependenciesErf_generated();
      var _dependenciesEvaluateGenerated = require_dependenciesEvaluate_generated();
      var _dependenciesExpGenerated = require_dependenciesExp_generated();
      var _dependenciesExpmGenerated = require_dependenciesExpm_generated();
      var _dependenciesExpm1Generated = require_dependenciesExpm1_generated();
      var _dependenciesFactorialGenerated = require_dependenciesFactorial_generated();
      var _dependenciesFalseGenerated = require_dependenciesFalse_generated();
      var _dependenciesFaradayGenerated = require_dependenciesFaraday_generated();
      var _dependenciesFermiCouplingGenerated = require_dependenciesFermiCoupling_generated();
      var _dependenciesFftGenerated = require_dependenciesFft_generated();
      var _dependenciesFibonacciHeapClassGenerated = require_dependenciesFibonacciHeapClass_generated();
      var _dependenciesFilterGenerated = require_dependenciesFilter_generated();
      var _dependenciesFilterTransformGenerated = require_dependenciesFilterTransform_generated();
      var _dependenciesFineStructureGenerated = require_dependenciesFineStructure_generated();
      var _dependenciesFirstRadiationGenerated = require_dependenciesFirstRadiation_generated();
      var _dependenciesFixGenerated = require_dependenciesFix_generated();
      var _dependenciesFlattenGenerated = require_dependenciesFlatten_generated();
      var _dependenciesFloorGenerated = require_dependenciesFloor_generated();
      var _dependenciesForEachGenerated = require_dependenciesForEach_generated();
      var _dependenciesForEachTransformGenerated = require_dependenciesForEachTransform_generated();
      var _dependenciesFormatGenerated = require_dependenciesFormat_generated();
      var _dependenciesFractionGenerated = require_dependenciesFraction_generated();
      var _dependenciesFractionClassGenerated = require_dependenciesFractionClass_generated();
      var _dependenciesFreqzGenerated = require_dependenciesFreqz_generated();
      var _dependenciesFunctionAssignmentNodeGenerated = require_dependenciesFunctionAssignmentNode_generated();
      var _dependenciesFunctionNodeGenerated = require_dependenciesFunctionNode_generated();
      var _dependenciesGammaGenerated = require_dependenciesGamma_generated();
      var _dependenciesGasConstantGenerated = require_dependenciesGasConstant_generated();
      var _dependenciesGcdGenerated = require_dependenciesGcd_generated();
      var _dependenciesGetMatrixDataTypeGenerated = require_dependenciesGetMatrixDataType_generated();
      var _dependenciesGravitationConstantGenerated = require_dependenciesGravitationConstant_generated();
      var _dependenciesGravityGenerated = require_dependenciesGravity_generated();
      var _dependenciesHartreeEnergyGenerated = require_dependenciesHartreeEnergy_generated();
      var _dependenciesHasNumericValueGenerated = require_dependenciesHasNumericValue_generated();
      var _dependenciesHelpGenerated = require_dependenciesHelp_generated();
      var _dependenciesHelpClassGenerated = require_dependenciesHelpClass_generated();
      var _dependenciesHexGenerated = require_dependenciesHex_generated();
      var _dependenciesHypotGenerated = require_dependenciesHypot_generated();
      var _dependenciesIGenerated = require_dependenciesI_generated();
      var _dependenciesIdentityGenerated = require_dependenciesIdentity_generated();
      var _dependenciesIfftGenerated = require_dependenciesIfft_generated();
      var _dependenciesImGenerated = require_dependenciesIm_generated();
      var _dependenciesImmutableDenseMatrixClassGenerated = require_dependenciesImmutableDenseMatrixClass_generated();
      var _dependenciesIndexGenerated = require_dependenciesIndex_generated();
      var _dependenciesIndexClassGenerated = require_dependenciesIndexClass_generated();
      var _dependenciesIndexNodeGenerated = require_dependenciesIndexNode_generated();
      var _dependenciesIndexTransformGenerated = require_dependenciesIndexTransform_generated();
      var _dependenciesInfinityGenerated = require_dependenciesInfinity_generated();
      var _dependenciesIntersectGenerated = require_dependenciesIntersect_generated();
      var _dependenciesInvGenerated = require_dependenciesInv_generated();
      var _dependenciesInverseConductanceQuantumGenerated = require_dependenciesInverseConductanceQuantum_generated();
      var _dependenciesInvmodGenerated = require_dependenciesInvmod_generated();
      var _dependenciesIsIntegerGenerated = require_dependenciesIsInteger_generated();
      var _dependenciesIsNaNGenerated = require_dependenciesIsNaN_generated();
      var _dependenciesIsNegativeGenerated = require_dependenciesIsNegative_generated();
      var _dependenciesIsNumericGenerated = require_dependenciesIsNumeric_generated();
      var _dependenciesIsPositiveGenerated = require_dependenciesIsPositive_generated();
      var _dependenciesIsPrimeGenerated = require_dependenciesIsPrime_generated();
      var _dependenciesIsZeroGenerated = require_dependenciesIsZero_generated();
      var _dependenciesKldivergenceGenerated = require_dependenciesKldivergence_generated();
      var _dependenciesKlitzingGenerated = require_dependenciesKlitzing_generated();
      var _dependenciesKronGenerated = require_dependenciesKron_generated();
      var _dependenciesLN10Generated = require_dependenciesLN10_generated();
      var _dependenciesLN2Generated = require_dependenciesLN2_generated();
      var _dependenciesLOG10EGenerated = require_dependenciesLOG10E_generated();
      var _dependenciesLOG2EGenerated = require_dependenciesLOG2E_generated();
      var _dependenciesLargerGenerated = require_dependenciesLarger_generated();
      var _dependenciesLargerEqGenerated = require_dependenciesLargerEq_generated();
      var _dependenciesLcmGenerated = require_dependenciesLcm_generated();
      var _dependenciesLeafCountGenerated = require_dependenciesLeafCount_generated();
      var _dependenciesLeftShiftGenerated = require_dependenciesLeftShift_generated();
      var _dependenciesLgammaGenerated = require_dependenciesLgamma_generated();
      var _dependenciesLogGenerated = require_dependenciesLog_generated();
      var _dependenciesLog10Generated = require_dependenciesLog10_generated();
      var _dependenciesLog1pGenerated = require_dependenciesLog1p_generated();
      var _dependenciesLog2Generated = require_dependenciesLog2_generated();
      var _dependenciesLoschmidtGenerated = require_dependenciesLoschmidt_generated();
      var _dependenciesLsolveGenerated = require_dependenciesLsolve_generated();
      var _dependenciesLsolveAllGenerated = require_dependenciesLsolveAll_generated();
      var _dependenciesLupGenerated = require_dependenciesLup_generated();
      var _dependenciesLusolveGenerated = require_dependenciesLusolve_generated();
      var _dependenciesLyapGenerated = require_dependenciesLyap_generated();
      var _dependenciesMadGenerated = require_dependenciesMad_generated();
      var _dependenciesMagneticConstantGenerated = require_dependenciesMagneticConstant_generated();
      var _dependenciesMagneticFluxQuantumGenerated = require_dependenciesMagneticFluxQuantum_generated();
      var _dependenciesMapGenerated = require_dependenciesMap_generated();
      var _dependenciesMapTransformGenerated = require_dependenciesMapTransform_generated();
      var _dependenciesMatrixGenerated = require_dependenciesMatrix_generated();
      var _dependenciesMatrixClassGenerated = require_dependenciesMatrixClass_generated();
      var _dependenciesMatrixFromColumnsGenerated = require_dependenciesMatrixFromColumns_generated();
      var _dependenciesMatrixFromFunctionGenerated = require_dependenciesMatrixFromFunction_generated();
      var _dependenciesMatrixFromRowsGenerated = require_dependenciesMatrixFromRows_generated();
      var _dependenciesMaxGenerated = require_dependenciesMax_generated();
      var _dependenciesMaxTransformGenerated = require_dependenciesMaxTransform_generated();
      var _dependenciesMeanGenerated = require_dependenciesMean_generated();
      var _dependenciesMeanTransformGenerated = require_dependenciesMeanTransform_generated();
      var _dependenciesMedianGenerated = require_dependenciesMedian_generated();
      var _dependenciesMinGenerated = require_dependenciesMin_generated();
      var _dependenciesMinTransformGenerated = require_dependenciesMinTransform_generated();
      var _dependenciesModGenerated = require_dependenciesMod_generated();
      var _dependenciesModeGenerated = require_dependenciesMode_generated();
      var _dependenciesMolarMassGenerated = require_dependenciesMolarMass_generated();
      var _dependenciesMolarMassC12Generated = require_dependenciesMolarMassC12_generated();
      var _dependenciesMolarPlanckConstantGenerated = require_dependenciesMolarPlanckConstant_generated();
      var _dependenciesMolarVolumeGenerated = require_dependenciesMolarVolume_generated();
      var _dependenciesMultinomialGenerated = require_dependenciesMultinomial_generated();
      var _dependenciesMultiplyGenerated = require_dependenciesMultiply_generated();
      var _dependenciesMultiplyScalarGenerated = require_dependenciesMultiplyScalar_generated();
      var _dependenciesNaNGenerated = require_dependenciesNaN_generated();
      var _dependenciesNeutronMassGenerated = require_dependenciesNeutronMass_generated();
      var _dependenciesNodeGenerated = require_dependenciesNode_generated();
      var _dependenciesNormGenerated = require_dependenciesNorm_generated();
      var _dependenciesNotGenerated = require_dependenciesNot_generated();
      var _dependenciesNthRootGenerated = require_dependenciesNthRoot_generated();
      var _dependenciesNthRootsGenerated = require_dependenciesNthRoots_generated();
      var _dependenciesNuclearMagnetonGenerated = require_dependenciesNuclearMagneton_generated();
      var _dependenciesNullGenerated = require_dependenciesNull_generated();
      var _dependenciesNumberGenerated = require_dependenciesNumber_generated();
      var _dependenciesNumericGenerated = require_dependenciesNumeric_generated();
      var _dependenciesObjectNodeGenerated = require_dependenciesObjectNode_generated();
      var _dependenciesOctGenerated = require_dependenciesOct_generated();
      var _dependenciesOnesGenerated = require_dependenciesOnes_generated();
      var _dependenciesOperatorNodeGenerated = require_dependenciesOperatorNode_generated();
      var _dependenciesOrGenerated = require_dependenciesOr_generated();
      var _dependenciesOrTransformGenerated = require_dependenciesOrTransform_generated();
      var _dependenciesParenthesisNodeGenerated = require_dependenciesParenthesisNode_generated();
      var _dependenciesParseGenerated = require_dependenciesParse_generated();
      var _dependenciesParserGenerated = require_dependenciesParser_generated();
      var _dependenciesParserClassGenerated = require_dependenciesParserClass_generated();
      var _dependenciesPartitionSelectGenerated = require_dependenciesPartitionSelect_generated();
      var _dependenciesPermutationsGenerated = require_dependenciesPermutations_generated();
      var _dependenciesPhiGenerated = require_dependenciesPhi_generated();
      var _dependenciesPiGenerated = require_dependenciesPi_generated();
      var _dependenciesPickRandomGenerated = require_dependenciesPickRandom_generated();
      var _dependenciesPinvGenerated = require_dependenciesPinv_generated();
      var _dependenciesPlanckChargeGenerated = require_dependenciesPlanckCharge_generated();
      var _dependenciesPlanckConstantGenerated = require_dependenciesPlanckConstant_generated();
      var _dependenciesPlanckLengthGenerated = require_dependenciesPlanckLength_generated();
      var _dependenciesPlanckMassGenerated = require_dependenciesPlanckMass_generated();
      var _dependenciesPlanckTemperatureGenerated = require_dependenciesPlanckTemperature_generated();
      var _dependenciesPlanckTimeGenerated = require_dependenciesPlanckTime_generated();
      var _dependenciesPolynomialRootGenerated = require_dependenciesPolynomialRoot_generated();
      var _dependenciesPowGenerated = require_dependenciesPow_generated();
      var _dependenciesPrintGenerated = require_dependenciesPrint_generated();
      var _dependenciesPrintTransformGenerated = require_dependenciesPrintTransform_generated();
      var _dependenciesProdGenerated = require_dependenciesProd_generated();
      var _dependenciesProtonMassGenerated = require_dependenciesProtonMass_generated();
      var _dependenciesQrGenerated = require_dependenciesQr_generated();
      var _dependenciesQuantileSeqGenerated = require_dependenciesQuantileSeq_generated();
      var _dependenciesQuantileSeqTransformGenerated = require_dependenciesQuantileSeqTransform_generated();
      var _dependenciesQuantumOfCirculationGenerated = require_dependenciesQuantumOfCirculation_generated();
      var _dependenciesRandomGenerated = require_dependenciesRandom_generated();
      var _dependenciesRandomIntGenerated = require_dependenciesRandomInt_generated();
      var _dependenciesRangeGenerated = require_dependenciesRange_generated();
      var _dependenciesRangeClassGenerated = require_dependenciesRangeClass_generated();
      var _dependenciesRangeNodeGenerated = require_dependenciesRangeNode_generated();
      var _dependenciesRangeTransformGenerated = require_dependenciesRangeTransform_generated();
      var _dependenciesRationalizeGenerated = require_dependenciesRationalize_generated();
      var _dependenciesReGenerated = require_dependenciesRe_generated();
      var _dependenciesReducedPlanckConstantGenerated = require_dependenciesReducedPlanckConstant_generated();
      var _dependenciesRelationalNodeGenerated = require_dependenciesRelationalNode_generated();
      var _dependenciesReplacerGenerated = require_dependenciesReplacer_generated();
      var _dependenciesReshapeGenerated = require_dependenciesReshape_generated();
      var _dependenciesResizeGenerated = require_dependenciesResize_generated();
      var _dependenciesResolveGenerated = require_dependenciesResolve_generated();
      var _dependenciesResultSetGenerated = require_dependenciesResultSet_generated();
      var _dependenciesReviverGenerated = require_dependenciesReviver_generated();
      var _dependenciesRightArithShiftGenerated = require_dependenciesRightArithShift_generated();
      var _dependenciesRightLogShiftGenerated = require_dependenciesRightLogShift_generated();
      var _dependenciesRotateGenerated = require_dependenciesRotate_generated();
      var _dependenciesRotationMatrixGenerated = require_dependenciesRotationMatrix_generated();
      var _dependenciesRoundGenerated = require_dependenciesRound_generated();
      var _dependenciesRowGenerated = require_dependenciesRow_generated();
      var _dependenciesRowTransformGenerated = require_dependenciesRowTransform_generated();
      var _dependenciesRydbergGenerated = require_dependenciesRydberg_generated();
      var _dependenciesSQRT1_2Generated = require_dependenciesSQRT1_2_generated();
      var _dependenciesSQRT2Generated = require_dependenciesSQRT2_generated();
      var _dependenciesSackurTetrodeGenerated = require_dependenciesSackurTetrode_generated();
      var _dependenciesSchurGenerated = require_dependenciesSchur_generated();
      var _dependenciesSecGenerated = require_dependenciesSec_generated();
      var _dependenciesSechGenerated = require_dependenciesSech_generated();
      var _dependenciesSecondRadiationGenerated = require_dependenciesSecondRadiation_generated();
      var _dependenciesSetCartesianGenerated = require_dependenciesSetCartesian_generated();
      var _dependenciesSetDifferenceGenerated = require_dependenciesSetDifference_generated();
      var _dependenciesSetDistinctGenerated = require_dependenciesSetDistinct_generated();
      var _dependenciesSetIntersectGenerated = require_dependenciesSetIntersect_generated();
      var _dependenciesSetIsSubsetGenerated = require_dependenciesSetIsSubset_generated();
      var _dependenciesSetMultiplicityGenerated = require_dependenciesSetMultiplicity_generated();
      var _dependenciesSetPowersetGenerated = require_dependenciesSetPowerset_generated();
      var _dependenciesSetSizeGenerated = require_dependenciesSetSize_generated();
      var _dependenciesSetSymDifferenceGenerated = require_dependenciesSetSymDifference_generated();
      var _dependenciesSetUnionGenerated = require_dependenciesSetUnion_generated();
      var _dependenciesSignGenerated = require_dependenciesSign_generated();
      var _dependenciesSimplifyGenerated = require_dependenciesSimplify_generated();
      var _dependenciesSimplifyConstantGenerated = require_dependenciesSimplifyConstant_generated();
      var _dependenciesSimplifyCoreGenerated = require_dependenciesSimplifyCore_generated();
      var _dependenciesSinGenerated = require_dependenciesSin_generated();
      var _dependenciesSinhGenerated = require_dependenciesSinh_generated();
      var _dependenciesSizeGenerated = require_dependenciesSize_generated();
      var _dependenciesSluGenerated = require_dependenciesSlu_generated();
      var _dependenciesSmallerGenerated = require_dependenciesSmaller_generated();
      var _dependenciesSmallerEqGenerated = require_dependenciesSmallerEq_generated();
      var _dependenciesSolveODEGenerated = require_dependenciesSolveODE_generated();
      var _dependenciesSortGenerated = require_dependenciesSort_generated();
      var _dependenciesSpaClassGenerated = require_dependenciesSpaClass_generated();
      var _dependenciesSparseGenerated = require_dependenciesSparse_generated();
      var _dependenciesSparseMatrixClassGenerated = require_dependenciesSparseMatrixClass_generated();
      var _dependenciesSpeedOfLightGenerated = require_dependenciesSpeedOfLight_generated();
      var _dependenciesSplitUnitGenerated = require_dependenciesSplitUnit_generated();
      var _dependenciesSqrtGenerated = require_dependenciesSqrt_generated();
      var _dependenciesSqrtmGenerated = require_dependenciesSqrtm_generated();
      var _dependenciesSquareGenerated = require_dependenciesSquare_generated();
      var _dependenciesSqueezeGenerated = require_dependenciesSqueeze_generated();
      var _dependenciesStdGenerated = require_dependenciesStd_generated();
      var _dependenciesStdTransformGenerated = require_dependenciesStdTransform_generated();
      var _dependenciesStefanBoltzmannGenerated = require_dependenciesStefanBoltzmann_generated();
      var _dependenciesStirlingS2Generated = require_dependenciesStirlingS2_generated();
      var _dependenciesStringGenerated = require_dependenciesString_generated();
      var _dependenciesSubsetGenerated = require_dependenciesSubset_generated();
      var _dependenciesSubsetTransformGenerated = require_dependenciesSubsetTransform_generated();
      var _dependenciesSubtractGenerated = require_dependenciesSubtract_generated();
      var _dependenciesSubtractScalarGenerated = require_dependenciesSubtractScalar_generated();
      var _dependenciesSumGenerated = require_dependenciesSum_generated();
      var _dependenciesSumTransformGenerated = require_dependenciesSumTransform_generated();
      var _dependenciesSylvesterGenerated = require_dependenciesSylvester_generated();
      var _dependenciesSymbolNodeGenerated = require_dependenciesSymbolNode_generated();
      var _dependenciesSymbolicEqualGenerated = require_dependenciesSymbolicEqual_generated();
      var _dependenciesTanGenerated = require_dependenciesTan_generated();
      var _dependenciesTanhGenerated = require_dependenciesTanh_generated();
      var _dependenciesTauGenerated = require_dependenciesTau_generated();
      var _dependenciesThomsonCrossSectionGenerated = require_dependenciesThomsonCrossSection_generated();
      var _dependenciesToGenerated = require_dependenciesTo_generated();
      var _dependenciesTraceGenerated = require_dependenciesTrace_generated();
      var _dependenciesTransposeGenerated = require_dependenciesTranspose_generated();
      var _dependenciesTrueGenerated = require_dependenciesTrue_generated();
      var _dependenciesTypeOfGenerated = require_dependenciesTypeOf_generated();
      var _dependenciesTypedGenerated = require_dependenciesTyped_generated();
      var _dependenciesUnaryMinusGenerated = require_dependenciesUnaryMinus_generated();
      var _dependenciesUnaryPlusGenerated = require_dependenciesUnaryPlus_generated();
      var _dependenciesUnequalGenerated = require_dependenciesUnequal_generated();
      var _dependenciesUnitClassGenerated = require_dependenciesUnitClass_generated();
      var _dependenciesUnitFunctionGenerated = require_dependenciesUnitFunction_generated();
      var _dependenciesUppercaseEGenerated = require_dependenciesUppercaseE_generated();
      var _dependenciesUppercasePiGenerated = require_dependenciesUppercasePi_generated();
      var _dependenciesUsolveGenerated = require_dependenciesUsolve_generated();
      var _dependenciesUsolveAllGenerated = require_dependenciesUsolveAll_generated();
      var _dependenciesVacuumImpedanceGenerated = require_dependenciesVacuumImpedance_generated();
      var _dependenciesVarianceGenerated = require_dependenciesVariance_generated();
      var _dependenciesVarianceTransformGenerated = require_dependenciesVarianceTransform_generated();
      var _dependenciesVersionGenerated = require_dependenciesVersion_generated();
      var _dependenciesWeakMixingAngleGenerated = require_dependenciesWeakMixingAngle_generated();
      var _dependenciesWienDisplacementGenerated = require_dependenciesWienDisplacement_generated();
      var _dependenciesXgcdGenerated = require_dependenciesXgcd_generated();
      var _dependenciesXorGenerated = require_dependenciesXor_generated();
      var _dependenciesZerosGenerated = require_dependenciesZeros_generated();
      var _dependenciesZetaGenerated = require_dependenciesZeta_generated();
      var _dependenciesZpk2tfGenerated = require_dependenciesZpk2tf_generated();
      var _allFactoriesAny = require_allFactoriesAny();
    }
  });

  // node_modules/.pnpm/tiny-emitter@2.1.0/node_modules/tiny-emitter/index.js
  var require_tiny_emitter = __commonJS({
    "node_modules/.pnpm/tiny-emitter@2.1.0/node_modules/tiny-emitter/index.js"(exports, module) {
      function E() {
      }
      E.prototype = {
        on: function(name18, callback, ctx) {
          var e = this.e || (this.e = {});
          (e[name18] || (e[name18] = [])).push({
            fn: callback,
            ctx
          });
          return this;
        },
        once: function(name18, callback, ctx) {
          var self2 = this;
          function listener() {
            self2.off(name18, listener);
            callback.apply(ctx, arguments);
          }
          ;
          listener._ = callback;
          return this.on(name18, listener, ctx);
        },
        emit: function(name18) {
          var data = [].slice.call(arguments, 1);
          var evtArr = ((this.e || (this.e = {}))[name18] || []).slice();
          var i = 0;
          var len = evtArr.length;
          for (i; i < len; i++) {
            evtArr[i].fn.apply(evtArr[i].ctx, data);
          }
          return this;
        },
        off: function(name18, callback) {
          var e = this.e || (this.e = {});
          var evts = e[name18];
          var liveEvents = [];
          if (evts && callback) {
            for (var i = 0, len = evts.length; i < len; i++) {
              if (evts[i].fn !== callback && evts[i].fn._ !== callback)
                liveEvents.push(evts[i]);
            }
          }
          liveEvents.length ? e[name18] = liveEvents : delete e[name18];
          return this;
        }
      };
      module.exports = E;
      module.exports.TinyEmitter = E;
    }
  });

  // node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/utils/emitter.js
  var require_emitter = __commonJS({
    "node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/utils/emitter.js"(exports) {
      "use strict";
      var _interopRequireDefault = require_interopRequireDefault();
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.mixin = mixin;
      var _tinyEmitter = _interopRequireDefault(require_tiny_emitter());
      function mixin(obj) {
        var emitter = new _tinyEmitter["default"]();
        obj.on = emitter.on.bind(emitter);
        obj.off = emitter.off.bind(emitter);
        obj.once = emitter.once.bind(emitter);
        obj.emit = emitter.emit.bind(emitter);
        return obj;
      }
    }
  });

  // node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/core/function/import.js
  var require_import2 = __commonJS({
    "node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/core/function/import.js"(exports) {
      "use strict";
      var _interopRequireDefault = require_interopRequireDefault();
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.importFactory = importFactory;
      var _defineProperty2 = _interopRequireDefault(require_defineProperty());
      var _typeof2 = _interopRequireDefault(require_typeof());
      var _is = require_is();
      var _factory = require_factory();
      var _object = require_object();
      var _ArgumentsError = require_ArgumentsError();
      function importFactory(typed2, load, math, importedFactories) {
        function mathImport(functions, options) {
          var num = arguments.length;
          if (num !== 1 && num !== 2) {
            throw new _ArgumentsError.ArgumentsError("import", num, 1, 2);
          }
          if (!options) {
            options = {};
          }
          function flattenImports(flatValues2, value2, name19) {
            if (Array.isArray(value2)) {
              value2.forEach(function(item) {
                return flattenImports(flatValues2, item);
              });
            } else if ((0, _typeof2["default"])(value2) === "object") {
              for (var _name in value2) {
                if ((0, _object.hasOwnProperty)(value2, _name)) {
                  flattenImports(flatValues2, value2[_name], _name);
                }
              }
            } else if ((0, _factory.isFactory)(value2) || name19 !== void 0) {
              var flatName = (0, _factory.isFactory)(value2) ? isTransformFunctionFactory(value2) ? value2.fn + ".transform" : value2.fn : name19;
              if ((0, _object.hasOwnProperty)(flatValues2, flatName) && flatValues2[flatName] !== value2 && !options.silent) {
                throw new Error('Cannot import "' + flatName + '" twice');
              }
              flatValues2[flatName] = value2;
            } else {
              if (!options.silent) {
                throw new TypeError("Factory, Object, or Array expected");
              }
            }
          }
          var flatValues = {};
          flattenImports(flatValues, functions);
          for (var name18 in flatValues) {
            if ((0, _object.hasOwnProperty)(flatValues, name18)) {
              var value = flatValues[name18];
              if ((0, _factory.isFactory)(value)) {
                _importFactory(value, options);
              } else if (isSupportedType(value)) {
                _import(name18, value, options);
              } else {
                if (!options.silent) {
                  throw new TypeError("Factory, Object, or Array expected");
                }
              }
            }
          }
        }
        function _import(name18, value, options) {
          if (options.wrap && typeof value === "function") {
            value = _wrap(value);
          }
          if (hasTypedFunctionSignature(value)) {
            value = typed2(name18, (0, _defineProperty2["default"])({}, value.signature, value));
          }
          if (typed2.isTypedFunction(math[name18]) && typed2.isTypedFunction(value)) {
            if (options.override) {
              value = typed2(name18, value.signatures);
            } else {
              value = typed2(math[name18], value);
            }
            math[name18] = value;
            delete importedFactories[name18];
            _importTransform(name18, value);
            math.emit("import", name18, function resolver() {
              return value;
            });
            return;
          }
          if (math[name18] === void 0 || options.override) {
            math[name18] = value;
            delete importedFactories[name18];
            _importTransform(name18, value);
            math.emit("import", name18, function resolver() {
              return value;
            });
            return;
          }
          if (!options.silent) {
            throw new Error('Cannot import "' + name18 + '": already exists');
          }
        }
        function _importTransform(name18, value) {
          if (value && typeof value.transform === "function") {
            math.expression.transform[name18] = value.transform;
            if (allowedInExpressions(name18)) {
              math.expression.mathWithTransform[name18] = value.transform;
            }
          } else {
            delete math.expression.transform[name18];
            if (allowedInExpressions(name18)) {
              math.expression.mathWithTransform[name18] = value;
            }
          }
        }
        function _deleteTransform(name18) {
          delete math.expression.transform[name18];
          if (allowedInExpressions(name18)) {
            math.expression.mathWithTransform[name18] = math[name18];
          } else {
            delete math.expression.mathWithTransform[name18];
          }
        }
        function _wrap(fn) {
          var wrapper = function wrapper2() {
            var args = [];
            for (var i = 0, len = arguments.length; i < len; i++) {
              var arg = arguments[i];
              args[i] = arg && arg.valueOf();
            }
            return fn.apply(math, args);
          };
          if (fn.transform) {
            wrapper.transform = fn.transform;
          }
          return wrapper;
        }
        function _importFactory(factory2, options) {
          var name18 = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : factory2.fn;
          if (name18.includes(".")) {
            throw new Error("Factory name should not contain a nested path. Name: " + JSON.stringify(name18));
          }
          var namespace = isTransformFunctionFactory(factory2) ? math.expression.transform : math;
          var existingTransform = name18 in math.expression.transform;
          var existing = (0, _object.hasOwnProperty)(namespace, name18) ? namespace[name18] : void 0;
          var resolver = function resolver2() {
            var dependencies19 = {};
            factory2.dependencies.map(_factory.stripOptionalNotation).forEach(function(dependency) {
              if (dependency.includes(".")) {
                throw new Error("Factory dependency should not contain a nested path. Name: " + JSON.stringify(dependency));
              }
              if (dependency === "math") {
                dependencies19.math = math;
              } else if (dependency === "mathWithTransform") {
                dependencies19.mathWithTransform = math.expression.mathWithTransform;
              } else if (dependency === "classes") {
                dependencies19.classes = math;
              } else {
                dependencies19[dependency] = math[dependency];
              }
            });
            var instance = /* @__PURE__ */ factory2(dependencies19);
            if (instance && typeof instance.transform === "function") {
              throw new Error('Transforms cannot be attached to factory functions. Please create a separate function for it with exports.path="expression.transform"');
            }
            if (existing === void 0 || options.override) {
              return instance;
            }
            if (typed2.isTypedFunction(existing) && typed2.isTypedFunction(instance)) {
              return typed2(existing, instance);
            }
            if (options.silent) {
              return existing;
            } else {
              throw new Error('Cannot import "' + name18 + '": already exists');
            }
          };
          if (!factory2.meta || factory2.meta.lazy !== false) {
            (0, _object.lazy)(namespace, name18, resolver);
            if (existing && existingTransform) {
              _deleteTransform(name18);
            } else {
              if (isTransformFunctionFactory(factory2) || factoryAllowedInExpressions(factory2)) {
                (0, _object.lazy)(math.expression.mathWithTransform, name18, function() {
                  return namespace[name18];
                });
              }
            }
          } else {
            namespace[name18] = resolver();
            if (existing && existingTransform) {
              _deleteTransform(name18);
            } else {
              if (isTransformFunctionFactory(factory2) || factoryAllowedInExpressions(factory2)) {
                (0, _object.lazy)(math.expression.mathWithTransform, name18, function() {
                  return namespace[name18];
                });
              }
            }
          }
          importedFactories[name18] = factory2;
          math.emit("import", name18, resolver);
        }
        function isSupportedType(object) {
          return typeof object === "function" || typeof object === "number" || typeof object === "string" || typeof object === "boolean" || object === null || (0, _is.isUnit)(object) || (0, _is.isComplex)(object) || (0, _is.isBigNumber)(object) || (0, _is.isFraction)(object) || (0, _is.isMatrix)(object) || Array.isArray(object);
        }
        function hasTypedFunctionSignature(fn) {
          return typeof fn === "function" && typeof fn.signature === "string";
        }
        function allowedInExpressions(name18) {
          return !(0, _object.hasOwnProperty)(unsafe, name18);
        }
        function factoryAllowedInExpressions(factory2) {
          return !factory2.fn.includes(".") && // FIXME: make checking on path redundant, check on meta data instead
          !(0, _object.hasOwnProperty)(unsafe, factory2.fn) && (!factory2.meta || !factory2.meta.isClass);
        }
        function isTransformFunctionFactory(factory2) {
          return factory2 !== void 0 && factory2.meta !== void 0 && factory2.meta.isTransformFunction === true || false;
        }
        var unsafe = {
          expression: true,
          type: true,
          docs: true,
          error: true,
          json: true,
          chain: true
          // chain method not supported. Note that there is a unit chain too.
        };
        return mathImport;
      }
    }
  });

  // node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/core/create.js
  var require_create = __commonJS({
    "node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/core/create.js"(exports) {
      "use strict";
      var _interopRequireDefault = require_interopRequireDefault();
      var _typeof = require_typeof();
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.create = create;
      var _extends2 = _interopRequireDefault(require_extends());
      var _typedFunction = _interopRequireDefault(require_typed_function());
      var _object = require_object();
      var emitter = _interopRequireWildcard(require_emitter());
      var _import = require_import2();
      var _config = require_config2();
      var _factory = require_factory();
      var _is = require_is();
      var _ArgumentsError = require_ArgumentsError();
      var _DimensionError = require_DimensionError();
      var _IndexError = require_IndexError();
      var _config2 = require_config();
      function _getRequireWildcardCache(e) {
        if ("function" != typeof WeakMap) return null;
        var r = /* @__PURE__ */ new WeakMap(), t = /* @__PURE__ */ new WeakMap();
        return (_getRequireWildcardCache = function _getRequireWildcardCache2(e2) {
          return e2 ? t : r;
        })(e);
      }
      function _interopRequireWildcard(e, r) {
        if (!r && e && e.__esModule) return e;
        if (null === e || "object" != _typeof(e) && "function" != typeof e) return { "default": e };
        var t = _getRequireWildcardCache(r);
        if (t && t.has(e)) return t.get(e);
        var n = { __proto__: null }, a = Object.defineProperty && Object.getOwnPropertyDescriptor;
        for (var u in e) if ("default" !== u && {}.hasOwnProperty.call(e, u)) {
          var i = a ? Object.getOwnPropertyDescriptor(e, u) : null;
          i && (i.get || i.set) ? Object.defineProperty(n, u, i) : n[u] = e[u];
        }
        return n["default"] = e, t && t.set(e, n), n;
      }
      function create(factories, config4) {
        var configInternal = (0, _extends2["default"])({}, _config2.DEFAULT_CONFIG, config4);
        if (typeof Object.create !== "function") {
          throw new Error("ES5 not supported by this JavaScript engine. Please load the es5-shim and es5-sham library for compatibility.");
        }
        var math = emitter.mixin({
          // only here for backward compatibility for legacy factory functions
          isNumber: _is.isNumber,
          isComplex: _is.isComplex,
          isBigNumber: _is.isBigNumber,
          isFraction: _is.isFraction,
          isUnit: _is.isUnit,
          isString: _is.isString,
          isArray: _is.isArray,
          isMatrix: _is.isMatrix,
          isCollection: _is.isCollection,
          isDenseMatrix: _is.isDenseMatrix,
          isSparseMatrix: _is.isSparseMatrix,
          isRange: _is.isRange,
          isIndex: _is.isIndex,
          isBoolean: _is.isBoolean,
          isResultSet: _is.isResultSet,
          isHelp: _is.isHelp,
          isFunction: _is.isFunction,
          isDate: _is.isDate,
          isRegExp: _is.isRegExp,
          isObject: _is.isObject,
          isNull: _is.isNull,
          isUndefined: _is.isUndefined,
          isAccessorNode: _is.isAccessorNode,
          isArrayNode: _is.isArrayNode,
          isAssignmentNode: _is.isAssignmentNode,
          isBlockNode: _is.isBlockNode,
          isConditionalNode: _is.isConditionalNode,
          isConstantNode: _is.isConstantNode,
          isFunctionAssignmentNode: _is.isFunctionAssignmentNode,
          isFunctionNode: _is.isFunctionNode,
          isIndexNode: _is.isIndexNode,
          isNode: _is.isNode,
          isObjectNode: _is.isObjectNode,
          isOperatorNode: _is.isOperatorNode,
          isParenthesisNode: _is.isParenthesisNode,
          isRangeNode: _is.isRangeNode,
          isRelationalNode: _is.isRelationalNode,
          isSymbolNode: _is.isSymbolNode,
          isChain: _is.isChain
        });
        math.config = (0, _config.configFactory)(configInternal, math.emit);
        math.expression = {
          transform: {},
          mathWithTransform: {
            config: math.config
          }
        };
        var legacyFactories = [];
        var legacyInstances = [];
        function load(factory2) {
          if ((0, _factory.isFactory)(factory2)) {
            return factory2(math);
          }
          var firstProperty = factory2[Object.keys(factory2)[0]];
          if ((0, _factory.isFactory)(firstProperty)) {
            return firstProperty(math);
          }
          if (!(0, _object.isLegacyFactory)(factory2)) {
            console.warn("Factory object with properties `type`, `name`, and `factory` expected", factory2);
            throw new Error("Factory object with properties `type`, `name`, and `factory` expected");
          }
          var index = legacyFactories.indexOf(factory2);
          var instance;
          if (index === -1) {
            if (factory2.math === true) {
              instance = factory2.factory(math.type, configInternal, load, math.typed, math);
            } else {
              instance = factory2.factory(math.type, configInternal, load, math.typed);
            }
            legacyFactories.push(factory2);
            legacyInstances.push(instance);
          } else {
            instance = legacyInstances[index];
          }
          return instance;
        }
        var importedFactories = {};
        function lazyTyped() {
          for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
            args[_key] = arguments[_key];
          }
          return math.typed.apply(math.typed, args);
        }
        lazyTyped.isTypedFunction = _typedFunction["default"].isTypedFunction;
        var internalImport = (0, _import.importFactory)(lazyTyped, load, math, importedFactories);
        math["import"] = internalImport;
        math.on("config", function() {
          Object.values(importedFactories).forEach(function(factory2) {
            if (factory2 && factory2.meta && factory2.meta.recreateOnConfigChange) {
              internalImport(factory2, {
                override: true
              });
            }
          });
        });
        math.create = create.bind(null, factories);
        math.factory = _factory.factory;
        math["import"](Object.values((0, _object.deepFlatten)(factories)));
        math.ArgumentsError = _ArgumentsError.ArgumentsError;
        math.DimensionError = _DimensionError.DimensionError;
        math.IndexError = _IndexError.IndexError;
        return math;
      }
    }
  });

  // node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/entry/mainAny.js
  var require_mainAny = __commonJS({
    "node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/entry/mainAny.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      var _exportNames = {
        config: true,
        IndexError: true,
        DimensionError: true,
        ArgumentsError: true,
        create: true,
        factory: true
      };
      Object.defineProperty(exports, "ArgumentsError", {
        enumerable: true,
        get: function get() {
          return _ArgumentsError.ArgumentsError;
        }
      });
      Object.defineProperty(exports, "DimensionError", {
        enumerable: true,
        get: function get() {
          return _DimensionError.DimensionError;
        }
      });
      Object.defineProperty(exports, "IndexError", {
        enumerable: true,
        get: function get() {
          return _IndexError.IndexError;
        }
      });
      Object.defineProperty(exports, "config", {
        enumerable: true,
        get: function get() {
          return _configReadonly.config;
        }
      });
      Object.defineProperty(exports, "create", {
        enumerable: true,
        get: function get() {
          return _create.create;
        }
      });
      Object.defineProperty(exports, "factory", {
        enumerable: true,
        get: function get() {
          return _factory.factory;
        }
      });
      var _configReadonly = require_configReadonly();
      var _pureFunctionsAnyGenerated = require_pureFunctionsAny_generated();
      Object.keys(_pureFunctionsAnyGenerated).forEach(function(key) {
        if (key === "default" || key === "__esModule") return;
        if (Object.prototype.hasOwnProperty.call(_exportNames, key)) return;
        if (key in exports && exports[key] === _pureFunctionsAnyGenerated[key]) return;
        Object.defineProperty(exports, key, {
          enumerable: true,
          get: function get() {
            return _pureFunctionsAnyGenerated[key];
          }
        });
      });
      var _impureFunctionsAnyGenerated = require_impureFunctionsAny_generated();
      Object.keys(_impureFunctionsAnyGenerated).forEach(function(key) {
        if (key === "default" || key === "__esModule") return;
        if (Object.prototype.hasOwnProperty.call(_exportNames, key)) return;
        if (key in exports && exports[key] === _impureFunctionsAnyGenerated[key]) return;
        Object.defineProperty(exports, key, {
          enumerable: true,
          get: function get() {
            return _impureFunctionsAnyGenerated[key];
          }
        });
      });
      var _typeChecks = require_typeChecks();
      Object.keys(_typeChecks).forEach(function(key) {
        if (key === "default" || key === "__esModule") return;
        if (Object.prototype.hasOwnProperty.call(_exportNames, key)) return;
        if (key in exports && exports[key] === _typeChecks[key]) return;
        Object.defineProperty(exports, key, {
          enumerable: true,
          get: function get() {
            return _typeChecks[key];
          }
        });
      });
      var _IndexError = require_IndexError();
      var _DimensionError = require_DimensionError();
      var _ArgumentsError = require_ArgumentsError();
      var _dependenciesAnyGenerated = require_dependenciesAny_generated();
      Object.keys(_dependenciesAnyGenerated).forEach(function(key) {
        if (key === "default" || key === "__esModule") return;
        if (Object.prototype.hasOwnProperty.call(_exportNames, key)) return;
        if (key in exports && exports[key] === _dependenciesAnyGenerated[key]) return;
        Object.defineProperty(exports, key, {
          enumerable: true,
          get: function get() {
            return _dependenciesAnyGenerated[key];
          }
        });
      });
      var _factoriesAny = require_factoriesAny();
      Object.keys(_factoriesAny).forEach(function(key) {
        if (key === "default" || key === "__esModule") return;
        if (Object.prototype.hasOwnProperty.call(_exportNames, key)) return;
        if (key in exports && exports[key] === _factoriesAny[key]) return;
        Object.defineProperty(exports, key, {
          enumerable: true,
          get: function get() {
            return _factoriesAny[key];
          }
        });
      });
      var _create = require_create();
      var _factory = require_factory();
    }
  });

  // node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/index.js
  var require_cjs = __commonJS({
    "node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/cjs/index.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      var _mainAny = require_mainAny();
      Object.keys(_mainAny).forEach(function(key) {
        if (key === "default" || key === "__esModule") return;
        if (key in exports && exports[key] === _mainAny[key]) return;
        Object.defineProperty(exports, key, {
          enumerable: true,
          get: function get() {
            return _mainAny[key];
          }
        });
      });
    }
  });

  // dist/core/types.js
  var require_types = __commonJS({
    "dist/core/types.js"(exports) {
      "use strict";
      var __createBinding = exports && exports.__createBinding || (Object.create ? (function(o, m, k, k2) {
        if (k2 === void 0) k2 = k;
        var desc = Object.getOwnPropertyDescriptor(m, k);
        if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
          desc = { enumerable: true, get: function() {
            return m[k];
          } };
        }
        Object.defineProperty(o, k2, desc);
      }) : (function(o, m, k, k2) {
        if (k2 === void 0) k2 = k;
        o[k2] = m[k];
      }));
      var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? (function(o, v) {
        Object.defineProperty(o, "default", { enumerable: true, value: v });
      }) : function(o, v) {
        o["default"] = v;
      });
      var __importStar = exports && exports.__importStar || /* @__PURE__ */ (function() {
        var ownKeys = function(o) {
          ownKeys = Object.getOwnPropertyNames || function(o2) {
            var ar = [];
            for (var k in o2) if (Object.prototype.hasOwnProperty.call(o2, k)) ar[ar.length] = k;
            return ar;
          };
          return ownKeys(o);
        };
        return function(mod2) {
          if (mod2 && mod2.__esModule) return mod2;
          var result = {};
          if (mod2 != null) {
            for (var k = ownKeys(mod2), i = 0; i < k.length; i++) if (k[i] !== "default") __createBinding(result, mod2, k[i]);
          }
          __setModuleDefault(result, mod2);
          return result;
        };
      })();
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.toComplex = toComplex;
      exports.ensureComplex = ensureComplex;
      exports.isState = isState;
      exports.isOperator = isOperator;
      exports.isDensityMatrix = isDensityMatrix;
      exports.adjoint = adjoint;
      exports.norm = norm;
      exports.getObjectType = getObjectType;
      var math = __importStar(require_cjs());
      function toComplex(value) {
        if (typeof value === "number") {
          return math.complex(value, 0);
        }
        if ("re" in value && "im" in value) {
          return math.complex(value.re, value.im);
        }
        return value;
      }
      function ensureComplex(value) {
        return toComplex(value);
      }
      function isState(obj) {
        return obj.objectType === "state";
      }
      function isOperator(obj) {
        return obj.objectType === "operator";
      }
      function isDensityMatrix(obj) {
        return "purity" in obj && "vonNeumannEntropy" in obj;
      }
      function adjoint(obj) {
        if (isState(obj)) {
          throw new Error("Adjoint of state vector not implemented - use innerProduct instead");
        }
        return obj.adjoint();
      }
      function norm(obj) {
        return obj.norm();
      }
      function getObjectType(obj) {
        return obj.objectType;
      }
    }
  });

  // dist/utils/validation.js
  var require_validation = __commonJS({
    "dist/utils/validation.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.validatePosDim = validatePosDim;
      exports.validateIdx = validateIdx;
      exports.validateAmps = validateAmps;
      exports.validateNorm = validateNorm;
      exports.validateMatchDims = validateMatchDims;
      exports.validatePartialTrace = validatePartialTrace;
      exports.validateMatDims = validateMatDims;
      function validatePosDim(dim) {
        if (!Number.isInteger(dim)) {
          throw new Error(`Dimension must be an integer, got ${dim}`);
        }
        if (dim <= 0) {
          throw new Error(`Dimension must be positive, got ${dim}`);
        }
      }
      function validateIdx(idx, length) {
        if (!Number.isInteger(idx)) {
          throw new Error(`Index must be an integer, got ${idx}`);
        }
        if (idx < 0 || idx >= length) {
          throw new Error(`Index ${idx} out of bounds [0, ${length})`);
        }
      }
      function validateAmps(amplitudes, dimension) {
        if (amplitudes.length !== dimension) {
          throw new Error("Number of amplitudes must match dimension");
        }
        for (let i = 0; i < amplitudes.length; i++) {
          const amp = amplitudes[i];
          if (typeof amp !== "object" || !("re" in amp) || !("im" in amp) || typeof amp.re !== "number" || typeof amp.im !== "number" || !isFinite(amp.re) || !isFinite(amp.im)) {
            throw new Error(`Invalid complex number at index ${i}`);
          }
        }
      }
      function validateNorm(amplitudes, tolerance = 1e-10) {
        const normSquared = amplitudes.reduce((sum2, amp) => sum2 + amp.re * amp.re + amp.im * amp.im, 0);
        if (Math.abs(normSquared - 1) > tolerance) {
          throw new Error("State vector must be normalized");
        }
      }
      function validateMatchDims(dim1, dim2) {
        if (dim1 !== dim2) {
          throw new Error(`Dimension mismatch: ${dim1} !== ${dim2}`);
        }
      }
      function validatePartialTrace(dims, totalDim, traceOutIndices) {
        const dimProduct = dims.reduce((a, b) => a * b, 1);
        if (dimProduct !== totalDim) {
          throw new Error("Product of subsystem dimensions must equal total dimension");
        }
        if (!traceOutIndices.every((i) => i >= 0 && i < dims.length)) {
          throw new Error("Invalid trace out indices");
        }
        const remainingDim = dims.filter((_, i) => !traceOutIndices.includes(i)).reduce((a, b) => a * b, 1);
        if (remainingDim === 0) {
          throw new Error("Cannot trace out all subsystems");
        }
      }
      function validateMatDims(matrix2) {
        if (!matrix2 || !matrix2[0]) {
          throw new Error("Invalid matrix: empty or undefined");
        }
        const rows = matrix2.length;
        const cols = matrix2[0].length;
        if (rows !== cols) {
          throw new Error("Matrix must be square");
        }
        for (const row of matrix2) {
          if (row.length !== cols) {
            throw new Error("All rows must have same length");
          }
        }
      }
    }
  });

  // dist/states/stateVector.js
  var require_stateVector = __commonJS({
    "dist/states/stateVector.js"(exports) {
      "use strict";
      var __createBinding = exports && exports.__createBinding || (Object.create ? (function(o, m, k, k2) {
        if (k2 === void 0) k2 = k;
        var desc = Object.getOwnPropertyDescriptor(m, k);
        if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
          desc = { enumerable: true, get: function() {
            return m[k];
          } };
        }
        Object.defineProperty(o, k2, desc);
      }) : (function(o, m, k, k2) {
        if (k2 === void 0) k2 = k;
        o[k2] = m[k];
      }));
      var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? (function(o, v) {
        Object.defineProperty(o, "default", { enumerable: true, value: v });
      }) : function(o, v) {
        o["default"] = v;
      });
      var __importStar = exports && exports.__importStar || /* @__PURE__ */ (function() {
        var ownKeys = function(o) {
          ownKeys = Object.getOwnPropertyNames || function(o2) {
            var ar = [];
            for (var k in o2) if (Object.prototype.hasOwnProperty.call(o2, k)) ar[ar.length] = k;
            return ar;
          };
          return ownKeys(o);
        };
        return function(mod2) {
          if (mod2 && mod2.__esModule) return mod2;
          var result = {};
          if (mod2 != null) {
            for (var k = ownKeys(mod2), i = 0; i < k.length; i++) if (k[i] !== "default") __createBinding(result, mod2, k[i]);
          }
          __setModuleDefault(result, mod2);
          return result;
        };
      })();
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.StateVector = void 0;
      var types_1 = require_types();
      var math = __importStar(require_cjs());
      var validation_1 = require_validation();
      var StateVector2 = class _StateVector {
        constructor(dimension, amplitudes, basis, properties) {
          this.objectType = "state";
          (0, validation_1.validatePosDim)(dimension);
          this.dimension = dimension;
          this.amplitudes = amplitudes || Array(dimension).fill(null).map(() => math.complex(0, 0));
          this.basis = basis;
          this.properties = properties;
          if (amplitudes) {
            (0, validation_1.validateAmps)(amplitudes, dimension);
          }
        }
        /**
         * Sets amplitude at specified index
         */
        setState(index, value) {
          (0, validation_1.validateIdx)(index, this.dimension);
          this.amplitudes[index] = value;
        }
        /**
         * Gets amplitude at specified index
         */
        getState(index) {
          (0, validation_1.validateIdx)(index, this.dimension);
          return this.amplitudes[index];
        }
        /**
         * Calculates inner product | with another state
         */
        innerProduct(other) {
          if (this.dimension !== other.dimension) {
            throw new Error("States must have same dimension for inner product");
          }
          let result = math.complex(0, 0);
          for (let i = 0; i < this.dimension; i++) {
            const conj2 = math.conj((0, types_1.toComplex)(this.amplitudes[i]));
            const prod = math.multiply(conj2, (0, types_1.toComplex)(other.amplitudes[i]));
            result = math.add(result, prod);
          }
          return result;
        }
        /**
         * Calculates norm of state vector
         */
        norm() {
          const innerProd = this.innerProduct(this);
          const abs2 = math.abs(innerProd);
          return Math.sqrt(abs2);
        }
        /**
         * Returns normalized version of state vector
         */
        normalize() {
          const currentNorm = this.norm();
          if (currentNorm < 1e-10) {
            throw new Error("Cannot normalize zero state vector");
          }
          const normalizedAmplitudes = this.amplitudes.map((amp) => math.divide((0, types_1.toComplex)(amp), math.complex(currentNorm, 0)));
          return new _StateVector(this.dimension, normalizedAmplitudes, this.basis, this.properties);
        }
        /**
         * Computes tensor product with another state vector
         */
        tensorProduct(other) {
          const newDimension = this.dimension * other.dimension;
          const newAmplitudes = [];
          for (let i = 0; i < this.dimension; i++) {
            for (let j = 0; j < other.dimension; j++) {
              newAmplitudes.push(math.multiply(this.amplitudes[i], other.amplitudes[j]));
            }
          }
          let newBasis;
          if (this.basis && other.basis) {
            newBasis = `${this.basis}\u2297${other.basis}`;
          }
          return new _StateVector(newDimension, newAmplitudes, newBasis, this.properties);
        }
        /**
         * Returns true if state is zero vector
         */
        isZero(tolerance = 1e-10) {
          return this.amplitudes.every((amp) => math.abs(amp) < tolerance);
        }
        /**
         * Get a copy of the amplitudes array
         */
        getAmplitudes() {
          return [...this.amplitudes];
        }
        /**
         * Check if this state vector equals another within tolerance
         */
        equals(other, tolerance = 1e-10) {
          if (this.dimension !== other.dimension) {
            return false;
          }
          return this.amplitudes.every((amp, i) => {
            const diff = math.subtract(amp, other.getState(i));
            const absDiff = math.abs(diff);
            return absDiff < tolerance;
          });
        }
        /**
         * Scale the state vector by a complex number
         * @param factor Complex scaling factor
         * @returns New scaled state vector
         */
        scale(factor) {
          const scaledAmplitudes = this.amplitudes.map((amp) => math.multiply((0, types_1.toComplex)(amp), (0, types_1.toComplex)(factor)));
          return new _StateVector(this.dimension, scaledAmplitudes, this.basis, this.properties ? { ...this.properties } : void 0);
        }
        /**
         * Add another state vector to this one
         * @param other The state vector to add
         * @returns New state vector representing the sum
         */
        add(other) {
          if (this.dimension !== other.dimension) {
            throw new Error(`Cannot add state vectors with different dimensions: ${this.dimension} vs ${other.dimension}`);
          }
          const sumAmplitudes = this.amplitudes.map((amp, i) => math.add((0, types_1.toComplex)(amp), (0, types_1.toComplex)(other.getState(i))));
          let newBasis;
          if (this.basis && other.basis) {
            newBasis = `(${this.basis}) + (${other.basis})`;
          }
          return new _StateVector(this.dimension, sumAmplitudes, newBasis, this.properties ? { ...this.properties } : void 0);
        }
        /**
         * Returns array representation of state vector
         */
        toArray() {
          return [...this.amplitudes];
        }
        /**
         * Returns string representation of state vector
         */
        toString() {
          const components = this.amplitudes.map((amp, i) => {
            if (math.abs(amp) < 1e-10) {
              return "";
            }
            const sign3 = i === 0 ? "" : " + ";
            return `${sign3}${amp.toString()}|${i}\u27E9`;
          }).filter((s) => s !== "").join("");
          return components || "0";
        }
        /**
         * Returns string representation in computational basis |n
         */
        toComputationalString() {
          const components = this.amplitudes.map((amp, i) => {
            if (math.abs(amp) < 1e-10) {
              return "";
            }
            const sign3 = i === 0 ? "" : " + ";
            return `${sign3}${amp.toString()}|${i}\u27E9`;
          }).filter((s) => s !== "").join("");
          return components || "0";
        }
        /**
         * Returns string representation in angular momentum basis |j,m
         * @param j Total angular momentum quantum number
         */
        toAngularString(j) {
          const dim = Math.floor(2 * j + 1);
          if (this.dimension !== dim) {
            throw new Error(`State dimension ${this.dimension} does not match 2j+1 = ${dim}`);
          }
          const components = this.amplitudes.map((amp, n) => {
            if (math.abs(amp) < 1e-10) {
              return "";
            }
            const m = -j + n;
            const sign3 = n === 0 ? "" : " + ";
            return `${sign3}${amp.toString()}|${j},${m}\u27E9`;
          }).filter((s) => s !== "").join("");
          return components || "0";
        }
        /**
         * Creates a computational basis state |i
         */
        static computationalBasis(dimension, index) {
          (0, validation_1.validatePosDim)(dimension);
          (0, validation_1.validateIdx)(index, dimension);
          const amplitudes = Array(dimension).fill(null).map((_, i) => i === index ? math.complex(1, 0) : math.complex(0, 0));
          return new _StateVector(dimension, amplitudes, `|${index}\u27E9`);
        }
        /**
         * Returns array of all computational basis states
         */
        static computationalBasisStates(dimension) {
          (0, validation_1.validatePosDim)(dimension);
          return Array(dimension).fill(null).map((_, i) => _StateVector.computationalBasis(dimension, i));
        }
        /**
         * Creates normalized superposition of basis states with given coefficients
         */
        static superposition(coefficients) {
          const dimension = coefficients.length;
          (0, validation_1.validatePosDim)(dimension);
          return new _StateVector(dimension, coefficients, "superposition").normalize();
        }
        /**
         * Creates an equally weighted superposition of all basis states
         */
        static equalSuperposition(dimension) {
          (0, validation_1.validatePosDim)(dimension);
          const coefficient = math.complex(1 / Math.sqrt(dimension), 0);
          const coefficients = Array(dimension).fill(coefficient);
          return new _StateVector(dimension, coefficients, "|+\u27E9");
        }
        /**
        * Sets angular momentum metadata for this state
        */
        setAngularMomentumMetadata(metadata) {
          if (!this.properties) {
            this.properties = {};
          }
          this.properties.angularMomentumMetadata = metadata;
        }
        /**
         * Gets angular momentum metadata if present
         */
        getAngularMomentumMetadata() {
          return this.properties?.angularMomentumMetadata || null;
        }
        /**
         * Checks if this state has angular momentum structure
         */
        hasAngularMomentumStructure() {
          const metadata = this.getAngularMomentumMetadata();
          return metadata?.type === "angular_momentum";
        }
      };
      exports.StateVector = StateVector2;
    }
  });

  // dist/states/states.js
  var require_states = __commonJS({
    "dist/states/states.js"(exports) {
      "use strict";
      var __createBinding = exports && exports.__createBinding || (Object.create ? (function(o, m, k, k2) {
        if (k2 === void 0) k2 = k;
        var desc = Object.getOwnPropertyDescriptor(m, k);
        if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
          desc = { enumerable: true, get: function() {
            return m[k];
          } };
        }
        Object.defineProperty(o, k2, desc);
      }) : (function(o, m, k, k2) {
        if (k2 === void 0) k2 = k;
        o[k2] = m[k];
      }));
      var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? (function(o, v) {
        Object.defineProperty(o, "default", { enumerable: true, value: v });
      }) : function(o, v) {
        o["default"] = v;
      });
      var __importStar = exports && exports.__importStar || /* @__PURE__ */ (function() {
        var ownKeys = function(o) {
          ownKeys = Object.getOwnPropertyNames || function(o2) {
            var ar = [];
            for (var k in o2) if (Object.prototype.hasOwnProperty.call(o2, k)) ar[ar.length] = k;
            return ar;
          };
          return ownKeys(o);
        };
        return function(mod2) {
          if (mod2 && mod2.__esModule) return mod2;
          var result = {};
          if (mod2 != null) {
            for (var k = ownKeys(mod2), i = 0; i < k.length; i++) if (k[i] !== "default") __createBinding(result, mod2, k[i]);
          }
          __setModuleDefault(result, mod2);
          return result;
        };
      })();
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.computationalBasis = computationalBasis;
      exports.createBasisState = createBasisState2;
      exports.createBellState = createBellState2;
      exports.createGHZState = createGHZState2;
      exports.createWState = createWState2;
      exports.createPlusState = createPlusState2;
      exports.createMinusState = createMinusState;
      var stateVector_1 = require_stateVector();
      var math = __importStar(require_cjs());
      function computationalBasis(numQubits) {
        if (numQubits < 1) {
          throw new Error("Number of qubits must be positive");
        }
        const dimension = 2 ** numQubits;
        const basis = [];
        for (let i = 0; i < dimension; i++) {
          const state = new stateVector_1.StateVector(dimension);
          state.setState(i, math.complex(1, 0));
          basis.push(state);
        }
        return basis;
      }
      function createBasisState2(dimension, index) {
        if (index < 0 || index >= dimension) {
          throw new Error(`Index ${index} out of bounds for dimension ${dimension}`);
        }
        const state = new stateVector_1.StateVector(dimension);
        state.setState(index, math.complex(1, 0));
        return state;
      }
      function createBellState2(type) {
        const state = new stateVector_1.StateVector(4);
        switch (type) {
          case "Phi+":
            state.setState(0, math.complex(1 / Math.sqrt(2), 0));
            state.setState(3, math.complex(1 / Math.sqrt(2), 0));
            break;
          case "Phi-":
            state.setState(0, math.complex(1 / Math.sqrt(2), 0));
            state.setState(3, math.complex(-1 / Math.sqrt(2), 0));
            break;
          case "Psi+":
            state.setState(1, math.complex(1 / Math.sqrt(2), 0));
            state.setState(2, math.complex(1 / Math.sqrt(2), 0));
            break;
          case "Psi-":
            state.setState(1, math.complex(1 / Math.sqrt(2), 0));
            state.setState(2, math.complex(-1 / Math.sqrt(2), 0));
            break;
        }
        return state;
      }
      function createGHZState2(numQubits) {
        if (numQubits < 2) {
          throw new Error("GHZ state requires at least 2 qubits");
        }
        const dimension = 2 ** numQubits;
        const state = new stateVector_1.StateVector(dimension);
        state.setState(0, math.complex(1 / Math.sqrt(2), 0));
        state.setState(dimension - 1, math.complex(1 / Math.sqrt(2), 0));
        return state;
      }
      function createWState2(numQubits) {
        if (numQubits < 2) {
          throw new Error("W state requires at least 2 qubits");
        }
        const dimension = 2 ** numQubits;
        const state = new stateVector_1.StateVector(dimension);
        const amplitude = math.complex(1 / Math.sqrt(numQubits), 0);
        for (let i = 0; i < numQubits; i++) {
          const index = 2 ** i;
          state.setState(index, amplitude);
        }
        return state;
      }
      function createPlusState2() {
        const state = new stateVector_1.StateVector(2);
        const amplitude = math.complex(1 / Math.sqrt(2), 0);
        state.setState(0, amplitude);
        state.setState(1, amplitude);
        return state;
      }
      function createMinusState() {
        const state = new stateVector_1.StateVector(2);
        state.setState(0, math.complex(1 / Math.sqrt(2), 0));
        state.setState(1, math.complex(-1 / Math.sqrt(2), 0));
        return state;
      }
    }
  });

  // dist/states/composite.js
  var require_composite = __commonJS({
    "dist/states/composite.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.composeSpaces = composeSpaces;
      exports.composeStates = composeStates;
      exports.composeOperators = composeOperators;
      exports.bipartiteSplit = bipartiteSplit;
      exports.partialTrace = partialTrace;
      var stateVector_1 = require_stateVector();
      var validation_1 = require_validation();
      function composeSpaces(spaces) {
        if (spaces.length === 0) {
          throw new Error("Empty spaces array");
        }
        return spaces.reduce((acc, space) => acc.tensorProduct(space));
      }
      function composeStates(states) {
        if (states.length === 0) {
          throw new Error("Empty states array");
        }
        const stateVectors = states.map((state) => state instanceof stateVector_1.StateVector ? state : new stateVector_1.StateVector(state.dimension, state.amplitudes, state.basis));
        return stateVectors.reduce((acc, state) => acc.tensorProduct(state));
      }
      function composeOperators(operators) {
        if (operators.length === 0) {
          throw new Error("Empty operators array");
        }
        const [first, ...rest] = operators;
        return rest.reduce((acc, op) => acc.tensorProduct(op), first);
      }
      function bipartiteSplit(space, firstDimension) {
        const totalDim = space.dimension;
        if (totalDim % firstDimension !== 0) {
          throw new Error("First dimension must divide total dimension");
        }
        const secondDimension = totalDim / firstDimension;
        return space.decompose([firstDimension, secondDimension]);
      }
      function partialTrace(operator, dims, traceOutIndices) {
        (0, validation_1.validatePartialTrace)(dims, operator.dimension, traceOutIndices);
        return operator.partialTrace(dims, traceOutIndices);
      }
    }
  });

  // dist/utils/matrixOperations.js
  var require_matrixOperations = __commonJS({
    "dist/utils/matrixOperations.js"(exports) {
      "use strict";
      var __createBinding = exports && exports.__createBinding || (Object.create ? (function(o, m, k, k2) {
        if (k2 === void 0) k2 = k;
        var desc = Object.getOwnPropertyDescriptor(m, k);
        if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
          desc = { enumerable: true, get: function() {
            return m[k];
          } };
        }
        Object.defineProperty(o, k2, desc);
      }) : (function(o, m, k, k2) {
        if (k2 === void 0) k2 = k;
        o[k2] = m[k];
      }));
      var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? (function(o, v) {
        Object.defineProperty(o, "default", { enumerable: true, value: v });
      }) : function(o, v) {
        o["default"] = v;
      });
      var __importStar = exports && exports.__importStar || /* @__PURE__ */ (function() {
        var ownKeys = function(o) {
          ownKeys = Object.getOwnPropertyNames || function(o2) {
            var ar = [];
            for (var k in o2) if (Object.prototype.hasOwnProperty.call(o2, k)) ar[ar.length] = k;
            return ar;
          };
          return ownKeys(o);
        };
        return function(mod2) {
          if (mod2 && mod2.__esModule) return mod2;
          var result = {};
          if (mod2 != null) {
            for (var k = ownKeys(mod2), i = 0; i < k.length; i++) if (k[i] !== "default") __createBinding(result, mod2, k[i]);
          }
          __setModuleDefault(result, mod2);
          return result;
        };
      })();
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.multiplyMatrices = multiplyMatrices;
      exports.adjoint = adjoint;
      exports.transpose = transpose;
      exports.matrixExponential = matrixExponential;
      exports.tensorProduct = tensorProduct;
      exports.eigenDecomposition = eigenDecomposition;
      exports.zeroMatrix = zeroMatrix;
      exports.addMatrices = addMatrices;
      exports.normalizeMatrix = normalizeMatrix;
      exports.scaleMatrix = scaleMatrix;
      exports.isHermitian = isHermitian;
      exports.isUnitary = isUnitary;
      exports.orthogonalizeStateVectors = orthogonalizeStateVectors;
      var math = __importStar(require_cjs());
      var stateVector_1 = require_stateVector();
      var NUMERICAL_THRESHOLD = 1e-10;
      function validateMatrix(matrix2) {
        if (!Array.isArray(matrix2) || matrix2.length === 0) {
          return { valid: false, error: "Matrix must be non-empty array" };
        }
        const cols = matrix2[0]?.length;
        if (!cols) {
          return { valid: false, error: "Matrix must have at least one column" };
        }
        for (let i = 0; i < matrix2.length; i++) {
          if (!Array.isArray(matrix2[i]) || matrix2[i].length !== cols) {
            return { valid: false, error: `Inconsistent row length at row ${i}` };
          }
          for (let j = 0; j < cols; j++) {
            const element = matrix2[i][j];
            if (!element || typeof element.re !== "number" || typeof element.im !== "number" || isNaN(element.re) || isNaN(element.im)) {
              return { valid: false, error: `Invalid complex number at position [${i},${j}]` };
            }
          }
        }
        return { valid: true };
      }
      function validateMultiplicationDimensions(a, b) {
        if (!a[0] || !b[0]) {
          return { valid: false, error: "Empty matrix provided" };
        }
        if (a[0].length !== b.length) {
          return {
            valid: false,
            error: `Invalid dimensions for multiplication: ${a.length}x${a[0].length} and ${b.length}x${b[0].length}`
          };
        }
        return { valid: true };
      }
      function validateSquareMatrix(matrix2) {
        if (!matrix2[0] || matrix2.length !== matrix2[0].length) {
          return { valid: false, error: "Matrix must be square" };
        }
        return { valid: true };
      }
      function cleanupNumericalNoise(value, precision = NUMERICAL_THRESHOLD) {
        return Math.abs(value) < precision ? 0 : value;
      }
      function toMathMatrix(matrix2) {
        return math.matrix(matrix2.map((row) => row.map((x) => math.complex(x.re, x.im))));
      }
      function fromMathMatrix(matrix2) {
        const data = matrix2.valueOf();
        return data.map((row) => row.map((elem) => math.complex(cleanupNumericalNoise(elem.re), cleanupNumericalNoise(elem.im))));
      }
      function multiplyMatrices(a, b) {
        const validationA = validateMatrix(a);
        if (!validationA.valid) {
          throw new Error(`First matrix invalid: ${validationA.error}`);
        }
        const validationB = validateMatrix(b);
        if (!validationB.valid) {
          throw new Error(`Second matrix invalid: ${validationB.error}`);
        }
        const dimValidation = validateMultiplicationDimensions(a, b);
        if (!dimValidation.valid) {
          throw new Error(dimValidation.error);
        }
        const matA = toMathMatrix(a);
        const matB = toMathMatrix(b);
        const result = math.multiply(matA, matB);
        return fromMathMatrix(result);
      }
      function adjoint(matrix2) {
        const validation = validateMatrix(matrix2);
        if (!validation.valid) {
          throw new Error(`Invalid matrix: ${validation.error}`);
        }
        return matrix2[0].map((_, colIndex) => matrix2.map((row, rowIndex) => math.complex(matrix2[rowIndex][colIndex].re, -matrix2[rowIndex][colIndex].im)));
      }
      function transpose(matrix2) {
        const validation = validateMatrix(matrix2);
        if (!validation.valid) {
          throw new Error(`Invalid matrix: ${validation.error}`);
        }
        const rows = matrix2.length;
        const cols = matrix2[0].length;
        const result = Array(cols).fill(null).map(() => Array(rows).fill(null));
        for (let i = 0; i < rows; i++) {
          for (let j = 0; j < cols; j++) {
            result[j][i] = matrix2[i][j];
          }
        }
        return result;
      }
      function matrixExponential(matrix2) {
        const validation = validateMatrix(matrix2);
        if (!validation.valid) {
          throw new Error(`Invalid matrix: ${validation.error}`);
        }
        const squareValidation = validateSquareMatrix(matrix2);
        if (!squareValidation.valid) {
          throw new Error(squareValidation.error);
        }
        const mathMatrix = toMathMatrix(matrix2);
        const result = math.expm(mathMatrix);
        return fromMathMatrix(result);
      }
      function tensorProduct(a, b) {
        const validationA = validateMatrix(a);
        if (!validationA.valid) {
          throw new Error(`First matrix invalid: ${validationA.error}`);
        }
        const validationB = validateMatrix(b);
        if (!validationB.valid) {
          throw new Error(`Second matrix invalid: ${validationB.error}`);
        }
        const matA = toMathMatrix(a);
        const matB = toMathMatrix(b);
        const result = math.kron(matA, matB);
        return fromMathMatrix(result);
      }
      function eigenDecomposition(matrix2, options = {}) {
        const validation = validateMatrix(matrix2);
        if (!validation.valid) {
          throw new Error(`Invalid matrix: ${validation.error}`);
        }
        const squareValidation = validateSquareMatrix(matrix2);
        if (!squareValidation.valid) {
          throw new Error(`Matrix must be square for eigendecomposition: ${squareValidation.error}`);
        }
        const mathMatrix = toMathMatrix(matrix2);
        try {
          const result = math.eigs(mathMatrix);
          const values = result.values.valueOf();
          const complexValues = values.map((v) => {
            if (typeof v === "number") {
              return math.complex(v, 0);
            }
            return v;
          });
          if (!options.computeEigenvectors) {
            return { values: complexValues };
          }
          let vectors;
          try {
            const eigenvectors = result.eigenvectors;
            const sortedEigenvectors = eigenvectors.sort((a, b) => {
              const aVal = math.isNumber(a.value) ? a.value : math.isComplex(a.value) ? a.value.re : Number(a.value.toString());
              const bVal = math.isNumber(b.value) ? b.value : math.isComplex(b.value) ? b.value.re : Number(b.value.toString());
              return aVal - bVal;
            });
            vectors = sortedEigenvectors.map((entry) => {
              const vectorData = entry.vector.valueOf();
              return vectorData.map((v) => {
                if (typeof v === "number") {
                  return math.complex(v, 0);
                }
                return v;
              });
            });
            if (options.enforceOrthogonality && vectors) {
              vectors = normalizeVectors(vectors);
            }
          } catch (error) {
            if (error instanceof Error) {
              console.warn(`Eigenvector computation warning: ${error.message}`);
            } else {
              console.warn("Unknown eigenvector computation error");
            }
            return { values: complexValues };
          }
          return {
            values: complexValues,
            vectors
          };
        } catch (error) {
          if (error instanceof Error) {
            throw new Error(`Eigendecomposition failed: ${error.message}`);
          } else {
            throw new Error("Unknown eigendecomposition error");
          }
        }
      }
      function zeroMatrix(rows, cols) {
        const matrix2 = math.zeros(rows, cols);
        return matrix2;
      }
      function normalizeVectors(vectors) {
        const n = vectors.length;
        let normalized = vectors.map((vector) => {
          const normSquared = vector.reduce((sum2, v) => {
            const abs2 = Number(math.abs(v));
            return sum2 + abs2 * abs2;
          }, 0);
          const norm = Math.sqrt(normSquared);
          return vector.map((v) => math.divide(v, norm));
        });
        if (n === 2) {
          const sign1 = Math.sign(normalized[0][0].re);
          const sign22 = Math.sign(normalized[1][0].re);
          const signProduct = sign1 * sign22;
          if (signProduct > 0) {
            normalized[1] = normalized[1].map((v) => math.multiply(v, -1));
          }
        } else {
          normalized = normalized.map((vector) => {
            const maxMagnitudeIdx = vector.reduce((maxIdx, v, idx) => {
              const currentMag = Math.sqrt(v.re * v.re + v.im * v.im);
              const maxMag = Math.sqrt(vector[maxIdx].re * vector[maxIdx].re + vector[maxIdx].im * vector[maxIdx].im);
              return currentMag > maxMag ? idx : maxIdx;
            }, 0);
            const maxComponent = vector[maxMagnitudeIdx];
            const currentPhase = math.arg(maxComponent);
            const correction = math.exp(-currentPhase);
            return vector.map((v) => math.multiply(v, correction));
          });
        }
        return normalized;
      }
      function orthogonalizeDegenerateEigenvectors(groups, precision) {
        const orthogonalVectors = [];
        Array.from(groups.values()).forEach((vectors) => {
          if (vectors.length > 1) {
            for (let i = 0; i < vectors.length; i++) {
              let vi = vectors[i];
              for (let j = 0; j < i; j++) {
                const vj = vectors[j];
                const proj = computeProjection(vi, vj);
                vi = subtractVectors(vi, proj);
              }
              const norm = vectorNorm(vi);
              if (norm > precision) {
                orthogonalVectors.push(vi);
              }
            }
          } else {
            orthogonalVectors.push(vectors[0]);
          }
        });
        return orthogonalVectors;
      }
      function computeProjection(v, u) {
        const uDotU = innerProduct(u, u);
        const vDotU = innerProduct(v, u);
        const scalar = math.divide(vDotU, uDotU);
        return u.map((ui) => math.multiply(ui, scalar));
      }
      function innerProduct(v, u) {
        return v.reduce((sum2, vi, i) => math.add(sum2, math.multiply(math.conj(vi), u[i])), math.complex(0, 0));
      }
      function subtractVectors(v, u) {
        return v.map((vi, i) => math.subtract(vi, u[i]));
      }
      function vectorNorm(v) {
        const normComplex = math.sqrt(innerProduct(v, v));
        return Math.sqrt(normComplex.re * normComplex.re + normComplex.im * normComplex.im);
      }
      function addMatrices(a, b) {
        const validationA = validateMatrix(a);
        if (!validationA.valid) {
          throw new Error(`First matrix invalid: ${validationA.error}`);
        }
        const validationB = validateMatrix(b);
        if (!validationB.valid) {
          throw new Error(`Second matrix invalid: ${validationB.error}`);
        }
        if (a.length !== b.length || a[0].length !== b[0].length) {
          throw new Error("Matrices must have same dimensions for addition");
        }
        const matA = toMathMatrix(a);
        const matB = toMathMatrix(b);
        const result = math.add(matA, matB);
        return fromMathMatrix(result);
      }
      function normalizeMatrix(matrix2) {
        const validation = validateMatrix(matrix2);
        if (!validation.valid) {
          throw new Error(`Invalid matrix: ${validation.error}`);
        }
        const squareValidation = validateSquareMatrix(matrix2);
        if (!squareValidation.valid) {
          throw new Error(squareValidation.error);
        }
        let trace = math.complex(0, 0);
        for (let i = 0; i < matrix2.length; i++) {
          trace = math.add(trace, matrix2[i][i]);
        }
        if (Math.abs(trace.re) < NUMERICAL_THRESHOLD && Math.abs(trace.im) < NUMERICAL_THRESHOLD) {
          throw new Error("Cannot normalize matrix with zero trace");
        }
        const scalar = math.divide(1, trace);
        return scaleMatrix(matrix2, scalar);
      }
      function scaleMatrix(matrix2, scalar) {
        const validation = validateMatrix(matrix2);
        if (!validation.valid) {
          throw new Error(`Invalid matrix: ${validation.error}`);
        }
        const matM = toMathMatrix(matrix2);
        const s = math.complex(scalar.re, scalar.im);
        const result = math.multiply(matM, s);
        return fromMathMatrix(result);
      }
      function isHermitian(matrix2, tolerance = NUMERICAL_THRESHOLD) {
        const validation = validateMatrix(matrix2);
        if (!validation.valid) {
          throw new Error(`Invalid matrix: ${validation.error}`);
        }
        const squareValidation = validateSquareMatrix(matrix2);
        if (!squareValidation.valid) {
          throw new Error(squareValidation.error);
        }
        const adj = adjoint(matrix2);
        for (let i = 0; i < matrix2.length; i++) {
          for (let j = 0; j < matrix2[0].length; j++) {
            const diff = {
              re: Math.abs(matrix2[i][j].re - adj[i][j].re),
              im: Math.abs(matrix2[i][j].im - adj[i][j].im)
            };
            if (diff.re > tolerance || diff.im > tolerance) {
              return false;
            }
          }
        }
        return true;
      }
      function isUnitary(matrix2, tolerance = NUMERICAL_THRESHOLD) {
        const validation = validateMatrix(matrix2);
        if (!validation.valid) {
          throw new Error(`Invalid matrix: ${validation.error}`);
        }
        const squareValidation = validateSquareMatrix(matrix2);
        if (!squareValidation.valid) {
          throw new Error(squareValidation.error);
        }
        const adj = adjoint(matrix2);
        const product2 = multiplyMatrices(matrix2, adj);
        const n = matrix2.length;
        for (let i = 0; i < n; i++) {
          for (let j = 0; j < n; j++) {
            const expected = i === j ? 1 : 0;
            const diff = {
              re: Math.abs(product2[i][j].re - expected),
              im: Math.abs(product2[i][j].im)
            };
            if (diff.re > tolerance || diff.im > tolerance) {
              return false;
            }
          }
        }
        return true;
      }
      function orthogonalizeStateVectors(stateVectors, precision = NUMERICAL_THRESHOLD) {
        if (stateVectors.length === 0) {
          return [];
        }
        const dimension = stateVectors[0].dimension;
        for (const state of stateVectors) {
          if (state.dimension !== dimension) {
            throw new Error(`All state vectors must have same dimension. Expected ${dimension}, got ${state.dimension}`);
          }
        }
        const complexMatrix = stateVectors.map((state) => state.getAmplitudes());
        const eigenvalues = stateVectors.map(() => math.complex(1, 0));
        const groups = /* @__PURE__ */ new Map();
        groups.set("1,0", complexMatrix);
        const orthogonalizedMatrix = orthogonalizeDegenerateEigenvectors(groups, precision);
        const result = [];
        for (let i = 0; i < orthogonalizedMatrix.length && i < stateVectors.length; i++) {
          const originalState = stateVectors[i];
          const orthogonalizedAmplitudes = orthogonalizedMatrix[i];
          const newState = new stateVector_1.StateVector(dimension, orthogonalizedAmplitudes, originalState.basis ? `orth(${originalState.basis})` : "orthogonalized", originalState.properties);
          result.push(newState);
        }
        return result;
      }
    }
  });

  // dist/operators/sparse.js
  var require_sparse3 = __commonJS({
    "dist/operators/sparse.js"(exports) {
      "use strict";
      var __createBinding = exports && exports.__createBinding || (Object.create ? (function(o, m, k, k2) {
        if (k2 === void 0) k2 = k;
        var desc = Object.getOwnPropertyDescriptor(m, k);
        if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
          desc = { enumerable: true, get: function() {
            return m[k];
          } };
        }
        Object.defineProperty(o, k2, desc);
      }) : (function(o, m, k, k2) {
        if (k2 === void 0) k2 = k;
        o[k2] = m[k];
      }));
      var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? (function(o, v) {
        Object.defineProperty(o, "default", { enumerable: true, value: v });
      }) : function(o, v) {
        o["default"] = v;
      });
      var __importStar = exports && exports.__importStar || /* @__PURE__ */ (function() {
        var ownKeys = function(o) {
          ownKeys = Object.getOwnPropertyNames || function(o2) {
            var ar = [];
            for (var k in o2) if (Object.prototype.hasOwnProperty.call(o2, k)) ar[ar.length] = k;
            return ar;
          };
          return ownKeys(o);
        };
        return function(mod2) {
          if (mod2 && mod2.__esModule) return mod2;
          var result = {};
          if (mod2 != null) {
            for (var k = ownKeys(mod2), i = 0; i < k.length; i++) if (k[i] !== "default") __createBinding(result, mod2, k[i]);
          }
          __setModuleDefault(result, mod2);
          return result;
        };
      })();
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.createSparseMatrix = createSparseMatrix2;
      exports.setSparseEntry = setSparseEntry2;
      exports.getSparseEntry = getSparseEntry;
      exports.sparseVectorMultiply = sparseVectorMultiply;
      exports.sparseMatrixMultiply = sparseMatrixMultiply;
      exports.sparseToDense = sparseToDense;
      exports.denseToSparse = denseToSparse2;
      exports.sparseTranspose = sparseTranspose;
      exports.sparseConjugateTranspose = sparseConjugateTranspose;
      exports.sparseTrace = sparseTrace;
      exports.sparseNorm = sparseNorm;
      exports.isIdentityMatrix = isIdentityMatrix;
      exports.isSparseDiagonalMatrix = isSparseDiagonalMatrix;
      exports.extractDiagonalEntries = extractDiagonalEntries;
      exports.validateSparseMatrix = validateSparseMatrix;
      exports.removeSparseZeros = removeSparseZeros;
      var math = __importStar(require_cjs());
      function createSparseMatrix2(rows, cols) {
        return {
          rows,
          cols,
          entries: [],
          nnz: 0
        };
      }
      function setSparseEntry2(matrix2, row, col, value) {
        const existingIndex = matrix2.entries.findIndex((entry) => entry.row === row && entry.col === col);
        if (existingIndex !== -1) {
          matrix2.entries.splice(existingIndex, 1);
          matrix2.nnz--;
        }
        if (!isZeroComplex(value)) {
          matrix2.entries.push({ row, col, value });
          matrix2.nnz++;
        }
      }
      function getSparseEntry(matrix2, row, col) {
        const entry = matrix2.entries.find((e) => e.row === row && e.col === col);
        return entry ? entry.value : math.complex(0, 0);
      }
      function sparseVectorMultiply(matrix2, vector) {
        if (matrix2.cols !== vector.length) {
          throw new Error(`Matrix columns (${matrix2.cols}) must match vector length (${vector.length})`);
        }
        const result = Array.from({ length: matrix2.rows }, () => math.complex(0, 0));
        for (const entry of matrix2.entries) {
          const product2 = math.multiply(entry.value, vector[entry.col]);
          if (typeof product2 !== "object" || !("re" in product2) || !("im" in product2)) {
            throw new Error("Invalid complex multiplication result");
          }
          result[entry.row] = math.add(result[entry.row], product2);
        }
        return result;
      }
      function sparseMatrixMultiply(a, b) {
        if (a.cols !== b.rows) {
          throw new Error(`Matrix A columns (${a.cols}) must match matrix B rows (${b.rows})`);
        }
        const result = createSparseMatrix2(a.rows, b.cols);
        const bCols = {};
        for (const entry of b.entries) {
          if (!bCols[entry.row]) {
            bCols[entry.row] = [];
          }
          bCols[entry.row].push(entry);
        }
        for (const aEntry of a.entries) {
          const bCol = bCols[aEntry.col];
          if (bCol) {
            for (const bEntry of bCol) {
              const row = aEntry.row;
              const col = bEntry.col;
              const product2 = math.multiply(aEntry.value, bEntry.value);
              const existing = getSparseEntry(result, row, col);
              const sum2 = math.add(existing, product2);
              setSparseEntry2(result, row, col, sum2);
            }
          }
        }
        return result;
      }
      function sparseToDense(matrix2) {
        const dense = Array.from({ length: matrix2.rows }, () => Array.from({ length: matrix2.cols }, () => math.complex(0, 0)));
        for (const entry of matrix2.entries) {
          dense[entry.row][entry.col] = entry.value;
        }
        return dense;
      }
      function denseToSparse2(dense) {
        if (dense.length === 0) {
          return createSparseMatrix2(0, 0);
        }
        const rows = dense.length;
        const cols = dense[0].length;
        if (!dense.every((row) => row.length === cols)) {
          throw new Error("Input matrix must be rectangular (all rows must have same length)");
        }
        const matrix2 = createSparseMatrix2(rows, cols);
        for (let i = 0; i < rows; i++) {
          for (let j = 0; j < cols; j++) {
            if (!isZeroComplex(dense[i][j])) {
              setSparseEntry2(matrix2, i, j, dense[i][j]);
            }
          }
        }
        return matrix2;
      }
      function sparseTranspose(matrix2) {
        const result = createSparseMatrix2(matrix2.cols, matrix2.rows);
        for (const entry of matrix2.entries) {
          setSparseEntry2(result, entry.col, entry.row, entry.value);
        }
        return result;
      }
      function sparseConjugateTranspose(matrix2) {
        const result = createSparseMatrix2(matrix2.cols, matrix2.rows);
        for (const entry of matrix2.entries) {
          const conjugate = math.conj(entry.value);
          setSparseEntry2(result, entry.col, entry.row, conjugate);
        }
        return result;
      }
      function sparseTrace(matrix2) {
        if (matrix2.rows !== matrix2.cols) {
          throw new Error("Trace requires square matrix");
        }
        let trace = math.complex(0, 0);
        for (const entry of matrix2.entries) {
          if (entry.row === entry.col) {
            trace = math.add(trace, entry.value);
          }
        }
        return trace;
      }
      function sparseNorm(matrix2) {
        let sum2 = 0;
        for (const entry of matrix2.entries) {
          const magnitude = Number(math.abs(entry.value));
          sum2 += magnitude * magnitude;
        }
        return Math.sqrt(sum2);
      }
      function isIdentityMatrix(matrix2, tolerance = 1e-12) {
        if (matrix2.rows !== matrix2.cols) {
          return false;
        }
        const n = matrix2.rows;
        if (matrix2.nnz !== n) {
          return false;
        }
        for (const entry of matrix2.entries) {
          if (entry.row !== entry.col) {
            return false;
          }
          const realPart = Number(entry.value.re);
          const imagPart = Number(entry.value.im);
          if (Math.abs(realPart - 1) > tolerance || Math.abs(imagPart) > tolerance) {
            return false;
          }
        }
        return true;
      }
      function isSparseDiagonalMatrix(matrix2) {
        for (const entry of matrix2.entries) {
          if (entry.row !== entry.col) {
            return false;
          }
        }
        return true;
      }
      function extractDiagonalEntries(matrix2) {
        const diagonal = new Array(Math.min(matrix2.rows, matrix2.cols)).fill(0).map(() => math.complex(0, 0));
        for (const entry of matrix2.entries) {
          if (entry.row === entry.col) {
            diagonal[entry.row] = entry.value;
          }
        }
        return diagonal;
      }
      function validateSparseMatrix(matrix2) {
        if (matrix2.rows <= 0 || matrix2.cols <= 0) {
          return false;
        }
        for (const entry of matrix2.entries) {
          if (entry.row < 0 || entry.row >= matrix2.rows || entry.col < 0 || entry.col >= matrix2.cols) {
            return false;
          }
        }
        return matrix2.nnz === matrix2.entries.length;
      }
      function removeSparseZeros(matrix2, tolerance = 1e-12) {
        matrix2.entries = matrix2.entries.filter((entry) => !isZeroComplex(entry.value, tolerance));
        matrix2.nnz = matrix2.entries.length;
      }
      function isZeroComplex(value, tolerance = 1e-12) {
        if (typeof value !== "object" || !("re" in value) || !("im" in value)) {
          throw new Error("Invalid complex number");
        }
        return Math.abs(value.re) < tolerance && Math.abs(value.im) < tolerance;
      }
    }
  });

  // dist/operators/sparseOperator.js
  var require_sparseOperator = __commonJS({
    "dist/operators/sparseOperator.js"(exports) {
      "use strict";
      var __createBinding = exports && exports.__createBinding || (Object.create ? (function(o, m, k, k2) {
        if (k2 === void 0) k2 = k;
        var desc = Object.getOwnPropertyDescriptor(m, k);
        if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
          desc = { enumerable: true, get: function() {
            return m[k];
          } };
        }
        Object.defineProperty(o, k2, desc);
      }) : (function(o, m, k, k2) {
        if (k2 === void 0) k2 = k;
        o[k2] = m[k];
      }));
      var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? (function(o, v) {
        Object.defineProperty(o, "default", { enumerable: true, value: v });
      }) : function(o, v) {
        o["default"] = v;
      });
      var __importStar = exports && exports.__importStar || /* @__PURE__ */ (function() {
        var ownKeys = function(o) {
          ownKeys = Object.getOwnPropertyNames || function(o2) {
            var ar = [];
            for (var k in o2) if (Object.prototype.hasOwnProperty.call(o2, k)) ar[ar.length] = k;
            return ar;
          };
          return ownKeys(o);
        };
        return function(mod2) {
          if (mod2 && mod2.__esModule) return mod2;
          var result = {};
          if (mod2 != null) {
            for (var k = ownKeys(mod2), i = 0; i < k.length; i++) if (k[i] !== "default") __createBinding(result, mod2, k[i]);
          }
          __setModuleDefault(result, mod2);
          return result;
        };
      })();
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.SparseOperator = void 0;
      var stateVector_1 = require_stateVector();
      var sparse_1 = require_sparse3();
      var validation_1 = require_validation();
      var math = __importStar(require_cjs());
      var SparseOperator2 = class _SparseOperator {
        constructor(matrix2, type = "general") {
          this.objectType = "operator";
          this.dimension = matrix2.rows;
          this.type = type;
          this.matrix = matrix2;
        }
        /**
         * Applies operator to state vector: |' = O|
         * O(nnz) complexity
         */
        apply(state) {
          (0, validation_1.validateMatchDims)(state.dimension, this.dimension);
          const resultAmplitudes = (0, sparse_1.sparseVectorMultiply)(this.matrix, state.getAmplitudes());
          return new stateVector_1.StateVector(this.dimension, resultAmplitudes, state.basis);
        }
        /**
         * Performs partial trace operation over specified quantum subsystems
         */
        partialTrace(dims, traceOutIndices) {
          return new operator_1.MatrixOperator(this.toMatrix()).partialTrace(dims, traceOutIndices);
        }
        /**
         * Scales operator by a complex number
         */
        scale(scalar) {
          const scaledMatrix = (0, sparse_1.createSparseMatrix)(this.matrix.rows, this.matrix.cols);
          for (const entry of this.matrix.entries) {
            (0, sparse_1.setSparseEntry)(scaledMatrix, entry.row, entry.col, math.multiply(entry.value, scalar));
          }
          return new _SparseOperator(scaledMatrix, this.type);
        }
        /**
         * Adds this operator with another operator
         */
        add(other) {
          (0, validation_1.validateMatchDims)(other.dimension, this.dimension);
          if (other instanceof _SparseOperator) {
            const resultMatrix = (0, sparse_1.createSparseMatrix)(this.dimension, this.dimension);
            for (const entry of this.matrix.entries) {
              (0, sparse_1.setSparseEntry)(resultMatrix, entry.row, entry.col, entry.value);
            }
            const otherMatrix = other.getSparseMatrix();
            for (const entry of otherMatrix.entries) {
              const existing = (0, sparse_1.getSparseEntry)(resultMatrix, entry.row, entry.col);
              (0, sparse_1.setSparseEntry)(resultMatrix, entry.row, entry.col, math.add(existing, entry.value));
            }
            return new _SparseOperator(resultMatrix);
          }
          return new operator_1.MatrixOperator(this.toMatrix()).add(other);
        }
        /**
         * Returns eigenvalues and eigenvectors of the operator
         */
        eigenDecompose() {
          return new operator_1.MatrixOperator(this.toMatrix()).eigenDecompose();
        }
        /**
         * Composes with another operator: OO
         */
        compose(other) {
          (0, validation_1.validateMatchDims)(other.dimension, this.dimension);
          if (other instanceof _SparseOperator) {
            const resultMatrix = (0, sparse_1.sparseMatrixMultiply)(this.matrix, other.getSparseMatrix());
            return new _SparseOperator(resultMatrix, this.type === other.type ? this.type : "general");
          }
          const denseResult = new operator_1.MatrixOperator(this.toMatrix()).compose(other);
          return denseResult;
        }
        /**
         * Returns the adjoint (Hermitian conjugate) of the operator
         */
        adjoint() {
          const adjointMatrix = (0, sparse_1.sparseConjugateTranspose)(this.matrix);
          return new _SparseOperator(adjointMatrix, this.type);
        }
        /**
         * Returns dense matrix representation
         */
        toMatrix() {
          return (0, sparse_1.sparseToDense)(this.matrix);
        }
        /**
         * Gets the underlying sparse matrix
         */
        getSparseMatrix() {
          return this.matrix;
        }
        /**
         * Computes tensor product with another operator
         */
        tensorProduct(other) {
          const otherDim = other.dimension;
          const newDim = this.dimension * otherDim;
          const result = (0, sparse_1.createSparseMatrix)(newDim, newDim);
          const otherMat = other.toMatrix();
          for (const entry of this.matrix.entries) {
            for (let i2 = 0; i2 < otherDim; i2++) {
              for (let j2 = 0; j2 < otherDim; j2++) {
                const val = math.multiply(entry.value, otherMat[i2][j2]);
                if (math.abs(val) > 1e-12) {
                  (0, sparse_1.setSparseEntry)(result, entry.row * otherDim + i2, entry.col * otherDim + j2, val);
                }
              }
            }
          }
          return new _SparseOperator(result);
        }
        norm() {
          return (0, sparse_1.sparseNorm)(this.matrix);
        }
        isZero(tolerance = 1e-12) {
          return this.matrix.nnz === 0;
        }
      };
      exports.SparseOperator = SparseOperator2;
      var operator_1 = require_operator();
    }
  });

  // dist/operators/specialized.js
  var require_specialized = __commonJS({
    "dist/operators/specialized.js"(exports) {
      "use strict";
      var __createBinding = exports && exports.__createBinding || (Object.create ? (function(o, m, k, k2) {
        if (k2 === void 0) k2 = k;
        var desc = Object.getOwnPropertyDescriptor(m, k);
        if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
          desc = { enumerable: true, get: function() {
            return m[k];
          } };
        }
        Object.defineProperty(o, k2, desc);
      }) : (function(o, m, k, k2) {
        if (k2 === void 0) k2 = k;
        o[k2] = m[k];
      }));
      var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? (function(o, v) {
        Object.defineProperty(o, "default", { enumerable: true, value: v });
      }) : function(o, v) {
        o["default"] = v;
      });
      var __importStar = exports && exports.__importStar || /* @__PURE__ */ (function() {
        var ownKeys = function(o) {
          ownKeys = Object.getOwnPropertyNames || function(o2) {
            var ar = [];
            for (var k in o2) if (Object.prototype.hasOwnProperty.call(o2, k)) ar[ar.length] = k;
            return ar;
          };
          return ownKeys(o);
        };
        return function(mod2) {
          if (mod2 && mod2.__esModule) return mod2;
          var result = {};
          if (mod2 != null) {
            for (var k = ownKeys(mod2), i = 0; i < k.length; i++) if (k[i] !== "default") __createBinding(result, mod2, k[i]);
          }
          __setModuleDefault(result, mod2);
          return result;
        };
      })();
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.DiagonalOperator = exports.IdentityOperator = void 0;
      exports.createIdentityOperator = createIdentityOperator;
      exports.createDiagonalOperator = createDiagonalOperator;
      exports.isDiagonalMatrix = isDiagonalMatrix;
      var stateVector_1 = require_stateVector();
      var validation_1 = require_validation();
      var operator_1 = require_operator();
      var sparseOperator_1 = require_sparseOperator();
      var sparse_1 = require_sparse3();
      var math = __importStar(require_cjs());
      var IdentityOperator = class _IdentityOperator {
        constructor(dimension) {
          this.objectType = "operator";
          this.type = "identity";
          if (dimension <= 0 || !Number.isInteger(dimension)) {
            throw new Error("Dimension must be a positive integer");
          }
          this.dimension = dimension;
        }
        /**
         * Apply identity operator - returns cloned state
         */
        apply(state) {
          (0, validation_1.validateMatchDims)(state.dimension, this.dimension);
          return new stateVector_1.StateVector(state.dimension, [...state.amplitudes], state.basis);
        }
        /**
         * Compose with another operator - returns other operator
         */
        compose(other) {
          (0, validation_1.validateMatchDims)(other.dimension, this.dimension);
          return other;
        }
        /**
         * Adjoint of identity is identity
         */
        adjoint() {
          return new _IdentityOperator(this.dimension);
        }
        /**
         * Generate identity matrix on demand
         */
        toMatrix() {
          return Array(this.dimension).fill(null).map((_, i) => Array(this.dimension).fill(null).map((_2, j) => i === j ? math.complex(1, 0) : math.complex(0, 0)));
        }
        tensorProduct(other) {
          const sparseId = new sparseOperator_1.SparseOperator((0, sparse_1.denseToSparse)(this.toMatrix()), "unitary");
          return sparseId.tensorProduct(other);
        }
        partialTrace(dims, traceOutIndices) {
          return new operator_1.MatrixOperator(this.toMatrix()).partialTrace(dims, traceOutIndices);
        }
        scale(scalar) {
          const diagonal = Array(this.dimension).fill(scalar);
          return new DiagonalOperator(diagonal);
        }
        add(other) {
          const { MatrixOperator: MatrixOperator2 } = require_operator();
          return new MatrixOperator2(this.toMatrix()).add(other);
        }
        eigenDecompose() {
          const { MatrixOperator: MatrixOperator2 } = require_operator();
          return new MatrixOperator2(this.toMatrix()).eigenDecompose();
        }
        norm() {
          return Math.sqrt(this.dimension);
        }
        isZero() {
          return false;
        }
      };
      exports.IdentityOperator = IdentityOperator;
      var DiagonalOperator = class _DiagonalOperator {
        constructor(diagonal) {
          this.objectType = "operator";
          this.type = "diagonal";
          if (diagonal.length === 0) {
            throw new Error("Diagonal cannot be empty");
          }
          this.dimension = diagonal.length;
          this.diagonal = diagonal.map((val) => math.clone(val));
        }
        /**
         * Apply diagonal operator - element-wise multiplication
         */
        apply(state) {
          (0, validation_1.validateMatchDims)(state.dimension, this.dimension);
          const newAmplitudes = state.amplitudes.map((amp, i) => math.multiply(amp, this.diagonal[i]));
          return new stateVector_1.StateVector(this.dimension, newAmplitudes, state.basis);
        }
        /**
         * Compose with another operator
         */
        compose(other) {
          (0, validation_1.validateMatchDims)(other.dimension, this.dimension);
          if (other.type === "diagonal") {
            const otherDiagonal = other.getDiagonal();
            const resultDiagonal = this.diagonal.map((val, i) => math.multiply(val, otherDiagonal[i]));
            return new _DiagonalOperator(resultDiagonal);
          }
          const { MatrixOperator: MatrixOperator2 } = require_operator();
          return new MatrixOperator2(this.toMatrix()).compose(other);
        }
        /**
         * Adjoint of diagonal operator
         */
        adjoint() {
          const conjugateDiagonal = this.diagonal.map((val) => math.conj(val));
          return new _DiagonalOperator(conjugateDiagonal);
        }
        /**
         * Generate full matrix on demand
         */
        toMatrix() {
          return Array(this.dimension).fill(null).map((_, i) => Array(this.dimension).fill(null).map((_2, j) => i === j ? math.clone(this.diagonal[i]) : math.complex(0, 0)));
        }
        tensorProduct(other) {
          const sparseDiag = new sparseOperator_1.SparseOperator((0, sparse_1.denseToSparse)(this.toMatrix()), "diagonal");
          return sparseDiag.tensorProduct(other);
        }
        partialTrace(dims, traceOutIndices) {
          return new operator_1.MatrixOperator(this.toMatrix()).partialTrace(dims, traceOutIndices);
        }
        scale(scalar) {
          const scaledDiagonal = this.diagonal.map((val) => math.multiply(val, scalar));
          return new _DiagonalOperator(scaledDiagonal);
        }
        add(other) {
          if (other.type === "diagonal") {
            const otherDiagonal = other.getDiagonal();
            const sumDiagonal = this.diagonal.map((val, i) => math.add(val, otherDiagonal[i]));
            return new _DiagonalOperator(sumDiagonal);
          }
          const { MatrixOperator: MatrixOperator2 } = require_operator();
          return new MatrixOperator2(this.toMatrix()).add(other);
        }
        eigenDecompose() {
          const { MatrixOperator: MatrixOperator2 } = require_operator();
          return new MatrixOperator2(this.toMatrix()).eigenDecompose();
        }
        norm() {
          return Math.sqrt(this.diagonal.reduce((sum2, val) => {
            const magnitude = Number(math.abs(val));
            return sum2 + magnitude * magnitude;
          }, 0));
        }
        isZero(tolerance = 1e-12) {
          return this.diagonal.every((val) => Math.abs(val.re) < tolerance && Math.abs(val.im) < tolerance);
        }
        /**
         * Get diagonal elements
         */
        getDiagonal() {
          return this.diagonal.map((val) => math.clone(val));
        }
      };
      exports.DiagonalOperator = DiagonalOperator;
      function createIdentityOperator(dimension) {
        return new IdentityOperator(dimension);
      }
      function createDiagonalOperator(diagonal) {
        return new DiagonalOperator(diagonal);
      }
      function isDiagonalMatrix(matrix2, tolerance = 1e-12) {
        for (let i = 0; i < matrix2.length; i++) {
          for (let j = 0; j < matrix2[i].length; j++) {
            if (i !== j) {
              const element = matrix2[i][j];
              if (Math.abs(element.re) > tolerance || Math.abs(element.im) > tolerance) {
                return false;
              }
            }
          }
        }
        return true;
      }
    }
  });

  // dist/operators/operator.js
  var require_operator = __commonJS({
    "dist/operators/operator.js"(exports) {
      "use strict";
      var __createBinding = exports && exports.__createBinding || (Object.create ? (function(o, m, k, k2) {
        if (k2 === void 0) k2 = k;
        var desc = Object.getOwnPropertyDescriptor(m, k);
        if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
          desc = { enumerable: true, get: function() {
            return m[k];
          } };
        }
        Object.defineProperty(o, k2, desc);
      }) : (function(o, m, k, k2) {
        if (k2 === void 0) k2 = k;
        o[k2] = m[k];
      }));
      var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? (function(o, v) {
        Object.defineProperty(o, "default", { enumerable: true, value: v });
      }) : function(o, v) {
        o["default"] = v;
      });
      var __importStar = exports && exports.__importStar || /* @__PURE__ */ (function() {
        var ownKeys = function(o) {
          ownKeys = Object.getOwnPropertyNames || function(o2) {
            var ar = [];
            for (var k in o2) if (Object.prototype.hasOwnProperty.call(o2, k)) ar[ar.length] = k;
            return ar;
          };
          return ownKeys(o);
        };
        return function(mod2) {
          if (mod2 && mod2.__esModule) return mod2;
          var result = {};
          if (mod2 != null) {
            for (var k = ownKeys(mod2), i = 0; i < k.length; i++) if (k[i] !== "default") __createBinding(result, mod2, k[i]);
          }
          __setModuleDefault(result, mod2);
          return result;
        };
      })();
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.MatrixOperator = void 0;
      exports.createZeroMatrix = createZeroMatrix;
      var stateVector_1 = require_stateVector();
      var validation_1 = require_validation();
      var matrixOperations_1 = require_matrixOperations();
      var specialized_1 = require_specialized();
      var sparseOperator_1 = require_sparseOperator();
      var sparse_1 = require_sparse3();
      var math = __importStar(require_cjs());
      function ensureComplex(value) {
        if (typeof value === "number") {
          return math.complex(value, 0);
        }
        if (math.typeOf(value) === "Complex") {
          return value;
        }
        if (typeof value === "object" && value !== null && "re" in value && "im" in value) {
          return math.complex(value.re, value.im);
        }
        throw new Error(`Cannot convert ${math.typeOf(value)} to Complex`);
      }
      function createZeroMatrix(dimension) {
        if (dimension <= 0 || !Number.isInteger(dimension)) {
          throw new Error("Dimension must be a positive integer");
        }
        return Array(dimension).fill(null).map(() => Array(dimension).fill(null).map(() => math.complex(0, 0)));
      }
      var MatrixOperator2 = class _MatrixOperator {
        constructor(matrix2, type = "general", validateTypeConstraints = true, additionalProps = {}) {
          this.objectType = "operator";
          (0, validation_1.validateMatDims)(matrix2);
          const dim = matrix2.length;
          if (type !== "general" && type !== "unitary" && type !== "hermitian" && type !== "projection") {
            throw new Error("Invalid operator type");
          }
          this.dimension = dim;
          this.type = type;
          this.matrix = matrix2.map((row) => row.map((elem) => math.clone(elem)));
          this.validateTypeConstraints = validateTypeConstraints;
          Object.assign(this, additionalProps);
          if (validateTypeConstraints) {
            if (type === "hermitian" && !this.isHermitian()) {
              throw new Error("Matrix is not Hermitian");
            } else if (type === "projection" && !this.isProjection()) {
              throw new Error("Matrix is not a projection");
            } else if (type === "unitary") {
              const adjointMatrix = Array(this.dimension).fill(null).map((_, i) => Array(this.dimension).fill(null).map((_2, j) => math.conj(this.matrix[j][i])));
              const productMatrix = Array(dim).fill(null).map(() => Array(dim).fill(null).map(() => math.complex()));
              for (let i = 0; i < dim; i++) {
                for (let j = 0; j < dim; j++) {
                  for (let k = 0; k < dim; k++) {
                    const term = math.multiply(this.matrix[i][k], adjointMatrix[k][j]);
                    productMatrix[i][j] = ensureComplex(math.add(productMatrix[i][j], term));
                  }
                }
              }
              for (let i = 0; i < dim; i++) {
                for (let j = 0; j < dim; j++) {
                  const expected = i === j ? math.complex(1, 0) : math.complex(0, 0);
                  const diff = math.subtract(productMatrix[i][j], expected);
                  if (Number(math.abs(ensureComplex(diff))) > 1e-10) {
                    throw new Error("Matrix is not unitary");
                  }
                }
              }
            }
          }
        }
        // Add this method to the MatrixOperator class
        /**
         * Returns a string representation of the operator in matrix form
         * @param precision Number of decimal places (default: 3)
         */
        toString(precision = 3) {
          const rows = this.matrix.map((row) => {
            return row.map((element) => {
              const re = element.re.toFixed(precision);
              const im = element.im.toFixed(precision);
              if (Math.abs(element.im) < Math.pow(10, -precision)) {
                return `${re}`;
              }
              return `${re}${Number(im) >= 0 ? "+" : ""}${im}i`;
            }).join("	");
          });
          const maxWidth = Math.max(...rows.map((row) => Math.max(...row.split("	").map((el) => el.length))));
          const paddedRows = rows.map((row) => "\u2502 " + row.split("	").map((el) => el.padStart(maxWidth)).join("  ") + " \u2502");
          const borderLine = "\u2500".repeat(maxWidth * this.dimension + 2 * this.dimension + 1);
          const topBorder = `\u250C${borderLine}\u2510`;
          const bottomBorder = `\u2514${borderLine}\u2518`;
          return [topBorder, ...paddedRows, bottomBorder].join("\n");
        }
        /**
         * Applies operator to state vector: |' = O|
         */
        apply(state) {
          (0, validation_1.validateMatchDims)(state.dimension, this.dimension);
          const newAmplitudes = new Array(this.dimension).fill(null).map(() => math.complex(0, 0));
          for (let i = 0; i < this.dimension; i++) {
            for (let j = 0; j < this.dimension; j++) {
              const term = math.multiply(this.matrix[i][j], state.amplitudes[j]);
              newAmplitudes[i] = ensureComplex(math.add(newAmplitudes[i], term));
            }
          }
          const maxIndex = newAmplitudes.reduce((maxIdx, current, idx, arr) => {
            const currentMag = math.abs(current);
            const maxMag = math.abs(arr[maxIdx]);
            return currentMag > maxMag ? idx : maxIdx;
          }, 0);
          let newBasis = state.basis;
          if (this.dimension === 2) {
            if (maxIndex === 1) {
              newBasis = "|1\u27E9";
            } else if (maxIndex === 0) {
              newBasis = "|0\u27E9";
            }
            if (Math.abs(Math.abs(newAmplitudes[0].re) - 1 / Math.sqrt(2)) < 1e-10 && Math.abs(Math.abs(newAmplitudes[1].re) - 1 / Math.sqrt(2)) < 1e-10) {
              newBasis = newAmplitudes[1].re > 0 ? "|+\u27E9" : "|-\u27E9";
            }
          } else if (this.dimension === 4) {
            const binaryStr = maxIndex.toString(2).padStart(2, "0");
            newBasis = `|${binaryStr}\u27E9`;
          }
          return new stateVector_1.StateVector(this.dimension, newAmplitudes, newBasis);
        }
        /**
         * Composes with another operator: OO
         */
        compose(other) {
          (0, validation_1.validateMatchDims)(other.dimension, this.dimension);
          const otherMatrix = other.toMatrix();
          const resultMatrix = Array(this.dimension).fill(null).map(() => Array(this.dimension).fill(null).map(() => math.complex(0, 0)));
          for (let i = 0; i < this.dimension; i++) {
            for (let j = 0; j < this.dimension; j++) {
              let sum2 = math.complex(0, 0);
              for (let k = 0; k < this.dimension; k++) {
                const term = math.multiply(math.complex(this.matrix[i][k].re, this.matrix[i][k].im), math.complex(otherMatrix[k][j].re, otherMatrix[k][j].im));
                sum2 = math.add(sum2, term);
              }
              resultMatrix[i][j] = sum2;
            }
          }
          let resultType = "general";
          if (this.type === other.type) {
            if (this.type === "hermitian" || this.type === "unitary" || this.type === "projection") {
              resultType = this.type;
            }
          } else if (this.type === "hermitian" && other.type === "unitary") {
            resultType = "hermitian";
          } else if (this.type === "unitary" && other.type === "hermitian") {
            resultType = "hermitian";
          }
          return new _MatrixOperator(resultMatrix, resultType);
        }
        /**
         * Returns the adjoint (Hermitian conjugate) of the operator
         */
        adjoint() {
          const adjointMatrix = Array(this.dimension).fill(null).map(() => Array(this.dimension).fill(null).map(() => math.complex(0, 0)));
          for (let i = 0; i < this.dimension; i++) {
            for (let j = 0; j < this.dimension; j++) {
              const elem = this.matrix[j][i];
              adjointMatrix[i][j] = math.complex(elem.re, -elem.im);
            }
          }
          let adjointType = "general";
          if (this.type === "unitary")
            adjointType = "unitary";
          if (this.type === "hermitian")
            adjointType = "hermitian";
          if (this.type === "projection")
            adjointType = "projection";
          return new _MatrixOperator(adjointMatrix, adjointType, false);
        }
        /**
         * Returns matrix representation
         */
        toMatrix() {
          return this.matrix.map((row) => row.map((elem) => (
            // Ensure positive zero in real and imaginary parts
            math.complex(elem.re === 0 ? 0 : elem.re, elem.im === 0 ? 0 : elem.im)
          )));
        }
        /**
         * Checks if matrix is Hermitian (self-adjoint)
         */
        isHermitian(tolerance = 1e-10) {
          for (let i = 0; i < this.dimension; i++) {
            if (Math.abs(this.matrix[i][i].im) > tolerance) {
              return false;
            }
            for (let j = i + 1; j < this.dimension; j++) {
              const upper = this.matrix[i][j];
              const lower = this.matrix[j][i];
              if (Math.abs(upper.re - lower.re) > tolerance || Math.abs(upper.im + lower.im) > tolerance) {
                return false;
              }
            }
          }
          return true;
        }
        /**
         * Checks if matrix is unitary
         */
        isUnitary(tolerance = 1e-10) {
          const matA = math.matrix(this.matrix);
          const matAH = math.transpose(math.conj(matA));
          const product2 = math.multiply(matA, matAH);
          const identity = math.identity(this.dimension, "dense");
          const diff = math.subtract(product2, identity);
          const maxDiffValue = math.max(math.abs(diff).valueOf());
          return maxDiffValue < tolerance;
        }
        /**
         * Checks if matrix is a projection operator (P = P)
         */
        isProjection(tolerance = 1e-10) {
          const matP = math.matrix(this.matrix);
          const matP2 = math.multiply(matP, matP);
          const diff = math.subtract(matP2, matP);
          const maxDiffValue = math.max(math.abs(diff).valueOf());
          return maxDiffValue < tolerance;
        }
        /**
         * Creates tensor product with another operator
         */
        tensorProduct(other) {
          const otherMatrix = other.toMatrix();
          const newDim = this.dimension * other.dimension;
          const resultMatrix = Array(newDim).fill(null).map(() => Array(newDim).fill(null).map(() => math.complex()));
          for (let i1 = 0; i1 < this.dimension; i1++) {
            for (let j1 = 0; j1 < this.dimension; j1++) {
              for (let i2 = 0; i2 < other.dimension; i2++) {
                for (let j2 = 0; j2 < other.dimension; j2++) {
                  const i = i1 * other.dimension + i2;
                  const j = j1 * other.dimension + j2;
                  resultMatrix[i][j] = ensureComplex(math.multiply(this.matrix[i1][j1], otherMatrix[i2][j2]));
                }
              }
            }
          }
          let resultType = "general";
          if (this.type === "unitary" && other.type === "unitary") {
            resultType = "unitary";
          }
          return new _MatrixOperator(resultMatrix, resultType);
        }
        /**
         * Creates the identity operator of given dimension
         */
        static identity(dimension) {
          return new specialized_1.IdentityOperator(dimension);
        }
        /**
         * Creates a zero operator of given dimension
         */
        static zero(dimension) {
          const matrix2 = Array(dimension).fill(null).map(() => Array(dimension).fill(null).map(() => math.complex(0, 0)));
          return new _MatrixOperator(matrix2);
        }
        /**
         * Create optimized operator based on matrix structure
         */
        static createOptimized(matrix2, type) {
          const dimension = matrix2.length;
          let isIdentity = true;
          for (let i = 0; i < dimension && isIdentity; i++) {
            for (let j = 0; j < dimension && isIdentity; j++) {
              const expected = i === j ? 1 : 0;
              const element = matrix2[i][j];
              if (Math.abs(element.re - expected) > 1e-12 || Math.abs(element.im) > 1e-12) {
                isIdentity = false;
              }
            }
          }
          if (isIdentity) {
            return new specialized_1.IdentityOperator(dimension);
          }
          if ((0, specialized_1.isDiagonalMatrix)(matrix2)) {
            const diagonal = matrix2.map((row, i) => math.clone(row[i]));
            return new specialized_1.DiagonalOperator(diagonal);
          }
          const totalElements = dimension * dimension;
          let nonZeroCount = 0;
          for (let i = 0; i < dimension; i++) {
            for (let j = 0; j < dimension; j++) {
              if (math.abs(matrix2[i][j]) > 1e-12) {
                nonZeroCount++;
              }
            }
          }
          if (nonZeroCount / totalElements < 0.1) {
            return new sparseOperator_1.SparseOperator((0, sparse_1.denseToSparse)(matrix2), type);
          }
          return new _MatrixOperator(matrix2, type);
        }
        /**
         * Scales operator by a complex number
         */
        scale(scalar) {
          const scaledMatrix = this.matrix.map((row) => row.map((elem) => ensureComplex(math.multiply(elem, scalar))));
          return new _MatrixOperator(scaledMatrix);
        }
        /**
         * Adds this operator with another operator
         */
        add(other) {
          (0, validation_1.validateMatchDims)(other.dimension, this.dimension);
          const otherMatrix = other.toMatrix();
          const sumMatrix = Array(this.dimension).fill(null).map((_, i) => Array(this.dimension).fill(null).map((_2, j) => math.add(math.complex(this.matrix[i][j].re, this.matrix[i][j].im), math.complex(otherMatrix[i][j].re, otherMatrix[i][j].im))));
          return new _MatrixOperator(sumMatrix);
        }
        /**
         * Performs partial trace operation over specified quantum subsystems
         *
         * In quantum mechanics, the partial trace is an operation that reduces the dimensionality of
         * a quantum system by "tracing out" (removing) certain subsystems. This is a fundamental
         * operation used to obtain the reduced density matrix of a composite system.
         *
         * @example
         * // For a 4-dimensional system (22) representing two qubits:
         * // Get reduced density matrix by tracing out the second qubit
         * const reducedOperator = operator.partialTrace([2, 2], [1]);
         *
         * @example
         * // For an 8-dimensional system (222) representing three qubits:
         * // Trace out the first and third qubits
         * const reducedOperator = operator.partialTrace([2, 2, 2], [0, 2]);
         *
         * @param dims - Array of dimensions for each subsystem. Product must equal this.dimension
         * @param traceOutIndices - Array of indices indicating which subsystems to trace out
         * @returns A new operator representing the reduced system after partial trace
         * @throws Error if dimensions are invalid or indices are out of bounds
         */
        partialTrace(dims, traceOutIndices) {
          (0, validation_1.validatePartialTrace)(dims, this.dimension, traceOutIndices);
          const remainingDim = dims.filter((_, i) => !traceOutIndices.includes(i)).reduce((a, b) => a * b, 1);
          const resultMatrix = createZeroMatrix(remainingDim);
          const traceRange = Array(this.dimension).fill(0).map((_, i) => i);
          for (let i = 0; i < remainingDim; i++) {
            for (let j = 0; j < remainingDim; j++) {
              for (const k of traceRange) {
                const iCoords = indexToCoords(i, dims.filter((_, idx) => !traceOutIndices.includes(idx)));
                const jCoords = indexToCoords(j, dims.filter((_, idx) => !traceOutIndices.includes(idx)));
                const kCoords = indexToCoords(k, dims.filter((_, idx) => traceOutIndices.includes(idx)));
                const fullICoords = combineCoords(iCoords, kCoords, traceOutIndices);
                const fullJCoords = combineCoords(jCoords, kCoords, traceOutIndices);
                const fullI = coordsToIndex(fullICoords, dims);
                const fullJ = coordsToIndex(fullJCoords, dims);
                resultMatrix[i][j] = ensureComplex(math.add(resultMatrix[i][j], this.matrix[fullI][fullJ]));
              }
            }
          }
          return new _MatrixOperator(resultMatrix);
        }
        /**
         * Returns eigenvalues and eigenvectors of the operator
         * Only works for Hermitian operators
         */
        eigenDecompose() {
          const { values, vectors } = (0, matrixOperations_1.eigenDecomposition)(this.matrix, { computeEigenvectors: true });
          if (!vectors || vectors.length === 0) {
            throw new Error("No eigenvectors found");
          }
          const vectorOperators = vectors.map((v) => {
            const matrix2 = Array(this.dimension).fill(null).map((_, i) => Array(this.dimension).fill(null).map((_2, j) => i === j ? math.clone(v[i]) : math.complex(0, 0)));
            return new _MatrixOperator(matrix2, "general");
          });
          return {
            values: values.map((v) => math.clone(v)),
            vectors: vectorOperators
          };
        }
        /**
         * Projects onto eigenspace with given eigenvalue
         */
        projectOntoEigenspace(eigenvalue, tolerance = 1e-10) {
          const { values, vectors } = this.eigenDecompose();
          const matchingVectors = vectors.filter((_, i) => Math.abs(values[i].re - eigenvalue.re) < tolerance && Math.abs(values[i].im - eigenvalue.im) < tolerance);
          if (matchingVectors.length === 0) {
            throw new Error("No eigenvectors found for given eigenvalue");
          }
          return matchingVectors.reduce((sum2, vector) => {
            const vectorMatrix = vector.toMatrix()[0];
            const proj = new _MatrixOperator([vectorMatrix], "projection");
            return sum2 ? sum2.add(proj) : proj;
          });
        }
        /**
         * Calculates the operator norm (Frobenius norm)
         */
        norm() {
          let sum2 = 0;
          for (let i = 0; i < this.dimension; i++) {
            for (let j = 0; j < this.dimension; j++) {
              const element = this.matrix[i][j];
              sum2 += element.re * element.re + element.im * element.im;
            }
          }
          return Math.sqrt(sum2);
        }
        /**
         * Tests whether the operator is identically zero
         * @param tolerance Numerical tolerance for zero comparison (default: 1e-12)
         * @returns true if all matrix elements are within tolerance of zero
         */
        isZero(tolerance = 1e-12) {
          for (let i = 0; i < this.dimension; i++) {
            for (let j = 0; j < this.dimension; j++) {
              const element = this.matrix[i][j];
              if (Math.abs(element.re) > tolerance || Math.abs(element.im) > tolerance) {
                return false;
              }
            }
          }
          return true;
        }
      };
      exports.MatrixOperator = MatrixOperator2;
      function indexToCoords(index, dims) {
        const coords = [];
        let remainder = index;
        for (let i = dims.length - 1; i >= 0; i--) {
          coords.unshift(remainder % dims[i]);
          remainder = Math.floor(remainder / dims[i]);
        }
        return coords;
      }
      function coordsToIndex(coords, dims) {
        let index = 0;
        let factor = 1;
        for (let i = coords.length - 1; i >= 0; i--) {
          index += coords[i] * factor;
          factor *= dims[i];
        }
        return index;
      }
      function combineCoords(coords1, coords2, traceIndices) {
        const result = [];
        let i1 = 0;
        let i2 = 0;
        for (let i = 0; i < coords1.length + coords2.length; i++) {
          if (traceIndices.includes(i)) {
            result.push(coords2[i2++]);
          } else {
            result.push(coords1[i1++]);
          }
        }
        return result;
      }
    }
  });

  // dist/utils/matrixFunctions.js
  var require_matrixFunctions = __commonJS({
    "dist/utils/matrixFunctions.js"(exports) {
      "use strict";
      var __createBinding = exports && exports.__createBinding || (Object.create ? (function(o, m, k, k2) {
        if (k2 === void 0) k2 = k;
        var desc = Object.getOwnPropertyDescriptor(m, k);
        if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
          desc = { enumerable: true, get: function() {
            return m[k];
          } };
        }
        Object.defineProperty(o, k2, desc);
      }) : (function(o, m, k, k2) {
        if (k2 === void 0) k2 = k;
        o[k2] = m[k];
      }));
      var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? (function(o, v) {
        Object.defineProperty(o, "default", { enumerable: true, value: v });
      }) : function(o, v) {
        o["default"] = v;
      });
      var __importStar = exports && exports.__importStar || /* @__PURE__ */ (function() {
        var ownKeys = function(o) {
          ownKeys = Object.getOwnPropertyNames || function(o2) {
            var ar = [];
            for (var k in o2) if (Object.prototype.hasOwnProperty.call(o2, k)) ar[ar.length] = k;
            return ar;
          };
          return ownKeys(o);
        };
        return function(mod2) {
          if (mod2 && mod2.__esModule) return mod2;
          var result = {};
          if (mod2 != null) {
            for (var k = ownKeys(mod2), i = 0; i < k.length; i++) if (k[i] !== "default") __createBinding(result, mod2, k[i]);
          }
          __setModuleDefault(result, mod2);
          return result;
        };
      })();
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.matrixFunction = matrixFunction;
      exports.matrixLogarithm = matrixLogarithm;
      exports.matrixSquareRoot = matrixSquareRoot;
      exports.matrixPower = matrixPower;
      exports.matrixSin = matrixSin;
      exports.matrixCos = matrixCos;
      var matrixOperations_1 = require_matrixOperations();
      var math = __importStar(require_cjs());
      function matrixFunction(matrix2, func) {
        const dim = matrix2.length;
        if ((0, matrixOperations_1.isHermitian)(matrix2)) {
          const { values, vectors } = (0, matrixOperations_1.eigenDecomposition)(matrix2, { computeEigenvectors: true });
          if (!vectors) {
            throw new Error("Failed to compute eigenvectors");
          }
          const funcValues = values.map((v) => func(v));
          const fD = Array(dim).fill(null).map((_, i) => Array(dim).fill(null).map((_2, j) => i === j ? funcValues[i] : math.complex(0, 0)));
          const U = vectors;
          const UDagger = (0, matrixOperations_1.adjoint)(U);
          const temp = (0, matrixOperations_1.multiplyMatrices)(U, fD);
          return (0, matrixOperations_1.multiplyMatrices)(temp, UDagger);
        } else {
          throw new Error("Matrix function for non-Hermitian matrices not implemented");
        }
      }
      function matrixLogarithm(matrix2) {
        return matrixFunction(matrix2, (x) => {
          const r = Math.sqrt(x.re * x.re + x.im * x.im);
          const theta = Math.atan2(x.im, x.re);
          return math.complex(Math.log(r), theta);
        });
      }
      function matrixSquareRoot(matrix2) {
        matrix2.forEach((row, i) => {
          row.forEach((elem, j) => {
            if (!math.isComplex(elem)) {
            }
          });
        });
        try {
          const result = matrixFunction(matrix2, (x) => math.sqrt(x));
          return result;
        } catch (e) {
          console.error("Error in matrix square root:", e);
          if (e instanceof Error) {
            console.error("Stack:", e.stack);
          }
          throw e;
        }
      }
      function matrixPower(matrix2, power) {
        return matrixFunction(matrix2, (x) => {
          const r = Math.pow(Math.sqrt(x.re * x.re + x.im * x.im), power);
          const theta = Math.atan2(x.im, x.re) * power;
          return math.complex(r * Math.cos(theta), r * Math.sin(theta));
        });
      }
      function matrixSin(matrix2) {
        return matrixFunction(matrix2, (x) => {
          return math.complex(Math.sin(x.re) * Math.cosh(x.im), Math.cos(x.re) * Math.sinh(x.im));
        });
      }
      function matrixCos(matrix2) {
        return matrixFunction(matrix2, (x) => {
          return math.complex(Math.cos(x.re) * Math.cosh(x.im), -Math.sin(x.re) * Math.sinh(x.im));
        });
      }
    }
  });

  // dist/utils/information.js
  var require_information = __commonJS({
    "dist/utils/information.js"(exports) {
      "use strict";
      var __createBinding = exports && exports.__createBinding || (Object.create ? (function(o, m, k, k2) {
        if (k2 === void 0) k2 = k;
        var desc = Object.getOwnPropertyDescriptor(m, k);
        if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
          desc = { enumerable: true, get: function() {
            return m[k];
          } };
        }
        Object.defineProperty(o, k2, desc);
      }) : (function(o, m, k, k2) {
        if (k2 === void 0) k2 = k;
        o[k2] = m[k];
      }));
      var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? (function(o, v) {
        Object.defineProperty(o, "default", { enumerable: true, value: v });
      }) : function(o, v) {
        o["default"] = v;
      });
      var __importStar = exports && exports.__importStar || /* @__PURE__ */ (function() {
        var ownKeys = function(o) {
          ownKeys = Object.getOwnPropertyNames || function(o2) {
            var ar = [];
            for (var k in o2) if (Object.prototype.hasOwnProperty.call(o2, k)) ar[ar.length] = k;
            return ar;
          };
          return ownKeys(o);
        };
        return function(mod2) {
          if (mod2 && mod2.__esModule) return mod2;
          var result = {};
          if (mod2 != null) {
            for (var k = ownKeys(mod2), i = 0; i < k.length; i++) if (k[i] !== "default") __createBinding(result, mod2, k[i]);
          }
          __setModuleDefault(result, mod2);
          return result;
        };
      })();
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.schmidtDecomposition = schmidtDecomposition;
      exports.traceDistance = traceDistance;
      exports.fidelity = fidelity;
      exports.traceFidelity = traceFidelity;
      exports.quantumRelativeEntropy = quantumRelativeEntropy;
      exports.vonNeumannEntropy = vonNeumannEntropy;
      exports.entanglementEntropy = entanglementEntropy2;
      exports.linearEntropy = linearEntropy;
      exports.quantumMutualInformation = quantumMutualInformation;
      exports.concurrence = concurrence2;
      exports.negativity = negativity2;
      exports.quantumDiscord = quantumDiscord;
      var stateVector_1 = require_stateVector();
      var matrixOperations_1 = require_matrixOperations();
      var matrixFunctions_1 = require_matrixFunctions();
      var math = __importStar(require_cjs());
      function schmidtDecomposition(state, dimA, dimB) {
        if (state.dimension !== dimA * dimB) {
          throw new Error("State dimension must equal product of subsystem dimensions");
        }
        const matrix2 = [];
        for (let i = 0; i < dimA; i++) {
          matrix2[i] = [];
          for (let j = 0; j < dimB; j++) {
            const index = i * dimB + j;
            matrix2[i][j] = state.amplitudes[index];
          }
        }
        const reducedRhoB = Array(dimB).fill(null).map(() => Array(dimB).fill(null).map(() => math.complex(0, 0)));
        for (let i = 0; i < dimB; i++) {
          for (let j = 0; j < dimB; j++) {
            for (let k = 0; k < dimA; k++) {
              const term = math.multiply(math.conj(matrix2[k][i]), matrix2[k][j]);
              reducedRhoB[i][j] = math.add(reducedRhoB[i][j], term);
            }
          }
        }
        const { values, vectors } = (0, matrixOperations_1.eigenDecomposition)(reducedRhoB, { computeEigenvectors: true });
        const indexValuePairs = values.map((val, idx) => ({
          index: idx,
          value: Math.sqrt(Math.max(0, val.re))
        })).filter((pair) => pair.value > 1e-14).sort((a, b) => b.value - a.value);
        const schmidtValues = indexValuePairs.map((pair) => pair.value);
        const filteredIndices = indexValuePairs.map((pair) => pair.index);
        if (!vectors || vectors.length === 0) {
          throw new Error("Invalid eigenvectors in Schmidt decomposition");
        }
        const statesB = filteredIndices.map((i) => {
          const vector = vectors[i];
          const norm = Math.sqrt(vector.reduce((sum2, v) => sum2 + v.re * v.re + v.im * v.im, 0));
          const amplitudes = vector.map((v) => math.divide(v, math.complex(norm, 0)));
          return new stateVector_1.StateVector(dimB, amplitudes);
        });
        if (!vectors || vectors.length === 0) {
          throw new Error("Invalid eigenvectors in Schmidt decomposition");
        }
        const statesA = filteredIndices.map((i, idx) => {
          const schmidt = schmidtValues[idx];
          const v = vectors[i];
          const amplitudes = Array(dimA).fill(null).map(() => math.complex(0, 0));
          for (let j = 0; j < dimA; j++) {
            for (let k = 0; k < dimB; k++) {
              const term = math.multiply(matrix2[j][k], v[k]);
              amplitudes[j] = math.add(amplitudes[j], term);
            }
          }
          const finalAmps = amplitudes.map((a) => math.divide(a, math.complex(schmidt, 0)));
          return new stateVector_1.StateVector(dimA, finalAmps);
        });
        return {
          values: schmidtValues,
          statesA,
          statesB
        };
      }
      function traceDistance(A, B) {
        if (A.dimension !== B.dimension) {
          throw new Error("Operators must have the same dimension for trace distance");
        }
        const matrixA = A.toMatrix();
        const matrixB = B.toMatrix();
        const diffMatrix = matrixA.map((row, i) => row.map((elem, j) => math.subtract(elem, matrixB[i][j])));
        const adjointDiffMatrix = diffMatrix.map((row, i) => row.map((elem, j) => math.complex(diffMatrix[j][i].re, -diffMatrix[j][i].im)));
        const product2 = (0, matrixOperations_1.multiplyMatrices)(adjointDiffMatrix, diffMatrix);
        const { values } = (0, matrixOperations_1.eigenDecomposition)(product2);
        const sqrtValues = values.map((v) => Math.sqrt(Math.max(0, v.re)));
        return sqrtValues.reduce((sum2, val) => sum2 + val, 0) / 2;
      }
      function fidelity(stateA, stateB) {
        if (stateA.dimension !== stateB.dimension) {
          throw new Error("States must have the same dimension for fidelity");
        }
        const innerProduct = stateA.innerProduct(stateB);
        const magnitude = math.abs(innerProduct);
        return typeof magnitude === "number" ? magnitude * magnitude : magnitude.re * magnitude.re;
      }
      function traceFidelity(rho, sigma) {
        if (rho.dimension !== sigma.dimension) {
          throw new Error("Density matrices must have the same dimension for fidelity");
        }
        const rhoMatrix = rho.toMatrix();
        const sigmaMatrix = sigma.toMatrix();
        const sqrtRho = (0, matrixFunctions_1.matrixSquareRoot)(rhoMatrix);
        const temp = (0, matrixOperations_1.multiplyMatrices)(sqrtRho, sigmaMatrix);
        const product2 = (0, matrixOperations_1.multiplyMatrices)(temp, sqrtRho);
        const sqrtProduct = (0, matrixFunctions_1.matrixSquareRoot)(product2);
        let trace = 0;
        for (let i = 0; i < rho.dimension; i++) {
          trace += sqrtProduct[i][i].re;
        }
        return trace * trace;
      }
      function quantumRelativeEntropy(rho, sigma) {
        if (rho.dimension !== sigma.dimension) {
          throw new Error("Density matrices must have the same dimension for relative entropy");
        }
        const rhoMatrix = rho.toMatrix();
        const sigmaMatrix = sigma.toMatrix();
        const { values: rhoEigenvalues, vectors: rhoEigenvectors } = (0, matrixOperations_1.eigenDecomposition)(rhoMatrix, { computeEigenvectors: true });
        const { values: sigmaEigenvalues, vectors: sigmaEigenvectors } = (0, matrixOperations_1.eigenDecomposition)(sigmaMatrix, { computeEigenvectors: true });
        const logSigmaEigenvalues = sigmaEigenvalues.map(
          (v) => v.re > 1e-10 ? math.complex(Math.log(v.re), 0) : math.complex(-1e3, 0)
          // Use a large negative number as approximation
        );
        const logSigma = Array(rho.dimension).fill(null).map(() => Array(rho.dimension).fill(null).map(() => math.complex(0, 0)));
        if (!sigmaEigenvectors) {
          throw new Error("Failed to compute eigenvectors for sigma");
        }
        for (let i = 0; i < rho.dimension; i++) {
          for (let j = 0; j < rho.dimension; j++) {
            for (let k = 0; k < rho.dimension; k++) {
              if (sigmaEigenvectors[k] && sigmaEigenvectors[k][i] && sigmaEigenvectors[k][j]) {
                const term1 = math.multiply(sigmaEigenvectors[k][i], math.conj(sigmaEigenvectors[k][j]));
                const term2 = math.multiply(term1, logSigmaEigenvalues[k]);
                logSigma[i][j] = math.add(logSigma[i][j], term2);
              }
            }
          }
        }
        let trRhoLogRho = 0;
        for (let i = 0; i < rho.dimension; i++) {
          if (rhoEigenvalues[i].re > 1e-10) {
            trRhoLogRho += rhoEigenvalues[i].re * Math.log(rhoEigenvalues[i].re);
          }
        }
        let trRhoLogSigma = 0;
        for (let i = 0; i < rho.dimension; i++) {
          for (let j = 0; j < rho.dimension; j++) {
            trRhoLogSigma += rhoMatrix[i][j].re * logSigma[j][i].re;
          }
        }
        return trRhoLogRho - trRhoLogSigma;
      }
      function vonNeumannEntropy(rho) {
        const matrix2 = rho.toMatrix();
        const { values } = (0, matrixOperations_1.eigenDecomposition)(matrix2);
        let entropy = 0;
        for (const value of values) {
          const p = value.re;
          if (p > 1e-10) {
            entropy -= p * Math.log(p);
          }
        }
        return entropy;
      }
      function entanglementEntropy2(state, dimA, dimB) {
        const { values } = schmidtDecomposition(state, dimA, dimB);
        let entropy = 0;
        for (const lambda of values) {
          const p = lambda * lambda;
          if (p > 1e-10) {
            entropy -= p * Math.log(p);
          }
        }
        return entropy;
      }
      function linearEntropy(rho) {
        return 1 - rho.purity();
      }
      function quantumMutualInformation(rhoAB, dimA, dimB) {
        if (rhoAB.dimension !== dimA * dimB) {
          throw new Error("Density matrix dimension must match product of subsystem dimensions");
        }
        const jointEntropy = vonNeumannEntropy(rhoAB);
        const rhoA = rhoAB.partialTrace([dimA, dimB], [1]);
        const rhoB = rhoAB.partialTrace([dimA, dimB], [0]);
        const entropyA = vonNeumannEntropy(rhoA);
        const entropyB = vonNeumannEntropy(rhoB);
        return entropyA + entropyB - jointEntropy;
      }
      function concurrence2(rho) {
        if (rho.dimension !== 4) {
          throw new Error("Concurrence only defined for 2-qubit states");
        }
        const rhoMatrix = rho.toMatrix();
        const sigmaY = [
          [math.complex(0, 0), math.complex(0, -1)],
          [math.complex(0, 1), math.complex(0, 0)]
        ];
        const sigmaYY = Array(4).fill(null).map(() => Array(4).fill(null).map(() => math.complex(0, 0)));
        for (let i1 = 0; i1 < 2; i1++) {
          for (let j1 = 0; j1 < 2; j1++) {
            for (let i2 = 0; i2 < 2; i2++) {
              for (let j2 = 0; j2 < 2; j2++) {
                const i = i1 * 2 + i2;
                const j = j1 * 2 + j2;
                sigmaYY[i][j] = math.multiply(sigmaY[i1][j1], sigmaY[i2][j2]);
              }
            }
          }
        }
        const rhoSigmaYY = (0, matrixOperations_1.multiplyMatrices)(rhoMatrix, sigmaYY);
        const rhoStar = rhoMatrix.map((row) => row.map((elem) => math.conj(elem)));
        const rhoSigmaYYRhoStar = (0, matrixOperations_1.multiplyMatrices)(rhoSigmaYY, rhoStar);
        const R = (0, matrixOperations_1.multiplyMatrices)(rhoSigmaYYRhoStar, sigmaYY);
        const RDagger = R.map((row, i) => row.map((_, j) => math.conj(R[j][i])));
        const RRDagger = (0, matrixOperations_1.multiplyMatrices)(R, RDagger);
        const { values } = (0, matrixOperations_1.eigenDecomposition)(RRDagger);
        const sqrtValues = values.map((v) => Math.sqrt(Math.sqrt(Math.max(0, v.re)))).sort((a, b) => b - a);
        const concurrence3 = Math.max(0, sqrtValues[0] - sqrtValues[1] - sqrtValues[2] - sqrtValues[3]);
        return concurrence3;
      }
      function negativity2(rho, dimA, dimB) {
        if (rho.dimension !== dimA * dimB) {
          throw new Error("Density matrix dimension must match product of subsystem dimensions");
        }
        const rhoMatrix = rho.toMatrix();
        const rhoTA = Array(dimA * dimB).fill(null).map(() => Array(dimA * dimB).fill(null).map(() => math.complex(0, 0)));
        for (let i1 = 0; i1 < dimA; i1++) {
          for (let i2 = 0; i2 < dimB; i2++) {
            for (let j1 = 0; j1 < dimA; j1++) {
              for (let j2 = 0; j2 < dimB; j2++) {
                const i = i1 * dimB + i2;
                const j = j1 * dimB + j2;
                const iTA = j1 * dimB + i2;
                const jTA = i1 * dimB + j2;
                rhoTA[iTA][jTA] = rhoMatrix[i][j];
              }
            }
          }
        }
        const { values } = (0, matrixOperations_1.eigenDecomposition)(rhoTA);
        const traceNorm = values.reduce((sum2, v) => sum2 + Math.abs(v.re), 0);
        return (traceNorm - 1) / 2;
      }
      function quantumDiscord(rho, dimA, dimB) {
        if (rho.dimension !== dimA * dimB) {
          throw new Error("Density matrix dimension must match product of subsystem dimensions");
        }
        const mutualInfo = quantumMutualInformation(rho, dimA, dimB);
        const rhoB = rho.partialTrace([dimA, dimB], [0]);
        const classicalCorrelation = 0.5 * mutualInfo;
        return mutualInfo - classicalCorrelation;
      }
    }
  });

  // dist/states/densityMatrix.js
  var require_densityMatrix = __commonJS({
    "dist/states/densityMatrix.js"(exports) {
      "use strict";
      var __createBinding = exports && exports.__createBinding || (Object.create ? (function(o, m, k, k2) {
        if (k2 === void 0) k2 = k;
        var desc = Object.getOwnPropertyDescriptor(m, k);
        if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
          desc = { enumerable: true, get: function() {
            return m[k];
          } };
        }
        Object.defineProperty(o, k2, desc);
      }) : (function(o, m, k, k2) {
        if (k2 === void 0) k2 = k;
        o[k2] = m[k];
      }));
      var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? (function(o, v) {
        Object.defineProperty(o, "default", { enumerable: true, value: v });
      }) : function(o, v) {
        o["default"] = v;
      });
      var __importStar = exports && exports.__importStar || /* @__PURE__ */ (function() {
        var ownKeys = function(o) {
          ownKeys = Object.getOwnPropertyNames || function(o2) {
            var ar = [];
            for (var k in o2) if (Object.prototype.hasOwnProperty.call(o2, k)) ar[ar.length] = k;
            return ar;
          };
          return ownKeys(o);
        };
        return function(mod2) {
          if (mod2 && mod2.__esModule) return mod2;
          var result = {};
          if (mod2 != null) {
            for (var k = ownKeys(mod2), i = 0; i < k.length; i++) if (k[i] !== "default") __createBinding(result, mod2, k[i]);
          }
          __setModuleDefault(result, mod2);
          return result;
        };
      })();
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.negativity = exports.concurrence = exports.traceFidelity = exports.KrausChannel = exports.DensityMatrixOperator = void 0;
      exports.createDepolarizingChannel = createDepolarizingChannel;
      exports.createAmplitudeDampingChannel = createAmplitudeDampingChannel;
      exports.createPhaseDampingChannel = createPhaseDampingChannel;
      exports.createBitFlipChannel = createBitFlipChannel;
      exports.createPhaseFlipChannel = createPhaseFlipChannel;
      var operator_1 = require_operator();
      var matrixOperations_1 = require_matrixOperations();
      var math = __importStar(require_cjs());
      var matrixOperations_2 = require_matrixOperations();
      var DensityMatrixOperator2 = class _DensityMatrixOperator {
        constructor(matrix2) {
          this.objectType = "operator";
          this.type = "hermitian";
          if (!matrix2 || matrix2.length === 0) {
            throw new Error("Empty matrix provided");
          }
          const dim = matrix2.length;
          if (!matrix2.every((row) => row.length === dim)) {
            throw new Error("Matrix must be square");
          }
          const normalizedMatrix = (0, matrixOperations_2.normalizeMatrix)(matrix2);
          this.operator = new operator_1.MatrixOperator(normalizedMatrix, "hermitian");
          this.dimension = dim;
          const tr = this.trace();
          if (Math.abs(tr.re - 1) > 1e-10 || Math.abs(tr.im) > 1e-10) {
            throw new Error("Density matrix must have trace 1");
          }
          if (this.purity() > 1 + 1e-10) {
            throw new Error("Density matrix must be positive semidefinite");
          }
        }
        /**
         * Applies density matrix to state vector
         */
        apply(state) {
          return this.operator.apply(state);
        }
        /**
         * Composes with another operator
         */
        compose(other) {
          return this.operator.compose(other);
        }
        /**
         * Returns adjoint (same as original for density matrix)
         */
        adjoint() {
          return this;
        }
        /**
         * Returns matrix representation
         */
        toMatrix() {
          return this.operator.toMatrix();
        }
        /**
         * Calculates trace of density matrix
         */
        trace() {
          const matrix2 = this.toMatrix();
          return matrix2.reduce((sum2, row, i) => math.add(sum2, row[i]), math.complex(0, 0));
        }
        /**
         * Calculates purity Tr()
         */
        purity() {
          const matrix2 = this.toMatrix();
          const matSquared = (0, matrixOperations_1.multiplyMatrices)(matrix2, matrix2);
          let trace = math.complex(0, 0);
          for (let i = 0; i < this.dimension; i++) {
            trace = math.add(trace, matSquared[i][i]);
          }
          return trace.re;
        }
        /**
         * Calculates von Neumann entropy -Tr( ln )
         */
        vonNeumannEntropy() {
          const { values } = this.eigenDecompose();
          let entropy = 0;
          for (const value of values) {
            if (value.re > 1e-10) {
              entropy -= value.re * Math.log(value.re);
            }
          }
          return entropy;
        }
        /**
         * Performs partial trace over specified subsystems
         */
        partialTrace(dims, traceOutIndices) {
          return this.operator.partialTrace(dims, traceOutIndices);
        }
        /**
         * Scales density matrix by a complex number
         */
        scale(scalar) {
          return this.operator.scale(scalar);
        }
        /**
         * Adds this density matrix with another operator
         */
        add(other) {
          return this.operator.add(other);
        }
        /**
         * Returns eigenvalues and eigenvectors
         */
        eigenDecompose() {
          return this.operator.eigenDecompose();
        }
        /**
         * Creates density matrix from pure state
         */
        static fromPureState(state) {
          const dim = state.dimension;
          const matrix2 = Array(dim).fill(null).map(() => Array(dim).fill(null).map(() => math.complex(0, 0)));
          for (let i = 0; i < dim; i++) {
            for (let j = 0; j < dim; j++) {
              matrix2[i][j] = math.multiply(state.amplitudes[i], math.conj(state.amplitudes[j]));
            }
          }
          return new _DensityMatrixOperator(matrix2);
        }
        /**
         * Creates density matrix from mixed state
         */
        static mixedState(states, probabilities) {
          if (states.length !== probabilities.length) {
            throw new Error("Number of states must match number of probabilities");
          }
          if (Math.abs(probabilities.reduce((a, b) => a + b, 0) - 1) > 1e-10) {
            throw new Error("Probabilities must sum to 1");
          }
          const dim = states[0].dimension;
          if (!states.every((s) => s.dimension === dim)) {
            throw new Error("All states must have same dimension");
          }
          const matrix2 = Array(dim).fill(null).map(() => Array(dim).fill(null).map(() => math.complex(0, 0)));
          for (let k = 0; k < states.length; k++) {
            const state = states[k];
            const prob = probabilities[k];
            for (let i = 0; i < dim; i++) {
              for (let j = 0; j < dim; j++) {
                const term = math.multiply(math.multiply(state.amplitudes[i], math.conj(state.amplitudes[j])), math.complex(prob, 0));
                matrix2[i][j] = math.add(matrix2[i][j], term);
              }
            }
          }
          return new _DensityMatrixOperator(matrix2);
        }
        /**
         * Returns tensor product with another operator
         */
        tensorProduct(other) {
          return this.operator.tensorProduct(other);
        }
        /**
         * Calculates the operator norm
         */
        norm() {
          return this.operator.norm();
        }
        /**
         * Tests whether the density matrix is identically zero
         */
        isZero(tolerance) {
          return this.operator.isZero(tolerance);
        }
      };
      exports.DensityMatrixOperator = DensityMatrixOperator2;
      var KrausChannel = class {
        constructor(krausOperators) {
          this.krausOperators = krausOperators;
          if (!krausOperators || krausOperators.length === 0) {
            throw new Error("At least one Kraus operator is required");
          }
          const dim = krausOperators[0].dimension;
          if (!krausOperators.every((op) => op.dimension === dim)) {
            throw new Error("All Kraus operators must have same dimension");
          }
          const sum2 = krausOperators.reduce((sum3, Ei) => {
            const EiDagger = Ei.adjoint();
            return addOperators(sum3, EiDagger.compose(Ei));
          }, createZeroOperator(dim));
          const identity = createIdentityOperator(dim);
          const diff = subtractOperators(sum2, identity);
          if (!diff.isZero()) {
            throw new Error("Kraus operators must satisfy completeness relation");
          }
        }
        getOperators() {
          return [...this.krausOperators];
        }
        apply(state) {
          const dim = this.krausOperators[0].dimension;
          const result = Array(dim).fill(null).map(() => Array(dim).fill(null).map(() => math.complex(0, 0)));
          for (const Ei of this.krausOperators) {
            const EiDagger = Ei.adjoint();
            const term = Ei.compose(state).compose(EiDagger);
            const termMatrix = term.toMatrix();
            for (let i = 0; i < dim; i++) {
              for (let j = 0; j < dim; j++) {
                result[i][j] = math.add(result[i][j], termMatrix[i][j]);
              }
            }
          }
          return new DensityMatrixOperator2(result);
        }
      };
      exports.KrausChannel = KrausChannel;
      function createDepolarizingChannel(dimension, p) {
        if (p < 0 || p > 1) {
          throw new Error("Probability must be between 0 and 1");
        }
        if (dimension !== 2) {
          throw new Error("Depolarizing channel currently only implemented for qubits (dimension=2)");
        }
        const krausOperators = [];
        const E0Matrix = [
          [math.complex(Math.sqrt(1 - p), 0), math.complex(0, 0)],
          [math.complex(0, 0), math.complex(Math.sqrt(1 - p), 0)]
        ];
        krausOperators.push(new operator_1.MatrixOperator(E0Matrix));
        const sqrt_p_3 = Math.sqrt(p / 3);
        const E1Matrix = [
          [math.complex(0, 0), math.complex(sqrt_p_3, 0)],
          [math.complex(sqrt_p_3, 0), math.complex(0, 0)]
        ];
        krausOperators.push(new operator_1.MatrixOperator(E1Matrix));
        const E2Matrix = [
          [math.complex(0, 0), math.complex(0, -sqrt_p_3)],
          [math.complex(0, sqrt_p_3), math.complex(0, 0)]
        ];
        krausOperators.push(new operator_1.MatrixOperator(E2Matrix));
        const E3Matrix = [
          [math.complex(sqrt_p_3, 0), math.complex(0, 0)],
          [math.complex(0, 0), math.complex(-sqrt_p_3, 0)]
        ];
        krausOperators.push(new operator_1.MatrixOperator(E3Matrix));
        return new KrausChannel(krausOperators);
      }
      function createAmplitudeDampingChannel(gamma) {
        if (gamma < 0 || gamma > 1) {
          throw new Error("Damping parameter must be between 0 and 1");
        }
        const krausOperators = [];
        const E0Matrix = [
          [math.complex(1, 0), math.complex(0, 0)],
          [math.complex(0, 0), math.complex(Math.sqrt(1 - gamma), 0)]
        ];
        krausOperators.push(new operator_1.MatrixOperator(E0Matrix));
        const E1Matrix = [
          [math.complex(0, 0), math.complex(Math.sqrt(gamma), 0)],
          [math.complex(0, 0), math.complex(0, 0)]
        ];
        krausOperators.push(new operator_1.MatrixOperator(E1Matrix));
        return new KrausChannel(krausOperators);
      }
      function createPhaseDampingChannel(gamma) {
        if (gamma < 0 || gamma > 1) {
          throw new Error("Damping parameter must be between 0 and 1");
        }
        const krausOperators = [];
        const E0Matrix = [
          [math.complex(1, 0), math.complex(0, 0)],
          [math.complex(0, 0), math.complex(Math.sqrt(1 - gamma), 0)]
        ];
        krausOperators.push(new operator_1.MatrixOperator(E0Matrix));
        const E1Matrix = [
          [math.complex(0, 0), math.complex(0, 0)],
          [math.complex(0, 0), math.complex(Math.sqrt(gamma), 0)]
        ];
        krausOperators.push(new operator_1.MatrixOperator(E1Matrix));
        return new KrausChannel(krausOperators);
      }
      function createBitFlipChannel(p) {
        if (p < 0 || p > 1) {
          throw new Error("Probability must be between 0 and 1");
        }
        const krausOperators = [];
        const E0Matrix = [
          [math.complex(Math.sqrt(1 - p), 0), math.complex(0, 0)],
          [math.complex(0, 0), math.complex(Math.sqrt(1 - p), 0)]
        ];
        krausOperators.push(new operator_1.MatrixOperator(E0Matrix));
        const sqrtP = Math.sqrt(p);
        const E1Matrix = [
          [math.complex(0, 0), math.complex(sqrtP, 0)],
          [math.complex(sqrtP, 0), math.complex(0, 0)]
        ];
        krausOperators.push(new operator_1.MatrixOperator(E1Matrix));
        return new KrausChannel(krausOperators);
      }
      function createPhaseFlipChannel(p) {
        if (p < 0 || p > 1) {
          throw new Error("Probability must be between 0 and 1");
        }
        const krausOperators = [];
        const E0Matrix = [
          [math.complex(Math.sqrt(1 - p), 0), math.complex(0, 0)],
          [math.complex(0, 0), math.complex(Math.sqrt(1 - p), 0)]
        ];
        krausOperators.push(new operator_1.MatrixOperator(E0Matrix));
        const sqrtP = Math.sqrt(p);
        const E1Matrix = [
          [math.complex(sqrtP, 0), math.complex(0, 0)],
          [math.complex(0, 0), math.complex(-sqrtP, 0)]
        ];
        krausOperators.push(new operator_1.MatrixOperator(E1Matrix));
        return new KrausChannel(krausOperators);
      }
      function addOperators(a, b) {
        if (a.dimension !== b.dimension) {
          throw new Error("Operator dimensions do not match");
        }
        const matrixA = a.toMatrix();
        const matrixB = b.toMatrix();
        const sumMatrix = matrixA.map((row, i) => row.map((elem, j) => math.add(elem, matrixB[i][j])));
        return new operator_1.MatrixOperator(sumMatrix);
      }
      function subtractOperators(a, b) {
        if (a.dimension !== b.dimension) {
          throw new Error("Operator dimensions do not match");
        }
        const matrixA = a.toMatrix();
        const matrixB = b.toMatrix();
        const diffMatrix = matrixA.map((row, i) => row.map((elem, j) => math.subtract(elem, matrixB[i][j])));
        return new operator_1.MatrixOperator(diffMatrix);
      }
      function createIdentityOperator(dimension) {
        const matrix2 = Array(dimension).fill(null).map((_, i) => Array(dimension).fill(null).map((_2, j) => i === j ? math.complex(1, 0) : math.complex(0, 0)));
        return new operator_1.MatrixOperator(matrix2, "unitary");
      }
      function createZeroOperator(dimension) {
        const matrix2 = Array(dimension).fill(null).map(() => Array(dimension).fill(null).map(() => math.complex(0, 0)));
        return new operator_1.MatrixOperator(matrix2);
      }
      var information_1 = require_information();
      Object.defineProperty(exports, "traceFidelity", { enumerable: true, get: function() {
        return information_1.traceFidelity;
      } });
      Object.defineProperty(exports, "concurrence", { enumerable: true, get: function() {
        return information_1.concurrence;
      } });
      Object.defineProperty(exports, "negativity", { enumerable: true, get: function() {
        return information_1.negativity;
      } });
    }
  });

  // dist/operators/algebra.js
  var require_algebra = __commonJS({
    "dist/operators/algebra.js"(exports) {
      "use strict";
      var __createBinding = exports && exports.__createBinding || (Object.create ? (function(o, m, k, k2) {
        if (k2 === void 0) k2 = k;
        var desc = Object.getOwnPropertyDescriptor(m, k);
        if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
          desc = { enumerable: true, get: function() {
            return m[k];
          } };
        }
        Object.defineProperty(o, k2, desc);
      }) : (function(o, m, k, k2) {
        if (k2 === void 0) k2 = k;
        o[k2] = m[k];
      }));
      var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? (function(o, v) {
        Object.defineProperty(o, "default", { enumerable: true, value: v });
      }) : function(o, v) {
        o["default"] = v;
      });
      var __importStar = exports && exports.__importStar || /* @__PURE__ */ (function() {
        var ownKeys = function(o) {
          ownKeys = Object.getOwnPropertyNames || function(o2) {
            var ar = [];
            for (var k in o2) if (Object.prototype.hasOwnProperty.call(o2, k)) ar[ar.length] = k;
            return ar;
          };
          return ownKeys(o);
        };
        return function(mod2) {
          if (mod2 && mod2.__esModule) return mod2;
          var result = {};
          if (mod2 != null) {
            for (var k = ownKeys(mod2), i = 0; i < k.length; i++) if (k[i] !== "default") __createBinding(result, mod2, k[i]);
          }
          __setModuleDefault(result, mod2);
          return result;
        };
      })();
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.addOperators = addOperators;
      exports.subtractOperators = subtractOperators;
      exports.commutator = commutator;
      exports.antiCommutator = antiCommutator;
      exports.nestedCommutator = nestedCommutator;
      exports.lieDerivative = lieDerivative;
      exports.BCHFormula = BCHFormula;
      exports.operatorsCommute = operatorsCommute;
      exports.commutatorExpectation = commutatorExpectation;
      exports.uncertaintyProduct = uncertaintyProduct;
      exports.isNormalOperator = isNormalOperator;
      exports.operatorFromGenerator = operatorFromGenerator;
      exports.createNestedCommutator = createNestedCommutator;
      exports.projectionOperator = projectionOperator;
      var operator_1 = require_operator();
      var matrixOperations_1 = require_matrixOperations();
      var math = __importStar(require_cjs());
      function addOperators(a, b) {
        if (a.dimension !== b.dimension) {
          throw new Error("Operator dimensions do not match");
        }
        return a.add(b);
      }
      function subtractOperators(a, b) {
        if (a.dimension !== b.dimension) {
          throw new Error("Operator dimensions do not match");
        }
        return a.add(b.scale(math.complex(-1, 0)));
      }
      function commutator(A, B) {
        if (A.dimension !== B.dimension) {
          throw new Error("Operators must have the same dimension for commutator");
        }
        const matrixA = A.toMatrix();
        const matrixB = B.toMatrix();
        const dim = A.dimension;
        const resultMatrix = Array(dim).fill(null).map(() => Array(dim).fill(null).map(() => math.complex(0, 0)));
        for (let i = 0; i < dim; i++) {
          for (let j = 0; j < dim; j++) {
            let ab = math.complex(0, 0);
            let ba = math.complex(0, 0);
            for (let k = 0; k < dim; k++) {
              ab = math.add(ab, math.multiply(math.complex(matrixA[i][k].re, matrixA[i][k].im), math.complex(matrixB[k][j].re, matrixB[k][j].im)));
              ba = math.add(ba, math.multiply(math.complex(matrixB[i][k].re, matrixB[i][k].im), math.complex(matrixA[k][j].re, matrixA[k][j].im)));
            }
            resultMatrix[i][j] = math.subtract(ab, ba);
          }
        }
        return new operator_1.MatrixOperator(resultMatrix);
      }
      function antiCommutator(A, B) {
        if (A.dimension !== B.dimension) {
          throw new Error("Operators must have the same dimension for anti-commutator");
        }
        const matrixA = A.toMatrix();
        const matrixB = B.toMatrix();
        const dim = A.dimension;
        const resultMatrix = Array(dim).fill(null).map(() => Array(dim).fill(null).map(() => math.complex(0, 0)));
        for (let i = 0; i < dim; i++) {
          for (let j = 0; j < dim; j++) {
            let ab = math.complex(0, 0);
            let ba = math.complex(0, 0);
            for (let k = 0; k < dim; k++) {
              ab = math.add(ab, math.multiply(math.complex(matrixA[i][k].re, matrixA[i][k].im), math.complex(matrixB[k][j].re, matrixB[k][j].im)));
              ba = math.add(ba, math.multiply(math.complex(matrixB[i][k].re, matrixB[i][k].im), math.complex(matrixA[k][j].re, matrixA[k][j].im)));
            }
            resultMatrix[i][j] = math.add(ab, ba);
          }
        }
        return new operator_1.MatrixOperator(resultMatrix);
      }
      function nestedCommutator(ops, indices) {
        if (ops.length < 2 || indices.length < 1) {
          throw new Error("Need at least two operators and one pair of indices");
        }
        const dim = ops[0].dimension;
        if (!ops.every((op) => op.dimension === dim)) {
          throw new Error("All operators must have the same dimension");
        }
        const lastPair = indices[indices.length - 1];
        const [innerA, innerB] = lastPair;
        if (innerA < 0 || innerB < 0 || innerA >= ops.length || innerB >= ops.length) {
          throw new Error("Invalid operator indices");
        }
        let result = commutator(ops[innerA], ops[innerB]);
        for (let i = indices.length - 2; i >= 0; i--) {
          const [a, b] = indices[i];
          if (a < 0 || a >= ops.length) {
            throw new Error("Invalid operator index");
          }
          result = commutator(ops[a], result);
        }
        return result;
      }
      function lieDerivative(A, B) {
        return commutator(A, B);
      }
      function BCHFormula(A, B, order = 2) {
        if (A.dimension !== B.dimension) {
          throw new Error("Operators must have the same dimension for BCH formula");
        }
        if (order < 1) {
          throw new Error("Order must be at least 1");
        }
        let result = addOperators(A, B);
        if (order >= 1) {
          const firstOrder = commutator(A, B).scale(math.complex(0.5, 0));
          result = addOperators(result, firstOrder);
        }
        if (order >= 2) {
          const AB = commutator(A, B);
          const AAB = commutator(A, AB).scale(math.complex(1 / 12, 0));
          const BAB = commutator(B, AB).scale(math.complex(-1 / 12, 0));
          result = addOperators(result, AAB);
          result = addOperators(result, BAB);
        }
        return result;
      }
      function operatorsCommute(A, B, tolerance = 1e-10) {
        const comm = commutator(A, B);
        if (comm.isZero()) {
          return true;
        }
        return false;
      }
      function commutatorExpectation(state, A, B) {
        const commutatorOp = commutator(A, B);
        const resultState = commutatorOp.apply(state);
        return state.innerProduct(resultState);
      }
      function uncertaintyProduct(state, A, B) {
        const expectA = state.innerProduct(A.apply(state));
        const expectA2 = state.innerProduct(A.compose(A).apply(state));
        const varA = expectA2.re - expectA.re * expectA.re - expectA.im * expectA.im;
        const deltaA = Math.sqrt(Math.max(0, varA));
        const expectB = state.innerProduct(B.apply(state));
        const expectB2 = state.innerProduct(B.compose(B).apply(state));
        const varB = expectB2.re - expectB.re * expectB.re - expectB.im * expectB.im;
        const deltaB = Math.sqrt(Math.max(0, varB));
        return deltaA * deltaB;
      }
      function isNormalOperator(A, tolerance = 1e-10) {
        const ADagger = A.adjoint();
        const AA_dagger = A.compose(ADagger);
        const A_daggerA = ADagger.compose(A);
        return operatorsCommute(AA_dagger, A_daggerA, tolerance);
      }
      function operatorFromGenerator(generator) {
        const iG = generator.scale(math.complex(0, 1));
        const matrix2 = iG.toMatrix();
        const expMatrix = (0, matrixOperations_1.matrixExponential)(matrix2);
        return new operator_1.MatrixOperator(expMatrix, "unitary");
      }
      function createNestedCommutator(ops) {
        if (ops.length < 3) {
          throw new Error("Need at least three operators for a nested commutator");
        }
        const dim = ops[0].dimension;
        if (!ops.every((op) => op.dimension === dim)) {
          throw new Error("All operators must have the same dimension");
        }
        let result = commutator(ops[ops.length - 2], ops[ops.length - 1]);
        for (let i = ops.length - 3; i >= 0; i--) {
          result = commutator(ops[i], result);
        }
        return result;
      }
      function projectionOperator(state) {
        const dim = state.dimension;
        const matrix2 = Array(dim).fill(null).map(() => Array(dim).fill(null).map(() => math.complex(0, 0)));
        for (let i = 0; i < dim; i++) {
          for (let j = 0; j < dim; j++) {
            matrix2[i][j] = math.multiply(state.amplitudes[i], math.conj(state.amplitudes[j]));
          }
        }
        return new operator_1.MatrixOperator(matrix2, "projection");
      }
    }
  });

  // dist/operators/gates.js
  var require_gates = __commonJS({
    "dist/operators/gates.js"(exports) {
      "use strict";
      var __createBinding = exports && exports.__createBinding || (Object.create ? (function(o, m, k, k2) {
        if (k2 === void 0) k2 = k;
        var desc = Object.getOwnPropertyDescriptor(m, k);
        if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
          desc = { enumerable: true, get: function() {
            return m[k];
          } };
        }
        Object.defineProperty(o, k2, desc);
      }) : (function(o, m, k, k2) {
        if (k2 === void 0) k2 = k;
        o[k2] = m[k];
      }));
      var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? (function(o, v) {
        Object.defineProperty(o, "default", { enumerable: true, value: v });
      }) : function(o, v) {
        o["default"] = v;
      });
      var __importStar = exports && exports.__importStar || /* @__PURE__ */ (function() {
        var ownKeys = function(o) {
          ownKeys = Object.getOwnPropertyNames || function(o2) {
            var ar = [];
            for (var k in o2) if (Object.prototype.hasOwnProperty.call(o2, k)) ar[ar.length] = k;
            return ar;
          };
          return ownKeys(o);
        };
        return function(mod2) {
          if (mod2 && mod2.__esModule) return mod2;
          var result = {};
          if (mod2 != null) {
            for (var k = ownKeys(mod2), i = 0; i < k.length; i++) if (k[i] !== "default") __createBinding(result, mod2, k[i]);
          }
          __setModuleDefault(result, mod2);
          return result;
        };
      })();
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.CNOT = exports.Hadamard = exports.PauliZ = exports.PauliY = exports.PauliX = void 0;
      var operator_1 = require_operator();
      var math = __importStar(require_cjs());
      exports.PauliX = new operator_1.MatrixOperator([
        [math.complex(0, 0), math.complex(1, 0)],
        [math.complex(1, 0), math.complex(0, 0)]
      ], "unitary");
      exports.PauliY = new operator_1.MatrixOperator([
        [math.complex(0, 0), math.complex(0, -1)],
        [math.complex(0, 1), math.complex(0, 0)]
      ], "unitary");
      exports.PauliZ = new operator_1.MatrixOperator([
        [math.complex(1, 0), math.complex(0, 0)],
        [math.complex(0, 0), math.complex(-1, 0)]
      ], "unitary");
      exports.Hadamard = new operator_1.MatrixOperator([
        [math.complex(1 / Math.sqrt(2), 0), math.complex(1 / Math.sqrt(2), 0)],
        [math.complex(1 / Math.sqrt(2), 0), math.complex(-1 / Math.sqrt(2), 0)]
      ], "unitary");
      exports.CNOT = new operator_1.MatrixOperator([
        [math.complex(1, 0), math.complex(0, 0), math.complex(0, 0), math.complex(0, 0)],
        [math.complex(0, 0), math.complex(1, 0), math.complex(0, 0), math.complex(0, 0)],
        [math.complex(0, 0), math.complex(0, 0), math.complex(0, 0), math.complex(1, 0)],
        [math.complex(0, 0), math.complex(0, 0), math.complex(1, 0), math.complex(0, 0)]
      ], "unitary");
    }
  });

  // dist/operators/measurement.js
  var require_measurement = __commonJS({
    "dist/operators/measurement.js"(exports) {
      "use strict";
      var __createBinding = exports && exports.__createBinding || (Object.create ? (function(o, m, k, k2) {
        if (k2 === void 0) k2 = k;
        var desc = Object.getOwnPropertyDescriptor(m, k);
        if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
          desc = { enumerable: true, get: function() {
            return m[k];
          } };
        }
        Object.defineProperty(o, k2, desc);
      }) : (function(o, m, k, k2) {
        if (k2 === void 0) k2 = k;
        o[k2] = m[k];
      }));
      var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? (function(o, v) {
        Object.defineProperty(o, "default", { enumerable: true, value: v });
      }) : function(o, v) {
        o["default"] = v;
      });
      var __importStar = exports && exports.__importStar || /* @__PURE__ */ (function() {
        var ownKeys = function(o) {
          ownKeys = Object.getOwnPropertyNames || function(o2) {
            var ar = [];
            for (var k in o2) if (Object.prototype.hasOwnProperty.call(o2, k)) ar[ar.length] = k;
            return ar;
          };
          return ownKeys(o);
        };
        return function(mod2) {
          if (mod2 && mod2.__esModule) return mod2;
          var result = {};
          if (mod2 != null) {
            for (var k = ownKeys(mod2), i = 0; i < k.length; i++) if (k[i] !== "default") __createBinding(result, mod2, k[i]);
          }
          __setModuleDefault(result, mod2);
          return result;
        };
      })();
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.ProjectionOperator = void 0;
      exports.expectationValue = expectationValue;
      exports.measureState = measureState2;
      exports.createMeasurementOperator = createMeasurementOperator;
      var operator_1 = require_operator();
      var stateVector_1 = require_stateVector();
      var math = __importStar(require_cjs());
      var ProjectionOperator2 = class {
        constructor(state) {
          this._dimension = state.dimension;
          const matrix2 = Array(state.dimension).fill(null).map(() => Array(state.dimension).fill(null).map(() => math.complex(0, 0)));
          for (let i = 0; i < state.dimension; i++) {
            for (let j = 0; j < state.dimension; j++) {
              matrix2[i][j] = math.multiply(math.complex(state.amplitudes[i].re, state.amplitudes[i].im), math.conj(state.amplitudes[j]));
            }
          }
          this._operator = new operator_1.MatrixOperator(matrix2, "projection", false);
        }
        get objectType() {
          return "operator";
        }
        get dimension() {
          return this._dimension;
        }
        get type() {
          return "projection";
        }
        /**
         * Tests whether the density matrix is identically zero
         */
        isZero(tolerance) {
          return this._operator.isZero(tolerance);
        }
        norm() {
          return this._operator.norm();
        }
        apply(state) {
          return this._operator.apply(state);
        }
        compose(other) {
          return this._operator.compose(other);
        }
        adjoint() {
          return new operator_1.MatrixOperator(this.toMatrix(), "projection");
        }
        toMatrix() {
          return this._operator.toMatrix();
        }
        tensorProduct(other) {
          return this._operator.tensorProduct(other);
        }
        partialTrace(dims, traceOutIndices) {
          return this._operator.partialTrace(dims, traceOutIndices);
        }
        scale(scalar) {
          return this._operator.scale(scalar);
        }
        add(other) {
          return this._operator.add(other);
        }
        eigenDecompose() {
          return this._operator.eigenDecompose();
        }
      };
      exports.ProjectionOperator = ProjectionOperator2;
      function expectationValue(state, operator) {
        const resultState = operator.apply(state);
        let result = math.complex(0, 0);
        for (let i = 0; i < state.dimension; i++) {
          result = math.add(result, math.multiply(math.conj(state.amplitudes[i]), resultState.amplitudes[i]));
        }
        return result;
      }
      function measureState2(state, operator) {
        const eigenvalue = 1;
        const resultState = operator.apply(state);
        const probability = resultState.amplitudes.reduce((sum2, amp) => sum2 + math.abs(amp) ** 2, 0);
        const normalizedAmplitudes = resultState.amplitudes.map((amp) => math.divide(amp, math.sqrt(probability)));
        return {
          value: eigenvalue,
          probability,
          state: new stateVector_1.StateVector(state.dimension, normalizedAmplitudes, state.basis)
        };
      }
      function createMeasurementOperator(observable, eigenvalue) {
        throw new Error("General measurement operators not yet implemented");
      }
    }
  });

  // dist/operators/hamiltonian.js
  var require_hamiltonian = __commonJS({
    "dist/operators/hamiltonian.js"(exports) {
      "use strict";
      var __createBinding = exports && exports.__createBinding || (Object.create ? (function(o, m, k, k2) {
        if (k2 === void 0) k2 = k;
        var desc = Object.getOwnPropertyDescriptor(m, k);
        if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
          desc = { enumerable: true, get: function() {
            return m[k];
          } };
        }
        Object.defineProperty(o, k2, desc);
      }) : (function(o, m, k, k2) {
        if (k2 === void 0) k2 = k;
        o[k2] = m[k];
      }));
      var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? (function(o, v) {
        Object.defineProperty(o, "default", { enumerable: true, value: v });
      }) : function(o, v) {
        o["default"] = v;
      });
      var __importStar = exports && exports.__importStar || /* @__PURE__ */ (function() {
        var ownKeys = function(o) {
          ownKeys = Object.getOwnPropertyNames || function(o2) {
            var ar = [];
            for (var k in o2) if (Object.prototype.hasOwnProperty.call(o2, k)) ar[ar.length] = k;
            return ar;
          };
          return ownKeys(o);
        };
        return function(mod2) {
          if (mod2 && mod2.__esModule) return mod2;
          var result = {};
          if (mod2 != null) {
            for (var k = ownKeys(mod2), i = 0; i < k.length; i++) if (k[i] !== "default") __createBinding(result, mod2, k[i]);
          }
          __setModuleDefault(result, mod2);
          return result;
        };
      })();
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.Hamiltonian = void 0;
      var operator_1 = require_operator();
      var validation_1 = require_validation();
      var matrixOperations_1 = require_matrixOperations();
      var gates_1 = require_gates();
      var composite_1 = require_composite();
      var matrixOperations_2 = require_matrixOperations();
      var math = __importStar(require_cjs());
      var Hamiltonian = class _Hamiltonian extends operator_1.MatrixOperator {
        constructor(dimension, terms, hamiltonianType = "custom", timeDependent = false, requireHermitian = false) {
          (0, validation_1.validatePosDim)(dimension);
          if (requireHermitian) {
            for (const term of terms) {
              if (!term || !term.operator) {
                throw new Error("Invalid term in Hamiltonian");
              }
              const termMatrix = term.operator.toMatrix();
              try {
                if (!(0, matrixOperations_2.isHermitian)(termMatrix)) {
                  throw new Error("All terms must be Hermitian when requireHermitian is true");
                }
              } catch (e) {
                if (e instanceof Error) {
                  throw new Error(`Hermiticity check failed: ${e.message}`);
                } else {
                  throw new Error("Hermiticity check failed: Unknown error");
                }
              }
              if (term.coefficient && Math.abs(term.coefficient.im) > 1e-10) {
                throw new Error("All coefficients must be real when requireHermitian is true");
              }
            }
            try {
              const matrix3 = terms.reduce((acc, term) => {
                const termMatrix = term.operator.toMatrix();
                const scaledTerm = (0, matrixOperations_1.scaleMatrix)(termMatrix, term.coefficient);
                return acc.map((row, i) => row.map((elem, j) => math.add(elem, scaledTerm[i][j])));
              }, Array(dimension).fill(null).map(() => Array(dimension).fill(null).map(() => math.complex(0, 0))));
              if (!(0, matrixOperations_2.isHermitian)(matrix3)) {
                throw new Error("Combined Hamiltonian must be Hermitian when requireHermitian is true");
              }
            } catch (e) {
              if (e instanceof Error) {
                throw new Error(`Hermiticity validation failed: ${e.message}`);
              } else {
                throw new Error("Hermiticity validation failed: Unknown error");
              }
            }
          }
          const matrix2 = terms.reduce((acc, term) => {
            const termMatrix = term.operator.toMatrix();
            const scaledTerm = (0, matrixOperations_1.scaleMatrix)(termMatrix, term.coefficient);
            return acc.map((row, i) => row.map((elem, j) => math.add(elem, scaledTerm[i][j])));
          }, Array(dimension).fill(null).map(() => Array(dimension).fill(null).map(() => math.complex(0, 0))));
          super(matrix2, "general");
          this.hamiltonianType = hamiltonianType;
          this.terms = [...terms];
          this._timeDependent = timeDependent;
        }
        /**
         * Generates the quantum time evolution operator U(t) = exp(-iHt/)
         *
         * The time evolution operator is fundamental in quantum mechanics:
         * - Transforms states from time t to t: |(t) = U(t-t)|(t)
         * - Preserves probability (unitary)
         * - Satisfies group properties (U(t)U(t) = U(t+t))
         *
         * Implementation:
         * 1. Validates time-independence
         * 2. Computes -iHt (using  = 1 units)
         * 3. Calculates matrix exponential
         * 4. Ensures unitarity
         *
         * @param time - Evolution time (in natural units)
         * @returns Unitary evolution operator U(t)
         * @throws Error for time-dependent Hamiltonians
         * @throws Error for invalid matrix structure
         */
        getEvolutionOperator(time) {
          if (this._timeDependent) {
            throw new Error("Time-dependent Hamiltonians require numerical integration");
          }
          const matrix2 = this.toMatrix();
          if (!matrix2 || matrix2.length === 0 || !matrix2[0] || matrix2[0].length === 0) {
            throw new Error("Invalid Hamiltonian matrix");
          }
          const scaledMatrix = matrix2.map((row) => row.map((element) => {
            return math.multiply(element, math.complex(0, -time));
          }));
          const evolutionMatrix = (0, matrixOperations_1.matrixExponential)(scaledMatrix);
          const dim = this.dimension;
          for (let i = 0; i < dim; i++) {
            for (let j = 0; j < dim; j++) {
              if (!evolutionMatrix[i][j] || typeof evolutionMatrix[i][j].re !== "number" || typeof evolutionMatrix[i][j].im !== "number") {
                evolutionMatrix[i][j] = math.complex(i === j ? 1 : 0, 0);
              }
            }
          }
          return new operator_1.MatrixOperator(evolutionMatrix, "unitary", false);
        }
        /**
         * Evolves a quantum state under this Hamiltonian for time t
         *
         * Implements Schrdinger equation evolution:
         * |(t) = exp(-iHt/)|(0)
         *
         * Process:
         * 1. Validates state dimension
         * 2. Computes evolution operator U(t)
         * 3. Applies U(t) to initial state
         * 4. Ensures normalization (corrects numerical errors)
         *
         * Physical meaning:
         * - Describes how quantum state changes with time
         * - Preserves total probability (norm = 1)
         * - Maintains quantum superposition
         *
         * @param state - Initial quantum state |(0)
         * @param time - Evolution time t
         * @returns Evolved state |(t)
         * @throws Error if dimensions don't match
         */
        evolveState(state, time) {
          if (state.dimension !== this.dimension) {
            throw new Error("State dimension does not match Hamiltonian dimension");
          }
          const U = this.getEvolutionOperator(time);
          const evolvedState = U.apply(state);
          try {
            const norm = evolvedState.norm();
            if (norm > 1e-10 && Math.abs(norm - 1) > 1e-10) {
              return evolvedState.normalize();
            }
            return evolvedState;
          } catch (e) {
            console.error("Normalization error in evolveState:", e instanceof Error ? e.message : "Unknown error");
            return state;
          }
        }
        /**
         * Computes the expectation value of energy for a given state
         *
         * The energy expectation value is:
         * E = |H|
         *
         * Physical significance:
         * - Average energy in state |
         * - Real for physical (Hermitian) Hamiltonians
         * - Bounded by energy eigenvalues
         * - Constant for energy eigenstates
         *
         * @param state - Quantum state |
         * @returns Complex energy expectation value
         * @throws Error if dimensions don't match
         */
        expectationValue(state) {
          if (state.dimension !== this.dimension) {
            throw new Error("State dimension does not match Hamiltonian dimension");
          }
          const Hpsi = this.apply(state);
          return state.innerProduct(Hpsi);
        }
        /**
         * Creates a spin-1/2 Hamiltonian in a magnetic field
         *
         * Implements the Zeeman Hamiltonian:
         * H = B = Bxx + Byy + Bzz
         * where:
         * - B = (Bx, By, Bz) is the magnetic field vector
         * -  = (x, y, z) are the Pauli matrices
         *
         * Physical significance:
         * - Describes magnetic dipole in field
         * - Energy splitting E = 2|B|
         * - Precession frequency  = 2|B|
         * - Eigenstates align/anti-align with B
         *
         * @param magneticField - [Bx, By, Bz] field components
         * @returns Spin Hamiltonian operator
         *
         * @example
         * // Create Hamiltonian for field along z-axis
         * const H = Hamiltonian.createSpinHamiltonian([0, 0, 1]);
         */
        static createSpinHamiltonian(magneticField) {
          const [Bx, By, Bz] = magneticField;
          const terms = [
            {
              coefficient: math.complex(Bx, 0),
              operator: gates_1.PauliX
            },
            {
              coefficient: math.complex(By, 0),
              operator: gates_1.PauliY
            },
            {
              coefficient: math.complex(Bz, 0),
              operator: gates_1.PauliZ
            }
          ];
          return new _Hamiltonian(2, terms, "spin");
        }
        /**
         * Creates a Heisenberg interaction Hamiltonian for a spin chain
         *
         * Implements the Heisenberg model:
         * H = J  SS
         * where:
         * - J is the exchange coupling constant
         * - S are spin operators at site i
         * - Sum runs over nearest neighbors
         *
         * The interaction term SS expands as:
         * SS = SxSx + SySy + SzSz
         *
         * Physical significance:
         * - Models magnetic interactions in materials
         * - J > 0: Ferromagnetic coupling (parallel spins favored)
         * - J < 0: Antiferromagnetic coupling (anti-parallel spins favored)
         * - Conserves total spin
         * - Supports quantum entanglement
         *
         * @param numSpins - Number of spins in the chain
         * @param coupling - Exchange coupling strength J
         * @returns Heisenberg Hamiltonian operator
         * @throws Error if numSpins < 2
         *
         * @example
         * // Create antiferromagnetic chain of 3 spins
         * const H = Hamiltonian.createHeisenbergHamiltonian(3, -1.0);
         */
        static createHeisenbergHamiltonian(numSpins, coupling) {
          if (numSpins < 2) {
            throw new Error("Heisenberg model requires at least 2 spins");
          }
          const terms = [];
          const coeff = math.complex(coupling, 0);
          const dimension = Math.pow(2, numSpins);
          for (let i = 0; i < numSpins - 1; i++) {
            for (const pauli of [gates_1.PauliX, gates_1.PauliY, gates_1.PauliZ]) {
              const ops = Array(numSpins).fill(null).map(() => operator_1.MatrixOperator.identity(2));
              ops[i] = pauli;
              ops[i + 1] = pauli;
              try {
                const op = (0, composite_1.composeOperators)(ops);
                if (op.dimension !== dimension) {
                  throw new Error(`Operator dimension mismatch: expected ${dimension}, got ${op.dimension}`);
                }
                terms.push({
                  coefficient: coeff,
                  operator: op
                });
              } catch (e) {
                console.error(`Error creating Heisenberg term: ${e instanceof Error ? e.message : "Unknown error"}`);
                terms.push({
                  coefficient: math.complex(0, 0),
                  // Zero coefficient
                  operator: operator_1.MatrixOperator.identity(dimension)
                });
              }
            }
          }
          if (terms.length === 0) {
            throw new Error("Failed to create any valid terms for Heisenberg Hamiltonian");
          }
          return new _Hamiltonian(dimension, terms, "interaction");
        }
      };
      exports.Hamiltonian = Hamiltonian;
    }
  });

  // dist/operators/circuit.js
  var require_circuit = __commonJS({
    "dist/operators/circuit.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
    }
  });

  // dist/utils/oscillator.js
  var require_oscillator = __commonJS({
    "dist/utils/oscillator.js"(exports) {
      "use strict";
      var __createBinding = exports && exports.__createBinding || (Object.create ? (function(o, m, k, k2) {
        if (k2 === void 0) k2 = k;
        var desc = Object.getOwnPropertyDescriptor(m, k);
        if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
          desc = { enumerable: true, get: function() {
            return m[k];
          } };
        }
        Object.defineProperty(o, k2, desc);
      }) : (function(o, m, k, k2) {
        if (k2 === void 0) k2 = k;
        o[k2] = m[k];
      }));
      var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? (function(o, v) {
        Object.defineProperty(o, "default", { enumerable: true, value: v });
      }) : function(o, v) {
        o["default"] = v;
      });
      var __importStar = exports && exports.__importStar || /* @__PURE__ */ (function() {
        var ownKeys = function(o) {
          ownKeys = Object.getOwnPropertyNames || function(o2) {
            var ar = [];
            for (var k in o2) if (Object.prototype.hasOwnProperty.call(o2, k)) ar[ar.length] = k;
            return ar;
          };
          return ownKeys(o);
        };
        return function(mod2) {
          if (mod2 && mod2.__esModule) return mod2;
          var result = {};
          if (mod2 != null) {
            for (var k = ownKeys(mod2), i = 0; i < k.length; i++) if (k[i] !== "default") __createBinding(result, mod2, k[i]);
          }
          __setModuleDefault(result, mod2);
          return result;
        };
      })();
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.creationOp = creationOp;
      exports.destructionOp = destructionOp;
      exports.numberOp = numberOp;
      exports.positionOp = positionOp;
      exports.momentumOp = momentumOp;
      exports.harmonicOscillator = harmonicOscillator;
      var operator_1 = require_operator();
      var math = __importStar(require_cjs());
      function creationOp(dimension) {
        const matrix2 = Array(dimension).fill(null).map(() => Array(dimension).fill(null).map(() => math.complex(0, 0)));
        for (let m = 0; m < dimension - 1; m++) {
          matrix2[m + 1][m] = math.complex(Math.sqrt(m + 1), 0);
        }
        return new operator_1.MatrixOperator(matrix2);
      }
      function destructionOp(dimension) {
        const matrix2 = Array(dimension).fill(null).map(() => Array(dimension).fill(null).map(() => math.complex(0, 0)));
        for (let m = 1; m < dimension; m++) {
          matrix2[m - 1][m] = math.complex(Math.sqrt(m), 0);
        }
        return new operator_1.MatrixOperator(matrix2);
      }
      function numberOp(dimension) {
        const matrix2 = Array(dimension).fill(null).map((_, i) => Array(dimension).fill(null).map((_2, j) => i === j ? math.complex(i, 0) : math.complex(0, 0)));
        return new operator_1.MatrixOperator(matrix2, "hermitian");
      }
      function positionOp(dimension) {
        const aOp = destructionOp(dimension);
        const aUpOp = creationOp(dimension);
        const sumOp = aOp.add(aUpOp);
        const finalOp = sumOp.scale(math.complex(1 / Math.sqrt(2), 0));
        return new operator_1.MatrixOperator(finalOp.toMatrix(), "hermitian");
      }
      function momentumOp(dimension) {
        const aOp = destructionOp(dimension);
        const aUpOp = creationOp(dimension);
        const diffOp = aUpOp.add(aOp.scale(math.complex(-1, 0)));
        const finalOp = diffOp.scale(math.complex(0, 1 / Math.sqrt(2)));
        return new operator_1.MatrixOperator(finalOp.toMatrix(), "hermitian");
      }
      function harmonicOscillator(dimension) {
        const n = numberOp(dimension);
        const halfId = operator_1.MatrixOperator.identity(dimension).scale(math.complex(0.5, 0));
        const hamiltonian = n.add(halfId);
        return new operator_1.MatrixOperator(hamiltonian.toMatrix(), "hermitian");
      }
    }
  });

  // dist/angularMomentum/core.js
  var require_core = __commonJS({
    "dist/angularMomentum/core.js"(exports) {
      "use strict";
      var __createBinding = exports && exports.__createBinding || (Object.create ? (function(o, m, k, k2) {
        if (k2 === void 0) k2 = k;
        var desc = Object.getOwnPropertyDescriptor(m, k);
        if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
          desc = { enumerable: true, get: function() {
            return m[k];
          } };
        }
        Object.defineProperty(o, k2, desc);
      }) : (function(o, m, k, k2) {
        if (k2 === void 0) k2 = k;
        o[k2] = m[k];
      }));
      var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? (function(o, v) {
        Object.defineProperty(o, "default", { enumerable: true, value: v });
      }) : function(o, v) {
        o["default"] = v;
      });
      var __importStar = exports && exports.__importStar || /* @__PURE__ */ (function() {
        var ownKeys = function(o) {
          ownKeys = Object.getOwnPropertyNames || function(o2) {
            var ar = [];
            for (var k in o2) if (Object.prototype.hasOwnProperty.call(o2, k)) ar[ar.length] = k;
            return ar;
          };
          return ownKeys(o);
        };
        return function(mod2) {
          if (mod2 && mod2.__esModule) return mod2;
          var result = {};
          if (mod2 != null) {
            for (var k = ownKeys(mod2), i = 0; i < k.length; i++) if (k[i] !== "default") __createBinding(result, mod2, k[i]);
          }
          __setModuleDefault(result, mod2);
          return result;
        };
      })();
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.createJmState = createJmState2;
      exports.computationalToAngularBasis = computationalToAngularBasis;
      exports.angularToComputationalBasis = angularToComputationalBasis;
      exports.identifyBasis = identifyBasis;
      exports.createJplus = createJplus2;
      exports.createJminus = createJminus2;
      exports.createJz = createJz2;
      exports.createJx = createJx;
      exports.createJy = createJy;
      exports.createJ2 = createJ22;
      exports.createJ2FromComponents = createJ2FromComponents;
      exports.validateJ = validateJ;
      exports.getValidM = getValidM2;
      exports.isValidM = isValidM;
      exports.createRotationOperator = createRotationOperator;
      exports.jmExpectationValue = jmExpectationValue2;
      exports.createCoherentState = createCoherentState;
      var operator_1 = require_operator();
      var measurement_1 = require_measurement();
      var stateVector_1 = require_stateVector();
      var matrixOperations_1 = require_matrixOperations();
      var math = __importStar(require_cjs());
      function createJmState2(j, m) {
        validateJ(j);
        if (!isValidM(j, m)) {
          throw new Error(`Invalid m=${m} for j=${j}`);
        }
        const dim = Math.floor(2 * j + 1);
        const amplitudes = Array(dim).fill(null).map(() => math.complex(0, 0));
        const idx = dim - 1 - (j + m);
        amplitudes[idx] = math.complex(1, 0);
        const state = new stateVector_1.StateVector(dim, amplitudes, `|${j},${m}\u27E9`);
        const metadata = {
          type: "angular_momentum",
          j,
          mRange: [-j, j],
          couplingHistory: [{
            operation: "single",
            resultJ: [j],
            timestamp: Date.now()
          }],
          jComponents: /* @__PURE__ */ new Map([[j, {
            j,
            startIndex: 0,
            dimension: dim,
            normalizationFactor: 1
          }]]),
          isComposite: false
        };
        state.setAngularMomentumMetadata(metadata);
        return state;
      }
      function computationalToAngularBasis(state, j) {
        validateJ(j);
        const dim = Math.floor(2 * j + 1);
        if (state.dimension !== dim) {
          throw new Error(`State dimension ${state.dimension} does not match 2j+1 = ${dim}`);
        }
        const newAmplitudes = Array(dim).fill(null).map(() => math.complex(0, 0));
        for (let n = 0; n < dim; n++) {
          const m = -j + n;
          const angularIndex = dim - 1 - (j + m);
          newAmplitudes[angularIndex] = state.amplitudes[n];
        }
        const labels = [];
        for (let m = -j; m <= j; m++) {
          labels.push(`|${j},${m}\u27E9`);
        }
        return new stateVector_1.StateVector(dim, newAmplitudes, "angular");
      }
      function angularToComputationalBasis(state, j) {
        validateJ(j);
        const dim = Math.floor(2 * j + 1);
        if (state.dimension !== dim) {
          throw new Error(`State dimension ${state.dimension} does not match 2j+1 = ${dim}`);
        }
        const newAmplitudes = Array(dim).fill(null).map(() => math.complex(0, 0));
        for (let m = -j; m <= j; m++) {
          const n = m + j;
          const angularIndex = dim - 1 - (j + m);
          newAmplitudes[n] = state.amplitudes[angularIndex];
        }
        const labels = [];
        for (let i = 0; i < dim; i++) {
          labels.push(`|${i}\u27E9`);
        }
        return new stateVector_1.StateVector(dim, newAmplitudes, "computational");
      }
      function identifyBasis(state) {
        const str = state.toString();
        if (str.match(/\|\d+\/?\d*,[-+]?\d+\/?\d*/)) {
          return "angular";
        }
        if (str.match(/\|\d+/)) {
          return "computational";
        }
        return "unknown";
      }
      function createZeroMatrix(dim) {
        return Array(dim).fill(null).map(() => Array(dim).fill(null).map(() => math.complex(0, 0)));
      }
      function createJplus2(j) {
        validateJ(j);
        const dim = Math.floor(2 * j + 1);
        const matrix2 = createZeroMatrix(dim);
        for (let m = -j; m < j; m++) {
          const fromStateIdx = dim - 1 - (j + m);
          const toStateIdx = dim - 1 - (j + (m + 1));
          const element = Math.sqrt(j * (j + 1) - m * (m + 1));
          matrix2[toStateIdx][fromStateIdx] = math.complex(element, 0);
        }
        return new operator_1.MatrixOperator(matrix2, "general", true, { j });
      }
      function createJminus2(j) {
        validateJ(j);
        const dim = Math.floor(2 * j + 1);
        const matrix2 = createZeroMatrix(dim);
        for (let m = -j + 1; m <= j; m++) {
          const fromStateIdx = dim - 1 - (j + m);
          const toStateIdx = dim - 1 - (j + (m - 1));
          const element = Math.sqrt(j * (j + 1) - m * (m - 1));
          matrix2[toStateIdx][fromStateIdx] = math.complex(element, 0);
        }
        return new operator_1.MatrixOperator(matrix2, "general", true, { j });
      }
      function createJz2(j) {
        validateJ(j);
        const dim = Math.floor(2 * j + 1);
        const matrix2 = createZeroMatrix(dim);
        for (let idx = 0; idx < dim; idx++) {
          const m = -j + (dim - 1 - idx);
          matrix2[idx][idx] = math.complex(m, 0);
        }
        return new operator_1.MatrixOperator(matrix2, "hermitian", true, { j });
      }
      function createJx(j) {
        const jPlus = createJplus2(j);
        const jMinus = createJminus2(j);
        const plusMatrix = jPlus.toMatrix();
        const minusMatrix = jMinus.toMatrix();
        const matrix2 = plusMatrix.map((row, i) => row.map((_, j2) => math.multiply(math.add(plusMatrix[i][j2], minusMatrix[i][j2]), math.complex(0.5, 0))));
        return new operator_1.MatrixOperator(matrix2, "hermitian", true, { j });
      }
      function createJy(j) {
        const jPlus = createJplus2(j);
        const jMinus = createJminus2(j);
        const plusMatrix = jPlus.toMatrix();
        const minusMatrix = jMinus.toMatrix();
        const matrix2 = plusMatrix.map((row, i) => row.map((_, j2) => math.multiply(
          math.subtract(plusMatrix[i][j2], minusMatrix[i][j2]),
          math.complex(0, -0.5)
          // multiply by 1/(2i)
        )));
        return new operator_1.MatrixOperator(matrix2, "general", true, { j });
      }
      function createJ22(j) {
        validateJ(j);
        const dim = Math.floor(2 * j + 1);
        const eigenvalue = j * (j + 1);
        const matrix2 = createZeroMatrix(dim);
        for (let i = 0; i < dim; i++) {
          matrix2[i][i] = math.complex(eigenvalue, 0);
        }
        const op = new operator_1.MatrixOperator(matrix2);
        return Object.assign(op, { j });
      }
      function createJ2FromComponents(j) {
        const jPlus = createJplus2(j);
        const jMinus = createJminus2(j);
        const jz = createJz2(j);
        const jPlusJMinus = jPlus.compose(jMinus);
        const jzSquared = jz.compose(jz);
        const result = jPlusJMinus.add(jzSquared).add(jz.scale(math.complex(-1, 0)));
        return Object.assign(new operator_1.MatrixOperator(result.toMatrix()), { j });
      }
      function validateJ(j) {
        if (j < 0) {
          throw new Error("Angular momentum j must be non-negative");
        }
        const isValid = Math.abs(j * 2 - Math.round(j * 2)) < 1e-10;
        if (!isValid) {
          throw new Error("Angular momentum j must be integer or half-integer");
        }
      }
      function getValidM2(j) {
        validateJ(j);
        const mValues = [];
        for (let m = -j; m <= j; m++) {
          mValues.push(m);
        }
        return mValues;
      }
      function isValidM(j, m) {
        validateJ(j);
        if (m < -j || m > j) {
          return false;
        }
        const mValues = getValidM2(j);
        return mValues.includes(m);
      }
      function createRotationOperator(j, alpha, beta, gamma) {
        const jz = createJz2(j);
        const jPlus = createJplus2(j);
        const jMinus = createJminus2(j);
        const jyMatrix = jPlus.toMatrix().map((row, i) => row.map((_, j2) => {
          const plusElem = jPlus.toMatrix()[i][j2];
          const minusElem = jMinus.toMatrix()[i][j2];
          return math.multiply(math.subtract(plusElem, minusElem), math.complex(0, -0.5));
        }));
        const jy = new operator_1.MatrixOperator(jyMatrix, "general", true, { j });
        const expAlpha = Object.assign(new operator_1.MatrixOperator((0, matrixOperations_1.matrixExponential)(jz.scale(math.complex(0, -alpha)).toMatrix())), { j });
        const expBeta = Object.assign(new operator_1.MatrixOperator((0, matrixOperations_1.matrixExponential)(jy.scale(math.complex(0, -beta)).toMatrix())), { j });
        const expGamma = Object.assign(new operator_1.MatrixOperator((0, matrixOperations_1.matrixExponential)(jz.scale(math.complex(0, -gamma)).toMatrix())), { j });
        const result = expAlpha.compose(expBeta).compose(expGamma);
        return Object.assign(new operator_1.MatrixOperator(result.toMatrix()), { j });
      }
      function jmExpectationValue2(operator, j, m) {
        const state = createJmState2(j, m);
        return (0, measurement_1.expectationValue)(state, operator);
      }
      function createCoherentState(j, theta, phi) {
        validateJ(j);
        const alpha = phi;
        const beta = theta;
        const gamma = 0;
        const D = createRotationOperator(j, alpha, beta, gamma);
        const highestState = createJmState2(j, j);
        return D.apply(highestState);
      }
    }
  });

  // dist/utils/math.js
  var require_math = __commonJS({
    "dist/utils/math.js"(exports) {
      "use strict";
      var __createBinding = exports && exports.__createBinding || (Object.create ? (function(o, m, k, k2) {
        if (k2 === void 0) k2 = k;
        var desc = Object.getOwnPropertyDescriptor(m, k);
        if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
          desc = { enumerable: true, get: function() {
            return m[k];
          } };
        }
        Object.defineProperty(o, k2, desc);
      }) : (function(o, m, k, k2) {
        if (k2 === void 0) k2 = k;
        o[k2] = m[k];
      }));
      var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? (function(o, v) {
        Object.defineProperty(o, "default", { enumerable: true, value: v });
      }) : function(o, v) {
        o["default"] = v;
      });
      var __importStar = exports && exports.__importStar || /* @__PURE__ */ (function() {
        var ownKeys = function(o) {
          ownKeys = Object.getOwnPropertyNames || function(o2) {
            var ar = [];
            for (var k in o2) if (Object.prototype.hasOwnProperty.call(o2, k)) ar[ar.length] = k;
            return ar;
          };
          return ownKeys(o);
        };
        return function(mod2) {
          if (mod2 && mod2.__esModule) return mod2;
          var result = {};
          if (mod2 != null) {
            for (var k = ownKeys(mod2), i = 0; i < k.length; i++) if (k[i] !== "default") __createBinding(result, mod2, k[i]);
          }
          __setModuleDefault(result, mod2);
          return result;
        };
      })();
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.logFactorial = logFactorial;
      exports.factorial = factorial;
      exports.doubleFactorial = doubleFactorial;
      exports.triangleCoefficient = triangleCoefficient;
      exports.legendrePolynomial = legendrePolynomial;
      exports.matrixExponential = matrixExponential;
      exports.multiplyMatrices = multiplyMatrices;
      exports.singularValueDecomposition = singularValueDecomposition;
      var math = __importStar(require_cjs());
      var factorialCache = /* @__PURE__ */ new Map();
      var logFactorialCache = /* @__PURE__ */ new Map();
      var doubleFactorialCache = /* @__PURE__ */ new Map();
      function logFactorial(n) {
        if (n < 0)
          return -Infinity;
        if (Math.abs(Math.round(n) - n) > 1e-10) {
          throw new Error("Factorial only defined for integers");
        }
        n = Math.round(n);
        const cached = logFactorialCache.get(n);
        if (cached !== void 0)
          return cached;
        let result = 0;
        for (let i = 2; i <= n; i++) {
          result += Math.log(i);
        }
        logFactorialCache.set(n, result);
        return result;
      }
      function factorial(n) {
        if (n < 0)
          throw new Error("Factorial not defined for negative numbers");
        if (n > 170)
          throw new Error("Factorial too large for direct computation");
        const cached = factorialCache.get(n);
        if (cached !== void 0)
          return cached;
        const result = Math.exp(logFactorial(n));
        factorialCache.set(n, result);
        return result;
      }
      function doubleFactorial(n) {
        if (n < 0)
          throw new Error("Double factorial not defined for negative numbers");
        if (n > 300)
          throw new Error("Double factorial too large for direct computation");
        const cached = doubleFactorialCache.get(n);
        if (cached !== void 0)
          return cached;
        if (n <= 1)
          return 1;
        const result = n * doubleFactorial(n - 2);
        doubleFactorialCache.set(n, result);
        return result;
      }
      function triangleCoefficient(a, b, c) {
        if (c > a + b || c < Math.abs(a - b)) {
          return 0;
        }
        const sum2 = logFactorial(Math.round(a + b - c)) + logFactorial(Math.round(a - b + c)) + logFactorial(Math.round(-a + b + c)) - logFactorial(Math.round(a + b + c + 1));
        return Math.exp(sum2 / 2);
      }
      function legendrePolynomial(n, x) {
        if (n < 0 || Math.abs(Math.round(n) - n) > 1e-10) {
          throw new Error("Degree must be non-negative integer");
        }
        if (Math.abs(x) > 1) {
          throw new Error("Argument must be in [-1,1]");
        }
        if (n === 0)
          return 1;
        if (n === 1)
          return x;
        let p0 = 1;
        let p1 = x;
        let pn = 0;
        for (let k = 2; k <= n; k++) {
          pn = ((2 * k - 1) * x * p1 - (k - 1) * p0) / k;
          p0 = p1;
          p1 = pn;
        }
        return pn;
      }
      function matrixExponential(matrix2, terms = 10) {
        const dim = matrix2.length;
        const result = Array(dim).fill(null).map((_, i) => Array(dim).fill(null).map((_2, j) => i === j ? math.complex(1, 0) : math.complex(0, 0)));
        let term = Array(dim).fill(null).map((_, i) => Array(dim).fill(null).map((_2, j) => i === j ? math.complex(1, 0) : math.complex(0, 0)));
        for (let n = 1; n <= terms; n++) {
          term = multiplyMatrices(term, matrix2).map((row) => row.map((element) => math.complex(element.re / n, element.im / n)));
          result.forEach((row, i) => row.forEach((_, j) => {
            result[i][j] = math.add(result[i][j], term[i][j]);
          }));
        }
        return result;
      }
      function multiplyMatrices(a, b) {
        const dim = a.length;
        const result = Array(dim).fill(null).map(() => Array(dim).fill(null).map(() => math.complex(0, 0)));
        for (let i = 0; i < dim; i++) {
          for (let j = 0; j < dim; j++) {
            for (let k = 0; k < dim; k++) {
              const prod = math.multiply(a[i][k], b[k][j]);
              result[i][j] = math.add(result[i][j], prod);
            }
          }
        }
        return result;
      }
      function singularValueDecomposition(matrix2) {
        const dim = matrix2.length;
        return {
          U: Array(dim).fill(null).map((_, i) => Array(dim).fill(null).map((_2, j) => i === j ? math.complex(1, 0) : math.complex(0, 0))),
          S: Array(dim).fill(1),
          V: Array(dim).fill(null).map((_, i) => Array(dim).fill(null).map((_2, j) => i === j ? math.complex(1, 0) : math.complex(0, 0)))
        };
      }
    }
  });

  // dist/angularMomentum/composition.js
  var require_composition3 = __commonJS({
    "dist/angularMomentum/composition.js"(exports) {
      "use strict";
      var __createBinding = exports && exports.__createBinding || (Object.create ? (function(o, m, k, k2) {
        if (k2 === void 0) k2 = k;
        var desc = Object.getOwnPropertyDescriptor(m, k);
        if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
          desc = { enumerable: true, get: function() {
            return m[k];
          } };
        }
        Object.defineProperty(o, k2, desc);
      }) : (function(o, m, k, k2) {
        if (k2 === void 0) k2 = k;
        o[k2] = m[k];
      }));
      var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? (function(o, v) {
        Object.defineProperty(o, "default", { enumerable: true, value: v });
      }) : function(o, v) {
        o["default"] = v;
      });
      var __importStar = exports && exports.__importStar || /* @__PURE__ */ (function() {
        var ownKeys = function(o) {
          ownKeys = Object.getOwnPropertyNames || function(o2) {
            var ar = [];
            for (var k in o2) if (Object.prototype.hasOwnProperty.call(o2, k)) ar[ar.length] = k;
            return ar;
          };
          return ownKeys(o);
        };
        return function(mod2) {
          if (mod2 && mod2.__esModule) return mod2;
          var result = {};
          if (mod2 != null) {
            for (var k = ownKeys(mod2), i = 0; i < k.length; i++) if (k[i] !== "default") __createBinding(result, mod2, k[i]);
          }
          __setModuleDefault(result, mod2);
          return result;
        };
      })();
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.clebschGordan = clebschGordan;
      exports.addAngularMomenta = addAngularMomenta;
      exports.decomposeAngularState = decomposeAngularState;
      exports.validateAngularMomentum = validateAngularMomentum;
      exports.isZeroCG = isZeroCG;
      var stateVector_1 = require_stateVector();
      var core_1 = require_core();
      var math_1 = require_math();
      var math = __importStar(require_cjs());
      var cgCache = /* @__PURE__ */ new Map();
      function cgKey(j1, m1, j2, m2, j, m) {
        return `${j1},${m1},${j2},${m2},${j},${m}`;
      }
      function validateAngularMomentum(j1, m1, j2, m2, j, m) {
        (0, core_1.validateJ)(j1);
        (0, core_1.validateJ)(j2);
        (0, core_1.validateJ)(j);
        if (!(0, core_1.isValidM)(j1, m1)) {
          throw new Error(`Invalid m1=${m1} for j1=${j1}`);
        }
        if (!(0, core_1.isValidM)(j2, m2)) {
          throw new Error(`Invalid m2=${m2} for j2=${j2}`);
        }
        if (!(0, core_1.isValidM)(j, m)) {
          throw new Error(`Invalid m=${m} for j=${j}`);
        }
        if (j < Math.abs(j1 - j2) || j > j1 + j2) {
          throw new Error(`Total angular momentum j=${j} must satisfy |j1-j2| \u2264 j \u2264 j1+j2, where j1=${j1}, j2=${j2}`);
        }
        if (Math.abs(m - (m1 + m2)) > 1e-10) {
          throw new Error(`m=${m} must equal m1+m2=${m1}+${m2}=${m1 + m2}`);
        }
      }
      function isZeroCG(j1, m1, j2, m2, j, m) {
        if (Math.abs(m - (m1 + m2)) > 1e-10) {
          return true;
        }
        if (j > j1 + j2) {
          return true;
        }
        if (j < Math.abs(j1 - j2)) {
          return true;
        }
        if (Math.abs(m1) > j1 || Math.abs(m2) > j2 || Math.abs(m) > j) {
          return true;
        }
        return false;
      }
      function clebschGordan(j1, m1, j2, m2, j, m) {
        try {
          validateAngularMomentum(j1, m1, j2, m2, j, m);
        } catch (error) {
          return math.complex(0, 0);
        }
        if (isZeroCG(j1, m1, j2, m2, j, m)) {
          return math.complex(0, 0);
        }
        const cacheKey = `${j1},${j2}`;
        let table;
        if (cgCache.has(cacheKey)) {
          table = cgCache.get(cacheKey);
        } else {
          table = generateCGSparseMap(j1, j2);
          cgCache.set(cacheKey, table);
        }
        const key = cgKey(j1, m1, j2, m2, j, m);
        if (table.has(key)) {
          return math.complex(table.get(key), 0);
        }
        return math.complex(0, 0);
      }
      function generateCGSparseMap(j1, j2) {
        const map = /* @__PURE__ */ new Map();
        const jMin = Math.abs(j1 - j2);
        const jMax = j1 + j2;
        for (let j = jMin; j <= jMax; j++) {
          for (let m = -j; m <= j; m++) {
            for (let m1 = -j1; m1 <= j1; m1++) {
              const m2 = m - m1;
              if (m2 < -j2 || m2 > j2)
                continue;
              if (isZeroCG(j1, m1, j2, m2, j, m))
                continue;
              let coeff = generateCGTableCoeff(j1, m1, j2, m2, j, m);
              if (Math.abs(coeff) > 1e-12) {
                map.set(cgKey(j1, m1, j2, m2, j, m), coeff);
              }
            }
          }
        }
        return map;
      }
      function generateCGTableCoeff(j1, m1, j2, m2, j, m) {
        if (isZeroCG(j1, m1, j2, m2, j, m)) {
          return 0;
        }
        if (Math.abs(j1 - 0.5) < 1e-10 && Math.abs(j2 - 0.5) < 1e-10 && Math.abs(j) < 1e-10) {
          if (Math.abs(m1 - 0.5) < 1e-10 && Math.abs(m2 + 0.5) < 1e-10) {
            return -1 / Math.sqrt(2);
          }
          if (Math.abs(m1 + 0.5) < 1e-10 && Math.abs(m2 - 0.5) < 1e-10) {
            return 1 / Math.sqrt(2);
          }
        }
        if (Math.abs(m - (j1 + j2)) < 1e-10 && Math.abs(m1 - j1) < 1e-10 && Math.abs(m2 - j2) < 1e-10) {
          return 1;
        }
        const logPrefactor = Math.log(2 * j + 1);
        const logDelta = 0.5 * ((0, math_1.logFactorial)(Math.round(j + j1 - j2)) + (0, math_1.logFactorial)(Math.round(j - j1 + j2)) + (0, math_1.logFactorial)(Math.round(j1 + j2 - j)) - (0, math_1.logFactorial)(Math.round(j1 + j2 + j + 1)));
        const logTerm1 = 0.5 * ((0, math_1.logFactorial)(Math.round(j + m)) + (0, math_1.logFactorial)(Math.round(j - m)) + (0, math_1.logFactorial)(Math.round(j1 - m1)) + (0, math_1.logFactorial)(Math.round(j1 + m1)) + (0, math_1.logFactorial)(Math.round(j2 - m2)) + (0, math_1.logFactorial)(Math.round(j2 + m2)));
        let sum2 = 0;
        const kMin = Math.max(0, j2 - j - m1, j1 - j + m2);
        const kMax = Math.min(j1 + j2 - j, j1 - m1, j2 + m2);
        for (let k = Math.ceil(kMin); k <= Math.floor(kMax); k++) {
          const sign3 = k % 2 === 0 ? 1 : -1;
          const logDenominatorTerms = (0, math_1.logFactorial)(k) + (0, math_1.logFactorial)(Math.round(j1 + j2 - j - k)) + (0, math_1.logFactorial)(Math.round(j1 - m1 - k)) + (0, math_1.logFactorial)(Math.round(j2 + m2 - k)) + (0, math_1.logFactorial)(Math.round(j - j1 + m2 + k)) + (0, math_1.logFactorial)(Math.round(j - j2 - m1 + k));
          const termValue = Math.exp(-logDenominatorTerms);
          if (!isNaN(termValue) && isFinite(termValue)) {
            sum2 += sign3 * termValue;
          }
        }
        const result = Math.exp(0.5 * logPrefactor + logDelta + logTerm1) * sum2;
        return result;
      }
      function addAngularMomenta(state1, j1, state2, j2) {
        const dim1 = Math.floor(2 * j1 + 1);
        const dim2 = Math.floor(2 * j2 + 1);
        if (state1.dimension !== dim1) {
          throw new Error(`State 1 dimension ${state1.dimension} does not match angular momentum j1=${j1} (expected ${dim1})`);
        }
        if (state2.dimension !== dim2) {
          throw new Error(`State 2 dimension ${state2.dimension} does not match angular momentum j2=${j2} (expected ${dim2})`);
        }
        const jMin = Math.abs(j1 - j2);
        const jMax = j1 + j2;
        const resultStates = {};
        for (let j = jMin; j <= jMax; j++) {
          resultStates[j.toString()] = {};
          for (let m = -j; m <= j; m++) {
            resultStates[j.toString()][m.toString()] = math.complex(0, 0);
            for (let m1 = -j1; m1 <= j1; m1++) {
              const m2 = m - m1;
              if (m2 < -j2 || m2 > j2) {
                continue;
              }
              const cg = clebschGordan(j1, m1, j2, m2, j, m);
              if (math.abs(cg.re ?? cg) < 1e-10) {
                continue;
              }
              const dim12 = Math.floor(2 * j1 + 1);
              const idx1 = dim12 - 1 - Math.floor(j1 + m1);
              const amp1 = state1.amplitudes[idx1];
              const dim22 = Math.floor(2 * j2 + 1);
              const idx2 = dim22 - 1 - Math.floor(j2 + m2);
              const amp2 = state2.amplitudes[idx2];
              const term = math.multiply(math.multiply(amp1, amp2), cg);
              resultStates[j.toString()][m.toString()] = math.add(resultStates[j.toString()][m.toString()], term);
            }
          }
        }
        const totalDim = Math.floor(Math.pow(j1 + j2 + 1, 2) - Math.pow(Math.abs(j1 - j2), 2));
        const resultAmplitudes = [];
        let maxJ = jMin;
        let maxM = -maxJ;
        let maxAmplitude = 0;
        for (let j = jMax; j >= jMin; j--) {
          for (let m = j; m >= -j; m--) {
            const amp = resultStates[j.toString()][m.toString()];
            const magnitude = math.abs(amp.re ?? amp);
            if (magnitude > maxAmplitude) {
              maxAmplitude = magnitude;
              maxJ = j;
              maxM = m;
            }
          }
        }
        for (let j = jMax; j >= jMin; j--) {
          for (let m = j; m >= -j; m--) {
            const amp = resultStates[j.toString()][m.toString()];
            if (math.abs(amp.re ?? amp) > 1e-12 || math.abs(amp.im ?? 0) > 1e-12) {
              resultAmplitudes.push(amp);
            } else {
              resultAmplitudes.push(math.complex(0, 0));
            }
          }
        }
        const basisLabel = `|(${j1},${j2}),${maxJ},${maxM}\u27E9`;
        const unnormalizedResult = new stateVector_1.StateVector(totalDim, resultAmplitudes, basisLabel);
        const result = unnormalizedResult.normalize();
        const history1 = state1.getAngularMomentumMetadata()?.couplingHistory || [];
        const history2 = state2.getAngularMomentumMetadata()?.couplingHistory || [];
        const jComponents = /* @__PURE__ */ new Map();
        let amplitudeIndex = 0;
        for (let j = jMax; j >= jMin; j -= 0.5) {
          const dimension = Math.floor(2 * j + 1);
          let hasNonZeroAmplitudes = false;
          for (let mIndex = 0; mIndex < dimension; mIndex++) {
            if (amplitudeIndex + mIndex < resultAmplitudes.length) {
              const amp = resultAmplitudes[amplitudeIndex + mIndex];
              if (math.abs(amp.re ?? amp) > 1e-12 || math.abs(amp.im ?? 0) > 1e-12) {
                hasNonZeroAmplitudes = true;
                break;
              }
            }
          }
          if (hasNonZeroAmplitudes) {
            jComponents.set(j, {
              j,
              startIndex: amplitudeIndex,
              dimension,
              normalizationFactor: 1
            });
          }
          amplitudeIndex += dimension;
        }
        const metadata = {
          type: "angular_momentum",
          j: jMax,
          // Maximum possible J
          mRange: [-jMax, jMax],
          couplingHistory: [
            ...history1,
            ...history2,
            {
              operation: "coupling",
              j1,
              j2,
              resultJ: Array.from({ length: Math.floor(2 * (jMax - jMin) + 1) }, (_, i) => jMin + i * 0.5),
              timestamp: Date.now()
            }
          ],
          jComponents,
          isComposite: true
        };
        result.setAngularMomentumMetadata(metadata);
        return result;
      }
      function decomposeAngularState(state, j1, j2) {
        const result = /* @__PURE__ */ new Map();
        const dim1 = Math.floor(2 * j1 + 1);
        const dim2 = Math.floor(2 * j2 + 1);
        const totalDim = dim1 * dim2;
        const uncoupledAmplitudes = new Array(totalDim).fill(null).map(() => math.complex(0, 0));
        const jMin = Math.abs(j1 - j2);
        const jMax = j1 + j2;
        let stateIndex = 0;
        for (let j = jMax; j >= jMin; j--) {
          for (let m = j; m >= -j; m--) {
            const amp = state.amplitudes[stateIndex++];
            if (math.abs(amp.re ?? amp) < 1e-10) {
              continue;
            }
            for (let m1 = -j1; m1 <= j1; m1++) {
              const m2 = m - m1;
              if (m2 < -j2 || m2 > j2) {
                continue;
              }
              const cg = clebschGordan(j1, m1, j2, m2, j, m);
              if (math.abs(cg.re ?? cg) < 1e-10) {
                continue;
              }
              const idx1 = dim1 - 1 - Math.floor(j1 + m1);
              const idx2 = dim2 - 1 - Math.floor(j2 + m2);
              const uncoupledIdx = idx1 * dim2 + idx2;
              uncoupledAmplitudes[uncoupledIdx] = math.add(uncoupledAmplitudes[uncoupledIdx], math.multiply(amp, cg));
            }
          }
        }
        const uncoupledState = new stateVector_1.StateVector(totalDim, uncoupledAmplitudes, `|j1,m1\u27E9|j2,m2\u27E9`);
        result.set("uncoupled", uncoupledState);
        return result;
      }
    }
  });

  // dist/angularMomentum/stateAnalysis.js
  var require_stateAnalysis = __commonJS({
    "dist/angularMomentum/stateAnalysis.js"(exports) {
      "use strict";
      var __createBinding = exports && exports.__createBinding || (Object.create ? (function(o, m, k, k2) {
        if (k2 === void 0) k2 = k;
        var desc = Object.getOwnPropertyDescriptor(m, k);
        if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
          desc = { enumerable: true, get: function() {
            return m[k];
          } };
        }
        Object.defineProperty(o, k2, desc);
      }) : (function(o, m, k, k2) {
        if (k2 === void 0) k2 = k;
        o[k2] = m[k];
      }));
      var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? (function(o, v) {
        Object.defineProperty(o, "default", { enumerable: true, value: v });
      }) : function(o, v) {
        o["default"] = v;
      });
      var __importStar = exports && exports.__importStar || /* @__PURE__ */ (function() {
        var ownKeys = function(o) {
          ownKeys = Object.getOwnPropertyNames || function(o2) {
            var ar = [];
            for (var k in o2) if (Object.prototype.hasOwnProperty.call(o2, k)) ar[ar.length] = k;
            return ar;
          };
          return ownKeys(o);
        };
        return function(mod2) {
          if (mod2 && mod2.__esModule) return mod2;
          var result = {};
          if (mod2 != null) {
            for (var k = ownKeys(mod2), i = 0; i < k.length; i++) if (k[i] !== "default") __createBinding(result, mod2, k[i]);
          }
          __setModuleDefault(result, mod2);
          return result;
        };
      })();
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.analyzeAngularState = analyzeAngularState;
      exports.extractJComponent = extractJComponent;
      exports.hasAngularMomentumData = hasAngularMomentumData;
      exports.getCouplingInfo = getCouplingInfo;
      exports.analysisToString = analysisToString;
      var stateVector_1 = require_stateVector();
      var math = __importStar(require_cjs());
      function analyzeAngularState(state, j1, j2) {
        const metadata = state.getAngularMomentumMetadata();
        if (metadata) {
          return analyzeFromMetadata(state, metadata);
        }
        const properties = state.properties;
        let couplingInfo;
        if (properties?.type === "angular_momentum" && properties.j1 !== void 0 && properties.j2 !== void 0) {
          couplingInfo = { j1: properties.j1, j2: properties.j2 };
        } else if (j1 !== void 0 && j2 !== void 0) {
          couplingInfo = { j1, j2 };
        }
        if (!couplingInfo) {
          return {
            isAngularMomentum: false,
            components: /* @__PURE__ */ new Map(),
            dominantJ: null,
            isPure: false
          };
        }
        const jMin = Math.abs(couplingInfo.j1 - couplingInfo.j2);
        const jMax = couplingInfo.j1 + couplingInfo.j2;
        const possibleJ = [];
        for (let j = jMin; j <= jMax; j += 0.5) {
          possibleJ.push(j);
        }
        const components = /* @__PURE__ */ new Map();
        let dominantJ = null;
        let dominantMagnitude = 0;
        for (const j of possibleJ) {
          const componentInfo = analyzeJComponent(state, j, couplingInfo.j1, couplingInfo.j2);
          components.set(j, componentInfo);
          if (componentInfo.isPresent && componentInfo.magnitude > dominantMagnitude) {
            dominantMagnitude = componentInfo.magnitude;
            dominantJ = j;
          }
        }
        const presentComponents = Array.from(components.values()).filter((c) => c.isPresent);
        const isPure = presentComponents.length === 1;
        return {
          isAngularMomentum: true,
          components,
          dominantJ,
          isPure,
          couplingInfo
        };
      }
      function analyzeFromMetadata(state, metadata) {
        const components = /* @__PURE__ */ new Map();
        let dominantJ = null;
        let dominantMagnitude = 0;
        for (const [j, componentMetadata] of metadata.jComponents) {
          const componentInfo = analyzeJComponentFromMetadata(state, j, componentMetadata);
          components.set(j, componentInfo);
          if (componentInfo.isPresent && componentInfo.magnitude > dominantMagnitude) {
            dominantMagnitude = componentInfo.magnitude;
            dominantJ = j;
          }
        }
        const presentComponents = Array.from(components.values()).filter((c) => c.isPresent);
        const isPure = presentComponents.length === 1;
        const latestCoupling = getLatestCoupling(metadata.couplingHistory);
        return {
          isAngularMomentum: true,
          components,
          dominantJ,
          isPure,
          couplingInfo: latestCoupling
        };
      }
      function analyzeJComponentFromMetadata(state, j, componentMetadata) {
        const dimension = componentMetadata.dimension;
        const startIndex = componentMetadata.startIndex;
        const mStates = /* @__PURE__ */ new Map();
        let totalAmplitudeSquared = 0;
        for (let mIndex = 0; mIndex < dimension; mIndex++) {
          const m = j - mIndex;
          const amplitudeIndex = startIndex + mIndex;
          if (amplitudeIndex < state.dimension) {
            const amplitude = state.amplitudes[amplitudeIndex];
            mStates.set(m, amplitude);
            totalAmplitudeSquared += math.abs(amplitude) ** 2;
          } else {
            mStates.set(m, math.complex(0, 0));
          }
        }
        const magnitude = Math.sqrt(totalAmplitudeSquared);
        const totalAmplitude = math.complex(magnitude, 0);
        return {
          j,
          dimension,
          totalAmplitude,
          magnitude,
          mStates,
          isPresent: magnitude > 1e-10
        };
      }
      function getLatestCoupling(couplingHistory) {
        for (let i = couplingHistory.length - 1; i >= 0; i--) {
          const record = couplingHistory[i];
          if (record.operation === "coupling" && record.j1 !== void 0 && record.j2 !== void 0) {
            return { j1: record.j1, j2: record.j2 };
          }
        }
        return void 0;
      }
      function analyzeJComponent(state, targetJ, j1, j2) {
        const dimension = Math.floor(2 * targetJ + 1);
        const mStates = /* @__PURE__ */ new Map();
        let totalAmplitudeSquared = 0;
        const jMin = Math.abs(j1 - j2);
        const jMax = j1 + j2;
        let stateIndex = 0;
        let targetStartIndex = -1;
        for (let j = jMax; j >= jMin; j -= 0.5) {
          if (Math.abs(j - targetJ) < 1e-10) {
            targetStartIndex = stateIndex;
            break;
          }
          stateIndex += Math.floor(2 * j + 1);
        }
        if (targetStartIndex === -1) {
          return {
            j: targetJ,
            dimension,
            totalAmplitude: math.complex(0, 0),
            magnitude: 0,
            mStates,
            isPresent: false
          };
        }
        for (let m = targetJ; m >= -targetJ; m -= 1) {
          const index = targetStartIndex + Math.floor(targetJ - m);
          if (index < state.dimension) {
            const amplitude = state.amplitudes[index];
            mStates.set(m, amplitude);
            totalAmplitudeSquared += math.abs(amplitude) ** 2;
          } else {
            mStates.set(m, math.complex(0, 0));
          }
        }
        const magnitude = Math.sqrt(totalAmplitudeSquared);
        const totalAmplitude = math.complex(magnitude, 0);
        return {
          j: targetJ,
          dimension,
          totalAmplitude,
          magnitude,
          mStates,
          isPresent: magnitude > 1e-10
        };
      }
      function extractJComponent(state, targetJ, j1, j2) {
        const metadata = state.getAngularMomentumMetadata();
        if (metadata) {
          return extractJComponentFromMetadata(state, targetJ, metadata);
        }
        const analysis = analyzeAngularState(state, j1, j2);
        if (!analysis.isAngularMomentum) {
          return null;
        }
        const componentInfo = analysis.components.get(targetJ);
        if (!componentInfo || !componentInfo.isPresent) {
          return null;
        }
        const pureDimension = Math.floor(2 * targetJ + 1);
        const pureAmplitudes = [];
        for (let m = targetJ; m >= -targetJ; m -= 1) {
          const amplitude = componentInfo.mStates.get(m) || math.complex(0, 0);
          pureAmplitudes.push(amplitude);
        }
        const pureState = new stateVector_1.StateVector(pureDimension, pureAmplitudes, `|${targetJ}\u27E9`);
        const norm = pureState.norm();
        if (norm < 1e-10) {
          return null;
        }
        const normalizedState = pureState.normalize();
        return {
          state: normalizedState,
          j: targetJ,
          normalizationFactor: 1 / norm,
          originalMagnitude: componentInfo.magnitude
        };
      }
      function extractJComponentFromMetadata(state, targetJ, metadata) {
        const componentMetadata = metadata.jComponents.get(targetJ);
        if (!componentMetadata) {
          return null;
        }
        const { startIndex, dimension } = componentMetadata;
        const pureAmplitudes = [];
        let totalAmplitudeSquared = 0;
        for (let i = 0; i < dimension; i++) {
          const amplitudeIndex = startIndex + i;
          if (amplitudeIndex < state.dimension) {
            const amplitude = state.amplitudes[amplitudeIndex];
            pureAmplitudes.push(amplitude);
            totalAmplitudeSquared += math.abs(amplitude) ** 2;
          } else {
            pureAmplitudes.push(math.complex(0, 0));
          }
        }
        const magnitude = Math.sqrt(totalAmplitudeSquared);
        if (magnitude < 1e-10) {
          return null;
        }
        const pureState = new stateVector_1.StateVector(dimension, pureAmplitudes, `|${targetJ}\u27E9`);
        const extractedMetadata = {
          type: "angular_momentum",
          j: targetJ,
          mRange: [-targetJ, targetJ],
          couplingHistory: [...metadata.couplingHistory],
          jComponents: /* @__PURE__ */ new Map([[targetJ, {
            j: targetJ,
            startIndex: 0,
            dimension,
            normalizationFactor: 1
          }]]),
          isComposite: false
        };
        pureState.setAngularMomentumMetadata(extractedMetadata);
        const normalizedState = pureState.normalize();
        return {
          state: normalizedState,
          j: targetJ,
          normalizationFactor: 1 / magnitude,
          originalMagnitude: magnitude
        };
      }
      function hasAngularMomentumData(state) {
        const properties = state.properties;
        return properties?.type === "angular_momentum" && properties.j1 !== void 0 && properties.j2 !== void 0;
      }
      function getCouplingInfo(state) {
        const properties = state.properties;
        if (properties?.type === "angular_momentum" && properties.j1 !== void 0 && properties.j2 !== void 0) {
          return { j1: properties.j1, j2: properties.j2 };
        }
        return null;
      }
      function analysisToString(analysis) {
        if (!analysis.isAngularMomentum) {
          return "Not an angular momentum state";
        }
        let result = `Angular Momentum State Analysis:
`;
        result += `  Type: ${analysis.isPure ? "Pure" : "Mixed"} state
`;
        result += `  Dominant J: ${analysis.dominantJ}
`;
        if (analysis.couplingInfo) {
          result += `  Original coupling: j1=${analysis.couplingInfo.j1}, j2=${analysis.couplingInfo.j2}
`;
        }
        result += `  Components:
`;
        for (const [j, info] of analysis.components) {
          if (info.isPresent) {
            result += `    J=${j}: magnitude=${info.magnitude.toFixed(4)}, dim=${info.dimension}
`;
          }
        }
        return result;
      }
    }
  });

  // dist/angularMomentum/multiSpinState.js
  var require_multiSpinState = __commonJS({
    "dist/angularMomentum/multiSpinState.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.MultiSpinState = void 0;
      var core_1 = require_core();
      var composition_1 = require_composition3();
      var stateAnalysis_1 = require_stateAnalysis();
      var MultiSpinState = class _MultiSpinState {
        constructor(spins, mValues, currentState, couplingHistory = [], availableJ = /* @__PURE__ */ new Set()) {
          this.spins = [...spins];
          this.mValues = [...mValues];
          this.currentState = currentState;
          this.couplingHistory = [...couplingHistory];
          this.availableJ = new Set(availableJ);
        }
        /**
         * Creates a MultiSpinState from a single spin state
         * @param j Angular momentum quantum number
         * @param m Magnetic quantum number
         * @returns New MultiSpinState with single spin
         */
        static fromSingleSpin(j, m) {
          const state = (0, core_1.createJmState)(j, m);
          const availableJ = /* @__PURE__ */ new Set([j]);
          return new _MultiSpinState(
            [j],
            // spins
            [m],
            // mValues  
            state,
            // currentState
            [],
            // couplingHistory
            availableJ
            // availableJ
          );
        }
        /**
         * Creates a MultiSpinState from existing coupled state (for analysis)
         * @param state Existing StateVector
         * @param spins Array of individual j values that were coupled
         * @param mValues Array of individual m values
         * @returns New MultiSpinState for analysis
         */
        static fromCoupledState(state, spins, mValues) {
          const availableJ = /* @__PURE__ */ new Set();
          return new _MultiSpinState(spins, mValues, state, [], availableJ);
        }
        /**
         * Adds another spin to this multi-spin state using proper state decomposition
         * @param j Angular momentum of spin to add
         * @param m Magnetic quantum number of spin to add
         * @returns New MultiSpinState with additional spin coupled
         */
        addSpin(j, m) {
          const newSpinState = (0, core_1.createJmState)(j, m);
          if (this.spins.length === 1) {
            const effectiveJ = this.spins[0];
            const coupledState = (0, composition_1.addAngularMomenta)(this.currentState, effectiveJ, newSpinState, j);
            const jMin = Math.abs(effectiveJ - j);
            const jMax = effectiveJ + j;
            const newAvailableJ = /* @__PURE__ */ new Set();
            for (let newJ = jMin; newJ <= jMax; newJ += 0.5) {
              newAvailableJ.add(newJ);
            }
            const couplingStep = {
              addedSpin: j,
              addedM: m,
              previousJ: Array.from(this.availableJ),
              resultingJ: Array.from(newAvailableJ),
              timestamp: Date.now()
            };
            const metadata = coupledState.getAngularMomentumMetadata();
            const actualAvailableJ = metadata ? new Set(metadata.jComponents.keys()) : newAvailableJ;
            return new _MultiSpinState([...this.spins, j], [...this.mValues, m], coupledState, [...this.couplingHistory, couplingStep], actualAvailableJ);
          } else {
            const analysis = (0, stateAnalysis_1.analyzeAngularState)(this.currentState);
            if (!analysis.isAngularMomentum) {
              throw new Error("Cannot add spin to non-angular momentum state");
            }
            const dominantJ = analysis.dominantJ;
            if (dominantJ === null) {
              throw new Error("Cannot determine dominant J component");
            }
            const extracted = (0, stateAnalysis_1.extractJComponent)(this.currentState, dominantJ);
            if (!extracted) {
              throw new Error(`Cannot extract J=${dominantJ} component from composite state`);
            }
            const coupledState = (0, composition_1.addAngularMomenta)(extracted.state, dominantJ, newSpinState, j);
            const jMin = Math.abs(dominantJ - j);
            const jMax = dominantJ + j;
            const newAvailableJ = /* @__PURE__ */ new Set();
            for (let newJ = jMin; newJ <= jMax; newJ += 0.5) {
              newAvailableJ.add(newJ);
            }
            const couplingStep = {
              addedSpin: j,
              addedM: m,
              previousJ: Array.from(this.availableJ),
              resultingJ: Array.from(newAvailableJ),
              timestamp: Date.now()
            };
            const metadata = coupledState.getAngularMomentumMetadata();
            const actualAvailableJ = metadata ? new Set(metadata.jComponents.keys()) : newAvailableJ;
            return new _MultiSpinState([...this.spins, j], [...this.mValues, m], coupledState, [...this.couplingHistory, couplingStep], actualAvailableJ);
          }
        }
        /**
         * Extracts a specific J component from the current state
         * @param targetJ The J value to extract
         * @returns StateVector for that J component, or null if not present
         */
        extractJComponent(targetJ) {
          if (!this.availableJ.has(targetJ)) {
            return null;
          }
          const extracted = (0, stateAnalysis_1.extractJComponent)(this.currentState, targetJ);
          return extracted ? extracted.state : null;
        }
        /**
         * Simple heuristic to determine dominant J value
         * Real implementation would analyze state amplitudes
         */
        getDominantJ() {
          if (this.availableJ.size === 0) {
            throw new Error("No available J values to determine dominant J");
          }
          return Math.max(...Array.from(this.availableJ));
        }
        /**
         * Gets all currently available J values and their information
         * @returns Map of J values to basic information
         */
        getJComponents() {
          const result = /* @__PURE__ */ new Map();
          for (const j of this.availableJ) {
            result.set(j, { available: true, estimated: true });
          }
          return result;
        }
        /**
         * Gets the valid intertwiner values for spin network vertices
         * These are the J values that could appear at a vertex with these incident spins
         * @returns Array of valid J values
         */
        getValidIntertwiners() {
          return Array.from(this.availableJ).sort((a, b) => a - b);
        }
        /**
         * Gets all individual spins in this multi-spin state
         * @returns Array of individual j values
         */
        getIndividualSpins() {
          return [...this.spins];
        }
        /**
         * Gets all individual magnetic quantum numbers
         * @returns Array of individual m values
         */
        getIndividualMs() {
          return [...this.mValues];
        }
        /**
         * Gets the coupling history showing how this state was built
         * @returns Array of coupling steps
         */
        getCouplingHistory() {
          return [...this.couplingHistory];
        }
        /**
         * Gets the current coupled state vector
         * @returns Current StateVector
         */
        getCurrentState() {
          return this.currentState;
        }
        /**
         * Gets the total dimension of the current state
         * @returns Dimension of current state vector
         */
        getDimension() {
          return this.currentState.dimension;
        }
        /**
         * Gets the number of individual spins in this state
         * @returns Number of spins
         */
        getSpinCount() {
          return this.spins.length;
        }
        /**
         * Gets the norm of the current state
         * @returns Norm of current state vector
         */
        norm() {
          return this.currentState.norm();
        }
        /**
         * Checks if the state is normalized
         * @param tolerance Numerical tolerance
         * @returns True if state is normalized
         */
        isNormalized(tolerance = 1e-10) {
          return Math.abs(this.norm() - 1) < tolerance;
        }
        /**
         * Returns a string representation of the multi-spin state
         * @returns Human-readable description
         */
        toString() {
          const spinInfo = this.spins.map((j, i) => `j${i + 1}=${j}`).join(", ");
          const mInfo = this.mValues.map((m, i) => `m${i + 1}=${m}`).join(", ");
          const jInfo = Array.from(this.availableJ).sort().join(", ");
          return `MultiSpinState(${this.spins.length} spins: ${spinInfo}; ${mInfo}; available J=[${jInfo}]; dim=${this.getDimension()})`;
        }
        /**
         * Returns detailed information about the state
         * @returns Detailed string representation
         */
        toDetailedString() {
          let result = this.toString() + "\n";
          result += `State: ${this.currentState.toString()}
`;
          if (this.couplingHistory.length > 0) {
            result += "Coupling History:\n";
            this.couplingHistory.forEach((step, i) => {
              result += `  ${i + 1}. Added j=${step.addedSpin}, m=${step.addedM}: [${step.previousJ.join(",")}] \u2192 [${step.resultingJ.join(",")}]
`;
            });
          }
          return result;
        }
      };
      exports.MultiSpinState = MultiSpinState;
    }
  });

  // dist/angularMomentum/wignerSymbols.js
  var require_wignerSymbols = __commonJS({
    "dist/angularMomentum/wignerSymbols.js"(exports) {
      "use strict";
      var __createBinding = exports && exports.__createBinding || (Object.create ? (function(o, m, k, k2) {
        if (k2 === void 0) k2 = k;
        var desc = Object.getOwnPropertyDescriptor(m, k);
        if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
          desc = { enumerable: true, get: function() {
            return m[k];
          } };
        }
        Object.defineProperty(o, k2, desc);
      }) : (function(o, m, k, k2) {
        if (k2 === void 0) k2 = k;
        o[k2] = m[k];
      }));
      var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? (function(o, v) {
        Object.defineProperty(o, "default", { enumerable: true, value: v });
      }) : function(o, v) {
        o["default"] = v;
      });
      var __importStar = exports && exports.__importStar || /* @__PURE__ */ (function() {
        var ownKeys = function(o) {
          ownKeys = Object.getOwnPropertyNames || function(o2) {
            var ar = [];
            for (var k in o2) if (Object.prototype.hasOwnProperty.call(o2, k)) ar[ar.length] = k;
            return ar;
          };
          return ownKeys(o);
        };
        return function(mod2) {
          if (mod2 && mod2.__esModule) return mod2;
          var result = {};
          if (mod2 != null) {
            for (var k = ownKeys(mod2), i = 0; i < k.length; i++) if (k[i] !== "default") __createBinding(result, mod2, k[i]);
          }
          __setModuleDefault(result, mod2);
          return result;
        };
      })();
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.isValidTriangle = isValidTriangle;
      exports.wigner3j = wigner3j;
      exports.wigner3jSymmetry = wigner3jSymmetry;
      exports.wigner6j = wigner6j;
      exports.wigner9j = wigner9j;
      var composition_1 = require_composition3();
      var math_1 = require_math();
      var math = __importStar(require_cjs());
      function isValidTriangle(j1, j2, j3) {
        return Math.abs(j1 - j2) <= j3 && j3 <= j1 + j2 && Math.abs(j2 - j3) <= j1 && j1 <= j2 + j3 && Math.abs(j3 - j1) <= j2 && j2 <= j3 + j1;
      }
      function validate6jTriangles(j1, j2, j3, l1, l2, l3) {
        return isValidTriangle(j1, j2, j3) && isValidTriangle(j1, l2, l3) && isValidTriangle(l1, j2, l3) && isValidTriangle(l1, l2, j3);
      }
      function phaseFactor(n) {
        return Math.pow(-1, Math.round(n));
      }
      function validateWigner3j(j1, j2, j3, m1, m2, m3) {
        if (j1 < 0 || j2 < 0 || j3 < 0) {
          return false;
        }
        if (Math.abs(m1) > j1 || Math.abs(m2) > j2 || Math.abs(m3) > j3) {
          return false;
        }
        if (!isValidTriangle(j1, j2, j3)) {
          return false;
        }
        if (Math.abs(m1 + m2 + m3) > 1e-10) {
          return false;
        }
        return true;
      }
      function wigner3j(j1, j2, j3, m1, m2, m3) {
        if (!validateWigner3j(j1, j2, j3, m1, m2, m3)) {
          return math.complex(0, 0);
        }
        const cgCoeff = (0, composition_1.clebschGordan)(j1, m1, j2, m2, j3, -m3);
        const phase = phaseFactor(j1 - j2 + m3);
        const normalization = 1 / Math.sqrt(2 * j3 + 1);
        const result = math.multiply(phase * normalization, cgCoeff);
        return result;
      }
      function wigner3jSymmetry(j1, j2, j3, m1, m2, m3, operation) {
        const base = wigner3j(j1, j2, j3, m1, m2, m3);
        switch (operation) {
          case 0:
            return { value: base, phase: 1 };
          case 1:
            return {
              value: wigner3j(j2, j3, j1, m2, m3, m1),
              phase: phaseFactor(j1 + j2 + j3)
            };
          case 2:
            return {
              value: wigner3j(j3, j1, j2, m3, m1, m2),
              phase: phaseFactor(j1 + j2 + j3)
            };
          case 3:
            return {
              value: wigner3j(j2, j1, j3, m2, m1, m3),
              phase: phaseFactor(j1 + j2 + j3)
            };
          case 4:
            return {
              value: wigner3j(j1, j2, j3, -m1, -m2, -m3),
              phase: phaseFactor(j1 + j2 + j3)
            };
          default:
            return { value: base, phase: 1 };
        }
      }
      function wigner6j(j1, j2, j3, l1, l2, l3) {
        if (!validate6jTriangles(j1, j2, j3, l1, l2, l3)) {
          return math.complex(0, 0);
        }
        if (j1 < 0 || j2 < 0 || j3 < 0 || l1 < 0 || l2 < 0 || l3 < 0) {
          return math.complex(0, 0);
        }
        const delta1 = (0, math_1.triangleCoefficient)(j1, j2, j3);
        const delta2 = (0, math_1.triangleCoefficient)(j1, l2, l3);
        const delta3 = (0, math_1.triangleCoefficient)(l1, j2, l3);
        const delta4 = (0, math_1.triangleCoefficient)(l1, l2, j3);
        if (delta1 === 0 || delta2 === 0 || delta3 === 0 || delta4 === 0) {
          return math.complex(0, 0);
        }
        const zMin = Math.max(j1 + j2 + j3, j1 + l2 + l3, l1 + j2 + l3, l1 + l2 + j3);
        const zMax = Math.min(j1 + j2 + l1 + l2, j2 + j3 + l2 + l3, j3 + j1 + l3 + l1);
        let sumLog = -Infinity;
        for (let z = Math.round(zMin); z <= Math.round(zMax); z++) {
          const logDenom = (0, math_1.logFactorial)(z - Math.round(j1 + j2 + j3)) + (0, math_1.logFactorial)(z - Math.round(j1 + l2 + l3)) + (0, math_1.logFactorial)(z - Math.round(l1 + j2 + l3)) + (0, math_1.logFactorial)(z - Math.round(l1 + l2 + j3)) + (0, math_1.logFactorial)(Math.round(j1 + j2 + l1 + l2 - z)) + (0, math_1.logFactorial)(Math.round(j2 + j3 + l2 + l3 - z)) + (0, math_1.logFactorial)(Math.round(j3 + j1 + l3 + l1 - z));
          const logTerm = -logDenom;
          if (sumLog === -Infinity) {
            sumLog = logTerm;
          } else {
            const maxLog = Math.max(sumLog, logTerm);
            sumLog = maxLog + Math.log(Math.exp(sumLog - maxLog) + Math.exp(logTerm - maxLog));
          }
        }
        const phaseFactor2 = Math.pow(-1, Math.round(j1 + j2 + j3 + l1 + l2 + l3));
        const result = phaseFactor2 * delta1 * delta2 * delta3 * delta4 * Math.exp(sumLog);
        return math.complex(result, 0);
      }
      function wigner9j(j1, j2, j3, l1, l2, l3, k1, k2, k3) {
        return math.complex(0, 0);
      }
    }
  });

  // dist/angularMomentum/index.js
  var require_angularMomentum = __commonJS({
    "dist/angularMomentum/index.js"(exports) {
      "use strict";
      var __createBinding = exports && exports.__createBinding || (Object.create ? (function(o, m, k, k2) {
        if (k2 === void 0) k2 = k;
        var desc = Object.getOwnPropertyDescriptor(m, k);
        if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
          desc = { enumerable: true, get: function() {
            return m[k];
          } };
        }
        Object.defineProperty(o, k2, desc);
      }) : (function(o, m, k, k2) {
        if (k2 === void 0) k2 = k;
        o[k2] = m[k];
      }));
      var __exportStar = exports && exports.__exportStar || function(m, exports2) {
        for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p)) __createBinding(exports2, m, p);
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      __exportStar(require_core(), exports);
      __exportStar(require_composition3(), exports);
      __exportStar(require_stateAnalysis(), exports);
      __exportStar(require_multiSpinState(), exports);
      __exportStar(require_wignerSymbols(), exports);
    }
  });

  // dist/geometry/quantumDistance.js
  var require_quantumDistance = __commonJS({
    "dist/geometry/quantumDistance.js"(exports) {
      "use strict";
      var __createBinding = exports && exports.__createBinding || (Object.create ? (function(o, m, k, k2) {
        if (k2 === void 0) k2 = k;
        var desc = Object.getOwnPropertyDescriptor(m, k);
        if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
          desc = { enumerable: true, get: function() {
            return m[k];
          } };
        }
        Object.defineProperty(o, k2, desc);
      }) : (function(o, m, k, k2) {
        if (k2 === void 0) k2 = k;
        o[k2] = m[k];
      }));
      var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? (function(o, v) {
        Object.defineProperty(o, "default", { enumerable: true, value: v });
      }) : function(o, v) {
        o["default"] = v;
      });
      var __importStar = exports && exports.__importStar || /* @__PURE__ */ (function() {
        var ownKeys = function(o) {
          ownKeys = Object.getOwnPropertyNames || function(o2) {
            var ar = [];
            for (var k in o2) if (Object.prototype.hasOwnProperty.call(o2, k)) ar[ar.length] = k;
            return ar;
          };
          return ownKeys(o);
        };
        return function(mod2) {
          if (mod2 && mod2.__esModule) return mod2;
          var result = {};
          if (mod2 != null) {
            for (var k = ownKeys(mod2), i = 0; i < k.length; i++) if (k[i] !== "default") __createBinding(result, mod2, k[i]);
          }
          __setModuleDefault(result, mod2);
          return result;
        };
      })();
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.BlochSphere = exports.TwoLevelSystem = void 0;
      exports.quantumDistance = quantumDistance;
      exports.quantumDistanceUnnormalized = quantumDistanceUnnormalized;
      exports.quantumFidelity = quantumFidelity;
      var stateVector_1 = require_stateVector();
      var math = __importStar(require_cjs());
      function quantumDistance(state1, state2) {
        if (state1.dimension !== state2.dimension) {
          throw new Error(`States must have same dimension: ${state1.dimension} vs ${state2.dimension}`);
        }
        const innerProduct = state1.innerProduct(state2);
        const overlapMagnitude = math.abs(innerProduct);
        const distanceSquared = 2 - 2 * overlapMagnitude;
        return Math.sqrt(Math.max(0, distanceSquared));
      }
      function quantumDistanceUnnormalized(state1, state2) {
        const norm1 = state1.norm();
        const norm2 = state2.norm();
        if (norm1 < 1e-10 || norm2 < 1e-10) {
          throw new Error("Cannot compute distance for zero states");
        }
        const normalized1 = state1.normalize();
        const normalized2 = state2.normalize();
        return quantumDistance(normalized1, normalized2);
      }
      function quantumFidelity(state1, state2) {
        if (state1.dimension !== state2.dimension) {
          throw new Error(`States must have same dimension: ${state1.dimension} vs ${state2.dimension}`);
        }
        const innerProduct = state1.innerProduct(state2);
        const overlapMagnitude = math.abs(innerProduct);
        return overlapMagnitude * overlapMagnitude;
      }
      var TwoLevelSystem = class {
        /**
         * Ground state |0
         */
        static ground() {
          return stateVector_1.StateVector.computationalBasis(2, 0);
        }
        /**
         * Excited state |1
         */
        static excited() {
          return stateVector_1.StateVector.computationalBasis(2, 1);
        }
        /**
         * Plus state |+ = (|0 + |1)/2
         */
        static plus() {
          const coeffs = [math.complex(1 / Math.sqrt(2), 0), math.complex(1 / Math.sqrt(2), 0)];
          return new stateVector_1.StateVector(2, coeffs, "|+\u27E9");
        }
        /**
         * Minus state |- = (|0 - |1)/2
         */
        static minus() {
          const coeffs = [math.complex(1 / Math.sqrt(2), 0), math.complex(-1 / Math.sqrt(2), 0)];
          return new stateVector_1.StateVector(2, coeffs, "|-\u27E9");
        }
        /**
         * General qubit state cos(/2)|0 + e^(i)sin(/2)|1
         * @param theta Polar angle (0 to )
         * @param phi Azimuthal angle (0 to 2)
         */
        static blochState(theta, phi) {
          const cosHalfTheta = Math.cos(theta / 2);
          const sinHalfTheta = Math.sin(theta / 2);
          const eiPhi = math.complex(Math.cos(phi), Math.sin(phi));
          const coeffs = [
            math.complex(cosHalfTheta, 0),
            math.multiply(eiPhi, sinHalfTheta)
          ];
          return new stateVector_1.StateVector(2, coeffs, `|\u03B8=${theta.toFixed(2)},\u03C6=${phi.toFixed(2)}\u27E9`);
        }
      };
      exports.TwoLevelSystem = TwoLevelSystem;
      var BlochSphere = class {
        /**
         * Calculates the quantum distance on the Bloch sphere
         * This matches the Provost-Vallee quantum distance for qubit states
         *
         * The relationship is: D_quantum = 2 * sin(_bloch/2)
         * where _bloch is the angle between Bloch vectors
         *
         * @param theta1 Polar angle of first state
         * @param phi1 Azimuthal angle of first state
         * @param theta2 Polar angle of second state
         * @param phi2 Azimuthal angle of second state
         * @returns Quantum distance between states
         */
        static geodesicDistance(theta1, phi1, theta2, phi2) {
          const x1 = Math.sin(theta1) * Math.cos(phi1);
          const y1 = Math.sin(theta1) * Math.sin(phi1);
          const z1 = Math.cos(theta1);
          const x2 = Math.sin(theta2) * Math.cos(phi2);
          const y2 = Math.sin(theta2) * Math.sin(phi2);
          const z2 = Math.cos(theta2);
          const dotProduct = x1 * x2 + y1 * y2 + z1 * z2;
          const clampedDot = Math.max(-1, Math.min(1, dotProduct));
          const blochAngle = Math.acos(clampedDot);
          return Math.sqrt(2) * Math.sin(blochAngle / 2);
        }
        /**
         * Verifies that quantum distance matches Bloch sphere calculation
         * @param theta1 Polar angle of first state
         * @param phi1 Azimuthal angle of first state
         * @param theta2 Polar angle of second state
         * @param phi2 Azimuthal angle of second state
         * @param tolerance Numerical tolerance for comparison
         * @returns True if distances match within tolerance
         */
        static verifyQuantumDistance(theta1, phi1, theta2, phi2, tolerance = 1e-10) {
          const state1 = TwoLevelSystem.blochState(theta1, phi1);
          const state2 = TwoLevelSystem.blochState(theta2, phi2);
          console.log("State1: ", state1);
          console.log("State2: ", state2);
          const quantumDist = quantumDistance(state1, state2);
          const blochDist = this.geodesicDistance(theta1, phi1, theta2, phi2);
          console.log("Quantum Distance: ", quantumDist);
          console.log("Bloch Distance: ", blochDist);
          return Math.abs(quantumDist - blochDist) < tolerance;
        }
      };
      exports.BlochSphere = BlochSphere;
    }
  });

  // dist/geometry/index.js
  var require_geometry = __commonJS({
    "dist/geometry/index.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.BlochSphere = exports.TwoLevelSystem = exports.quantumFidelity = exports.quantumDistanceUnnormalized = exports.quantumDistance = void 0;
      var quantumDistance_1 = require_quantumDistance();
      Object.defineProperty(exports, "quantumDistance", { enumerable: true, get: function() {
        return quantumDistance_1.quantumDistance;
      } });
      Object.defineProperty(exports, "quantumDistanceUnnormalized", { enumerable: true, get: function() {
        return quantumDistance_1.quantumDistanceUnnormalized;
      } });
      Object.defineProperty(exports, "quantumFidelity", { enumerable: true, get: function() {
        return quantumDistance_1.quantumFidelity;
      } });
      Object.defineProperty(exports, "TwoLevelSystem", { enumerable: true, get: function() {
        return quantumDistance_1.TwoLevelSystem;
      } });
      Object.defineProperty(exports, "BlochSphere", { enumerable: true, get: function() {
        return quantumDistance_1.BlochSphere;
      } });
    }
  });

  // dist/index.js
  var require_dist2 = __commonJS({
    "dist/index.js"(exports) {
      "use strict";
      var __createBinding = exports && exports.__createBinding || (Object.create ? (function(o, m, k, k2) {
        if (k2 === void 0) k2 = k;
        var desc = Object.getOwnPropertyDescriptor(m, k);
        if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
          desc = { enumerable: true, get: function() {
            return m[k];
          } };
        }
        Object.defineProperty(o, k2, desc);
      }) : (function(o, m, k, k2) {
        if (k2 === void 0) k2 = k;
        o[k2] = m[k];
      }));
      var __exportStar = exports && exports.__exportStar || function(m, exports2) {
        for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p)) __createBinding(exports2, m, p);
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.orthogonalizeStateVectors = exports.isUnitary = exports.isHermitian = exports.normalizeMatrix = exports.scaleMatrix = exports.addMatrices = exports.eigenDecomposition = exports.tensorProduct = exports.transpose = exports.multiplyMatrices = exports.StateVector = void 0;
      __exportStar(require_types(), exports);
      var stateVector_1 = require_stateVector();
      Object.defineProperty(exports, "StateVector", { enumerable: true, get: function() {
        return stateVector_1.StateVector;
      } });
      __exportStar(require_stateVector(), exports);
      __exportStar(require_states(), exports);
      __exportStar(require_composite(), exports);
      __exportStar(require_densityMatrix(), exports);
      __exportStar(require_operator(), exports);
      __exportStar(require_algebra(), exports);
      __exportStar(require_gates(), exports);
      __exportStar(require_measurement(), exports);
      __exportStar(require_hamiltonian(), exports);
      __exportStar(require_circuit(), exports);
      __exportStar(require_sparse3(), exports);
      __exportStar(require_sparseOperator(), exports);
      var matrixOperations_1 = require_matrixOperations();
      Object.defineProperty(exports, "multiplyMatrices", { enumerable: true, get: function() {
        return matrixOperations_1.multiplyMatrices;
      } });
      Object.defineProperty(exports, "transpose", { enumerable: true, get: function() {
        return matrixOperations_1.transpose;
      } });
      Object.defineProperty(exports, "tensorProduct", { enumerable: true, get: function() {
        return matrixOperations_1.tensorProduct;
      } });
      Object.defineProperty(exports, "eigenDecomposition", { enumerable: true, get: function() {
        return matrixOperations_1.eigenDecomposition;
      } });
      Object.defineProperty(exports, "addMatrices", { enumerable: true, get: function() {
        return matrixOperations_1.addMatrices;
      } });
      Object.defineProperty(exports, "scaleMatrix", { enumerable: true, get: function() {
        return matrixOperations_1.scaleMatrix;
      } });
      Object.defineProperty(exports, "normalizeMatrix", { enumerable: true, get: function() {
        return matrixOperations_1.normalizeMatrix;
      } });
      Object.defineProperty(exports, "isHermitian", { enumerable: true, get: function() {
        return matrixOperations_1.isHermitian;
      } });
      Object.defineProperty(exports, "isUnitary", { enumerable: true, get: function() {
        return matrixOperations_1.isUnitary;
      } });
      Object.defineProperty(exports, "orthogonalizeStateVectors", { enumerable: true, get: function() {
        return matrixOperations_1.orthogonalizeStateVectors;
      } });
      __exportStar(require_matrixFunctions(), exports);
      __exportStar(require_information(), exports);
      __exportStar(require_oscillator(), exports);
      __exportStar(require_angularMomentum(), exports);
      __exportStar(require_geometry(), exports);
    }
  });

  // web/simulations.ts
  var import_dist = __toESM(require_dist2());

  // node_modules/.pnpm/@babel+runtime@7.28.4/node_modules/@babel/runtime/helpers/esm/extends.js
  function _extends() {
    return _extends = Object.assign ? Object.assign.bind() : function(n) {
      for (var e = 1; e < arguments.length; e++) {
        var t = arguments[e];
        for (var r in t) ({}).hasOwnProperty.call(t, r) && (n[r] = t[r]);
      }
      return n;
    }, _extends.apply(null, arguments);
  }

  // node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/esm/core/config.js
  var DEFAULT_CONFIG = {
    // minimum relative difference between two compared values,
    // used by all comparison functions
    epsilon: 1e-12,
    // type of default matrix output. Choose 'matrix' (default) or 'array'
    matrix: "Matrix",
    // type of default number output. Choose 'number' (default) 'BigNumber', or 'Fraction
    number: "number",
    // number of significant digits in BigNumbers
    precision: 64,
    // predictable output type of functions. When true, output type depends only
    // on the input types. When false (default), output type can vary depending
    // on input values. For example `math.sqrt(-4)` returns `complex('2i')` when
    // predictable is false, and returns `NaN` when true.
    predictable: false,
    // random seed for seeded pseudo random number generation
    // null = randomly seed
    randomSeed: null
  };

  // node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/esm/utils/is.js
  function isNumber(x) {
    return typeof x === "number";
  }
  function isBigNumber(x) {
    if (!x || typeof x !== "object" || typeof x.constructor !== "function") {
      return false;
    }
    if (x.isBigNumber === true && typeof x.constructor.prototype === "object" && x.constructor.prototype.isBigNumber === true) {
      return true;
    }
    if (typeof x.constructor.isDecimal === "function" && x.constructor.isDecimal(x) === true) {
      return true;
    }
    return false;
  }
  function isComplex(x) {
    return x && typeof x === "object" && Object.getPrototypeOf(x).isComplex === true || false;
  }
  function isFraction(x) {
    return x && typeof x === "object" && Object.getPrototypeOf(x).isFraction === true || false;
  }
  function isUnit(x) {
    return x && x.constructor.prototype.isUnit === true || false;
  }
  function isString(x) {
    return typeof x === "string";
  }
  var isArray = Array.isArray;
  function isMatrix(x) {
    return x && x.constructor.prototype.isMatrix === true || false;
  }
  function isCollection(x) {
    return Array.isArray(x) || isMatrix(x);
  }
  function isDenseMatrix(x) {
    return x && x.isDenseMatrix && x.constructor.prototype.isMatrix === true || false;
  }
  function isSparseMatrix(x) {
    return x && x.isSparseMatrix && x.constructor.prototype.isMatrix === true || false;
  }
  function isRange(x) {
    return x && x.constructor.prototype.isRange === true || false;
  }
  function isIndex(x) {
    return x && x.constructor.prototype.isIndex === true || false;
  }
  function isBoolean(x) {
    return typeof x === "boolean";
  }
  function isResultSet(x) {
    return x && x.constructor.prototype.isResultSet === true || false;
  }
  function isHelp(x) {
    return x && x.constructor.prototype.isHelp === true || false;
  }
  function isFunction(x) {
    return typeof x === "function";
  }
  function isDate(x) {
    return x instanceof Date;
  }
  function isRegExp(x) {
    return x instanceof RegExp;
  }
  function isObject(x) {
    return !!(x && typeof x === "object" && x.constructor === Object && !isComplex(x) && !isFraction(x));
  }
  function isNull(x) {
    return x === null;
  }
  function isUndefined(x) {
    return x === void 0;
  }
  function isAccessorNode(x) {
    return x && x.isAccessorNode === true && x.constructor.prototype.isNode === true || false;
  }
  function isArrayNode(x) {
    return x && x.isArrayNode === true && x.constructor.prototype.isNode === true || false;
  }
  function isAssignmentNode(x) {
    return x && x.isAssignmentNode === true && x.constructor.prototype.isNode === true || false;
  }
  function isBlockNode(x) {
    return x && x.isBlockNode === true && x.constructor.prototype.isNode === true || false;
  }
  function isConditionalNode(x) {
    return x && x.isConditionalNode === true && x.constructor.prototype.isNode === true || false;
  }
  function isConstantNode(x) {
    return x && x.isConstantNode === true && x.constructor.prototype.isNode === true || false;
  }
  function isFunctionAssignmentNode(x) {
    return x && x.isFunctionAssignmentNode === true && x.constructor.prototype.isNode === true || false;
  }
  function isFunctionNode(x) {
    return x && x.isFunctionNode === true && x.constructor.prototype.isNode === true || false;
  }
  function isIndexNode(x) {
    return x && x.isIndexNode === true && x.constructor.prototype.isNode === true || false;
  }
  function isNode(x) {
    return x && x.isNode === true && x.constructor.prototype.isNode === true || false;
  }
  function isObjectNode(x) {
    return x && x.isObjectNode === true && x.constructor.prototype.isNode === true || false;
  }
  function isOperatorNode(x) {
    return x && x.isOperatorNode === true && x.constructor.prototype.isNode === true || false;
  }
  function isParenthesisNode(x) {
    return x && x.isParenthesisNode === true && x.constructor.prototype.isNode === true || false;
  }
  function isRangeNode(x) {
    return x && x.isRangeNode === true && x.constructor.prototype.isNode === true || false;
  }
  function isRelationalNode(x) {
    return x && x.isRelationalNode === true && x.constructor.prototype.isNode === true || false;
  }
  function isSymbolNode(x) {
    return x && x.isSymbolNode === true && x.constructor.prototype.isNode === true || false;
  }
  function isChain(x) {
    return x && x.constructor.prototype.isChain === true || false;
  }
  function typeOf(x) {
    var t = typeof x;
    if (t === "object") {
      if (x === null) return "null";
      if (isBigNumber(x)) return "BigNumber";
      if (x.constructor && x.constructor.name) return x.constructor.name;
      return "Object";
    }
    return t;
  }

  // node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/esm/utils/object.js
  function clone(x) {
    var type = typeof x;
    if (type === "number" || type === "string" || type === "boolean" || x === null || x === void 0) {
      return x;
    }
    if (typeof x.clone === "function") {
      return x.clone();
    }
    if (Array.isArray(x)) {
      return x.map(function(value) {
        return clone(value);
      });
    }
    if (x instanceof Date) return new Date(x.valueOf());
    if (isBigNumber(x)) return x;
    if (isObject(x)) {
      return mapObject(x, clone);
    }
    throw new TypeError("Cannot clone: unknown type of value (value: ".concat(x, ")"));
  }
  function mapObject(object, callback) {
    var clone4 = {};
    for (var key in object) {
      if (hasOwnProperty(object, key)) {
        clone4[key] = callback(object[key]);
      }
    }
    return clone4;
  }
  function deepStrictEqual(a, b) {
    var prop, i, len;
    if (Array.isArray(a)) {
      if (!Array.isArray(b)) {
        return false;
      }
      if (a.length !== b.length) {
        return false;
      }
      for (i = 0, len = a.length; i < len; i++) {
        if (!deepStrictEqual(a[i], b[i])) {
          return false;
        }
      }
      return true;
    } else if (typeof a === "function") {
      return a === b;
    } else if (a instanceof Object) {
      if (Array.isArray(b) || !(b instanceof Object)) {
        return false;
      }
      for (prop in a) {
        if (!(prop in b) || !deepStrictEqual(a[prop], b[prop])) {
          return false;
        }
      }
      for (prop in b) {
        if (!(prop in a)) {
          return false;
        }
      }
      return true;
    } else {
      return a === b;
    }
  }
  function hasOwnProperty(object, property) {
    return object && Object.hasOwnProperty.call(object, property);
  }
  function pickShallow(object, properties) {
    var copy = {};
    for (var i = 0; i < properties.length; i++) {
      var key = properties[i];
      var value = object[key];
      if (value !== void 0) {
        copy[key] = value;
      }
    }
    return copy;
  }

  // node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/esm/core/function/config.js
  var MATRIX_OPTIONS = ["Matrix", "Array"];
  var NUMBER_OPTIONS = ["number", "BigNumber", "Fraction"];

  // node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/esm/entry/configReadonly.js
  var config = function config2(options) {
    if (options) {
      throw new Error("The global config is readonly. \nPlease create a mathjs instance if you want to change the default configuration. \nExample:\n\n  import { create, all } from 'mathjs';\n  const mathjs = create(all);\n  mathjs.config({ number: 'BigNumber' });\n");
    }
    return Object.freeze(DEFAULT_CONFIG);
  };
  _extends(config, DEFAULT_CONFIG, {
    MATRIX_OPTIONS,
    NUMBER_OPTIONS
  });

  // node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/esm/core/function/typed.js
  var import_typed_function = __toESM(require_typed_function(), 1);

  // node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/esm/utils/number.js
  function isInteger(value) {
    if (typeof value === "boolean") {
      return true;
    }
    return isFinite(value) ? value === Math.round(value) : false;
  }
  var sign = Math.sign || function(x) {
    if (x > 0) {
      return 1;
    } else if (x < 0) {
      return -1;
    } else {
      return 0;
    }
  };
  var log2 = Math.log2 || function log22(x) {
    return Math.log(x) / Math.LN2;
  };
  var log10 = Math.log10 || function log102(x) {
    return Math.log(x) / Math.LN10;
  };
  var log1p = Math.log1p || function(x) {
    return Math.log(x + 1);
  };
  var cbrt = Math.cbrt || function cbrt2(x) {
    if (x === 0) {
      return x;
    }
    var negate = x < 0;
    var result;
    if (negate) {
      x = -x;
    }
    if (isFinite(x)) {
      result = Math.exp(Math.log(x) / 3);
      result = (x / (result * result) + 2 * result) / 3;
    } else {
      result = x;
    }
    return negate ? -result : result;
  };
  var expm1 = Math.expm1 || function expm12(x) {
    return x >= 2e-4 || x <= -2e-4 ? Math.exp(x) - 1 : x + x * x / 2 + x * x * x / 6;
  };
  function formatNumberToBase(n, base, size2) {
    var prefixes = {
      2: "0b",
      8: "0o",
      16: "0x"
    };
    var prefix = prefixes[base];
    var suffix = "";
    if (size2) {
      if (size2 < 1) {
        throw new Error("size must be in greater than 0");
      }
      if (!isInteger(size2)) {
        throw new Error("size must be an integer");
      }
      if (n > 2 ** (size2 - 1) - 1 || n < -(2 ** (size2 - 1))) {
        throw new Error("Value must be in range [-2^".concat(size2 - 1, ", 2^").concat(size2 - 1, "-1]"));
      }
      if (!isInteger(n)) {
        throw new Error("Value must be an integer");
      }
      if (n < 0) {
        n = n + 2 ** size2;
      }
      suffix = "i".concat(size2);
    }
    var sign3 = "";
    if (n < 0) {
      n = -n;
      sign3 = "-";
    }
    return "".concat(sign3).concat(prefix).concat(n.toString(base)).concat(suffix);
  }
  function format(value, options) {
    if (typeof options === "function") {
      return options(value);
    }
    if (value === Infinity) {
      return "Infinity";
    } else if (value === -Infinity) {
      return "-Infinity";
    } else if (isNaN(value)) {
      return "NaN";
    }
    var {
      notation,
      precision,
      wordSize
    } = normalizeFormatOptions(options);
    switch (notation) {
      case "fixed":
        return toFixed(value, precision);
      case "exponential":
        return toExponential(value, precision);
      case "engineering":
        return toEngineering(value, precision);
      case "bin":
        return formatNumberToBase(value, 2, wordSize);
      case "oct":
        return formatNumberToBase(value, 8, wordSize);
      case "hex":
        return formatNumberToBase(value, 16, wordSize);
      case "auto":
        return toPrecision(value, precision, options).replace(/((\.\d*?)(0+))($|e)/, function() {
          var digits2 = arguments[2];
          var e = arguments[4];
          return digits2 !== "." ? digits2 + e : e;
        });
      default:
        throw new Error('Unknown notation "' + notation + '". Choose "auto", "exponential", "fixed", "bin", "oct", or "hex.');
    }
  }
  function normalizeFormatOptions(options) {
    var notation = "auto";
    var precision;
    var wordSize;
    if (options !== void 0) {
      if (isNumber(options)) {
        precision = options;
      } else if (isBigNumber(options)) {
        precision = options.toNumber();
      } else if (isObject(options)) {
        if (options.precision !== void 0) {
          precision = _toNumberOrThrow(options.precision, () => {
            throw new Error('Option "precision" must be a number or BigNumber');
          });
        }
        if (options.wordSize !== void 0) {
          wordSize = _toNumberOrThrow(options.wordSize, () => {
            throw new Error('Option "wordSize" must be a number or BigNumber');
          });
        }
        if (options.notation) {
          notation = options.notation;
        }
      } else {
        throw new Error("Unsupported type of options, number, BigNumber, or object expected");
      }
    }
    return {
      notation,
      precision,
      wordSize
    };
  }
  function splitNumber(value) {
    var match = String(value).toLowerCase().match(/^(-?)(\d+\.?\d*)(e([+-]?\d+))?$/);
    if (!match) {
      throw new SyntaxError("Invalid number " + value);
    }
    var sign3 = match[1];
    var digits2 = match[2];
    var exponent = parseFloat(match[4] || "0");
    var dot2 = digits2.indexOf(".");
    exponent += dot2 !== -1 ? dot2 - 1 : digits2.length - 1;
    var coefficients = digits2.replace(".", "").replace(/^0*/, function(zeros2) {
      exponent -= zeros2.length;
      return "";
    }).replace(/0*$/, "").split("").map(function(d) {
      return parseInt(d);
    });
    if (coefficients.length === 0) {
      coefficients.push(0);
      exponent++;
    }
    return {
      sign: sign3,
      coefficients,
      exponent
    };
  }
  function toEngineering(value, precision) {
    if (isNaN(value) || !isFinite(value)) {
      return String(value);
    }
    var split = splitNumber(value);
    var rounded = roundDigits(split, precision);
    var e = rounded.exponent;
    var c = rounded.coefficients;
    var newExp = e % 3 === 0 ? e : e < 0 ? e - 3 - e % 3 : e - e % 3;
    if (isNumber(precision)) {
      while (precision > c.length || e - newExp + 1 > c.length) {
        c.push(0);
      }
    } else {
      var missingZeros = Math.abs(e - newExp) - (c.length - 1);
      for (var i = 0; i < missingZeros; i++) {
        c.push(0);
      }
    }
    var expDiff = Math.abs(e - newExp);
    var decimalIdx = 1;
    while (expDiff > 0) {
      decimalIdx++;
      expDiff--;
    }
    var decimals = c.slice(decimalIdx).join("");
    var decimalVal = isNumber(precision) && decimals.length || decimals.match(/[1-9]/) ? "." + decimals : "";
    var str = c.slice(0, decimalIdx).join("") + decimalVal + "e" + (e >= 0 ? "+" : "") + newExp.toString();
    return rounded.sign + str;
  }
  function toFixed(value, precision) {
    if (isNaN(value) || !isFinite(value)) {
      return String(value);
    }
    var splitValue = splitNumber(value);
    var rounded = typeof precision === "number" ? roundDigits(splitValue, splitValue.exponent + 1 + precision) : splitValue;
    var c = rounded.coefficients;
    var p = rounded.exponent + 1;
    var pp = p + (precision || 0);
    if (c.length < pp) {
      c = c.concat(zeros(pp - c.length));
    }
    if (p < 0) {
      c = zeros(-p + 1).concat(c);
      p = 1;
    }
    if (p < c.length) {
      c.splice(p, 0, p === 0 ? "0." : ".");
    }
    return rounded.sign + c.join("");
  }
  function toExponential(value, precision) {
    if (isNaN(value) || !isFinite(value)) {
      return String(value);
    }
    var split = splitNumber(value);
    var rounded = precision ? roundDigits(split, precision) : split;
    var c = rounded.coefficients;
    var e = rounded.exponent;
    if (c.length < precision) {
      c = c.concat(zeros(precision - c.length));
    }
    var first = c.shift();
    return rounded.sign + first + (c.length > 0 ? "." + c.join("") : "") + "e" + (e >= 0 ? "+" : "") + e;
  }
  function toPrecision(value, precision, options) {
    if (isNaN(value) || !isFinite(value)) {
      return String(value);
    }
    var lowerExp = _toNumberOrDefault(options === null || options === void 0 ? void 0 : options.lowerExp, -3);
    var upperExp = _toNumberOrDefault(options === null || options === void 0 ? void 0 : options.upperExp, 5);
    var split = splitNumber(value);
    var rounded = precision ? roundDigits(split, precision) : split;
    if (rounded.exponent < lowerExp || rounded.exponent >= upperExp) {
      return toExponential(value, precision);
    } else {
      var c = rounded.coefficients;
      var e = rounded.exponent;
      if (c.length < precision) {
        c = c.concat(zeros(precision - c.length));
      }
      c = c.concat(zeros(e - c.length + 1 + (c.length < precision ? precision - c.length : 0)));
      c = zeros(-e).concat(c);
      var dot2 = e > 0 ? e : 0;
      if (dot2 < c.length - 1) {
        c.splice(dot2 + 1, 0, ".");
      }
      return rounded.sign + c.join("");
    }
  }
  function roundDigits(split, precision) {
    var rounded = {
      sign: split.sign,
      coefficients: split.coefficients,
      exponent: split.exponent
    };
    var c = rounded.coefficients;
    while (precision <= 0) {
      c.unshift(0);
      rounded.exponent++;
      precision++;
    }
    if (c.length > precision) {
      var removed = c.splice(precision, c.length - precision);
      if (removed[0] >= 5) {
        var i = precision - 1;
        c[i]++;
        while (c[i] === 10) {
          c.pop();
          if (i === 0) {
            c.unshift(0);
            rounded.exponent++;
            i++;
          }
          i--;
          c[i]++;
        }
      }
    }
    return rounded;
  }
  function zeros(length) {
    var arr = [];
    for (var i = 0; i < length; i++) {
      arr.push(0);
    }
    return arr;
  }
  function digits(value) {
    return value.toExponential().replace(/e.*$/, "").replace(/^0\.?0*|\./, "").length;
  }
  var DBL_EPSILON = Number.EPSILON || 2220446049250313e-31;
  function nearlyEqual(x, y, epsilon) {
    if (epsilon === null || epsilon === void 0) {
      return x === y;
    }
    if (x === y) {
      return true;
    }
    if (isNaN(x) || isNaN(y)) {
      return false;
    }
    if (isFinite(x) && isFinite(y)) {
      var diff = Math.abs(x - y);
      if (diff <= DBL_EPSILON) {
        return true;
      } else {
        return diff <= Math.max(Math.abs(x), Math.abs(y)) * epsilon;
      }
    }
    return false;
  }
  function _toNumberOrThrow(value, onError) {
    if (isNumber(value)) {
      return value;
    } else if (isBigNumber(value)) {
      return value.toNumber();
    } else {
      onError();
    }
  }
  function _toNumberOrDefault(value, defaultValue) {
    if (isNumber(value)) {
      return value;
    } else if (isBigNumber(value)) {
      return value.toNumber();
    } else {
      return defaultValue;
    }
  }

  // node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/esm/utils/factory.js
  function factory(name18, dependencies19, create, meta) {
    function assertAndCreate(scope) {
      var deps = pickShallow(scope, dependencies19.map(stripOptionalNotation));
      assertDependencies(name18, dependencies19, scope);
      return create(deps);
    }
    assertAndCreate.isFactory = true;
    assertAndCreate.fn = name18;
    assertAndCreate.dependencies = dependencies19.slice().sort();
    if (meta) {
      assertAndCreate.meta = meta;
    }
    return assertAndCreate;
  }
  function assertDependencies(name18, dependencies19, scope) {
    var allDefined = dependencies19.filter((dependency) => !isOptionalDependency(dependency)).every((dependency) => scope[dependency] !== void 0);
    if (!allDefined) {
      var missingDependencies = dependencies19.filter((dependency) => scope[dependency] === void 0);
      throw new Error('Cannot create function "'.concat(name18, '", ') + "some dependencies are missing: ".concat(missingDependencies.map((d) => '"'.concat(d, '"')).join(", "), "."));
    }
  }
  function isOptionalDependency(dependency) {
    return dependency && dependency[0] === "?";
  }
  function stripOptionalNotation(dependency) {
    return dependency && dependency[0] === "?" ? dependency.slice(1) : dependency;
  }

  // node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/esm/utils/customs.js
  function getSafeProperty(object, prop) {
    if (isPlainObject(object) && isSafeProperty(object, prop)) {
      return object[prop];
    }
    if (typeof object[prop] === "function" && isSafeMethod(object, prop)) {
      throw new Error('Cannot access method "' + prop + '" as a property');
    }
    throw new Error('No access to property "' + prop + '"');
  }
  function setSafeProperty(object, prop, value) {
    if (isPlainObject(object) && isSafeProperty(object, prop)) {
      object[prop] = value;
      return value;
    }
    throw new Error('No access to property "' + prop + '"');
  }
  function hasSafeProperty(object, prop) {
    return prop in object;
  }
  function isSafeProperty(object, prop) {
    if (!object || typeof object !== "object") {
      return false;
    }
    if (hasOwnProperty(safeNativeProperties, prop)) {
      return true;
    }
    if (prop in Object.prototype) {
      return false;
    }
    if (prop in Function.prototype) {
      return false;
    }
    return true;
  }
  function isSafeMethod(object, method) {
    if (object === null || object === void 0 || typeof object[method] !== "function") {
      return false;
    }
    if (hasOwnProperty(object, method) && Object.getPrototypeOf && method in Object.getPrototypeOf(object)) {
      return false;
    }
    if (hasOwnProperty(safeNativeMethods, method)) {
      return true;
    }
    if (method in Object.prototype) {
      return false;
    }
    if (method in Function.prototype) {
      return false;
    }
    return true;
  }
  function isPlainObject(object) {
    return typeof object === "object" && object && object.constructor === Object;
  }
  var safeNativeProperties = {
    length: true,
    name: true
  };
  var safeNativeMethods = {
    toString: true,
    valueOf: true,
    toLocaleString: true
  };

  // node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/esm/utils/map.js
  var ObjectWrappingMap = class {
    constructor(object) {
      this.wrappedObject = object;
      this[Symbol.iterator] = this.entries;
    }
    keys() {
      return Object.keys(this.wrappedObject).values();
    }
    get(key) {
      return getSafeProperty(this.wrappedObject, key);
    }
    set(key, value) {
      setSafeProperty(this.wrappedObject, key, value);
      return this;
    }
    has(key) {
      return hasSafeProperty(this.wrappedObject, key);
    }
    entries() {
      return mapIterator(this.keys(), (key) => [key, this.get(key)]);
    }
    forEach(callback) {
      for (var key of this.keys()) {
        callback(this.get(key), key, this);
      }
    }
    delete(key) {
      delete this.wrappedObject[key];
    }
    clear() {
      for (var key of this.keys()) {
        this.delete(key);
      }
    }
    get size() {
      return Object.keys(this.wrappedObject).length;
    }
  };
  function mapIterator(it, callback) {
    return {
      next: () => {
        var n = it.next();
        return n.done ? n : {
          value: callback(n.value),
          done: false
        };
      }
    };
  }
  function isMap(object) {
    if (!object) {
      return false;
    }
    return object instanceof Map || object instanceof ObjectWrappingMap || typeof object.set === "function" && typeof object.get === "function" && typeof object.keys === "function" && typeof object.has === "function";
  }

  // node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/esm/core/function/typed.js
  var _createTyped2 = function _createTyped() {
    _createTyped2 = import_typed_function.default.create;
    return import_typed_function.default;
  };
  var dependencies = ["?BigNumber", "?Complex", "?DenseMatrix", "?Fraction"];
  var createTyped = /* @__PURE__ */ factory("typed", dependencies, function createTyped2(_ref) {
    var {
      BigNumber: BigNumber2,
      Complex: Complex3,
      DenseMatrix: DenseMatrix2,
      Fraction: Fraction3
    } = _ref;
    var typed2 = _createTyped2();
    typed2.clear();
    typed2.addTypes([
      {
        name: "number",
        test: isNumber
      },
      {
        name: "Complex",
        test: isComplex
      },
      {
        name: "BigNumber",
        test: isBigNumber
      },
      {
        name: "Fraction",
        test: isFraction
      },
      {
        name: "Unit",
        test: isUnit
      },
      // The following type matches a valid variable name, i.e., an alphanumeric
      // string starting with an alphabetic character. It is used (at least)
      // in the definition of the derivative() function, as the argument telling
      // what to differentiate over must (currently) be a variable.
      {
        name: "identifier",
        test: (s) => isString && /^(?:[A-Za-z\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0370-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u048A-\u052F\u0531-\u0556\u0559\u0560-\u0588\u05D0-\u05EA\u05EF-\u05F2\u0620-\u064A\u066E\u066F\u0671-\u06D3\u06D5\u06E5\u06E6\u06EE\u06EF\u06FA-\u06FC\u06FF\u0710\u0712-\u072F\u074D-\u07A5\u07B1\u07CA-\u07EA\u07F4\u07F5\u07FA\u0800-\u0815\u081A\u0824\u0828\u0840-\u0858\u0860-\u086A\u0870-\u0887\u0889-\u088E\u08A0-\u08C9\u0904-\u0939\u093D\u0950\u0958-\u0961\u0971-\u0980\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BD\u09CE\u09DC\u09DD\u09DF-\u09E1\u09F0\u09F1\u09FC\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A59-\u0A5C\u0A5E\u0A72-\u0A74\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABD\u0AD0\u0AE0\u0AE1\u0AF9\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3D\u0B5C\u0B5D\u0B5F-\u0B61\u0B71\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BD0\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D\u0C58-\u0C5A\u0C5D\u0C60\u0C61\u0C80\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBD\u0CDD\u0CDE\u0CE0\u0CE1\u0CF1\u0CF2\u0D04-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D\u0D4E\u0D54-\u0D56\u0D5F-\u0D61\u0D7A-\u0D7F\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0E01-\u0E30\u0E32\u0E33\u0E40-\u0E46\u0E81\u0E82\u0E84\u0E86-\u0E8A\u0E8C-\u0EA3\u0EA5\u0EA7-\u0EB0\u0EB2\u0EB3\u0EBD\u0EC0-\u0EC4\u0EC6\u0EDC-\u0EDF\u0F00\u0F40-\u0F47\u0F49-\u0F6C\u0F88-\u0F8C\u1000-\u102A\u103F\u1050-\u1055\u105A-\u105D\u1061\u1065\u1066\u106E-\u1070\u1075-\u1081\u108E\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16F1-\u16F8\u1700-\u1711\u171F-\u1731\u1740-\u1751\u1760-\u176C\u176E-\u1770\u1780-\u17B3\u17D7\u17DC\u1820-\u1878\u1880-\u1884\u1887-\u18A8\u18AA\u18B0-\u18F5\u1900-\u191E\u1950-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u1A00-\u1A16\u1A20-\u1A54\u1AA7\u1B05-\u1B33\u1B45-\u1B4C\u1B83-\u1BA0\u1BAE\u1BAF\u1BBA-\u1BE5\u1C00-\u1C23\u1C4D-\u1C4F\u1C5A-\u1C7D\u1C80-\u1C88\u1C90-\u1CBA\u1CBD-\u1CBF\u1CE9-\u1CEC\u1CEE-\u1CF3\u1CF5\u1CF6\u1CFA\u1D00-\u1DBF\u1E00-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u2071\u207F\u2090-\u209C\u2102\u2107\u210A-\u2113\u2115\u2119-\u211D\u2124\u2126\u2128\u212A-\u212D\u212F-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2183\u2184\u2C00-\u2CE4\u2CEB-\u2CEE\u2CF2\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D80-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u2E2F\u3005\u3006\u3031-\u3035\u303B\u303C\u3041-\u3096\u309D-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312F\u3131-\u318E\u31A0-\u31BF\u31F0-\u31FF\u3400-\u4DBF\u4E00-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA61F\uA62A\uA62B\uA640-\uA66E\uA67F-\uA69D\uA6A0-\uA6E5\uA717-\uA71F\uA722-\uA788\uA78B-\uA7CA\uA7D0\uA7D1\uA7D3\uA7D5-\uA7D9\uA7F2-\uA801\uA803-\uA805\uA807-\uA80A\uA80C-\uA822\uA840-\uA873\uA882-\uA8B3\uA8F2-\uA8F7\uA8FB\uA8FD\uA8FE\uA90A-\uA925\uA930-\uA946\uA960-\uA97C\uA984-\uA9B2\uA9CF\uA9E0-\uA9E4\uA9E6-\uA9EF\uA9FA-\uA9FE\uAA00-\uAA28\uAA40-\uAA42\uAA44-\uAA4B\uAA60-\uAA76\uAA7A\uAA7E-\uAAAF\uAAB1\uAAB5\uAAB6\uAAB9-\uAABD\uAAC0\uAAC2\uAADB-\uAADD\uAAE0-\uAAEA\uAAF2-\uAAF4\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB69\uAB70-\uABE2\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D\uFB1F-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE70-\uFE74\uFE76-\uFEFC\uFF21-\uFF3A\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]|\uD800[\uDC00-\uDC0B\uDC0D-\uDC26\uDC28-\uDC3A\uDC3C\uDC3D\uDC3F-\uDC4D\uDC50-\uDC5D\uDC80-\uDCFA\uDE80-\uDE9C\uDEA0-\uDED0\uDF00-\uDF1F\uDF2D-\uDF40\uDF42-\uDF49\uDF50-\uDF75\uDF80-\uDF9D\uDFA0-\uDFC3\uDFC8-\uDFCF]|\uD801[\uDC00-\uDC9D\uDCB0-\uDCD3\uDCD8-\uDCFB\uDD00-\uDD27\uDD30-\uDD63\uDD70-\uDD7A\uDD7C-\uDD8A\uDD8C-\uDD92\uDD94\uDD95\uDD97-\uDDA1\uDDA3-\uDDB1\uDDB3-\uDDB9\uDDBB\uDDBC\uDE00-\uDF36\uDF40-\uDF55\uDF60-\uDF67\uDF80-\uDF85\uDF87-\uDFB0\uDFB2-\uDFBA]|\uD802[\uDC00-\uDC05\uDC08\uDC0A-\uDC35\uDC37\uDC38\uDC3C\uDC3F-\uDC55\uDC60-\uDC76\uDC80-\uDC9E\uDCE0-\uDCF2\uDCF4\uDCF5\uDD00-\uDD15\uDD20-\uDD39\uDD80-\uDDB7\uDDBE\uDDBF\uDE00\uDE10-\uDE13\uDE15-\uDE17\uDE19-\uDE35\uDE60-\uDE7C\uDE80-\uDE9C\uDEC0-\uDEC7\uDEC9-\uDEE4\uDF00-\uDF35\uDF40-\uDF55\uDF60-\uDF72\uDF80-\uDF91]|\uD803[\uDC00-\uDC48\uDC80-\uDCB2\uDCC0-\uDCF2\uDD00-\uDD23\uDE80-\uDEA9\uDEB0\uDEB1\uDF00-\uDF1C\uDF27\uDF30-\uDF45\uDF70-\uDF81\uDFB0-\uDFC4\uDFE0-\uDFF6]|\uD804[\uDC03-\uDC37\uDC71\uDC72\uDC75\uDC83-\uDCAF\uDCD0-\uDCE8\uDD03-\uDD26\uDD44\uDD47\uDD50-\uDD72\uDD76\uDD83-\uDDB2\uDDC1-\uDDC4\uDDDA\uDDDC\uDE00-\uDE11\uDE13-\uDE2B\uDE3F\uDE40\uDE80-\uDE86\uDE88\uDE8A-\uDE8D\uDE8F-\uDE9D\uDE9F-\uDEA8\uDEB0-\uDEDE\uDF05-\uDF0C\uDF0F\uDF10\uDF13-\uDF28\uDF2A-\uDF30\uDF32\uDF33\uDF35-\uDF39\uDF3D\uDF50\uDF5D-\uDF61]|\uD805[\uDC00-\uDC34\uDC47-\uDC4A\uDC5F-\uDC61\uDC80-\uDCAF\uDCC4\uDCC5\uDCC7\uDD80-\uDDAE\uDDD8-\uDDDB\uDE00-\uDE2F\uDE44\uDE80-\uDEAA\uDEB8\uDF00-\uDF1A\uDF40-\uDF46]|\uD806[\uDC00-\uDC2B\uDCA0-\uDCDF\uDCFF-\uDD06\uDD09\uDD0C-\uDD13\uDD15\uDD16\uDD18-\uDD2F\uDD3F\uDD41\uDDA0-\uDDA7\uDDAA-\uDDD0\uDDE1\uDDE3\uDE00\uDE0B-\uDE32\uDE3A\uDE50\uDE5C-\uDE89\uDE9D\uDEB0-\uDEF8]|\uD807[\uDC00-\uDC08\uDC0A-\uDC2E\uDC40\uDC72-\uDC8F\uDD00-\uDD06\uDD08\uDD09\uDD0B-\uDD30\uDD46\uDD60-\uDD65\uDD67\uDD68\uDD6A-\uDD89\uDD98\uDEE0-\uDEF2\uDF02\uDF04-\uDF10\uDF12-\uDF33\uDFB0]|\uD808[\uDC00-\uDF99]|\uD809[\uDC80-\uDD43]|\uD80B[\uDF90-\uDFF0]|[\uD80C\uD81C-\uD820\uD822\uD840-\uD868\uD86A-\uD86C\uD86F-\uD872\uD874-\uD879\uD880-\uD883\uD885-\uD887][\uDC00-\uDFFF]|\uD80D[\uDC00-\uDC2F\uDC41-\uDC46]|\uD811[\uDC00-\uDE46]|\uD81A[\uDC00-\uDE38\uDE40-\uDE5E\uDE70-\uDEBE\uDED0-\uDEED\uDF00-\uDF2F\uDF40-\uDF43\uDF63-\uDF77\uDF7D-\uDF8F]|\uD81B[\uDE40-\uDE7F\uDF00-\uDF4A\uDF50\uDF93-\uDF9F\uDFE0\uDFE1\uDFE3]|\uD821[\uDC00-\uDFF7]|\uD823[\uDC00-\uDCD5\uDD00-\uDD08]|\uD82B[\uDFF0-\uDFF3\uDFF5-\uDFFB\uDFFD\uDFFE]|\uD82C[\uDC00-\uDD22\uDD32\uDD50-\uDD52\uDD55\uDD64-\uDD67\uDD70-\uDEFB]|\uD82F[\uDC00-\uDC6A\uDC70-\uDC7C\uDC80-\uDC88\uDC90-\uDC99]|\uD835[\uDC00-\uDC54\uDC56-\uDC9C\uDC9E\uDC9F\uDCA2\uDCA5\uDCA6\uDCA9-\uDCAC\uDCAE-\uDCB9\uDCBB\uDCBD-\uDCC3\uDCC5-\uDD05\uDD07-\uDD0A\uDD0D-\uDD14\uDD16-\uDD1C\uDD1E-\uDD39\uDD3B-\uDD3E\uDD40-\uDD44\uDD46\uDD4A-\uDD50\uDD52-\uDEA5\uDEA8-\uDEC0\uDEC2-\uDEDA\uDEDC-\uDEFA\uDEFC-\uDF14\uDF16-\uDF34\uDF36-\uDF4E\uDF50-\uDF6E\uDF70-\uDF88\uDF8A-\uDFA8\uDFAA-\uDFC2\uDFC4-\uDFCB]|\uD837[\uDF00-\uDF1E\uDF25-\uDF2A]|\uD838[\uDC30-\uDC6D\uDD00-\uDD2C\uDD37-\uDD3D\uDD4E\uDE90-\uDEAD\uDEC0-\uDEEB]|\uD839[\uDCD0-\uDCEB\uDFE0-\uDFE6\uDFE8-\uDFEB\uDFED\uDFEE\uDFF0-\uDFFE]|\uD83A[\uDC00-\uDCC4\uDD00-\uDD43\uDD4B]|\uD83B[\uDE00-\uDE03\uDE05-\uDE1F\uDE21\uDE22\uDE24\uDE27\uDE29-\uDE32\uDE34-\uDE37\uDE39\uDE3B\uDE42\uDE47\uDE49\uDE4B\uDE4D-\uDE4F\uDE51\uDE52\uDE54\uDE57\uDE59\uDE5B\uDE5D\uDE5F\uDE61\uDE62\uDE64\uDE67-\uDE6A\uDE6C-\uDE72\uDE74-\uDE77\uDE79-\uDE7C\uDE7E\uDE80-\uDE89\uDE8B-\uDE9B\uDEA1-\uDEA3\uDEA5-\uDEA9\uDEAB-\uDEBB]|\uD869[\uDC00-\uDEDF\uDF00-\uDFFF]|\uD86D[\uDC00-\uDF39\uDF40-\uDFFF]|\uD86E[\uDC00-\uDC1D\uDC20-\uDFFF]|\uD873[\uDC00-\uDEA1\uDEB0-\uDFFF]|\uD87A[\uDC00-\uDFE0]|\uD87E[\uDC00-\uDE1D]|\uD884[\uDC00-\uDF4A\uDF50-\uDFFF]|\uD888[\uDC00-\uDFAF])(?:[0-9A-Za-z\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0370-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u048A-\u052F\u0531-\u0556\u0559\u0560-\u0588\u05D0-\u05EA\u05EF-\u05F2\u0620-\u064A\u066E\u066F\u0671-\u06D3\u06D5\u06E5\u06E6\u06EE\u06EF\u06FA-\u06FC\u06FF\u0710\u0712-\u072F\u074D-\u07A5\u07B1\u07CA-\u07EA\u07F4\u07F5\u07FA\u0800-\u0815\u081A\u0824\u0828\u0840-\u0858\u0860-\u086A\u0870-\u0887\u0889-\u088E\u08A0-\u08C9\u0904-\u0939\u093D\u0950\u0958-\u0961\u0971-\u0980\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BD\u09CE\u09DC\u09DD\u09DF-\u09E1\u09F0\u09F1\u09FC\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A59-\u0A5C\u0A5E\u0A72-\u0A74\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABD\u0AD0\u0AE0\u0AE1\u0AF9\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3D\u0B5C\u0B5D\u0B5F-\u0B61\u0B71\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BD0\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D\u0C58-\u0C5A\u0C5D\u0C60\u0C61\u0C80\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBD\u0CDD\u0CDE\u0CE0\u0CE1\u0CF1\u0CF2\u0D04-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D\u0D4E\u0D54-\u0D56\u0D5F-\u0D61\u0D7A-\u0D7F\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0E01-\u0E30\u0E32\u0E33\u0E40-\u0E46\u0E81\u0E82\u0E84\u0E86-\u0E8A\u0E8C-\u0EA3\u0EA5\u0EA7-\u0EB0\u0EB2\u0EB3\u0EBD\u0EC0-\u0EC4\u0EC6\u0EDC-\u0EDF\u0F00\u0F40-\u0F47\u0F49-\u0F6C\u0F88-\u0F8C\u1000-\u102A\u103F\u1050-\u1055\u105A-\u105D\u1061\u1065\u1066\u106E-\u1070\u1075-\u1081\u108E\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16F1-\u16F8\u1700-\u1711\u171F-\u1731\u1740-\u1751\u1760-\u176C\u176E-\u1770\u1780-\u17B3\u17D7\u17DC\u1820-\u1878\u1880-\u1884\u1887-\u18A8\u18AA\u18B0-\u18F5\u1900-\u191E\u1950-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u1A00-\u1A16\u1A20-\u1A54\u1AA7\u1B05-\u1B33\u1B45-\u1B4C\u1B83-\u1BA0\u1BAE\u1BAF\u1BBA-\u1BE5\u1C00-\u1C23\u1C4D-\u1C4F\u1C5A-\u1C7D\u1C80-\u1C88\u1C90-\u1CBA\u1CBD-\u1CBF\u1CE9-\u1CEC\u1CEE-\u1CF3\u1CF5\u1CF6\u1CFA\u1D00-\u1DBF\u1E00-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u2071\u207F\u2090-\u209C\u2102\u2107\u210A-\u2113\u2115\u2119-\u211D\u2124\u2126\u2128\u212A-\u212D\u212F-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2183\u2184\u2C00-\u2CE4\u2CEB-\u2CEE\u2CF2\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D80-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u2E2F\u3005\u3006\u3031-\u3035\u303B\u303C\u3041-\u3096\u309D-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312F\u3131-\u318E\u31A0-\u31BF\u31F0-\u31FF\u3400-\u4DBF\u4E00-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA61F\uA62A\uA62B\uA640-\uA66E\uA67F-\uA69D\uA6A0-\uA6E5\uA717-\uA71F\uA722-\uA788\uA78B-\uA7CA\uA7D0\uA7D1\uA7D3\uA7D5-\uA7D9\uA7F2-\uA801\uA803-\uA805\uA807-\uA80A\uA80C-\uA822\uA840-\uA873\uA882-\uA8B3\uA8F2-\uA8F7\uA8FB\uA8FD\uA8FE\uA90A-\uA925\uA930-\uA946\uA960-\uA97C\uA984-\uA9B2\uA9CF\uA9E0-\uA9E4\uA9E6-\uA9EF\uA9FA-\uA9FE\uAA00-\uAA28\uAA40-\uAA42\uAA44-\uAA4B\uAA60-\uAA76\uAA7A\uAA7E-\uAAAF\uAAB1\uAAB5\uAAB6\uAAB9-\uAABD\uAAC0\uAAC2\uAADB-\uAADD\uAAE0-\uAAEA\uAAF2-\uAAF4\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB69\uAB70-\uABE2\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D\uFB1F-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE70-\uFE74\uFE76-\uFEFC\uFF21-\uFF3A\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]|\uD800[\uDC00-\uDC0B\uDC0D-\uDC26\uDC28-\uDC3A\uDC3C\uDC3D\uDC3F-\uDC4D\uDC50-\uDC5D\uDC80-\uDCFA\uDE80-\uDE9C\uDEA0-\uDED0\uDF00-\uDF1F\uDF2D-\uDF40\uDF42-\uDF49\uDF50-\uDF75\uDF80-\uDF9D\uDFA0-\uDFC3\uDFC8-\uDFCF]|\uD801[\uDC00-\uDC9D\uDCB0-\uDCD3\uDCD8-\uDCFB\uDD00-\uDD27\uDD30-\uDD63\uDD70-\uDD7A\uDD7C-\uDD8A\uDD8C-\uDD92\uDD94\uDD95\uDD97-\uDDA1\uDDA3-\uDDB1\uDDB3-\uDDB9\uDDBB\uDDBC\uDE00-\uDF36\uDF40-\uDF55\uDF60-\uDF67\uDF80-\uDF85\uDF87-\uDFB0\uDFB2-\uDFBA]|\uD802[\uDC00-\uDC05\uDC08\uDC0A-\uDC35\uDC37\uDC38\uDC3C\uDC3F-\uDC55\uDC60-\uDC76\uDC80-\uDC9E\uDCE0-\uDCF2\uDCF4\uDCF5\uDD00-\uDD15\uDD20-\uDD39\uDD80-\uDDB7\uDDBE\uDDBF\uDE00\uDE10-\uDE13\uDE15-\uDE17\uDE19-\uDE35\uDE60-\uDE7C\uDE80-\uDE9C\uDEC0-\uDEC7\uDEC9-\uDEE4\uDF00-\uDF35\uDF40-\uDF55\uDF60-\uDF72\uDF80-\uDF91]|\uD803[\uDC00-\uDC48\uDC80-\uDCB2\uDCC0-\uDCF2\uDD00-\uDD23\uDE80-\uDEA9\uDEB0\uDEB1\uDF00-\uDF1C\uDF27\uDF30-\uDF45\uDF70-\uDF81\uDFB0-\uDFC4\uDFE0-\uDFF6]|\uD804[\uDC03-\uDC37\uDC71\uDC72\uDC75\uDC83-\uDCAF\uDCD0-\uDCE8\uDD03-\uDD26\uDD44\uDD47\uDD50-\uDD72\uDD76\uDD83-\uDDB2\uDDC1-\uDDC4\uDDDA\uDDDC\uDE00-\uDE11\uDE13-\uDE2B\uDE3F\uDE40\uDE80-\uDE86\uDE88\uDE8A-\uDE8D\uDE8F-\uDE9D\uDE9F-\uDEA8\uDEB0-\uDEDE\uDF05-\uDF0C\uDF0F\uDF10\uDF13-\uDF28\uDF2A-\uDF30\uDF32\uDF33\uDF35-\uDF39\uDF3D\uDF50\uDF5D-\uDF61]|\uD805[\uDC00-\uDC34\uDC47-\uDC4A\uDC5F-\uDC61\uDC80-\uDCAF\uDCC4\uDCC5\uDCC7\uDD80-\uDDAE\uDDD8-\uDDDB\uDE00-\uDE2F\uDE44\uDE80-\uDEAA\uDEB8\uDF00-\uDF1A\uDF40-\uDF46]|\uD806[\uDC00-\uDC2B\uDCA0-\uDCDF\uDCFF-\uDD06\uDD09\uDD0C-\uDD13\uDD15\uDD16\uDD18-\uDD2F\uDD3F\uDD41\uDDA0-\uDDA7\uDDAA-\uDDD0\uDDE1\uDDE3\uDE00\uDE0B-\uDE32\uDE3A\uDE50\uDE5C-\uDE89\uDE9D\uDEB0-\uDEF8]|\uD807[\uDC00-\uDC08\uDC0A-\uDC2E\uDC40\uDC72-\uDC8F\uDD00-\uDD06\uDD08\uDD09\uDD0B-\uDD30\uDD46\uDD60-\uDD65\uDD67\uDD68\uDD6A-\uDD89\uDD98\uDEE0-\uDEF2\uDF02\uDF04-\uDF10\uDF12-\uDF33\uDFB0]|\uD808[\uDC00-\uDF99]|\uD809[\uDC80-\uDD43]|\uD80B[\uDF90-\uDFF0]|[\uD80C\uD81C-\uD820\uD822\uD840-\uD868\uD86A-\uD86C\uD86F-\uD872\uD874-\uD879\uD880-\uD883\uD885-\uD887][\uDC00-\uDFFF]|\uD80D[\uDC00-\uDC2F\uDC41-\uDC46]|\uD811[\uDC00-\uDE46]|\uD81A[\uDC00-\uDE38\uDE40-\uDE5E\uDE70-\uDEBE\uDED0-\uDEED\uDF00-\uDF2F\uDF40-\uDF43\uDF63-\uDF77\uDF7D-\uDF8F]|\uD81B[\uDE40-\uDE7F\uDF00-\uDF4A\uDF50\uDF93-\uDF9F\uDFE0\uDFE1\uDFE3]|\uD821[\uDC00-\uDFF7]|\uD823[\uDC00-\uDCD5\uDD00-\uDD08]|\uD82B[\uDFF0-\uDFF3\uDFF5-\uDFFB\uDFFD\uDFFE]|\uD82C[\uDC00-\uDD22\uDD32\uDD50-\uDD52\uDD55\uDD64-\uDD67\uDD70-\uDEFB]|\uD82F[\uDC00-\uDC6A\uDC70-\uDC7C\uDC80-\uDC88\uDC90-\uDC99]|\uD835[\uDC00-\uDC54\uDC56-\uDC9C\uDC9E\uDC9F\uDCA2\uDCA5\uDCA6\uDCA9-\uDCAC\uDCAE-\uDCB9\uDCBB\uDCBD-\uDCC3\uDCC5-\uDD05\uDD07-\uDD0A\uDD0D-\uDD14\uDD16-\uDD1C\uDD1E-\uDD39\uDD3B-\uDD3E\uDD40-\uDD44\uDD46\uDD4A-\uDD50\uDD52-\uDEA5\uDEA8-\uDEC0\uDEC2-\uDEDA\uDEDC-\uDEFA\uDEFC-\uDF14\uDF16-\uDF34\uDF36-\uDF4E\uDF50-\uDF6E\uDF70-\uDF88\uDF8A-\uDFA8\uDFAA-\uDFC2\uDFC4-\uDFCB]|\uD837[\uDF00-\uDF1E\uDF25-\uDF2A]|\uD838[\uDC30-\uDC6D\uDD00-\uDD2C\uDD37-\uDD3D\uDD4E\uDE90-\uDEAD\uDEC0-\uDEEB]|\uD839[\uDCD0-\uDCEB\uDFE0-\uDFE6\uDFE8-\uDFEB\uDFED\uDFEE\uDFF0-\uDFFE]|\uD83A[\uDC00-\uDCC4\uDD00-\uDD43\uDD4B]|\uD83B[\uDE00-\uDE03\uDE05-\uDE1F\uDE21\uDE22\uDE24\uDE27\uDE29-\uDE32\uDE34-\uDE37\uDE39\uDE3B\uDE42\uDE47\uDE49\uDE4B\uDE4D-\uDE4F\uDE51\uDE52\uDE54\uDE57\uDE59\uDE5B\uDE5D\uDE5F\uDE61\uDE62\uDE64\uDE67-\uDE6A\uDE6C-\uDE72\uDE74-\uDE77\uDE79-\uDE7C\uDE7E\uDE80-\uDE89\uDE8B-\uDE9B\uDEA1-\uDEA3\uDEA5-\uDEA9\uDEAB-\uDEBB]|\uD869[\uDC00-\uDEDF\uDF00-\uDFFF]|\uD86D[\uDC00-\uDF39\uDF40-\uDFFF]|\uD86E[\uDC00-\uDC1D\uDC20-\uDFFF]|\uD873[\uDC00-\uDEA1\uDEB0-\uDFFF]|\uD87A[\uDC00-\uDFE0]|\uD87E[\uDC00-\uDE1D]|\uD884[\uDC00-\uDF4A\uDF50-\uDFFF]|\uD888[\uDC00-\uDFAF])*$/.test(s)
      },
      {
        name: "string",
        test: isString
      },
      {
        name: "Chain",
        test: isChain
      },
      {
        name: "Array",
        test: isArray
      },
      {
        name: "Matrix",
        test: isMatrix
      },
      {
        name: "DenseMatrix",
        test: isDenseMatrix
      },
      {
        name: "SparseMatrix",
        test: isSparseMatrix
      },
      {
        name: "Range",
        test: isRange
      },
      {
        name: "Index",
        test: isIndex
      },
      {
        name: "boolean",
        test: isBoolean
      },
      {
        name: "ResultSet",
        test: isResultSet
      },
      {
        name: "Help",
        test: isHelp
      },
      {
        name: "function",
        test: isFunction
      },
      {
        name: "Date",
        test: isDate
      },
      {
        name: "RegExp",
        test: isRegExp
      },
      {
        name: "null",
        test: isNull
      },
      {
        name: "undefined",
        test: isUndefined
      },
      {
        name: "AccessorNode",
        test: isAccessorNode
      },
      {
        name: "ArrayNode",
        test: isArrayNode
      },
      {
        name: "AssignmentNode",
        test: isAssignmentNode
      },
      {
        name: "BlockNode",
        test: isBlockNode
      },
      {
        name: "ConditionalNode",
        test: isConditionalNode
      },
      {
        name: "ConstantNode",
        test: isConstantNode
      },
      {
        name: "FunctionNode",
        test: isFunctionNode
      },
      {
        name: "FunctionAssignmentNode",
        test: isFunctionAssignmentNode
      },
      {
        name: "IndexNode",
        test: isIndexNode
      },
      {
        name: "Node",
        test: isNode
      },
      {
        name: "ObjectNode",
        test: isObjectNode
      },
      {
        name: "OperatorNode",
        test: isOperatorNode
      },
      {
        name: "ParenthesisNode",
        test: isParenthesisNode
      },
      {
        name: "RangeNode",
        test: isRangeNode
      },
      {
        name: "RelationalNode",
        test: isRelationalNode
      },
      {
        name: "SymbolNode",
        test: isSymbolNode
      },
      {
        name: "Map",
        test: isMap
      },
      {
        name: "Object",
        test: isObject
      }
      // order 'Object' last, it matches on other classes too
    ]);
    typed2.addConversions([{
      from: "number",
      to: "BigNumber",
      convert: function convert(x) {
        if (!BigNumber2) {
          throwNoBignumber(x);
        }
        if (digits(x) > 15) {
          throw new TypeError("Cannot implicitly convert a number with >15 significant digits to BigNumber (value: " + x + "). Use function bignumber(x) to convert to BigNumber.");
        }
        return new BigNumber2(x);
      }
    }, {
      from: "number",
      to: "Complex",
      convert: function convert(x) {
        if (!Complex3) {
          throwNoComplex(x);
        }
        return new Complex3(x, 0);
      }
    }, {
      from: "BigNumber",
      to: "Complex",
      convert: function convert(x) {
        if (!Complex3) {
          throwNoComplex(x);
        }
        return new Complex3(x.toNumber(), 0);
      }
    }, {
      from: "Fraction",
      to: "BigNumber",
      convert: function convert(x) {
        throw new TypeError("Cannot implicitly convert a Fraction to BigNumber or vice versa. Use function bignumber(x) to convert to BigNumber or fraction(x) to convert to Fraction.");
      }
    }, {
      from: "Fraction",
      to: "Complex",
      convert: function convert(x) {
        if (!Complex3) {
          throwNoComplex(x);
        }
        return new Complex3(x.valueOf(), 0);
      }
    }, {
      from: "number",
      to: "Fraction",
      convert: function convert(x) {
        if (!Fraction3) {
          throwNoFraction(x);
        }
        var f = new Fraction3(x);
        if (f.valueOf() !== x) {
          throw new TypeError("Cannot implicitly convert a number to a Fraction when there will be a loss of precision (value: " + x + "). Use function fraction(x) to convert to Fraction.");
        }
        return f;
      }
    }, {
      // FIXME: add conversion from Fraction to number, for example for `sqrt(fraction(1,3))`
      //  from: 'Fraction',
      //  to: 'number',
      //  convert: function (x) {
      //    return x.valueOf()
      //  }
      // }, {
      from: "string",
      to: "number",
      convert: function convert(x) {
        var n = Number(x);
        if (isNaN(n)) {
          throw new Error('Cannot convert "' + x + '" to a number');
        }
        return n;
      }
    }, {
      from: "string",
      to: "BigNumber",
      convert: function convert(x) {
        if (!BigNumber2) {
          throwNoBignumber(x);
        }
        try {
          return new BigNumber2(x);
        } catch (err) {
          throw new Error('Cannot convert "' + x + '" to BigNumber');
        }
      }
    }, {
      from: "string",
      to: "Fraction",
      convert: function convert(x) {
        if (!Fraction3) {
          throwNoFraction(x);
        }
        try {
          return new Fraction3(x);
        } catch (err) {
          throw new Error('Cannot convert "' + x + '" to Fraction');
        }
      }
    }, {
      from: "string",
      to: "Complex",
      convert: function convert(x) {
        if (!Complex3) {
          throwNoComplex(x);
        }
        try {
          return new Complex3(x);
        } catch (err) {
          throw new Error('Cannot convert "' + x + '" to Complex');
        }
      }
    }, {
      from: "boolean",
      to: "number",
      convert: function convert(x) {
        return +x;
      }
    }, {
      from: "boolean",
      to: "BigNumber",
      convert: function convert(x) {
        if (!BigNumber2) {
          throwNoBignumber(x);
        }
        return new BigNumber2(+x);
      }
    }, {
      from: "boolean",
      to: "Fraction",
      convert: function convert(x) {
        if (!Fraction3) {
          throwNoFraction(x);
        }
        return new Fraction3(+x);
      }
    }, {
      from: "boolean",
      to: "string",
      convert: function convert(x) {
        return String(x);
      }
    }, {
      from: "Array",
      to: "Matrix",
      convert: function convert(array) {
        if (!DenseMatrix2) {
          throwNoMatrix();
        }
        return new DenseMatrix2(array);
      }
    }, {
      from: "Matrix",
      to: "Array",
      convert: function convert(matrix2) {
        return matrix2.valueOf();
      }
    }]);
    typed2.onMismatch = (name18, args, signatures) => {
      var usualError = typed2.createError(name18, args, signatures);
      if (["wrongType", "mismatch"].includes(usualError.data.category) && args.length === 1 && isCollection(args[0]) && // check if the function can be unary:
      signatures.some((sig) => !sig.params.includes(","))) {
        var err = new TypeError("Function '".concat(name18, "' doesn't apply to matrices. To call it ") + "elementwise on a matrix 'M', try 'map(M, ".concat(name18, ")'."));
        err.data = usualError.data;
        throw err;
      }
      throw usualError;
    };
    typed2.onMismatch = (name18, args, signatures) => {
      var usualError = typed2.createError(name18, args, signatures);
      if (["wrongType", "mismatch"].includes(usualError.data.category) && args.length === 1 && isCollection(args[0]) && // check if the function can be unary:
      signatures.some((sig) => !sig.params.includes(","))) {
        var err = new TypeError("Function '".concat(name18, "' doesn't apply to matrices. To call it ") + "elementwise on a matrix 'M', try 'map(M, ".concat(name18, ")'."));
        err.data = usualError.data;
        throw err;
      }
      throw usualError;
    };
    return typed2;
  });
  function throwNoBignumber(x) {
    throw new Error("Cannot convert value ".concat(x, " into a BigNumber: no class 'BigNumber' provided"));
  }
  function throwNoComplex(x) {
    throw new Error("Cannot convert value ".concat(x, " into a Complex number: no class 'Complex' provided"));
  }
  function throwNoMatrix() {
    throw new Error("Cannot convert array into a Matrix: no class 'DenseMatrix' provided");
  }
  function throwNoFraction(x) {
    throw new Error("Cannot convert value ".concat(x, " into a Fraction, no class 'Fraction' provided."));
  }

  // node_modules/.pnpm/decimal.js@10.6.0/node_modules/decimal.js/decimal.mjs
  var EXP_LIMIT = 9e15;
  var MAX_DIGITS = 1e9;
  var NUMERALS = "0123456789abcdef";
  var LN10 = "2.3025850929940456840179914546843642076011014886287729760333279009675726096773524802359972050895982983419677840422862486334095254650828067566662873690987816894829072083255546808437998948262331985283935053089653777326288461633662222876982198867465436674744042432743651550489343149393914796194044002221051017141748003688084012647080685567743216228355220114804663715659121373450747856947683463616792101806445070648000277502684916746550586856935673420670581136429224554405758925724208241314695689016758940256776311356919292033376587141660230105703089634572075440370847469940168269282808481184289314848524948644871927809676271275775397027668605952496716674183485704422507197965004714951050492214776567636938662976979522110718264549734772662425709429322582798502585509785265383207606726317164309505995087807523710333101197857547331541421808427543863591778117054309827482385045648019095610299291824318237525357709750539565187697510374970888692180205189339507238539205144634197265287286965110862571492198849978748873771345686209167058";
  var PI = "3.1415926535897932384626433832795028841971693993751058209749445923078164062862089986280348253421170679821480865132823066470938446095505822317253594081284811174502841027019385211055596446229489549303819644288109756659334461284756482337867831652712019091456485669234603486104543266482133936072602491412737245870066063155881748815209209628292540917153643678925903600113305305488204665213841469519415116094330572703657595919530921861173819326117931051185480744623799627495673518857527248912279381830119491298336733624406566430860213949463952247371907021798609437027705392171762931767523846748184676694051320005681271452635608277857713427577896091736371787214684409012249534301465495853710507922796892589235420199561121290219608640344181598136297747713099605187072113499999983729780499510597317328160963185950244594553469083026425223082533446850352619311881710100031378387528865875332083814206171776691473035982534904287554687311595628638823537875937519577818577805321712268066130019278766111959092164201989380952572010654858632789";
  var DEFAULTS = {
    // These values must be integers within the stated ranges (inclusive).
    // Most of these values can be changed at run-time using the `Decimal.config` method.
    // The maximum number of significant digits of the result of a calculation or base conversion.
    // E.g. `Decimal.config({ precision: 20 });`
    precision: 20,
    // 1 to MAX_DIGITS
    // The rounding mode used when rounding to `precision`.
    //
    // ROUND_UP         0 Away from zero.
    // ROUND_DOWN       1 Towards zero.
    // ROUND_CEIL       2 Towards +Infinity.
    // ROUND_FLOOR      3 Towards -Infinity.
    // ROUND_HALF_UP    4 Towards nearest neighbour. If equidistant, up.
    // ROUND_HALF_DOWN  5 Towards nearest neighbour. If equidistant, down.
    // ROUND_HALF_EVEN  6 Towards nearest neighbour. If equidistant, towards even neighbour.
    // ROUND_HALF_CEIL  7 Towards nearest neighbour. If equidistant, towards +Infinity.
    // ROUND_HALF_FLOOR 8 Towards nearest neighbour. If equidistant, towards -Infinity.
    //
    // E.g.
    // `Decimal.rounding = 4;`
    // `Decimal.rounding = Decimal.ROUND_HALF_UP;`
    rounding: 4,
    // 0 to 8
    // The modulo mode used when calculating the modulus: a mod n.
    // The quotient (q = a / n) is calculated according to the corresponding rounding mode.
    // The remainder (r) is calculated as: r = a - n * q.
    //
    // UP         0 The remainder is positive if the dividend is negative, else is negative.
    // DOWN       1 The remainder has the same sign as the dividend (JavaScript %).
    // FLOOR      3 The remainder has the same sign as the divisor (Python %).
    // HALF_EVEN  6 The IEEE 754 remainder function.
    // EUCLID     9 Euclidian division. q = sign(n) * floor(a / abs(n)). Always positive.
    //
    // Truncated division (1), floored division (3), the IEEE 754 remainder (6), and Euclidian
    // division (9) are commonly used for the modulus operation. The other rounding modes can also
    // be used, but they may not give useful results.
    modulo: 1,
    // 0 to 9
    // The exponent value at and beneath which `toString` returns exponential notation.
    // JavaScript numbers: -7
    toExpNeg: -7,
    // 0 to -EXP_LIMIT
    // The exponent value at and above which `toString` returns exponential notation.
    // JavaScript numbers: 21
    toExpPos: 21,
    // 0 to EXP_LIMIT
    // The minimum exponent value, beneath which underflow to zero occurs.
    // JavaScript numbers: -324  (5e-324)
    minE: -EXP_LIMIT,
    // -1 to -EXP_LIMIT
    // The maximum exponent value, above which overflow to Infinity occurs.
    // JavaScript numbers: 308  (1.7976931348623157e+308)
    maxE: EXP_LIMIT,
    // 1 to EXP_LIMIT
    // Whether to use cryptographically-secure random number generation, if available.
    crypto: false
    // true/false
  };
  var inexact;
  var quadrant;
  var external = true;
  var decimalError = "[DecimalError] ";
  var invalidArgument = decimalError + "Invalid argument: ";
  var precisionLimitExceeded = decimalError + "Precision limit exceeded";
  var cryptoUnavailable = decimalError + "crypto unavailable";
  var tag = "[object Decimal]";
  var mathfloor = Math.floor;
  var mathpow = Math.pow;
  var isBinary = /^0b([01]+(\.[01]*)?|\.[01]+)(p[+-]?\d+)?$/i;
  var isHex = /^0x([0-9a-f]+(\.[0-9a-f]*)?|\.[0-9a-f]+)(p[+-]?\d+)?$/i;
  var isOctal = /^0o([0-7]+(\.[0-7]*)?|\.[0-7]+)(p[+-]?\d+)?$/i;
  var isDecimal = /^(\d+(\.\d*)?|\.\d+)(e[+-]?\d+)?$/i;
  var BASE = 1e7;
  var LOG_BASE = 7;
  var MAX_SAFE_INTEGER = 9007199254740991;
  var LN10_PRECISION = LN10.length - 1;
  var PI_PRECISION = PI.length - 1;
  var P = { toStringTag: tag };
  P.absoluteValue = P.abs = function() {
    var x = new this.constructor(this);
    if (x.s < 0) x.s = 1;
    return finalise(x);
  };
  P.ceil = function() {
    return finalise(new this.constructor(this), this.e + 1, 2);
  };
  P.clampedTo = P.clamp = function(min2, max2) {
    var k, x = this, Ctor = x.constructor;
    min2 = new Ctor(min2);
    max2 = new Ctor(max2);
    if (!min2.s || !max2.s) return new Ctor(NaN);
    if (min2.gt(max2)) throw Error(invalidArgument + max2);
    k = x.cmp(min2);
    return k < 0 ? min2 : x.cmp(max2) > 0 ? max2 : new Ctor(x);
  };
  P.comparedTo = P.cmp = function(y) {
    var i, j, xdL, ydL, x = this, xd = x.d, yd = (y = new x.constructor(y)).d, xs = x.s, ys = y.s;
    if (!xd || !yd) {
      return !xs || !ys ? NaN : xs !== ys ? xs : xd === yd ? 0 : !xd ^ xs < 0 ? 1 : -1;
    }
    if (!xd[0] || !yd[0]) return xd[0] ? xs : yd[0] ? -ys : 0;
    if (xs !== ys) return xs;
    if (x.e !== y.e) return x.e > y.e ^ xs < 0 ? 1 : -1;
    xdL = xd.length;
    ydL = yd.length;
    for (i = 0, j = xdL < ydL ? xdL : ydL; i < j; ++i) {
      if (xd[i] !== yd[i]) return xd[i] > yd[i] ^ xs < 0 ? 1 : -1;
    }
    return xdL === ydL ? 0 : xdL > ydL ^ xs < 0 ? 1 : -1;
  };
  P.cosine = P.cos = function() {
    var pr, rm, x = this, Ctor = x.constructor;
    if (!x.d) return new Ctor(NaN);
    if (!x.d[0]) return new Ctor(1);
    pr = Ctor.precision;
    rm = Ctor.rounding;
    Ctor.precision = pr + Math.max(x.e, x.sd()) + LOG_BASE;
    Ctor.rounding = 1;
    x = cosine(Ctor, toLessThanHalfPi(Ctor, x));
    Ctor.precision = pr;
    Ctor.rounding = rm;
    return finalise(quadrant == 2 || quadrant == 3 ? x.neg() : x, pr, rm, true);
  };
  P.cubeRoot = P.cbrt = function() {
    var e, m, n, r, rep, s, sd, t, t3, t3plusx, x = this, Ctor = x.constructor;
    if (!x.isFinite() || x.isZero()) return new Ctor(x);
    external = false;
    s = x.s * mathpow(x.s * x, 1 / 3);
    if (!s || Math.abs(s) == 1 / 0) {
      n = digitsToString(x.d);
      e = x.e;
      if (s = (e - n.length + 1) % 3) n += s == 1 || s == -2 ? "0" : "00";
      s = mathpow(n, 1 / 3);
      e = mathfloor((e + 1) / 3) - (e % 3 == (e < 0 ? -1 : 2));
      if (s == 1 / 0) {
        n = "5e" + e;
      } else {
        n = s.toExponential();
        n = n.slice(0, n.indexOf("e") + 1) + e;
      }
      r = new Ctor(n);
      r.s = x.s;
    } else {
      r = new Ctor(s.toString());
    }
    sd = (e = Ctor.precision) + 3;
    for (; ; ) {
      t = r;
      t3 = t.times(t).times(t);
      t3plusx = t3.plus(x);
      r = divide(t3plusx.plus(x).times(t), t3plusx.plus(t3), sd + 2, 1);
      if (digitsToString(t.d).slice(0, sd) === (n = digitsToString(r.d)).slice(0, sd)) {
        n = n.slice(sd - 3, sd + 1);
        if (n == "9999" || !rep && n == "4999") {
          if (!rep) {
            finalise(t, e + 1, 0);
            if (t.times(t).times(t).eq(x)) {
              r = t;
              break;
            }
          }
          sd += 4;
          rep = 1;
        } else {
          if (!+n || !+n.slice(1) && n.charAt(0) == "5") {
            finalise(r, e + 1, 1);
            m = !r.times(r).times(r).eq(x);
          }
          break;
        }
      }
    }
    external = true;
    return finalise(r, e, Ctor.rounding, m);
  };
  P.decimalPlaces = P.dp = function() {
    var w, d = this.d, n = NaN;
    if (d) {
      w = d.length - 1;
      n = (w - mathfloor(this.e / LOG_BASE)) * LOG_BASE;
      w = d[w];
      if (w) for (; w % 10 == 0; w /= 10) n--;
      if (n < 0) n = 0;
    }
    return n;
  };
  P.dividedBy = P.div = function(y) {
    return divide(this, new this.constructor(y));
  };
  P.dividedToIntegerBy = P.divToInt = function(y) {
    var x = this, Ctor = x.constructor;
    return finalise(divide(x, new Ctor(y), 0, 1, 1), Ctor.precision, Ctor.rounding);
  };
  P.equals = P.eq = function(y) {
    return this.cmp(y) === 0;
  };
  P.floor = function() {
    return finalise(new this.constructor(this), this.e + 1, 3);
  };
  P.greaterThan = P.gt = function(y) {
    return this.cmp(y) > 0;
  };
  P.greaterThanOrEqualTo = P.gte = function(y) {
    var k = this.cmp(y);
    return k == 1 || k === 0;
  };
  P.hyperbolicCosine = P.cosh = function() {
    var k, n, pr, rm, len, x = this, Ctor = x.constructor, one = new Ctor(1);
    if (!x.isFinite()) return new Ctor(x.s ? 1 / 0 : NaN);
    if (x.isZero()) return one;
    pr = Ctor.precision;
    rm = Ctor.rounding;
    Ctor.precision = pr + Math.max(x.e, x.sd()) + 4;
    Ctor.rounding = 1;
    len = x.d.length;
    if (len < 32) {
      k = Math.ceil(len / 3);
      n = (1 / tinyPow(4, k)).toString();
    } else {
      k = 16;
      n = "2.3283064365386962890625e-10";
    }
    x = taylorSeries(Ctor, 1, x.times(n), new Ctor(1), true);
    var cosh2_x, i = k, d8 = new Ctor(8);
    for (; i--; ) {
      cosh2_x = x.times(x);
      x = one.minus(cosh2_x.times(d8.minus(cosh2_x.times(d8))));
    }
    return finalise(x, Ctor.precision = pr, Ctor.rounding = rm, true);
  };
  P.hyperbolicSine = P.sinh = function() {
    var k, pr, rm, len, x = this, Ctor = x.constructor;
    if (!x.isFinite() || x.isZero()) return new Ctor(x);
    pr = Ctor.precision;
    rm = Ctor.rounding;
    Ctor.precision = pr + Math.max(x.e, x.sd()) + 4;
    Ctor.rounding = 1;
    len = x.d.length;
    if (len < 3) {
      x = taylorSeries(Ctor, 2, x, x, true);
    } else {
      k = 1.4 * Math.sqrt(len);
      k = k > 16 ? 16 : k | 0;
      x = x.times(1 / tinyPow(5, k));
      x = taylorSeries(Ctor, 2, x, x, true);
      var sinh2_x, d5 = new Ctor(5), d16 = new Ctor(16), d20 = new Ctor(20);
      for (; k--; ) {
        sinh2_x = x.times(x);
        x = x.times(d5.plus(sinh2_x.times(d16.times(sinh2_x).plus(d20))));
      }
    }
    Ctor.precision = pr;
    Ctor.rounding = rm;
    return finalise(x, pr, rm, true);
  };
  P.hyperbolicTangent = P.tanh = function() {
    var pr, rm, x = this, Ctor = x.constructor;
    if (!x.isFinite()) return new Ctor(x.s);
    if (x.isZero()) return new Ctor(x);
    pr = Ctor.precision;
    rm = Ctor.rounding;
    Ctor.precision = pr + 7;
    Ctor.rounding = 1;
    return divide(x.sinh(), x.cosh(), Ctor.precision = pr, Ctor.rounding = rm);
  };
  P.inverseCosine = P.acos = function() {
    var x = this, Ctor = x.constructor, k = x.abs().cmp(1), pr = Ctor.precision, rm = Ctor.rounding;
    if (k !== -1) {
      return k === 0 ? x.isNeg() ? getPi(Ctor, pr, rm) : new Ctor(0) : new Ctor(NaN);
    }
    if (x.isZero()) return getPi(Ctor, pr + 4, rm).times(0.5);
    Ctor.precision = pr + 6;
    Ctor.rounding = 1;
    x = new Ctor(1).minus(x).div(x.plus(1)).sqrt().atan();
    Ctor.precision = pr;
    Ctor.rounding = rm;
    return x.times(2);
  };
  P.inverseHyperbolicCosine = P.acosh = function() {
    var pr, rm, x = this, Ctor = x.constructor;
    if (x.lte(1)) return new Ctor(x.eq(1) ? 0 : NaN);
    if (!x.isFinite()) return new Ctor(x);
    pr = Ctor.precision;
    rm = Ctor.rounding;
    Ctor.precision = pr + Math.max(Math.abs(x.e), x.sd()) + 4;
    Ctor.rounding = 1;
    external = false;
    x = x.times(x).minus(1).sqrt().plus(x);
    external = true;
    Ctor.precision = pr;
    Ctor.rounding = rm;
    return x.ln();
  };
  P.inverseHyperbolicSine = P.asinh = function() {
    var pr, rm, x = this, Ctor = x.constructor;
    if (!x.isFinite() || x.isZero()) return new Ctor(x);
    pr = Ctor.precision;
    rm = Ctor.rounding;
    Ctor.precision = pr + 2 * Math.max(Math.abs(x.e), x.sd()) + 6;
    Ctor.rounding = 1;
    external = false;
    x = x.times(x).plus(1).sqrt().plus(x);
    external = true;
    Ctor.precision = pr;
    Ctor.rounding = rm;
    return x.ln();
  };
  P.inverseHyperbolicTangent = P.atanh = function() {
    var pr, rm, wpr, xsd, x = this, Ctor = x.constructor;
    if (!x.isFinite()) return new Ctor(NaN);
    if (x.e >= 0) return new Ctor(x.abs().eq(1) ? x.s / 0 : x.isZero() ? x : NaN);
    pr = Ctor.precision;
    rm = Ctor.rounding;
    xsd = x.sd();
    if (Math.max(xsd, pr) < 2 * -x.e - 1) return finalise(new Ctor(x), pr, rm, true);
    Ctor.precision = wpr = xsd - x.e;
    x = divide(x.plus(1), new Ctor(1).minus(x), wpr + pr, 1);
    Ctor.precision = pr + 4;
    Ctor.rounding = 1;
    x = x.ln();
    Ctor.precision = pr;
    Ctor.rounding = rm;
    return x.times(0.5);
  };
  P.inverseSine = P.asin = function() {
    var halfPi, k, pr, rm, x = this, Ctor = x.constructor;
    if (x.isZero()) return new Ctor(x);
    k = x.abs().cmp(1);
    pr = Ctor.precision;
    rm = Ctor.rounding;
    if (k !== -1) {
      if (k === 0) {
        halfPi = getPi(Ctor, pr + 4, rm).times(0.5);
        halfPi.s = x.s;
        return halfPi;
      }
      return new Ctor(NaN);
    }
    Ctor.precision = pr + 6;
    Ctor.rounding = 1;
    x = x.div(new Ctor(1).minus(x.times(x)).sqrt().plus(1)).atan();
    Ctor.precision = pr;
    Ctor.rounding = rm;
    return x.times(2);
  };
  P.inverseTangent = P.atan = function() {
    var i, j, k, n, px, t, r, wpr, x2, x = this, Ctor = x.constructor, pr = Ctor.precision, rm = Ctor.rounding;
    if (!x.isFinite()) {
      if (!x.s) return new Ctor(NaN);
      if (pr + 4 <= PI_PRECISION) {
        r = getPi(Ctor, pr + 4, rm).times(0.5);
        r.s = x.s;
        return r;
      }
    } else if (x.isZero()) {
      return new Ctor(x);
    } else if (x.abs().eq(1) && pr + 4 <= PI_PRECISION) {
      r = getPi(Ctor, pr + 4, rm).times(0.25);
      r.s = x.s;
      return r;
    }
    Ctor.precision = wpr = pr + 10;
    Ctor.rounding = 1;
    k = Math.min(28, wpr / LOG_BASE + 2 | 0);
    for (i = k; i; --i) x = x.div(x.times(x).plus(1).sqrt().plus(1));
    external = false;
    j = Math.ceil(wpr / LOG_BASE);
    n = 1;
    x2 = x.times(x);
    r = new Ctor(x);
    px = x;
    for (; i !== -1; ) {
      px = px.times(x2);
      t = r.minus(px.div(n += 2));
      px = px.times(x2);
      r = t.plus(px.div(n += 2));
      if (r.d[j] !== void 0) for (i = j; r.d[i] === t.d[i] && i--; ) ;
    }
    if (k) r = r.times(2 << k - 1);
    external = true;
    return finalise(r, Ctor.precision = pr, Ctor.rounding = rm, true);
  };
  P.isFinite = function() {
    return !!this.d;
  };
  P.isInteger = P.isInt = function() {
    return !!this.d && mathfloor(this.e / LOG_BASE) > this.d.length - 2;
  };
  P.isNaN = function() {
    return !this.s;
  };
  P.isNegative = P.isNeg = function() {
    return this.s < 0;
  };
  P.isPositive = P.isPos = function() {
    return this.s > 0;
  };
  P.isZero = function() {
    return !!this.d && this.d[0] === 0;
  };
  P.lessThan = P.lt = function(y) {
    return this.cmp(y) < 0;
  };
  P.lessThanOrEqualTo = P.lte = function(y) {
    return this.cmp(y) < 1;
  };
  P.logarithm = P.log = function(base) {
    var isBase10, d, denominator, k, inf, num, sd, r, arg = this, Ctor = arg.constructor, pr = Ctor.precision, rm = Ctor.rounding, guard = 5;
    if (base == null) {
      base = new Ctor(10);
      isBase10 = true;
    } else {
      base = new Ctor(base);
      d = base.d;
      if (base.s < 0 || !d || !d[0] || base.eq(1)) return new Ctor(NaN);
      isBase10 = base.eq(10);
    }
    d = arg.d;
    if (arg.s < 0 || !d || !d[0] || arg.eq(1)) {
      return new Ctor(d && !d[0] ? -1 / 0 : arg.s != 1 ? NaN : d ? 0 : 1 / 0);
    }
    if (isBase10) {
      if (d.length > 1) {
        inf = true;
      } else {
        for (k = d[0]; k % 10 === 0; ) k /= 10;
        inf = k !== 1;
      }
    }
    external = false;
    sd = pr + guard;
    num = naturalLogarithm(arg, sd);
    denominator = isBase10 ? getLn10(Ctor, sd + 10) : naturalLogarithm(base, sd);
    r = divide(num, denominator, sd, 1);
    if (checkRoundingDigits(r.d, k = pr, rm)) {
      do {
        sd += 10;
        num = naturalLogarithm(arg, sd);
        denominator = isBase10 ? getLn10(Ctor, sd + 10) : naturalLogarithm(base, sd);
        r = divide(num, denominator, sd, 1);
        if (!inf) {
          if (+digitsToString(r.d).slice(k + 1, k + 15) + 1 == 1e14) {
            r = finalise(r, pr + 1, 0);
          }
          break;
        }
      } while (checkRoundingDigits(r.d, k += 10, rm));
    }
    external = true;
    return finalise(r, pr, rm);
  };
  P.minus = P.sub = function(y) {
    var d, e, i, j, k, len, pr, rm, xd, xe, xLTy, yd, x = this, Ctor = x.constructor;
    y = new Ctor(y);
    if (!x.d || !y.d) {
      if (!x.s || !y.s) y = new Ctor(NaN);
      else if (x.d) y.s = -y.s;
      else y = new Ctor(y.d || x.s !== y.s ? x : NaN);
      return y;
    }
    if (x.s != y.s) {
      y.s = -y.s;
      return x.plus(y);
    }
    xd = x.d;
    yd = y.d;
    pr = Ctor.precision;
    rm = Ctor.rounding;
    if (!xd[0] || !yd[0]) {
      if (yd[0]) y.s = -y.s;
      else if (xd[0]) y = new Ctor(x);
      else return new Ctor(rm === 3 ? -0 : 0);
      return external ? finalise(y, pr, rm) : y;
    }
    e = mathfloor(y.e / LOG_BASE);
    xe = mathfloor(x.e / LOG_BASE);
    xd = xd.slice();
    k = xe - e;
    if (k) {
      xLTy = k < 0;
      if (xLTy) {
        d = xd;
        k = -k;
        len = yd.length;
      } else {
        d = yd;
        e = xe;
        len = xd.length;
      }
      i = Math.max(Math.ceil(pr / LOG_BASE), len) + 2;
      if (k > i) {
        k = i;
        d.length = 1;
      }
      d.reverse();
      for (i = k; i--; ) d.push(0);
      d.reverse();
    } else {
      i = xd.length;
      len = yd.length;
      xLTy = i < len;
      if (xLTy) len = i;
      for (i = 0; i < len; i++) {
        if (xd[i] != yd[i]) {
          xLTy = xd[i] < yd[i];
          break;
        }
      }
      k = 0;
    }
    if (xLTy) {
      d = xd;
      xd = yd;
      yd = d;
      y.s = -y.s;
    }
    len = xd.length;
    for (i = yd.length - len; i > 0; --i) xd[len++] = 0;
    for (i = yd.length; i > k; ) {
      if (xd[--i] < yd[i]) {
        for (j = i; j && xd[--j] === 0; ) xd[j] = BASE - 1;
        --xd[j];
        xd[i] += BASE;
      }
      xd[i] -= yd[i];
    }
    for (; xd[--len] === 0; ) xd.pop();
    for (; xd[0] === 0; xd.shift()) --e;
    if (!xd[0]) return new Ctor(rm === 3 ? -0 : 0);
    y.d = xd;
    y.e = getBase10Exponent(xd, e);
    return external ? finalise(y, pr, rm) : y;
  };
  P.modulo = P.mod = function(y) {
    var q, x = this, Ctor = x.constructor;
    y = new Ctor(y);
    if (!x.d || !y.s || y.d && !y.d[0]) return new Ctor(NaN);
    if (!y.d || x.d && !x.d[0]) {
      return finalise(new Ctor(x), Ctor.precision, Ctor.rounding);
    }
    external = false;
    if (Ctor.modulo == 9) {
      q = divide(x, y.abs(), 0, 3, 1);
      q.s *= y.s;
    } else {
      q = divide(x, y, 0, Ctor.modulo, 1);
    }
    q = q.times(y);
    external = true;
    return x.minus(q);
  };
  P.naturalExponential = P.exp = function() {
    return naturalExponential(this);
  };
  P.naturalLogarithm = P.ln = function() {
    return naturalLogarithm(this);
  };
  P.negated = P.neg = function() {
    var x = new this.constructor(this);
    x.s = -x.s;
    return finalise(x);
  };
  P.plus = P.add = function(y) {
    var carry, d, e, i, k, len, pr, rm, xd, yd, x = this, Ctor = x.constructor;
    y = new Ctor(y);
    if (!x.d || !y.d) {
      if (!x.s || !y.s) y = new Ctor(NaN);
      else if (!x.d) y = new Ctor(y.d || x.s === y.s ? x : NaN);
      return y;
    }
    if (x.s != y.s) {
      y.s = -y.s;
      return x.minus(y);
    }
    xd = x.d;
    yd = y.d;
    pr = Ctor.precision;
    rm = Ctor.rounding;
    if (!xd[0] || !yd[0]) {
      if (!yd[0]) y = new Ctor(x);
      return external ? finalise(y, pr, rm) : y;
    }
    k = mathfloor(x.e / LOG_BASE);
    e = mathfloor(y.e / LOG_BASE);
    xd = xd.slice();
    i = k - e;
    if (i) {
      if (i < 0) {
        d = xd;
        i = -i;
        len = yd.length;
      } else {
        d = yd;
        e = k;
        len = xd.length;
      }
      k = Math.ceil(pr / LOG_BASE);
      len = k > len ? k + 1 : len + 1;
      if (i > len) {
        i = len;
        d.length = 1;
      }
      d.reverse();
      for (; i--; ) d.push(0);
      d.reverse();
    }
    len = xd.length;
    i = yd.length;
    if (len - i < 0) {
      i = len;
      d = yd;
      yd = xd;
      xd = d;
    }
    for (carry = 0; i; ) {
      carry = (xd[--i] = xd[i] + yd[i] + carry) / BASE | 0;
      xd[i] %= BASE;
    }
    if (carry) {
      xd.unshift(carry);
      ++e;
    }
    for (len = xd.length; xd[--len] == 0; ) xd.pop();
    y.d = xd;
    y.e = getBase10Exponent(xd, e);
    return external ? finalise(y, pr, rm) : y;
  };
  P.precision = P.sd = function(z) {
    var k, x = this;
    if (z !== void 0 && z !== !!z && z !== 1 && z !== 0) throw Error(invalidArgument + z);
    if (x.d) {
      k = getPrecision(x.d);
      if (z && x.e + 1 > k) k = x.e + 1;
    } else {
      k = NaN;
    }
    return k;
  };
  P.round = function() {
    var x = this, Ctor = x.constructor;
    return finalise(new Ctor(x), x.e + 1, Ctor.rounding);
  };
  P.sine = P.sin = function() {
    var pr, rm, x = this, Ctor = x.constructor;
    if (!x.isFinite()) return new Ctor(NaN);
    if (x.isZero()) return new Ctor(x);
    pr = Ctor.precision;
    rm = Ctor.rounding;
    Ctor.precision = pr + Math.max(x.e, x.sd()) + LOG_BASE;
    Ctor.rounding = 1;
    x = sine(Ctor, toLessThanHalfPi(Ctor, x));
    Ctor.precision = pr;
    Ctor.rounding = rm;
    return finalise(quadrant > 2 ? x.neg() : x, pr, rm, true);
  };
  P.squareRoot = P.sqrt = function() {
    var m, n, sd, r, rep, t, x = this, d = x.d, e = x.e, s = x.s, Ctor = x.constructor;
    if (s !== 1 || !d || !d[0]) {
      return new Ctor(!s || s < 0 && (!d || d[0]) ? NaN : d ? x : 1 / 0);
    }
    external = false;
    s = Math.sqrt(+x);
    if (s == 0 || s == 1 / 0) {
      n = digitsToString(d);
      if ((n.length + e) % 2 == 0) n += "0";
      s = Math.sqrt(n);
      e = mathfloor((e + 1) / 2) - (e < 0 || e % 2);
      if (s == 1 / 0) {
        n = "5e" + e;
      } else {
        n = s.toExponential();
        n = n.slice(0, n.indexOf("e") + 1) + e;
      }
      r = new Ctor(n);
    } else {
      r = new Ctor(s.toString());
    }
    sd = (e = Ctor.precision) + 3;
    for (; ; ) {
      t = r;
      r = t.plus(divide(x, t, sd + 2, 1)).times(0.5);
      if (digitsToString(t.d).slice(0, sd) === (n = digitsToString(r.d)).slice(0, sd)) {
        n = n.slice(sd - 3, sd + 1);
        if (n == "9999" || !rep && n == "4999") {
          if (!rep) {
            finalise(t, e + 1, 0);
            if (t.times(t).eq(x)) {
              r = t;
              break;
            }
          }
          sd += 4;
          rep = 1;
        } else {
          if (!+n || !+n.slice(1) && n.charAt(0) == "5") {
            finalise(r, e + 1, 1);
            m = !r.times(r).eq(x);
          }
          break;
        }
      }
    }
    external = true;
    return finalise(r, e, Ctor.rounding, m);
  };
  P.tangent = P.tan = function() {
    var pr, rm, x = this, Ctor = x.constructor;
    if (!x.isFinite()) return new Ctor(NaN);
    if (x.isZero()) return new Ctor(x);
    pr = Ctor.precision;
    rm = Ctor.rounding;
    Ctor.precision = pr + 10;
    Ctor.rounding = 1;
    x = x.sin();
    x.s = 1;
    x = divide(x, new Ctor(1).minus(x.times(x)).sqrt(), pr + 10, 0);
    Ctor.precision = pr;
    Ctor.rounding = rm;
    return finalise(quadrant == 2 || quadrant == 4 ? x.neg() : x, pr, rm, true);
  };
  P.times = P.mul = function(y) {
    var carry, e, i, k, r, rL, t, xdL, ydL, x = this, Ctor = x.constructor, xd = x.d, yd = (y = new Ctor(y)).d;
    y.s *= x.s;
    if (!xd || !xd[0] || !yd || !yd[0]) {
      return new Ctor(!y.s || xd && !xd[0] && !yd || yd && !yd[0] && !xd ? NaN : !xd || !yd ? y.s / 0 : y.s * 0);
    }
    e = mathfloor(x.e / LOG_BASE) + mathfloor(y.e / LOG_BASE);
    xdL = xd.length;
    ydL = yd.length;
    if (xdL < ydL) {
      r = xd;
      xd = yd;
      yd = r;
      rL = xdL;
      xdL = ydL;
      ydL = rL;
    }
    r = [];
    rL = xdL + ydL;
    for (i = rL; i--; ) r.push(0);
    for (i = ydL; --i >= 0; ) {
      carry = 0;
      for (k = xdL + i; k > i; ) {
        t = r[k] + yd[i] * xd[k - i - 1] + carry;
        r[k--] = t % BASE | 0;
        carry = t / BASE | 0;
      }
      r[k] = (r[k] + carry) % BASE | 0;
    }
    for (; !r[--rL]; ) r.pop();
    if (carry) ++e;
    else r.shift();
    y.d = r;
    y.e = getBase10Exponent(r, e);
    return external ? finalise(y, Ctor.precision, Ctor.rounding) : y;
  };
  P.toBinary = function(sd, rm) {
    return toStringBinary(this, 2, sd, rm);
  };
  P.toDecimalPlaces = P.toDP = function(dp, rm) {
    var x = this, Ctor = x.constructor;
    x = new Ctor(x);
    if (dp === void 0) return x;
    checkInt32(dp, 0, MAX_DIGITS);
    if (rm === void 0) rm = Ctor.rounding;
    else checkInt32(rm, 0, 8);
    return finalise(x, dp + x.e + 1, rm);
  };
  P.toExponential = function(dp, rm) {
    var str, x = this, Ctor = x.constructor;
    if (dp === void 0) {
      str = finiteToString(x, true);
    } else {
      checkInt32(dp, 0, MAX_DIGITS);
      if (rm === void 0) rm = Ctor.rounding;
      else checkInt32(rm, 0, 8);
      x = finalise(new Ctor(x), dp + 1, rm);
      str = finiteToString(x, true, dp + 1);
    }
    return x.isNeg() && !x.isZero() ? "-" + str : str;
  };
  P.toFixed = function(dp, rm) {
    var str, y, x = this, Ctor = x.constructor;
    if (dp === void 0) {
      str = finiteToString(x);
    } else {
      checkInt32(dp, 0, MAX_DIGITS);
      if (rm === void 0) rm = Ctor.rounding;
      else checkInt32(rm, 0, 8);
      y = finalise(new Ctor(x), dp + x.e + 1, rm);
      str = finiteToString(y, false, dp + y.e + 1);
    }
    return x.isNeg() && !x.isZero() ? "-" + str : str;
  };
  P.toFraction = function(maxD) {
    var d, d0, d1, d2, e, k, n, n0, n12, pr, q, r, x = this, xd = x.d, Ctor = x.constructor;
    if (!xd) return new Ctor(x);
    n12 = d0 = new Ctor(1);
    d1 = n0 = new Ctor(0);
    d = new Ctor(d1);
    e = d.e = getPrecision(xd) - x.e - 1;
    k = e % LOG_BASE;
    d.d[0] = mathpow(10, k < 0 ? LOG_BASE + k : k);
    if (maxD == null) {
      maxD = e > 0 ? d : n12;
    } else {
      n = new Ctor(maxD);
      if (!n.isInt() || n.lt(n12)) throw Error(invalidArgument + n);
      maxD = n.gt(d) ? e > 0 ? d : n12 : n;
    }
    external = false;
    n = new Ctor(digitsToString(xd));
    pr = Ctor.precision;
    Ctor.precision = e = xd.length * LOG_BASE * 2;
    for (; ; ) {
      q = divide(n, d, 0, 1, 1);
      d2 = d0.plus(q.times(d1));
      if (d2.cmp(maxD) == 1) break;
      d0 = d1;
      d1 = d2;
      d2 = n12;
      n12 = n0.plus(q.times(d2));
      n0 = d2;
      d2 = d;
      d = n.minus(q.times(d2));
      n = d2;
    }
    d2 = divide(maxD.minus(d0), d1, 0, 1, 1);
    n0 = n0.plus(d2.times(n12));
    d0 = d0.plus(d2.times(d1));
    n0.s = n12.s = x.s;
    r = divide(n12, d1, e, 1).minus(x).abs().cmp(divide(n0, d0, e, 1).minus(x).abs()) < 1 ? [n12, d1] : [n0, d0];
    Ctor.precision = pr;
    external = true;
    return r;
  };
  P.toHexadecimal = P.toHex = function(sd, rm) {
    return toStringBinary(this, 16, sd, rm);
  };
  P.toNearest = function(y, rm) {
    var x = this, Ctor = x.constructor;
    x = new Ctor(x);
    if (y == null) {
      if (!x.d) return x;
      y = new Ctor(1);
      rm = Ctor.rounding;
    } else {
      y = new Ctor(y);
      if (rm === void 0) {
        rm = Ctor.rounding;
      } else {
        checkInt32(rm, 0, 8);
      }
      if (!x.d) return y.s ? x : y;
      if (!y.d) {
        if (y.s) y.s = x.s;
        return y;
      }
    }
    if (y.d[0]) {
      external = false;
      x = divide(x, y, 0, rm, 1).times(y);
      external = true;
      finalise(x);
    } else {
      y.s = x.s;
      x = y;
    }
    return x;
  };
  P.toNumber = function() {
    return +this;
  };
  P.toOctal = function(sd, rm) {
    return toStringBinary(this, 8, sd, rm);
  };
  P.toPower = P.pow = function(y) {
    var e, k, pr, r, rm, s, x = this, Ctor = x.constructor, yn = +(y = new Ctor(y));
    if (!x.d || !y.d || !x.d[0] || !y.d[0]) return new Ctor(mathpow(+x, yn));
    x = new Ctor(x);
    if (x.eq(1)) return x;
    pr = Ctor.precision;
    rm = Ctor.rounding;
    if (y.eq(1)) return finalise(x, pr, rm);
    e = mathfloor(y.e / LOG_BASE);
    if (e >= y.d.length - 1 && (k = yn < 0 ? -yn : yn) <= MAX_SAFE_INTEGER) {
      r = intPow(Ctor, x, k, pr);
      return y.s < 0 ? new Ctor(1).div(r) : finalise(r, pr, rm);
    }
    s = x.s;
    if (s < 0) {
      if (e < y.d.length - 1) return new Ctor(NaN);
      if ((y.d[e] & 1) == 0) s = 1;
      if (x.e == 0 && x.d[0] == 1 && x.d.length == 1) {
        x.s = s;
        return x;
      }
    }
    k = mathpow(+x, yn);
    e = k == 0 || !isFinite(k) ? mathfloor(yn * (Math.log("0." + digitsToString(x.d)) / Math.LN10 + x.e + 1)) : new Ctor(k + "").e;
    if (e > Ctor.maxE + 1 || e < Ctor.minE - 1) return new Ctor(e > 0 ? s / 0 : 0);
    external = false;
    Ctor.rounding = x.s = 1;
    k = Math.min(12, (e + "").length);
    r = naturalExponential(y.times(naturalLogarithm(x, pr + k)), pr);
    if (r.d) {
      r = finalise(r, pr + 5, 1);
      if (checkRoundingDigits(r.d, pr, rm)) {
        e = pr + 10;
        r = finalise(naturalExponential(y.times(naturalLogarithm(x, e + k)), e), e + 5, 1);
        if (+digitsToString(r.d).slice(pr + 1, pr + 15) + 1 == 1e14) {
          r = finalise(r, pr + 1, 0);
        }
      }
    }
    r.s = s;
    external = true;
    Ctor.rounding = rm;
    return finalise(r, pr, rm);
  };
  P.toPrecision = function(sd, rm) {
    var str, x = this, Ctor = x.constructor;
    if (sd === void 0) {
      str = finiteToString(x, x.e <= Ctor.toExpNeg || x.e >= Ctor.toExpPos);
    } else {
      checkInt32(sd, 1, MAX_DIGITS);
      if (rm === void 0) rm = Ctor.rounding;
      else checkInt32(rm, 0, 8);
      x = finalise(new Ctor(x), sd, rm);
      str = finiteToString(x, sd <= x.e || x.e <= Ctor.toExpNeg, sd);
    }
    return x.isNeg() && !x.isZero() ? "-" + str : str;
  };
  P.toSignificantDigits = P.toSD = function(sd, rm) {
    var x = this, Ctor = x.constructor;
    if (sd === void 0) {
      sd = Ctor.precision;
      rm = Ctor.rounding;
    } else {
      checkInt32(sd, 1, MAX_DIGITS);
      if (rm === void 0) rm = Ctor.rounding;
      else checkInt32(rm, 0, 8);
    }
    return finalise(new Ctor(x), sd, rm);
  };
  P.toString = function() {
    var x = this, Ctor = x.constructor, str = finiteToString(x, x.e <= Ctor.toExpNeg || x.e >= Ctor.toExpPos);
    return x.isNeg() && !x.isZero() ? "-" + str : str;
  };
  P.truncated = P.trunc = function() {
    return finalise(new this.constructor(this), this.e + 1, 1);
  };
  P.valueOf = P.toJSON = function() {
    var x = this, Ctor = x.constructor, str = finiteToString(x, x.e <= Ctor.toExpNeg || x.e >= Ctor.toExpPos);
    return x.isNeg() ? "-" + str : str;
  };
  function digitsToString(d) {
    var i, k, ws, indexOfLastWord = d.length - 1, str = "", w = d[0];
    if (indexOfLastWord > 0) {
      str += w;
      for (i = 1; i < indexOfLastWord; i++) {
        ws = d[i] + "";
        k = LOG_BASE - ws.length;
        if (k) str += getZeroString(k);
        str += ws;
      }
      w = d[i];
      ws = w + "";
      k = LOG_BASE - ws.length;
      if (k) str += getZeroString(k);
    } else if (w === 0) {
      return "0";
    }
    for (; w % 10 === 0; ) w /= 10;
    return str + w;
  }
  function checkInt32(i, min2, max2) {
    if (i !== ~~i || i < min2 || i > max2) {
      throw Error(invalidArgument + i);
    }
  }
  function checkRoundingDigits(d, i, rm, repeating) {
    var di, k, r, rd;
    for (k = d[0]; k >= 10; k /= 10) --i;
    if (--i < 0) {
      i += LOG_BASE;
      di = 0;
    } else {
      di = Math.ceil((i + 1) / LOG_BASE);
      i %= LOG_BASE;
    }
    k = mathpow(10, LOG_BASE - i);
    rd = d[di] % k | 0;
    if (repeating == null) {
      if (i < 3) {
        if (i == 0) rd = rd / 100 | 0;
        else if (i == 1) rd = rd / 10 | 0;
        r = rm < 4 && rd == 99999 || rm > 3 && rd == 49999 || rd == 5e4 || rd == 0;
      } else {
        r = (rm < 4 && rd + 1 == k || rm > 3 && rd + 1 == k / 2) && (d[di + 1] / k / 100 | 0) == mathpow(10, i - 2) - 1 || (rd == k / 2 || rd == 0) && (d[di + 1] / k / 100 | 0) == 0;
      }
    } else {
      if (i < 4) {
        if (i == 0) rd = rd / 1e3 | 0;
        else if (i == 1) rd = rd / 100 | 0;
        else if (i == 2) rd = rd / 10 | 0;
        r = (repeating || rm < 4) && rd == 9999 || !repeating && rm > 3 && rd == 4999;
      } else {
        r = ((repeating || rm < 4) && rd + 1 == k || !repeating && rm > 3 && rd + 1 == k / 2) && (d[di + 1] / k / 1e3 | 0) == mathpow(10, i - 3) - 1;
      }
    }
    return r;
  }
  function convertBase(str, baseIn, baseOut) {
    var j, arr = [0], arrL, i = 0, strL = str.length;
    for (; i < strL; ) {
      for (arrL = arr.length; arrL--; ) arr[arrL] *= baseIn;
      arr[0] += NUMERALS.indexOf(str.charAt(i++));
      for (j = 0; j < arr.length; j++) {
        if (arr[j] > baseOut - 1) {
          if (arr[j + 1] === void 0) arr[j + 1] = 0;
          arr[j + 1] += arr[j] / baseOut | 0;
          arr[j] %= baseOut;
        }
      }
    }
    return arr.reverse();
  }
  function cosine(Ctor, x) {
    var k, len, y;
    if (x.isZero()) return x;
    len = x.d.length;
    if (len < 32) {
      k = Math.ceil(len / 3);
      y = (1 / tinyPow(4, k)).toString();
    } else {
      k = 16;
      y = "2.3283064365386962890625e-10";
    }
    Ctor.precision += k;
    x = taylorSeries(Ctor, 1, x.times(y), new Ctor(1));
    for (var i = k; i--; ) {
      var cos2x = x.times(x);
      x = cos2x.times(cos2x).minus(cos2x).times(8).plus(1);
    }
    Ctor.precision -= k;
    return x;
  }
  var divide = /* @__PURE__ */ (function() {
    function multiplyInteger(x, k, base) {
      var temp, carry = 0, i = x.length;
      for (x = x.slice(); i--; ) {
        temp = x[i] * k + carry;
        x[i] = temp % base | 0;
        carry = temp / base | 0;
      }
      if (carry) x.unshift(carry);
      return x;
    }
    function compare(a, b, aL, bL) {
      var i, r;
      if (aL != bL) {
        r = aL > bL ? 1 : -1;
      } else {
        for (i = r = 0; i < aL; i++) {
          if (a[i] != b[i]) {
            r = a[i] > b[i] ? 1 : -1;
            break;
          }
        }
      }
      return r;
    }
    function subtract(a, b, aL, base) {
      var i = 0;
      for (; aL--; ) {
        a[aL] -= i;
        i = a[aL] < b[aL] ? 1 : 0;
        a[aL] = i * base + a[aL] - b[aL];
      }
      for (; !a[0] && a.length > 1; ) a.shift();
    }
    return function(x, y, pr, rm, dp, base) {
      var cmp, e, i, k, logBase, more, prod, prodL, q, qd, rem, remL, rem0, sd, t, xi, xL, yd0, yL, yz, Ctor = x.constructor, sign3 = x.s == y.s ? 1 : -1, xd = x.d, yd = y.d;
      if (!xd || !xd[0] || !yd || !yd[0]) {
        return new Ctor(
          // Return NaN if either NaN, or both Infinity or 0.
          !x.s || !y.s || (xd ? yd && xd[0] == yd[0] : !yd) ? NaN : (
            // Return 0 if x is 0 or y is Infinity, or return Infinity as y is 0.
            xd && xd[0] == 0 || !yd ? sign3 * 0 : sign3 / 0
          )
        );
      }
      if (base) {
        logBase = 1;
        e = x.e - y.e;
      } else {
        base = BASE;
        logBase = LOG_BASE;
        e = mathfloor(x.e / logBase) - mathfloor(y.e / logBase);
      }
      yL = yd.length;
      xL = xd.length;
      q = new Ctor(sign3);
      qd = q.d = [];
      for (i = 0; yd[i] == (xd[i] || 0); i++) ;
      if (yd[i] > (xd[i] || 0)) e--;
      if (pr == null) {
        sd = pr = Ctor.precision;
        rm = Ctor.rounding;
      } else if (dp) {
        sd = pr + (x.e - y.e) + 1;
      } else {
        sd = pr;
      }
      if (sd < 0) {
        qd.push(1);
        more = true;
      } else {
        sd = sd / logBase + 2 | 0;
        i = 0;
        if (yL == 1) {
          k = 0;
          yd = yd[0];
          sd++;
          for (; (i < xL || k) && sd--; i++) {
            t = k * base + (xd[i] || 0);
            qd[i] = t / yd | 0;
            k = t % yd | 0;
          }
          more = k || i < xL;
        } else {
          k = base / (yd[0] + 1) | 0;
          if (k > 1) {
            yd = multiplyInteger(yd, k, base);
            xd = multiplyInteger(xd, k, base);
            yL = yd.length;
            xL = xd.length;
          }
          xi = yL;
          rem = xd.slice(0, yL);
          remL = rem.length;
          for (; remL < yL; ) rem[remL++] = 0;
          yz = yd.slice();
          yz.unshift(0);
          yd0 = yd[0];
          if (yd[1] >= base / 2) ++yd0;
          do {
            k = 0;
            cmp = compare(yd, rem, yL, remL);
            if (cmp < 0) {
              rem0 = rem[0];
              if (yL != remL) rem0 = rem0 * base + (rem[1] || 0);
              k = rem0 / yd0 | 0;
              if (k > 1) {
                if (k >= base) k = base - 1;
                prod = multiplyInteger(yd, k, base);
                prodL = prod.length;
                remL = rem.length;
                cmp = compare(prod, rem, prodL, remL);
                if (cmp == 1) {
                  k--;
                  subtract(prod, yL < prodL ? yz : yd, prodL, base);
                }
              } else {
                if (k == 0) cmp = k = 1;
                prod = yd.slice();
              }
              prodL = prod.length;
              if (prodL < remL) prod.unshift(0);
              subtract(rem, prod, remL, base);
              if (cmp == -1) {
                remL = rem.length;
                cmp = compare(yd, rem, yL, remL);
                if (cmp < 1) {
                  k++;
                  subtract(rem, yL < remL ? yz : yd, remL, base);
                }
              }
              remL = rem.length;
            } else if (cmp === 0) {
              k++;
              rem = [0];
            }
            qd[i++] = k;
            if (cmp && rem[0]) {
              rem[remL++] = xd[xi] || 0;
            } else {
              rem = [xd[xi]];
              remL = 1;
            }
          } while ((xi++ < xL || rem[0] !== void 0) && sd--);
          more = rem[0] !== void 0;
        }
        if (!qd[0]) qd.shift();
      }
      if (logBase == 1) {
        q.e = e;
        inexact = more;
      } else {
        for (i = 1, k = qd[0]; k >= 10; k /= 10) i++;
        q.e = i + e * logBase - 1;
        finalise(q, dp ? pr + q.e + 1 : pr, rm, more);
      }
      return q;
    };
  })();
  function finalise(x, sd, rm, isTruncated) {
    var digits2, i, j, k, rd, roundUp, w, xd, xdi, Ctor = x.constructor;
    out: if (sd != null) {
      xd = x.d;
      if (!xd) return x;
      for (digits2 = 1, k = xd[0]; k >= 10; k /= 10) digits2++;
      i = sd - digits2;
      if (i < 0) {
        i += LOG_BASE;
        j = sd;
        w = xd[xdi = 0];
        rd = w / mathpow(10, digits2 - j - 1) % 10 | 0;
      } else {
        xdi = Math.ceil((i + 1) / LOG_BASE);
        k = xd.length;
        if (xdi >= k) {
          if (isTruncated) {
            for (; k++ <= xdi; ) xd.push(0);
            w = rd = 0;
            digits2 = 1;
            i %= LOG_BASE;
            j = i - LOG_BASE + 1;
          } else {
            break out;
          }
        } else {
          w = k = xd[xdi];
          for (digits2 = 1; k >= 10; k /= 10) digits2++;
          i %= LOG_BASE;
          j = i - LOG_BASE + digits2;
          rd = j < 0 ? 0 : w / mathpow(10, digits2 - j - 1) % 10 | 0;
        }
      }
      isTruncated = isTruncated || sd < 0 || xd[xdi + 1] !== void 0 || (j < 0 ? w : w % mathpow(10, digits2 - j - 1));
      roundUp = rm < 4 ? (rd || isTruncated) && (rm == 0 || rm == (x.s < 0 ? 3 : 2)) : rd > 5 || rd == 5 && (rm == 4 || isTruncated || rm == 6 && // Check whether the digit to the left of the rounding digit is odd.
      (i > 0 ? j > 0 ? w / mathpow(10, digits2 - j) : 0 : xd[xdi - 1]) % 10 & 1 || rm == (x.s < 0 ? 8 : 7));
      if (sd < 1 || !xd[0]) {
        xd.length = 0;
        if (roundUp) {
          sd -= x.e + 1;
          xd[0] = mathpow(10, (LOG_BASE - sd % LOG_BASE) % LOG_BASE);
          x.e = -sd || 0;
        } else {
          xd[0] = x.e = 0;
        }
        return x;
      }
      if (i == 0) {
        xd.length = xdi;
        k = 1;
        xdi--;
      } else {
        xd.length = xdi + 1;
        k = mathpow(10, LOG_BASE - i);
        xd[xdi] = j > 0 ? (w / mathpow(10, digits2 - j) % mathpow(10, j) | 0) * k : 0;
      }
      if (roundUp) {
        for (; ; ) {
          if (xdi == 0) {
            for (i = 1, j = xd[0]; j >= 10; j /= 10) i++;
            j = xd[0] += k;
            for (k = 1; j >= 10; j /= 10) k++;
            if (i != k) {
              x.e++;
              if (xd[0] == BASE) xd[0] = 1;
            }
            break;
          } else {
            xd[xdi] += k;
            if (xd[xdi] != BASE) break;
            xd[xdi--] = 0;
            k = 1;
          }
        }
      }
      for (i = xd.length; xd[--i] === 0; ) xd.pop();
    }
    if (external) {
      if (x.e > Ctor.maxE) {
        x.d = null;
        x.e = NaN;
      } else if (x.e < Ctor.minE) {
        x.e = 0;
        x.d = [0];
      }
    }
    return x;
  }
  function finiteToString(x, isExp, sd) {
    if (!x.isFinite()) return nonFiniteToString(x);
    var k, e = x.e, str = digitsToString(x.d), len = str.length;
    if (isExp) {
      if (sd && (k = sd - len) > 0) {
        str = str.charAt(0) + "." + str.slice(1) + getZeroString(k);
      } else if (len > 1) {
        str = str.charAt(0) + "." + str.slice(1);
      }
      str = str + (x.e < 0 ? "e" : "e+") + x.e;
    } else if (e < 0) {
      str = "0." + getZeroString(-e - 1) + str;
      if (sd && (k = sd - len) > 0) str += getZeroString(k);
    } else if (e >= len) {
      str += getZeroString(e + 1 - len);
      if (sd && (k = sd - e - 1) > 0) str = str + "." + getZeroString(k);
    } else {
      if ((k = e + 1) < len) str = str.slice(0, k) + "." + str.slice(k);
      if (sd && (k = sd - len) > 0) {
        if (e + 1 === len) str += ".";
        str += getZeroString(k);
      }
    }
    return str;
  }
  function getBase10Exponent(digits2, e) {
    var w = digits2[0];
    for (e *= LOG_BASE; w >= 10; w /= 10) e++;
    return e;
  }
  function getLn10(Ctor, sd, pr) {
    if (sd > LN10_PRECISION) {
      external = true;
      if (pr) Ctor.precision = pr;
      throw Error(precisionLimitExceeded);
    }
    return finalise(new Ctor(LN10), sd, 1, true);
  }
  function getPi(Ctor, sd, rm) {
    if (sd > PI_PRECISION) throw Error(precisionLimitExceeded);
    return finalise(new Ctor(PI), sd, rm, true);
  }
  function getPrecision(digits2) {
    var w = digits2.length - 1, len = w * LOG_BASE + 1;
    w = digits2[w];
    if (w) {
      for (; w % 10 == 0; w /= 10) len--;
      for (w = digits2[0]; w >= 10; w /= 10) len++;
    }
    return len;
  }
  function getZeroString(k) {
    var zs = "";
    for (; k--; ) zs += "0";
    return zs;
  }
  function intPow(Ctor, x, n, pr) {
    var isTruncated, r = new Ctor(1), k = Math.ceil(pr / LOG_BASE + 4);
    external = false;
    for (; ; ) {
      if (n % 2) {
        r = r.times(x);
        if (truncate(r.d, k)) isTruncated = true;
      }
      n = mathfloor(n / 2);
      if (n === 0) {
        n = r.d.length - 1;
        if (isTruncated && r.d[n] === 0) ++r.d[n];
        break;
      }
      x = x.times(x);
      truncate(x.d, k);
    }
    external = true;
    return r;
  }
  function isOdd(n) {
    return n.d[n.d.length - 1] & 1;
  }
  function maxOrMin(Ctor, args, n) {
    var k, y, x = new Ctor(args[0]), i = 0;
    for (; ++i < args.length; ) {
      y = new Ctor(args[i]);
      if (!y.s) {
        x = y;
        break;
      }
      k = x.cmp(y);
      if (k === n || k === 0 && x.s === n) {
        x = y;
      }
    }
    return x;
  }
  function naturalExponential(x, sd) {
    var denominator, guard, j, pow2, sum2, t, wpr, rep = 0, i = 0, k = 0, Ctor = x.constructor, rm = Ctor.rounding, pr = Ctor.precision;
    if (!x.d || !x.d[0] || x.e > 17) {
      return new Ctor(x.d ? !x.d[0] ? 1 : x.s < 0 ? 0 : 1 / 0 : x.s ? x.s < 0 ? 0 : x : 0 / 0);
    }
    if (sd == null) {
      external = false;
      wpr = pr;
    } else {
      wpr = sd;
    }
    t = new Ctor(0.03125);
    while (x.e > -2) {
      x = x.times(t);
      k += 5;
    }
    guard = Math.log(mathpow(2, k)) / Math.LN10 * 2 + 5 | 0;
    wpr += guard;
    denominator = pow2 = sum2 = new Ctor(1);
    Ctor.precision = wpr;
    for (; ; ) {
      pow2 = finalise(pow2.times(x), wpr, 1);
      denominator = denominator.times(++i);
      t = sum2.plus(divide(pow2, denominator, wpr, 1));
      if (digitsToString(t.d).slice(0, wpr) === digitsToString(sum2.d).slice(0, wpr)) {
        j = k;
        while (j--) sum2 = finalise(sum2.times(sum2), wpr, 1);
        if (sd == null) {
          if (rep < 3 && checkRoundingDigits(sum2.d, wpr - guard, rm, rep)) {
            Ctor.precision = wpr += 10;
            denominator = pow2 = t = new Ctor(1);
            i = 0;
            rep++;
          } else {
            return finalise(sum2, Ctor.precision = pr, rm, external = true);
          }
        } else {
          Ctor.precision = pr;
          return sum2;
        }
      }
      sum2 = t;
    }
  }
  function naturalLogarithm(y, sd) {
    var c, c0, denominator, e, numerator, rep, sum2, t, wpr, x1, x2, n = 1, guard = 10, x = y, xd = x.d, Ctor = x.constructor, rm = Ctor.rounding, pr = Ctor.precision;
    if (x.s < 0 || !xd || !xd[0] || !x.e && xd[0] == 1 && xd.length == 1) {
      return new Ctor(xd && !xd[0] ? -1 / 0 : x.s != 1 ? NaN : xd ? 0 : x);
    }
    if (sd == null) {
      external = false;
      wpr = pr;
    } else {
      wpr = sd;
    }
    Ctor.precision = wpr += guard;
    c = digitsToString(xd);
    c0 = c.charAt(0);
    if (Math.abs(e = x.e) < 15e14) {
      while (c0 < 7 && c0 != 1 || c0 == 1 && c.charAt(1) > 3) {
        x = x.times(y);
        c = digitsToString(x.d);
        c0 = c.charAt(0);
        n++;
      }
      e = x.e;
      if (c0 > 1) {
        x = new Ctor("0." + c);
        e++;
      } else {
        x = new Ctor(c0 + "." + c.slice(1));
      }
    } else {
      t = getLn10(Ctor, wpr + 2, pr).times(e + "");
      x = naturalLogarithm(new Ctor(c0 + "." + c.slice(1)), wpr - guard).plus(t);
      Ctor.precision = pr;
      return sd == null ? finalise(x, pr, rm, external = true) : x;
    }
    x1 = x;
    sum2 = numerator = x = divide(x.minus(1), x.plus(1), wpr, 1);
    x2 = finalise(x.times(x), wpr, 1);
    denominator = 3;
    for (; ; ) {
      numerator = finalise(numerator.times(x2), wpr, 1);
      t = sum2.plus(divide(numerator, new Ctor(denominator), wpr, 1));
      if (digitsToString(t.d).slice(0, wpr) === digitsToString(sum2.d).slice(0, wpr)) {
        sum2 = sum2.times(2);
        if (e !== 0) sum2 = sum2.plus(getLn10(Ctor, wpr + 2, pr).times(e + ""));
        sum2 = divide(sum2, new Ctor(n), wpr, 1);
        if (sd == null) {
          if (checkRoundingDigits(sum2.d, wpr - guard, rm, rep)) {
            Ctor.precision = wpr += guard;
            t = numerator = x = divide(x1.minus(1), x1.plus(1), wpr, 1);
            x2 = finalise(x.times(x), wpr, 1);
            denominator = rep = 1;
          } else {
            return finalise(sum2, Ctor.precision = pr, rm, external = true);
          }
        } else {
          Ctor.precision = pr;
          return sum2;
        }
      }
      sum2 = t;
      denominator += 2;
    }
  }
  function nonFiniteToString(x) {
    return String(x.s * x.s / 0);
  }
  function parseDecimal(x, str) {
    var e, i, len;
    if ((e = str.indexOf(".")) > -1) str = str.replace(".", "");
    if ((i = str.search(/e/i)) > 0) {
      if (e < 0) e = i;
      e += +str.slice(i + 1);
      str = str.substring(0, i);
    } else if (e < 0) {
      e = str.length;
    }
    for (i = 0; str.charCodeAt(i) === 48; i++) ;
    for (len = str.length; str.charCodeAt(len - 1) === 48; --len) ;
    str = str.slice(i, len);
    if (str) {
      len -= i;
      x.e = e = e - i - 1;
      x.d = [];
      i = (e + 1) % LOG_BASE;
      if (e < 0) i += LOG_BASE;
      if (i < len) {
        if (i) x.d.push(+str.slice(0, i));
        for (len -= LOG_BASE; i < len; ) x.d.push(+str.slice(i, i += LOG_BASE));
        str = str.slice(i);
        i = LOG_BASE - str.length;
      } else {
        i -= len;
      }
      for (; i--; ) str += "0";
      x.d.push(+str);
      if (external) {
        if (x.e > x.constructor.maxE) {
          x.d = null;
          x.e = NaN;
        } else if (x.e < x.constructor.minE) {
          x.e = 0;
          x.d = [0];
        }
      }
    } else {
      x.e = 0;
      x.d = [0];
    }
    return x;
  }
  function parseOther(x, str) {
    var base, Ctor, divisor, i, isFloat, len, p, xd, xe;
    if (str.indexOf("_") > -1) {
      str = str.replace(/(\d)_(?=\d)/g, "$1");
      if (isDecimal.test(str)) return parseDecimal(x, str);
    } else if (str === "Infinity" || str === "NaN") {
      if (!+str) x.s = NaN;
      x.e = NaN;
      x.d = null;
      return x;
    }
    if (isHex.test(str)) {
      base = 16;
      str = str.toLowerCase();
    } else if (isBinary.test(str)) {
      base = 2;
    } else if (isOctal.test(str)) {
      base = 8;
    } else {
      throw Error(invalidArgument + str);
    }
    i = str.search(/p/i);
    if (i > 0) {
      p = +str.slice(i + 1);
      str = str.substring(2, i);
    } else {
      str = str.slice(2);
    }
    i = str.indexOf(".");
    isFloat = i >= 0;
    Ctor = x.constructor;
    if (isFloat) {
      str = str.replace(".", "");
      len = str.length;
      i = len - i;
      divisor = intPow(Ctor, new Ctor(base), i, i * 2);
    }
    xd = convertBase(str, base, BASE);
    xe = xd.length - 1;
    for (i = xe; xd[i] === 0; --i) xd.pop();
    if (i < 0) return new Ctor(x.s * 0);
    x.e = getBase10Exponent(xd, xe);
    x.d = xd;
    external = false;
    if (isFloat) x = divide(x, divisor, len * 4);
    if (p) x = x.times(Math.abs(p) < 54 ? mathpow(2, p) : Decimal.pow(2, p));
    external = true;
    return x;
  }
  function sine(Ctor, x) {
    var k, len = x.d.length;
    if (len < 3) {
      return x.isZero() ? x : taylorSeries(Ctor, 2, x, x);
    }
    k = 1.4 * Math.sqrt(len);
    k = k > 16 ? 16 : k | 0;
    x = x.times(1 / tinyPow(5, k));
    x = taylorSeries(Ctor, 2, x, x);
    var sin2_x, d5 = new Ctor(5), d16 = new Ctor(16), d20 = new Ctor(20);
    for (; k--; ) {
      sin2_x = x.times(x);
      x = x.times(d5.plus(sin2_x.times(d16.times(sin2_x).minus(d20))));
    }
    return x;
  }
  function taylorSeries(Ctor, n, x, y, isHyperbolic) {
    var j, t, u, x2, i = 1, pr = Ctor.precision, k = Math.ceil(pr / LOG_BASE);
    external = false;
    x2 = x.times(x);
    u = new Ctor(y);
    for (; ; ) {
      t = divide(u.times(x2), new Ctor(n++ * n++), pr, 1);
      u = isHyperbolic ? y.plus(t) : y.minus(t);
      y = divide(t.times(x2), new Ctor(n++ * n++), pr, 1);
      t = u.plus(y);
      if (t.d[k] !== void 0) {
        for (j = k; t.d[j] === u.d[j] && j--; ) ;
        if (j == -1) break;
      }
      j = u;
      u = y;
      y = t;
      t = j;
      i++;
    }
    external = true;
    t.d.length = k + 1;
    return t;
  }
  function tinyPow(b, e) {
    var n = b;
    while (--e) n *= b;
    return n;
  }
  function toLessThanHalfPi(Ctor, x) {
    var t, isNeg = x.s < 0, pi = getPi(Ctor, Ctor.precision, 1), halfPi = pi.times(0.5);
    x = x.abs();
    if (x.lte(halfPi)) {
      quadrant = isNeg ? 4 : 1;
      return x;
    }
    t = x.divToInt(pi);
    if (t.isZero()) {
      quadrant = isNeg ? 3 : 2;
    } else {
      x = x.minus(t.times(pi));
      if (x.lte(halfPi)) {
        quadrant = isOdd(t) ? isNeg ? 2 : 3 : isNeg ? 4 : 1;
        return x;
      }
      quadrant = isOdd(t) ? isNeg ? 1 : 4 : isNeg ? 3 : 2;
    }
    return x.minus(pi).abs();
  }
  function toStringBinary(x, baseOut, sd, rm) {
    var base, e, i, k, len, roundUp, str, xd, y, Ctor = x.constructor, isExp = sd !== void 0;
    if (isExp) {
      checkInt32(sd, 1, MAX_DIGITS);
      if (rm === void 0) rm = Ctor.rounding;
      else checkInt32(rm, 0, 8);
    } else {
      sd = Ctor.precision;
      rm = Ctor.rounding;
    }
    if (!x.isFinite()) {
      str = nonFiniteToString(x);
    } else {
      str = finiteToString(x);
      i = str.indexOf(".");
      if (isExp) {
        base = 2;
        if (baseOut == 16) {
          sd = sd * 4 - 3;
        } else if (baseOut == 8) {
          sd = sd * 3 - 2;
        }
      } else {
        base = baseOut;
      }
      if (i >= 0) {
        str = str.replace(".", "");
        y = new Ctor(1);
        y.e = str.length - i;
        y.d = convertBase(finiteToString(y), 10, base);
        y.e = y.d.length;
      }
      xd = convertBase(str, 10, base);
      e = len = xd.length;
      for (; xd[--len] == 0; ) xd.pop();
      if (!xd[0]) {
        str = isExp ? "0p+0" : "0";
      } else {
        if (i < 0) {
          e--;
        } else {
          x = new Ctor(x);
          x.d = xd;
          x.e = e;
          x = divide(x, y, sd, rm, 0, base);
          xd = x.d;
          e = x.e;
          roundUp = inexact;
        }
        i = xd[sd];
        k = base / 2;
        roundUp = roundUp || xd[sd + 1] !== void 0;
        roundUp = rm < 4 ? (i !== void 0 || roundUp) && (rm === 0 || rm === (x.s < 0 ? 3 : 2)) : i > k || i === k && (rm === 4 || roundUp || rm === 6 && xd[sd - 1] & 1 || rm === (x.s < 0 ? 8 : 7));
        xd.length = sd;
        if (roundUp) {
          for (; ++xd[--sd] > base - 1; ) {
            xd[sd] = 0;
            if (!sd) {
              ++e;
              xd.unshift(1);
            }
          }
        }
        for (len = xd.length; !xd[len - 1]; --len) ;
        for (i = 0, str = ""; i < len; i++) str += NUMERALS.charAt(xd[i]);
        if (isExp) {
          if (len > 1) {
            if (baseOut == 16 || baseOut == 8) {
              i = baseOut == 16 ? 4 : 3;
              for (--len; len % i; len++) str += "0";
              xd = convertBase(str, base, baseOut);
              for (len = xd.length; !xd[len - 1]; --len) ;
              for (i = 1, str = "1."; i < len; i++) str += NUMERALS.charAt(xd[i]);
            } else {
              str = str.charAt(0) + "." + str.slice(1);
            }
          }
          str = str + (e < 0 ? "p" : "p+") + e;
        } else if (e < 0) {
          for (; ++e; ) str = "0" + str;
          str = "0." + str;
        } else {
          if (++e > len) for (e -= len; e--; ) str += "0";
          else if (e < len) str = str.slice(0, e) + "." + str.slice(e);
        }
      }
      str = (baseOut == 16 ? "0x" : baseOut == 2 ? "0b" : baseOut == 8 ? "0o" : "") + str;
    }
    return x.s < 0 ? "-" + str : str;
  }
  function truncate(arr, len) {
    if (arr.length > len) {
      arr.length = len;
      return true;
    }
  }
  function abs(x) {
    return new this(x).abs();
  }
  function acos(x) {
    return new this(x).acos();
  }
  function acosh(x) {
    return new this(x).acosh();
  }
  function add(x, y) {
    return new this(x).plus(y);
  }
  function asin(x) {
    return new this(x).asin();
  }
  function asinh(x) {
    return new this(x).asinh();
  }
  function atan(x) {
    return new this(x).atan();
  }
  function atanh(x) {
    return new this(x).atanh();
  }
  function atan2(y, x) {
    y = new this(y);
    x = new this(x);
    var r, pr = this.precision, rm = this.rounding, wpr = pr + 4;
    if (!y.s || !x.s) {
      r = new this(NaN);
    } else if (!y.d && !x.d) {
      r = getPi(this, wpr, 1).times(x.s > 0 ? 0.25 : 0.75);
      r.s = y.s;
    } else if (!x.d || y.isZero()) {
      r = x.s < 0 ? getPi(this, pr, rm) : new this(0);
      r.s = y.s;
    } else if (!y.d || x.isZero()) {
      r = getPi(this, wpr, 1).times(0.5);
      r.s = y.s;
    } else if (x.s < 0) {
      this.precision = wpr;
      this.rounding = 1;
      r = this.atan(divide(y, x, wpr, 1));
      x = getPi(this, wpr, 1);
      this.precision = pr;
      this.rounding = rm;
      r = y.s < 0 ? r.minus(x) : r.plus(x);
    } else {
      r = this.atan(divide(y, x, wpr, 1));
    }
    return r;
  }
  function cbrt3(x) {
    return new this(x).cbrt();
  }
  function ceil(x) {
    return finalise(x = new this(x), x.e + 1, 2);
  }
  function clamp(x, min2, max2) {
    return new this(x).clamp(min2, max2);
  }
  function config3(obj) {
    if (!obj || typeof obj !== "object") throw Error(decimalError + "Object expected");
    var i, p, v, useDefaults = obj.defaults === true, ps = [
      "precision",
      1,
      MAX_DIGITS,
      "rounding",
      0,
      8,
      "toExpNeg",
      -EXP_LIMIT,
      0,
      "toExpPos",
      0,
      EXP_LIMIT,
      "maxE",
      0,
      EXP_LIMIT,
      "minE",
      -EXP_LIMIT,
      0,
      "modulo",
      0,
      9
    ];
    for (i = 0; i < ps.length; i += 3) {
      if (p = ps[i], useDefaults) this[p] = DEFAULTS[p];
      if ((v = obj[p]) !== void 0) {
        if (mathfloor(v) === v && v >= ps[i + 1] && v <= ps[i + 2]) this[p] = v;
        else throw Error(invalidArgument + p + ": " + v);
      }
    }
    if (p = "crypto", useDefaults) this[p] = DEFAULTS[p];
    if ((v = obj[p]) !== void 0) {
      if (v === true || v === false || v === 0 || v === 1) {
        if (v) {
          if (typeof crypto != "undefined" && crypto && (crypto.getRandomValues || crypto.randomBytes)) {
            this[p] = true;
          } else {
            throw Error(cryptoUnavailable);
          }
        } else {
          this[p] = false;
        }
      } else {
        throw Error(invalidArgument + p + ": " + v);
      }
    }
    return this;
  }
  function cos(x) {
    return new this(x).cos();
  }
  function cosh(x) {
    return new this(x).cosh();
  }
  function clone2(obj) {
    var i, p, ps;
    function Decimal2(v) {
      var e, i2, t, x = this;
      if (!(x instanceof Decimal2)) return new Decimal2(v);
      x.constructor = Decimal2;
      if (isDecimalInstance(v)) {
        x.s = v.s;
        if (external) {
          if (!v.d || v.e > Decimal2.maxE) {
            x.e = NaN;
            x.d = null;
          } else if (v.e < Decimal2.minE) {
            x.e = 0;
            x.d = [0];
          } else {
            x.e = v.e;
            x.d = v.d.slice();
          }
        } else {
          x.e = v.e;
          x.d = v.d ? v.d.slice() : v.d;
        }
        return;
      }
      t = typeof v;
      if (t === "number") {
        if (v === 0) {
          x.s = 1 / v < 0 ? -1 : 1;
          x.e = 0;
          x.d = [0];
          return;
        }
        if (v < 0) {
          v = -v;
          x.s = -1;
        } else {
          x.s = 1;
        }
        if (v === ~~v && v < 1e7) {
          for (e = 0, i2 = v; i2 >= 10; i2 /= 10) e++;
          if (external) {
            if (e > Decimal2.maxE) {
              x.e = NaN;
              x.d = null;
            } else if (e < Decimal2.minE) {
              x.e = 0;
              x.d = [0];
            } else {
              x.e = e;
              x.d = [v];
            }
          } else {
            x.e = e;
            x.d = [v];
          }
          return;
        }
        if (v * 0 !== 0) {
          if (!v) x.s = NaN;
          x.e = NaN;
          x.d = null;
          return;
        }
        return parseDecimal(x, v.toString());
      }
      if (t === "string") {
        if ((i2 = v.charCodeAt(0)) === 45) {
          v = v.slice(1);
          x.s = -1;
        } else {
          if (i2 === 43) v = v.slice(1);
          x.s = 1;
        }
        return isDecimal.test(v) ? parseDecimal(x, v) : parseOther(x, v);
      }
      if (t === "bigint") {
        if (v < 0) {
          v = -v;
          x.s = -1;
        } else {
          x.s = 1;
        }
        return parseDecimal(x, v.toString());
      }
      throw Error(invalidArgument + v);
    }
    Decimal2.prototype = P;
    Decimal2.ROUND_UP = 0;
    Decimal2.ROUND_DOWN = 1;
    Decimal2.ROUND_CEIL = 2;
    Decimal2.ROUND_FLOOR = 3;
    Decimal2.ROUND_HALF_UP = 4;
    Decimal2.ROUND_HALF_DOWN = 5;
    Decimal2.ROUND_HALF_EVEN = 6;
    Decimal2.ROUND_HALF_CEIL = 7;
    Decimal2.ROUND_HALF_FLOOR = 8;
    Decimal2.EUCLID = 9;
    Decimal2.config = Decimal2.set = config3;
    Decimal2.clone = clone2;
    Decimal2.isDecimal = isDecimalInstance;
    Decimal2.abs = abs;
    Decimal2.acos = acos;
    Decimal2.acosh = acosh;
    Decimal2.add = add;
    Decimal2.asin = asin;
    Decimal2.asinh = asinh;
    Decimal2.atan = atan;
    Decimal2.atanh = atanh;
    Decimal2.atan2 = atan2;
    Decimal2.cbrt = cbrt3;
    Decimal2.ceil = ceil;
    Decimal2.clamp = clamp;
    Decimal2.cos = cos;
    Decimal2.cosh = cosh;
    Decimal2.div = div;
    Decimal2.exp = exp;
    Decimal2.floor = floor;
    Decimal2.hypot = hypot;
    Decimal2.ln = ln;
    Decimal2.log = log;
    Decimal2.log10 = log103;
    Decimal2.log2 = log23;
    Decimal2.max = max;
    Decimal2.min = min;
    Decimal2.mod = mod;
    Decimal2.mul = mul;
    Decimal2.pow = pow;
    Decimal2.random = random;
    Decimal2.round = round;
    Decimal2.sign = sign2;
    Decimal2.sin = sin;
    Decimal2.sinh = sinh;
    Decimal2.sqrt = sqrt;
    Decimal2.sub = sub;
    Decimal2.sum = sum;
    Decimal2.tan = tan;
    Decimal2.tanh = tanh;
    Decimal2.trunc = trunc;
    if (obj === void 0) obj = {};
    if (obj) {
      if (obj.defaults !== true) {
        ps = ["precision", "rounding", "toExpNeg", "toExpPos", "maxE", "minE", "modulo", "crypto"];
        for (i = 0; i < ps.length; ) if (!obj.hasOwnProperty(p = ps[i++])) obj[p] = this[p];
      }
    }
    Decimal2.config(obj);
    return Decimal2;
  }
  function div(x, y) {
    return new this(x).div(y);
  }
  function exp(x) {
    return new this(x).exp();
  }
  function floor(x) {
    return finalise(x = new this(x), x.e + 1, 3);
  }
  function hypot() {
    var i, n, t = new this(0);
    external = false;
    for (i = 0; i < arguments.length; ) {
      n = new this(arguments[i++]);
      if (!n.d) {
        if (n.s) {
          external = true;
          return new this(1 / 0);
        }
        t = n;
      } else if (t.d) {
        t = t.plus(n.times(n));
      }
    }
    external = true;
    return t.sqrt();
  }
  function isDecimalInstance(obj) {
    return obj instanceof Decimal || obj && obj.toStringTag === tag || false;
  }
  function ln(x) {
    return new this(x).ln();
  }
  function log(x, y) {
    return new this(x).log(y);
  }
  function log23(x) {
    return new this(x).log(2);
  }
  function log103(x) {
    return new this(x).log(10);
  }
  function max() {
    return maxOrMin(this, arguments, -1);
  }
  function min() {
    return maxOrMin(this, arguments, 1);
  }
  function mod(x, y) {
    return new this(x).mod(y);
  }
  function mul(x, y) {
    return new this(x).mul(y);
  }
  function pow(x, y) {
    return new this(x).pow(y);
  }
  function random(sd) {
    var d, e, k, n, i = 0, r = new this(1), rd = [];
    if (sd === void 0) sd = this.precision;
    else checkInt32(sd, 1, MAX_DIGITS);
    k = Math.ceil(sd / LOG_BASE);
    if (!this.crypto) {
      for (; i < k; ) rd[i++] = Math.random() * 1e7 | 0;
    } else if (crypto.getRandomValues) {
      d = crypto.getRandomValues(new Uint32Array(k));
      for (; i < k; ) {
        n = d[i];
        if (n >= 429e7) {
          d[i] = crypto.getRandomValues(new Uint32Array(1))[0];
        } else {
          rd[i++] = n % 1e7;
        }
      }
    } else if (crypto.randomBytes) {
      d = crypto.randomBytes(k *= 4);
      for (; i < k; ) {
        n = d[i] + (d[i + 1] << 8) + (d[i + 2] << 16) + ((d[i + 3] & 127) << 24);
        if (n >= 214e7) {
          crypto.randomBytes(4).copy(d, i);
        } else {
          rd.push(n % 1e7);
          i += 4;
        }
      }
      i = k / 4;
    } else {
      throw Error(cryptoUnavailable);
    }
    k = rd[--i];
    sd %= LOG_BASE;
    if (k && sd) {
      n = mathpow(10, LOG_BASE - sd);
      rd[i] = (k / n | 0) * n;
    }
    for (; rd[i] === 0; i--) rd.pop();
    if (i < 0) {
      e = 0;
      rd = [0];
    } else {
      e = -1;
      for (; rd[0] === 0; e -= LOG_BASE) rd.shift();
      for (k = 1, n = rd[0]; n >= 10; n /= 10) k++;
      if (k < LOG_BASE) e -= LOG_BASE - k;
    }
    r.e = e;
    r.d = rd;
    return r;
  }
  function round(x) {
    return finalise(x = new this(x), x.e + 1, this.rounding);
  }
  function sign2(x) {
    x = new this(x);
    return x.d ? x.d[0] ? x.s : 0 * x.s : x.s || NaN;
  }
  function sin(x) {
    return new this(x).sin();
  }
  function sinh(x) {
    return new this(x).sinh();
  }
  function sqrt(x) {
    return new this(x).sqrt();
  }
  function sub(x, y) {
    return new this(x).sub(y);
  }
  function sum() {
    var i = 0, args = arguments, x = new this(args[i]);
    external = false;
    for (; x.s && ++i < args.length; ) x = x.plus(args[i]);
    external = true;
    return finalise(x, this.precision, this.rounding);
  }
  function tan(x) {
    return new this(x).tan();
  }
  function tanh(x) {
    return new this(x).tanh();
  }
  function trunc(x) {
    return finalise(x = new this(x), x.e + 1, 1);
  }
  P[/* @__PURE__ */ Symbol.for("nodejs.util.inspect.custom")] = P.toString;
  P[Symbol.toStringTag] = "Decimal";
  var Decimal = P.constructor = clone2(DEFAULTS);
  LN10 = new Decimal(LN10);
  PI = new Decimal(PI);
  var decimal_default = Decimal;

  // node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/esm/type/bignumber/BigNumber.js
  var name = "BigNumber";
  var dependencies2 = ["?on", "config"];
  var createBigNumberClass = /* @__PURE__ */ factory(name, dependencies2, (_ref) => {
    var {
      on,
      config: config4
    } = _ref;
    var BigNumber2 = decimal_default.clone({
      precision: config4.precision,
      modulo: decimal_default.EUCLID
    });
    BigNumber2.prototype = Object.create(BigNumber2.prototype);
    BigNumber2.prototype.type = "BigNumber";
    BigNumber2.prototype.isBigNumber = true;
    BigNumber2.prototype.toJSON = function() {
      return {
        mathjs: "BigNumber",
        value: this.toString()
      };
    };
    BigNumber2.fromJSON = function(json) {
      return new BigNumber2(json.value);
    };
    if (on) {
      on("config", function(curr, prev) {
        if (curr.precision !== prev.precision) {
          BigNumber2.config({
            precision: curr.precision
          });
        }
      });
    }
    return BigNumber2;
  }, {
    isClass: true
  });

  // node_modules/.pnpm/complex.js@2.4.3/node_modules/complex.js/dist/complex.mjs
  var cosh2 = Math.cosh || function(x) {
    return Math.abs(x) < 1e-9 ? 1 - x : (Math.exp(x) + Math.exp(-x)) * 0.5;
  };
  var sinh2 = Math.sinh || function(x) {
    return Math.abs(x) < 1e-9 ? x : (Math.exp(x) - Math.exp(-x)) * 0.5;
  };
  var cosm1 = (x) => {
    const s = Math.sin(0.5 * x);
    return -2 * s * s;
  };
  var hypot2 = function(x, y) {
    x = Math.abs(x);
    y = Math.abs(y);
    if (x < y) [x, y] = [y, x];
    if (x < 1e8) return Math.sqrt(x * x + y * y);
    y /= x;
    return x * Math.sqrt(1 + y * y);
  };
  var parser_exit = function() {
    throw SyntaxError("Invalid Param");
  };
  function logHypot(a, b) {
    const _a = Math.abs(a);
    const _b = Math.abs(b);
    if (a === 0) {
      return Math.log(_b);
    }
    if (b === 0) {
      return Math.log(_a);
    }
    if (_a < 3e3 && _b < 3e3) {
      return Math.log(a * a + b * b) * 0.5;
    }
    a = a * 0.5;
    b = b * 0.5;
    return 0.5 * Math.log(a * a + b * b) + Math.LN2;
  }
  var P2 = { "re": 0, "im": 0 };
  var parse = function(a, b) {
    const z = P2;
    if (a === void 0 || a === null) {
      z["re"] = z["im"] = 0;
    } else if (b !== void 0) {
      z["re"] = a;
      z["im"] = b;
    } else
      switch (typeof a) {
        case "object":
          if ("im" in a && "re" in a) {
            z["re"] = a["re"];
            z["im"] = a["im"];
          } else if ("abs" in a && "arg" in a) {
            if (!isFinite(a["abs"]) && isFinite(a["arg"])) {
              return Complex["INFINITY"];
            }
            z["re"] = a["abs"] * Math.cos(a["arg"]);
            z["im"] = a["abs"] * Math.sin(a["arg"]);
          } else if ("r" in a && "phi" in a) {
            if (!isFinite(a["r"]) && isFinite(a["phi"])) {
              return Complex["INFINITY"];
            }
            z["re"] = a["r"] * Math.cos(a["phi"]);
            z["im"] = a["r"] * Math.sin(a["phi"]);
          } else if (a.length === 2) {
            z["re"] = a[0];
            z["im"] = a[1];
          } else {
            parser_exit();
          }
          break;
        case "string":
          z["im"] = /* void */
          z["re"] = 0;
          const tokens = a.replace(/_/g, "").match(/\d+\.?\d*e[+-]?\d+|\d+\.?\d*|\.\d+|./g);
          let plus = 1;
          let minus = 0;
          if (tokens === null) {
            parser_exit();
          }
          for (let i = 0; i < tokens.length; i++) {
            const c = tokens[i];
            if (c === " " || c === "	" || c === "\n") {
            } else if (c === "+") {
              plus++;
            } else if (c === "-") {
              minus++;
            } else if (c === "i" || c === "I") {
              if (plus + minus === 0) {
                parser_exit();
              }
              if (tokens[i + 1] !== " " && !isNaN(tokens[i + 1])) {
                z["im"] += parseFloat((minus % 2 ? "-" : "") + tokens[i + 1]);
                i++;
              } else {
                z["im"] += parseFloat((minus % 2 ? "-" : "") + "1");
              }
              plus = minus = 0;
            } else {
              if (plus + minus === 0 || isNaN(c)) {
                parser_exit();
              }
              if (tokens[i + 1] === "i" || tokens[i + 1] === "I") {
                z["im"] += parseFloat((minus % 2 ? "-" : "") + c);
                i++;
              } else {
                z["re"] += parseFloat((minus % 2 ? "-" : "") + c);
              }
              plus = minus = 0;
            }
          }
          if (plus + minus > 0) {
            parser_exit();
          }
          break;
        case "number":
          z["im"] = 0;
          z["re"] = a;
          break;
        default:
          parser_exit();
      }
    if (isNaN(z["re"]) || isNaN(z["im"])) {
    }
    return z;
  };
  function Complex(a, b) {
    if (!(this instanceof Complex)) {
      return new Complex(a, b);
    }
    const z = parse(a, b);
    this["re"] = z["re"];
    this["im"] = z["im"];
  }
  Complex.prototype = {
    "re": 0,
    "im": 0,
    /**
     * Calculates the sign of a complex number, which is a normalized complex
     *
     * @returns {Complex}
     */
    "sign": function() {
      const abs2 = hypot2(this["re"], this["im"]);
      return new Complex(
        this["re"] / abs2,
        this["im"] / abs2
      );
    },
    /**
     * Adds two complex numbers
     *
     * @returns {Complex}
     */
    "add": function(a, b) {
      const z = parse(a, b);
      const tInfin = this["isInfinite"]();
      const zInfin = !(isFinite(z["re"]) && isFinite(z["im"]));
      if (tInfin || zInfin) {
        if (tInfin && zInfin) {
          return Complex["NAN"];
        }
        return Complex["INFINITY"];
      }
      return new Complex(
        this["re"] + z["re"],
        this["im"] + z["im"]
      );
    },
    /**
     * Subtracts two complex numbers
     *
     * @returns {Complex}
     */
    "sub": function(a, b) {
      const z = parse(a, b);
      const tInfin = this["isInfinite"]();
      const zInfin = !(isFinite(z["re"]) && isFinite(z["im"]));
      if (tInfin || zInfin) {
        if (tInfin && zInfin) {
          return Complex["NAN"];
        }
        return Complex["INFINITY"];
      }
      return new Complex(
        this["re"] - z["re"],
        this["im"] - z["im"]
      );
    },
    /**
     * Multiplies two complex numbers
     *
     * @returns {Complex}
     */
    "mul": function(a, b) {
      const z = parse(a, b);
      const tInfin = this["isInfinite"]();
      const zInfin = !(isFinite(z["re"]) && isFinite(z["im"]));
      const tIsZero = this["re"] === 0 && this["im"] === 0;
      const zIsZero = z["re"] === 0 && z["im"] === 0;
      if (tInfin && zIsZero || zInfin && tIsZero) {
        return Complex["NAN"];
      }
      if (tInfin || zInfin) {
        return Complex["INFINITY"];
      }
      if (z["im"] === 0 && this["im"] === 0) {
        return new Complex(this["re"] * z["re"], 0);
      }
      return new Complex(
        this["re"] * z["re"] - this["im"] * z["im"],
        this["re"] * z["im"] + this["im"] * z["re"]
      );
    },
    /**
     * Divides two complex numbers
     *
     * @returns {Complex}
     */
    "div": function(a, b) {
      const z = parse(a, b);
      const tInfin = this["isInfinite"]();
      const zInfin = !(isFinite(z["re"]) && isFinite(z["im"]));
      const tIsZero = this["re"] === 0 && this["im"] === 0;
      const zIsZero = z["re"] === 0 && z["im"] === 0;
      if (tIsZero && zIsZero || tInfin && zInfin) {
        return Complex["NAN"];
      }
      if (zIsZero || tInfin) {
        return Complex["INFINITY"];
      }
      if (tIsZero || zInfin) {
        return Complex["ZERO"];
      }
      if (0 === z["im"]) {
        return new Complex(this["re"] / z["re"], this["im"] / z["re"]);
      }
      if (Math.abs(z["re"]) < Math.abs(z["im"])) {
        const x = z["re"] / z["im"];
        const t = z["re"] * x + z["im"];
        return new Complex(
          (this["re"] * x + this["im"]) / t,
          (this["im"] * x - this["re"]) / t
        );
      } else {
        const x = z["im"] / z["re"];
        const t = z["im"] * x + z["re"];
        return new Complex(
          (this["re"] + this["im"] * x) / t,
          (this["im"] - this["re"] * x) / t
        );
      }
    },
    /**
     * Calculate the power of two complex numbers
     *
     * @returns {Complex}
     */
    "pow": function(a, b) {
      const z = parse(a, b);
      const tIsZero = this["re"] === 0 && this["im"] === 0;
      const zIsZero = z["re"] === 0 && z["im"] === 0;
      if (zIsZero) {
        return Complex["ONE"];
      }
      if (z["im"] === 0) {
        if (this["im"] === 0 && this["re"] > 0) {
          return new Complex(Math.pow(this["re"], z["re"]), 0);
        } else if (this["re"] === 0) {
          switch ((z["re"] % 4 + 4) % 4) {
            case 0:
              return new Complex(Math.pow(this["im"], z["re"]), 0);
            case 1:
              return new Complex(0, Math.pow(this["im"], z["re"]));
            case 2:
              return new Complex(-Math.pow(this["im"], z["re"]), 0);
            case 3:
              return new Complex(0, -Math.pow(this["im"], z["re"]));
          }
        }
      }
      if (tIsZero && z["re"] > 0) {
        return Complex["ZERO"];
      }
      const arg = Math.atan2(this["im"], this["re"]);
      const loh = logHypot(this["re"], this["im"]);
      let re = Math.exp(z["re"] * loh - z["im"] * arg);
      let im = z["im"] * loh + z["re"] * arg;
      return new Complex(
        re * Math.cos(im),
        re * Math.sin(im)
      );
    },
    /**
     * Calculate the complex square root
     *
     * @returns {Complex}
     */
    "sqrt": function() {
      const a = this["re"];
      const b = this["im"];
      if (b === 0) {
        if (a >= 0) {
          return new Complex(Math.sqrt(a), 0);
        } else {
          return new Complex(0, Math.sqrt(-a));
        }
      }
      const r = hypot2(a, b);
      let re = Math.sqrt(0.5 * (r + Math.abs(a)));
      let im = Math.abs(b) / (2 * re);
      if (a >= 0) {
        return new Complex(re, b < 0 ? -im : im);
      } else {
        return new Complex(im, b < 0 ? -re : re);
      }
    },
    /**
     * Calculate the complex exponent
     *
     * @returns {Complex}
     */
    "exp": function() {
      const er = Math.exp(this["re"]);
      if (this["im"] === 0) {
        return new Complex(er, 0);
      }
      return new Complex(
        er * Math.cos(this["im"]),
        er * Math.sin(this["im"])
      );
    },
    /**
     * Calculate the complex exponent and subtracts one.
     *
     * This may be more accurate than `Complex(x).exp().sub(1)` if
     * `x` is small.
     *
     * @returns {Complex}
     */
    "expm1": function() {
      const a = this["re"];
      const b = this["im"];
      return new Complex(
        Math.expm1(a) * Math.cos(b) + cosm1(b),
        Math.exp(a) * Math.sin(b)
      );
    },
    /**
     * Calculate the natural log
     *
     * @returns {Complex}
     */
    "log": function() {
      const a = this["re"];
      const b = this["im"];
      if (b === 0 && a > 0) {
        return new Complex(Math.log(a), 0);
      }
      return new Complex(
        logHypot(a, b),
        Math.atan2(b, a)
      );
    },
    /**
     * Calculate the magnitude of the complex number
     *
     * @returns {number}
     */
    "abs": function() {
      return hypot2(this["re"], this["im"]);
    },
    /**
     * Calculate the angle of the complex number
     *
     * @returns {number}
     */
    "arg": function() {
      return Math.atan2(this["im"], this["re"]);
    },
    /**
     * Calculate the sine of the complex number
     *
     * @returns {Complex}
     */
    "sin": function() {
      const a = this["re"];
      const b = this["im"];
      return new Complex(
        Math.sin(a) * cosh2(b),
        Math.cos(a) * sinh2(b)
      );
    },
    /**
     * Calculate the cosine
     *
     * @returns {Complex}
     */
    "cos": function() {
      const a = this["re"];
      const b = this["im"];
      return new Complex(
        Math.cos(a) * cosh2(b),
        -Math.sin(a) * sinh2(b)
      );
    },
    /**
     * Calculate the tangent
     *
     * @returns {Complex}
     */
    "tan": function() {
      const a = 2 * this["re"];
      const b = 2 * this["im"];
      const d = Math.cos(a) + cosh2(b);
      return new Complex(
        Math.sin(a) / d,
        sinh2(b) / d
      );
    },
    /**
     * Calculate the cotangent
     *
     * @returns {Complex}
     */
    "cot": function() {
      const a = 2 * this["re"];
      const b = 2 * this["im"];
      const d = Math.cos(a) - cosh2(b);
      return new Complex(
        -Math.sin(a) / d,
        sinh2(b) / d
      );
    },
    /**
     * Calculate the secant
     *
     * @returns {Complex}
     */
    "sec": function() {
      const a = this["re"];
      const b = this["im"];
      const d = 0.5 * cosh2(2 * b) + 0.5 * Math.cos(2 * a);
      return new Complex(
        Math.cos(a) * cosh2(b) / d,
        Math.sin(a) * sinh2(b) / d
      );
    },
    /**
     * Calculate the cosecans
     *
     * @returns {Complex}
     */
    "csc": function() {
      const a = this["re"];
      const b = this["im"];
      const d = 0.5 * cosh2(2 * b) - 0.5 * Math.cos(2 * a);
      return new Complex(
        Math.sin(a) * cosh2(b) / d,
        -Math.cos(a) * sinh2(b) / d
      );
    },
    /**
     * Calculate the complex arcus sinus
     *
     * @returns {Complex}
     */
    "asin": function() {
      const a = this["re"];
      const b = this["im"];
      const t1 = new Complex(
        b * b - a * a + 1,
        -2 * a * b
      )["sqrt"]();
      const t2 = new Complex(
        t1["re"] - b,
        t1["im"] + a
      )["log"]();
      return new Complex(t2["im"], -t2["re"]);
    },
    /**
     * Calculate the complex arcus cosinus
     *
     * @returns {Complex}
     */
    "acos": function() {
      const a = this["re"];
      const b = this["im"];
      const t1 = new Complex(
        b * b - a * a + 1,
        -2 * a * b
      )["sqrt"]();
      const t2 = new Complex(
        t1["re"] - b,
        t1["im"] + a
      )["log"]();
      return new Complex(Math.PI / 2 - t2["im"], t2["re"]);
    },
    /**
     * Calculate the complex arcus tangent
     *
     * @returns {Complex}
     */
    "atan": function() {
      const a = this["re"];
      const b = this["im"];
      if (a === 0) {
        if (b === 1) {
          return new Complex(0, Infinity);
        }
        if (b === -1) {
          return new Complex(0, -Infinity);
        }
      }
      const d = a * a + (1 - b) * (1 - b);
      const t1 = new Complex(
        (1 - b * b - a * a) / d,
        -2 * a / d
      ).log();
      return new Complex(-0.5 * t1["im"], 0.5 * t1["re"]);
    },
    /**
     * Calculate the complex arcus cotangent
     *
     * @returns {Complex}
     */
    "acot": function() {
      const a = this["re"];
      const b = this["im"];
      if (b === 0) {
        return new Complex(Math.atan2(1, a), 0);
      }
      const d = a * a + b * b;
      return d !== 0 ? new Complex(
        a / d,
        -b / d
      ).atan() : new Complex(
        a !== 0 ? a / 0 : 0,
        b !== 0 ? -b / 0 : 0
      ).atan();
    },
    /**
     * Calculate the complex arcus secant
     *
     * @returns {Complex}
     */
    "asec": function() {
      const a = this["re"];
      const b = this["im"];
      if (a === 0 && b === 0) {
        return new Complex(0, Infinity);
      }
      const d = a * a + b * b;
      return d !== 0 ? new Complex(
        a / d,
        -b / d
      ).acos() : new Complex(
        a !== 0 ? a / 0 : 0,
        b !== 0 ? -b / 0 : 0
      ).acos();
    },
    /**
     * Calculate the complex arcus cosecans
     *
     * @returns {Complex}
     */
    "acsc": function() {
      const a = this["re"];
      const b = this["im"];
      if (a === 0 && b === 0) {
        return new Complex(Math.PI / 2, Infinity);
      }
      const d = a * a + b * b;
      return d !== 0 ? new Complex(
        a / d,
        -b / d
      ).asin() : new Complex(
        a !== 0 ? a / 0 : 0,
        b !== 0 ? -b / 0 : 0
      ).asin();
    },
    /**
     * Calculate the complex sinh
     *
     * @returns {Complex}
     */
    "sinh": function() {
      const a = this["re"];
      const b = this["im"];
      return new Complex(
        sinh2(a) * Math.cos(b),
        cosh2(a) * Math.sin(b)
      );
    },
    /**
     * Calculate the complex cosh
     *
     * @returns {Complex}
     */
    "cosh": function() {
      const a = this["re"];
      const b = this["im"];
      return new Complex(
        cosh2(a) * Math.cos(b),
        sinh2(a) * Math.sin(b)
      );
    },
    /**
     * Calculate the complex tanh
     *
     * @returns {Complex}
     */
    "tanh": function() {
      const a = 2 * this["re"];
      const b = 2 * this["im"];
      const d = cosh2(a) + Math.cos(b);
      return new Complex(
        sinh2(a) / d,
        Math.sin(b) / d
      );
    },
    /**
     * Calculate the complex coth
     *
     * @returns {Complex}
     */
    "coth": function() {
      const a = 2 * this["re"];
      const b = 2 * this["im"];
      const d = cosh2(a) - Math.cos(b);
      return new Complex(
        sinh2(a) / d,
        -Math.sin(b) / d
      );
    },
    /**
     * Calculate the complex csch
     *
     * @returns {Complex}
     */
    "csch": function() {
      const a = this["re"];
      const b = this["im"];
      const d = Math.cos(2 * b) - cosh2(2 * a);
      return new Complex(
        -2 * sinh2(a) * Math.cos(b) / d,
        2 * cosh2(a) * Math.sin(b) / d
      );
    },
    /**
     * Calculate the complex sech
     *
     * @returns {Complex}
     */
    "sech": function() {
      const a = this["re"];
      const b = this["im"];
      const d = Math.cos(2 * b) + cosh2(2 * a);
      return new Complex(
        2 * cosh2(a) * Math.cos(b) / d,
        -2 * sinh2(a) * Math.sin(b) / d
      );
    },
    /**
     * Calculate the complex asinh
     *
     * @returns {Complex}
     */
    "asinh": function() {
      const a = this["re"];
      const b = this["im"];
      if (b === 0) {
        if (a === 0) {
          return new Complex(0, 0);
        }
        const x = Math.abs(a);
        const r = Math.log(x + Math.sqrt(x * x + 1));
        return new Complex(a < 0 ? -r : r, 0);
      }
      const re2 = a * a - b * b + 1;
      const im2 = 2 * a * b;
      const t = new Complex(re2, im2)["sqrt"]();
      return new Complex(a + t["re"], b + t["im"])["log"]();
    },
    /**
     * Calculate the complex acosh
     *
     * @returns {Complex}
     */
    "acosh": function() {
      const a = this["re"];
      const b = this["im"];
      if (b === 0) {
        if (a > 1) {
          return new Complex(
            Math.log(a + Math.sqrt(a - 1) * Math.sqrt(a + 1)),
            0
          );
        }
        if (a < -1) {
          const t = Math.sqrt(a * a - 1);
          return new Complex(Math.log(-a + t), Math.PI);
        }
        return new Complex(0, Math.acos(a));
      }
      const t1 = new Complex(a - 1, b)["sqrt"]();
      const t2 = new Complex(a + 1, b)["sqrt"]();
      return new Complex(
        a + t1["re"] * t2["re"] - t1["im"] * t2["im"],
        b + t1["re"] * t2["im"] + t1["im"] * t2["re"]
      )["log"]();
    },
    /**
     * Calculate the complex atanh
     *
     * @returns {Complex}
     */
    "atanh": function() {
      const a = this["re"];
      const b = this["im"];
      if (b === 0) {
        if (a === 0) {
          return new Complex(0, 0);
        }
        if (a === 1) {
          return new Complex(Infinity, 0);
        }
        if (a === -1) {
          return new Complex(-Infinity, 0);
        }
        if (-1 < a && a < 1) {
          return new Complex(
            0.5 * Math.log((1 + a) / (1 - a)),
            0
          );
        }
        if (a > 1) {
          const t2 = (a + 1) / (a - 1);
          return new Complex(
            0.5 * Math.log(t2),
            -Math.PI / 2
          );
        }
        const t = (1 + a) / (1 - a);
        return new Complex(
          0.5 * Math.log(-t),
          // log((1 - a)/(1 + a))
          Math.PI / 2
        );
      }
      const oneMinus = 1 - a;
      const onePlus = 1 + a;
      const d = oneMinus * oneMinus + b * b;
      if (d === 0) {
        return new Complex(
          a !== -1 ? a / 0 : 0,
          b !== 0 ? b / 0 : 0
        );
      }
      const xr = (onePlus * oneMinus - b * b) / d;
      const xi = (b * oneMinus + onePlus * b) / d;
      return new Complex(
        logHypot(xr, xi) / 2,
        Math.atan2(xi, xr) / 2
      );
    },
    /**
     * Calculate the complex acoth
     *
     * @returns {Complex}
     */
    "acoth": function() {
      const a = this["re"];
      const b = this["im"];
      if (a === 0 && b === 0) {
        return new Complex(0, Math.PI / 2);
      }
      const d = a * a + b * b;
      if (d !== 0) {
        return new Complex(a / d, -b / d)["atanh"]();
      }
      return new Complex(
        a !== 0 ? a / 0 : 0,
        b !== 0 ? -b / 0 : 0
      )["atanh"]();
    },
    /**
     * Calculate the complex acsch
     *
     * @returns {Complex}
     */
    "acsch": function() {
      const a = this["re"];
      const b = this["im"];
      if (b === 0) {
        if (a === 0) {
          return new Complex(Infinity, 0);
        }
        const inv = 1 / a;
        return new Complex(
          Math.log(inv + Math.sqrt(inv * inv + 1)),
          0
        );
      }
      const d = a * a + b * b;
      if (d !== 0) {
        return new Complex(a / d, -b / d)["asinh"]();
      }
      return new Complex(
        a !== 0 ? a / 0 : 0,
        b !== 0 ? -b / 0 : 0
      )["asinh"]();
    },
    /**
     * Calculate the complex asech
     *
     * @returns {Complex}
     */
    "asech": function() {
      const a = this["re"];
      const b = this["im"];
      if (this["isZero"]()) {
        return Complex["INFINITY"];
      }
      const d = a * a + b * b;
      if (d !== 0) {
        return new Complex(a / d, -b / d)["acosh"]();
      }
      return new Complex(
        a !== 0 ? a / 0 : 0,
        b !== 0 ? -b / 0 : 0
      )["acosh"]();
    },
    /**
     * Calculate the complex inverse 1/z
     *
     * @returns {Complex}
     */
    "inverse": function() {
      if (this["isZero"]()) {
        return Complex["INFINITY"];
      }
      if (this["isInfinite"]()) {
        return Complex["ZERO"];
      }
      const a = this["re"];
      const b = this["im"];
      const d = a * a + b * b;
      return new Complex(a / d, -b / d);
    },
    /**
     * Returns the complex conjugate
     *
     * @returns {Complex}
     */
    "conjugate": function() {
      return new Complex(this["re"], -this["im"]);
    },
    /**
     * Gets the negated complex number
     *
     * @returns {Complex}
     */
    "neg": function() {
      return new Complex(-this["re"], -this["im"]);
    },
    /**
     * Ceils the actual complex number
     *
     * @returns {Complex}
     */
    "ceil": function(places) {
      places = Math.pow(10, places || 0);
      return new Complex(
        Math.ceil(this["re"] * places) / places,
        Math.ceil(this["im"] * places) / places
      );
    },
    /**
     * Floors the actual complex number
     *
     * @returns {Complex}
     */
    "floor": function(places) {
      places = Math.pow(10, places || 0);
      return new Complex(
        Math.floor(this["re"] * places) / places,
        Math.floor(this["im"] * places) / places
      );
    },
    /**
     * Ceils the actual complex number
     *
     * @returns {Complex}
     */
    "round": function(places) {
      places = Math.pow(10, places || 0);
      return new Complex(
        Math.round(this["re"] * places) / places,
        Math.round(this["im"] * places) / places
      );
    },
    /**
     * Compares two complex numbers
     *
     * **Note:** new Complex(Infinity).equals(Infinity) === false
     *
     * @returns {boolean}
     */
    "equals": function(a, b) {
      const z = parse(a, b);
      return Math.abs(z["re"] - this["re"]) <= Complex["EPSILON"] && Math.abs(z["im"] - this["im"]) <= Complex["EPSILON"];
    },
    /**
     * Clones the actual object
     *
     * @returns {Complex}
     */
    "clone": function() {
      return new Complex(this["re"], this["im"]);
    },
    /**
     * Gets a string of the actual complex number
     *
     * @returns {string}
     */
    "toString": function() {
      let a = this["re"];
      let b = this["im"];
      let ret = "";
      if (this["isNaN"]()) {
        return "NaN";
      }
      if (this["isInfinite"]()) {
        return "Infinity";
      }
      if (Math.abs(a) < Complex["EPSILON"]) {
        a = 0;
      }
      if (Math.abs(b) < Complex["EPSILON"]) {
        b = 0;
      }
      if (b === 0) {
        return ret + a;
      }
      if (a !== 0) {
        ret += a;
        ret += " ";
        if (b < 0) {
          b = -b;
          ret += "-";
        } else {
          ret += "+";
        }
        ret += " ";
      } else if (b < 0) {
        b = -b;
        ret += "-";
      }
      if (1 !== b) {
        ret += b;
      }
      return ret + "i";
    },
    /**
     * Returns the actual number as a vector
     *
     * @returns {Array}
     */
    "toVector": function() {
      return [this["re"], this["im"]];
    },
    /**
     * Returns the actual real value of the current object
     *
     * @returns {number|null}
     */
    "valueOf": function() {
      if (this["im"] === 0) {
        return this["re"];
      }
      return null;
    },
    /**
     * Determines whether a complex number is not on the Riemann sphere.
     *
     * @returns {boolean}
     */
    "isNaN": function() {
      return isNaN(this["re"]) || isNaN(this["im"]);
    },
    /**
     * Determines whether or not a complex number is at the zero pole of the
     * Riemann sphere.
     *
     * @returns {boolean}
     */
    "isZero": function() {
      return this["im"] === 0 && this["re"] === 0;
    },
    /**
     * Determines whether a complex number is not at the infinity pole of the
     * Riemann sphere.
     *
     * @returns {boolean}
     */
    "isFinite": function() {
      return isFinite(this["re"]) && isFinite(this["im"]);
    },
    /**
     * Determines whether or not a complex number is at the infinity pole of the
     * Riemann sphere.
     *
     * @returns {boolean}
     */
    "isInfinite": function() {
      return !this["isFinite"]();
    }
  };
  Complex["ZERO"] = new Complex(0, 0);
  Complex["ONE"] = new Complex(1, 0);
  Complex["I"] = new Complex(0, 1);
  Complex["PI"] = new Complex(Math.PI, 0);
  Complex["E"] = new Complex(Math.E, 0);
  Complex["INFINITY"] = new Complex(Infinity, Infinity);
  Complex["NAN"] = new Complex(NaN, NaN);
  Complex["EPSILON"] = 1e-15;

  // node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/esm/type/complex/Complex.js
  var name2 = "Complex";
  var dependencies3 = [];
  var createComplexClass = /* @__PURE__ */ factory(name2, dependencies3, () => {
    Object.defineProperty(Complex, "name", {
      value: "Complex"
    });
    Complex.prototype.constructor = Complex;
    Complex.prototype.type = "Complex";
    Complex.prototype.isComplex = true;
    Complex.prototype.toJSON = function() {
      return {
        mathjs: "Complex",
        re: this.re,
        im: this.im
      };
    };
    Complex.prototype.toPolar = function() {
      return {
        r: this.abs(),
        phi: this.arg()
      };
    };
    Complex.prototype.format = function(options) {
      var str = "";
      var im = this.im;
      var re = this.re;
      var strRe = format(this.re, options);
      var strIm = format(this.im, options);
      var precision = isNumber(options) ? options : options ? options.precision : null;
      if (precision !== null) {
        var epsilon = Math.pow(10, -precision);
        if (Math.abs(re / im) < epsilon) {
          re = 0;
        }
        if (Math.abs(im / re) < epsilon) {
          im = 0;
        }
      }
      if (im === 0) {
        str = strRe;
      } else if (re === 0) {
        if (im === 1) {
          str = "i";
        } else if (im === -1) {
          str = "-i";
        } else {
          str = strIm + "i";
        }
      } else {
        if (im < 0) {
          if (im === -1) {
            str = strRe + " - i";
          } else {
            str = strRe + " - " + strIm.substring(1) + "i";
          }
        } else {
          if (im === 1) {
            str = strRe + " + i";
          } else {
            str = strRe + " + " + strIm + "i";
          }
        }
      }
      return str;
    };
    Complex.fromPolar = function(args) {
      switch (arguments.length) {
        case 1: {
          var arg = arguments[0];
          if (typeof arg === "object") {
            return Complex(arg);
          } else {
            throw new TypeError("Input has to be an object with r and phi keys.");
          }
        }
        case 2: {
          var r = arguments[0];
          var phi = arguments[1];
          if (isNumber(r)) {
            if (isUnit(phi) && phi.hasBase("ANGLE")) {
              phi = phi.toNumber("rad");
            }
            if (isNumber(phi)) {
              return new Complex({
                r,
                phi
              });
            }
            throw new TypeError("Phi is not a number nor an angle unit.");
          } else {
            throw new TypeError("Radius r is not a number.");
          }
        }
        default:
          throw new SyntaxError("Wrong number of arguments in function fromPolar");
      }
    };
    Complex.prototype.valueOf = Complex.prototype.toString;
    Complex.fromJSON = function(json) {
      return new Complex(json);
    };
    Complex.compare = function(a, b) {
      if (a.re > b.re) {
        return 1;
      }
      if (a.re < b.re) {
        return -1;
      }
      if (a.im > b.im) {
        return 1;
      }
      if (a.im < b.im) {
        return -1;
      }
      return 0;
    };
    return Complex;
  }, {
    isClass: true
  });

  // node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/esm/type/fraction/Fraction.js
  var import_fraction = __toESM(require_fraction(), 1);
  var name3 = "Fraction";
  var dependencies4 = [];
  var createFractionClass = /* @__PURE__ */ factory(name3, dependencies4, () => {
    Object.defineProperty(import_fraction.default, "name", {
      value: "Fraction"
    });
    import_fraction.default.prototype.constructor = import_fraction.default;
    import_fraction.default.prototype.type = "Fraction";
    import_fraction.default.prototype.isFraction = true;
    import_fraction.default.prototype.toJSON = function() {
      return {
        mathjs: "Fraction",
        n: this.s * this.n,
        d: this.d
      };
    };
    import_fraction.default.fromJSON = function(json) {
      return new import_fraction.default(json);
    };
    return import_fraction.default;
  }, {
    isClass: true
  });

  // node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/esm/type/matrix/Matrix.js
  var name4 = "Matrix";
  var dependencies5 = [];
  var createMatrixClass = /* @__PURE__ */ factory(name4, dependencies5, () => {
    function Matrix2() {
      if (!(this instanceof Matrix2)) {
        throw new SyntaxError("Constructor must be called with the new operator");
      }
    }
    Matrix2.prototype.type = "Matrix";
    Matrix2.prototype.isMatrix = true;
    Matrix2.prototype.storage = function() {
      throw new Error("Cannot invoke storage on a Matrix interface");
    };
    Matrix2.prototype.datatype = function() {
      throw new Error("Cannot invoke datatype on a Matrix interface");
    };
    Matrix2.prototype.create = function(data, datatype) {
      throw new Error("Cannot invoke create on a Matrix interface");
    };
    Matrix2.prototype.subset = function(index, replacement, defaultValue) {
      throw new Error("Cannot invoke subset on a Matrix interface");
    };
    Matrix2.prototype.get = function(index) {
      throw new Error("Cannot invoke get on a Matrix interface");
    };
    Matrix2.prototype.set = function(index, value, defaultValue) {
      throw new Error("Cannot invoke set on a Matrix interface");
    };
    Matrix2.prototype.resize = function(size2, defaultValue) {
      throw new Error("Cannot invoke resize on a Matrix interface");
    };
    Matrix2.prototype.reshape = function(size2, defaultValue) {
      throw new Error("Cannot invoke reshape on a Matrix interface");
    };
    Matrix2.prototype.clone = function() {
      throw new Error("Cannot invoke clone on a Matrix interface");
    };
    Matrix2.prototype.size = function() {
      throw new Error("Cannot invoke size on a Matrix interface");
    };
    Matrix2.prototype.map = function(callback, skipZeros) {
      throw new Error("Cannot invoke map on a Matrix interface");
    };
    Matrix2.prototype.forEach = function(callback) {
      throw new Error("Cannot invoke forEach on a Matrix interface");
    };
    Matrix2.prototype[Symbol.iterator] = function() {
      throw new Error("Cannot iterate a Matrix interface");
    };
    Matrix2.prototype.toArray = function() {
      throw new Error("Cannot invoke toArray on a Matrix interface");
    };
    Matrix2.prototype.valueOf = function() {
      throw new Error("Cannot invoke valueOf on a Matrix interface");
    };
    Matrix2.prototype.format = function(options) {
      throw new Error("Cannot invoke format on a Matrix interface");
    };
    Matrix2.prototype.toString = function() {
      throw new Error("Cannot invoke toString on a Matrix interface");
    };
    return Matrix2;
  }, {
    isClass: true
  });

  // node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/esm/utils/bignumber/formatter.js
  function formatBigNumberToBase(n, base, size2) {
    var BigNumberCtor = n.constructor;
    var big2 = new BigNumberCtor(2);
    var suffix = "";
    if (size2) {
      if (size2 < 1) {
        throw new Error("size must be in greater than 0");
      }
      if (!isInteger(size2)) {
        throw new Error("size must be an integer");
      }
      if (n.greaterThan(big2.pow(size2 - 1).sub(1)) || n.lessThan(big2.pow(size2 - 1).mul(-1))) {
        throw new Error("Value must be in range [-2^".concat(size2 - 1, ", 2^").concat(size2 - 1, "-1]"));
      }
      if (!n.isInteger()) {
        throw new Error("Value must be an integer");
      }
      if (n.lessThan(0)) {
        n = n.add(big2.pow(size2));
      }
      suffix = "i".concat(size2);
    }
    switch (base) {
      case 2:
        return "".concat(n.toBinary()).concat(suffix);
      case 8:
        return "".concat(n.toOctal()).concat(suffix);
      case 16:
        return "".concat(n.toHexadecimal()).concat(suffix);
      default:
        throw new Error("Base ".concat(base, " not supported "));
    }
  }
  function format2(value, options) {
    if (typeof options === "function") {
      return options(value);
    }
    if (!value.isFinite()) {
      return value.isNaN() ? "NaN" : value.gt(0) ? "Infinity" : "-Infinity";
    }
    var {
      notation,
      precision,
      wordSize
    } = normalizeFormatOptions(options);
    switch (notation) {
      case "fixed":
        return toFixed2(value, precision);
      case "exponential":
        return toExponential2(value, precision);
      case "engineering":
        return toEngineering2(value, precision);
      case "bin":
        return formatBigNumberToBase(value, 2, wordSize);
      case "oct":
        return formatBigNumberToBase(value, 8, wordSize);
      case "hex":
        return formatBigNumberToBase(value, 16, wordSize);
      case "auto": {
        var lowerExp = _toNumberOrDefault2(options === null || options === void 0 ? void 0 : options.lowerExp, -3);
        var upperExp = _toNumberOrDefault2(options === null || options === void 0 ? void 0 : options.upperExp, 5);
        if (value.isZero()) return "0";
        var str;
        var rounded = value.toSignificantDigits(precision);
        var exp2 = rounded.e;
        if (exp2 >= lowerExp && exp2 < upperExp) {
          str = rounded.toFixed();
        } else {
          str = toExponential2(value, precision);
        }
        return str.replace(/((\.\d*?)(0+))($|e)/, function() {
          var digits2 = arguments[2];
          var e = arguments[4];
          return digits2 !== "." ? digits2 + e : e;
        });
      }
      default:
        throw new Error('Unknown notation "' + notation + '". Choose "auto", "exponential", "fixed", "bin", "oct", or "hex.');
    }
  }
  function toEngineering2(value, precision) {
    var e = value.e;
    var newExp = e % 3 === 0 ? e : e < 0 ? e - 3 - e % 3 : e - e % 3;
    var valueWithoutExp = value.mul(Math.pow(10, -newExp));
    var valueStr = valueWithoutExp.toPrecision(precision);
    if (valueStr.includes("e")) {
      var BigNumber2 = value.constructor;
      valueStr = new BigNumber2(valueStr).toFixed();
    }
    return valueStr + "e" + (e >= 0 ? "+" : "") + newExp.toString();
  }
  function toExponential2(value, precision) {
    if (precision !== void 0) {
      return value.toExponential(precision - 1);
    } else {
      return value.toExponential();
    }
  }
  function toFixed2(value, precision) {
    return value.toFixed(precision);
  }
  function _toNumberOrDefault2(value, defaultValue) {
    if (isNumber(value)) {
      return value;
    } else if (isBigNumber(value)) {
      return value.toNumber();
    } else {
      return defaultValue;
    }
  }

  // node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/esm/utils/string.js
  function format3(value, options) {
    var result = _format(value, options);
    if (options && typeof options === "object" && "truncate" in options && result.length > options.truncate) {
      return result.substring(0, options.truncate - 3) + "...";
    }
    return result;
  }
  function _format(value, options) {
    if (typeof value === "number") {
      return format(value, options);
    }
    if (isBigNumber(value)) {
      return format2(value, options);
    }
    if (looksLikeFraction(value)) {
      if (!options || options.fraction !== "decimal") {
        return value.s * value.n + "/" + value.d;
      } else {
        return value.toString();
      }
    }
    if (Array.isArray(value)) {
      return formatArray(value, options);
    }
    if (isString(value)) {
      return stringify(value);
    }
    if (typeof value === "function") {
      return value.syntax ? String(value.syntax) : "function";
    }
    if (value && typeof value === "object") {
      if (typeof value.format === "function") {
        return value.format(options);
      } else if (value && value.toString(options) !== {}.toString()) {
        return value.toString(options);
      } else {
        var entries = Object.keys(value).map((key) => {
          return stringify(key) + ": " + format3(value[key], options);
        });
        return "{" + entries.join(", ") + "}";
      }
    }
    return String(value);
  }
  function stringify(value) {
    var text = String(value);
    var escaped = "";
    var i = 0;
    while (i < text.length) {
      var c = text.charAt(i);
      escaped += c in controlCharacters ? controlCharacters[c] : c;
      i++;
    }
    return '"' + escaped + '"';
  }
  var controlCharacters = {
    '"': '\\"',
    "\\": "\\\\",
    "\b": "\\b",
    "\f": "\\f",
    "\n": "\\n",
    "\r": "\\r",
    "	": "\\t"
  };
  function formatArray(array, options) {
    if (Array.isArray(array)) {
      var str = "[";
      var len = array.length;
      for (var i = 0; i < len; i++) {
        if (i !== 0) {
          str += ", ";
        }
        str += formatArray(array[i], options);
      }
      str += "]";
      return str;
    } else {
      return format3(array, options);
    }
  }
  function looksLikeFraction(value) {
    return value && typeof value === "object" && typeof value.s === "number" && typeof value.n === "number" && typeof value.d === "number" || false;
  }

  // node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/esm/error/DimensionError.js
  function DimensionError(actual, expected, relation) {
    if (!(this instanceof DimensionError)) {
      throw new SyntaxError("Constructor must be called with the new operator");
    }
    this.actual = actual;
    this.expected = expected;
    this.relation = relation;
    this.message = "Dimension mismatch (" + (Array.isArray(actual) ? "[" + actual.join(", ") + "]" : actual) + " " + (this.relation || "!=") + " " + (Array.isArray(expected) ? "[" + expected.join(", ") + "]" : expected) + ")";
    this.stack = new Error().stack;
  }
  DimensionError.prototype = new RangeError();
  DimensionError.prototype.constructor = RangeError;
  DimensionError.prototype.name = "DimensionError";
  DimensionError.prototype.isDimensionError = true;

  // node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/esm/error/IndexError.js
  function IndexError(index, min2, max2) {
    if (!(this instanceof IndexError)) {
      throw new SyntaxError("Constructor must be called with the new operator");
    }
    this.index = index;
    if (arguments.length < 3) {
      this.min = 0;
      this.max = min2;
    } else {
      this.min = min2;
      this.max = max2;
    }
    if (this.min !== void 0 && this.index < this.min) {
      this.message = "Index out of range (" + this.index + " < " + this.min + ")";
    } else if (this.max !== void 0 && this.index >= this.max) {
      this.message = "Index out of range (" + this.index + " > " + (this.max - 1) + ")";
    } else {
      this.message = "Index out of range (" + this.index + ")";
    }
    this.stack = new Error().stack;
  }
  IndexError.prototype = new RangeError();
  IndexError.prototype.constructor = RangeError;
  IndexError.prototype.name = "IndexError";
  IndexError.prototype.isIndexError = true;

  // node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/esm/utils/array.js
  function arraySize(x) {
    var s = [];
    while (Array.isArray(x)) {
      s.push(x.length);
      x = x[0];
    }
    return s;
  }
  function _validate(array, size2, dim) {
    var i;
    var len = array.length;
    if (len !== size2[dim]) {
      throw new DimensionError(len, size2[dim]);
    }
    if (dim < size2.length - 1) {
      var dimNext = dim + 1;
      for (i = 0; i < len; i++) {
        var child = array[i];
        if (!Array.isArray(child)) {
          throw new DimensionError(size2.length - 1, size2.length, "<");
        }
        _validate(array[i], size2, dimNext);
      }
    } else {
      for (i = 0; i < len; i++) {
        if (Array.isArray(array[i])) {
          throw new DimensionError(size2.length + 1, size2.length, ">");
        }
      }
    }
  }
  function validate(array, size2) {
    var isScalar = size2.length === 0;
    if (isScalar) {
      if (Array.isArray(array)) {
        throw new DimensionError(array.length, 0);
      }
    } else {
      _validate(array, size2, 0);
    }
  }
  function validateIndex(index, length) {
    if (index !== void 0) {
      if (!isNumber(index) || !isInteger(index)) {
        throw new TypeError("Index must be an integer (value: " + index + ")");
      }
      if (index < 0 || typeof length === "number" && index >= length) {
        throw new IndexError(index, length);
      }
    }
  }
  function resize(array, size2, defaultValue) {
    if (!Array.isArray(size2)) {
      throw new TypeError("Array expected");
    }
    if (size2.length === 0) {
      throw new Error("Resizing to scalar is not supported");
    }
    size2.forEach(function(value) {
      if (!isNumber(value) || !isInteger(value) || value < 0) {
        throw new TypeError("Invalid size, must contain positive integers (size: " + format3(size2) + ")");
      }
    });
    if (isNumber(array) || isBigNumber(array)) {
      array = [array];
    }
    var _defaultValue = defaultValue !== void 0 ? defaultValue : 0;
    _resize(array, size2, 0, _defaultValue);
    return array;
  }
  function _resize(array, size2, dim, defaultValue) {
    var i;
    var elem;
    var oldLen = array.length;
    var newLen = size2[dim];
    var minLen = Math.min(oldLen, newLen);
    array.length = newLen;
    if (dim < size2.length - 1) {
      var dimNext = dim + 1;
      for (i = 0; i < minLen; i++) {
        elem = array[i];
        if (!Array.isArray(elem)) {
          elem = [elem];
          array[i] = elem;
        }
        _resize(elem, size2, dimNext, defaultValue);
      }
      for (i = minLen; i < newLen; i++) {
        elem = [];
        array[i] = elem;
        _resize(elem, size2, dimNext, defaultValue);
      }
    } else {
      for (i = 0; i < minLen; i++) {
        while (Array.isArray(array[i])) {
          array[i] = array[i][0];
        }
      }
      for (i = minLen; i < newLen; i++) {
        array[i] = defaultValue;
      }
    }
  }
  function reshape(array, sizes) {
    var flatArray = flatten(array);
    var currentLength = flatArray.length;
    if (!Array.isArray(array) || !Array.isArray(sizes)) {
      throw new TypeError("Array expected");
    }
    if (sizes.length === 0) {
      throw new DimensionError(0, currentLength, "!=");
    }
    sizes = processSizesWildcard(sizes, currentLength);
    var newLength = product(sizes);
    if (currentLength !== newLength) {
      throw new DimensionError(newLength, currentLength, "!=");
    }
    try {
      return _reshape(flatArray, sizes);
    } catch (e) {
      if (e instanceof DimensionError) {
        throw new DimensionError(newLength, currentLength, "!=");
      }
      throw e;
    }
  }
  function processSizesWildcard(sizes, currentLength) {
    var newLength = product(sizes);
    var processedSizes = sizes.slice();
    var WILDCARD = -1;
    var wildCardIndex = sizes.indexOf(WILDCARD);
    var isMoreThanOneWildcard = sizes.indexOf(WILDCARD, wildCardIndex + 1) >= 0;
    if (isMoreThanOneWildcard) {
      throw new Error("More than one wildcard in sizes");
    }
    var hasWildcard = wildCardIndex >= 0;
    var canReplaceWildcard = currentLength % newLength === 0;
    if (hasWildcard) {
      if (canReplaceWildcard) {
        processedSizes[wildCardIndex] = -currentLength / newLength;
      } else {
        throw new Error("Could not replace wildcard, since " + currentLength + " is no multiple of " + -newLength);
      }
    }
    return processedSizes;
  }
  function product(array) {
    return array.reduce((prev, curr) => prev * curr, 1);
  }
  function _reshape(array, sizes) {
    var tmpArray = array;
    var tmpArray2;
    for (var sizeIndex = sizes.length - 1; sizeIndex > 0; sizeIndex--) {
      var size2 = sizes[sizeIndex];
      tmpArray2 = [];
      var length = tmpArray.length / size2;
      for (var i = 0; i < length; i++) {
        tmpArray2.push(tmpArray.slice(i * size2, (i + 1) * size2));
      }
      tmpArray = tmpArray2;
    }
    return tmpArray;
  }
  function unsqueeze(array, dims, outer, size2) {
    var s = size2 || arraySize(array);
    if (outer) {
      for (var i = 0; i < outer; i++) {
        array = [array];
        s.unshift(1);
      }
    }
    array = _unsqueeze(array, dims, 0);
    while (s.length < dims) {
      s.push(1);
    }
    return array;
  }
  function _unsqueeze(array, dims, dim) {
    var i, ii;
    if (Array.isArray(array)) {
      var next = dim + 1;
      for (i = 0, ii = array.length; i < ii; i++) {
        array[i] = _unsqueeze(array[i], dims, next);
      }
    } else {
      for (var d = dim; d < dims; d++) {
        array = [array];
      }
    }
    return array;
  }
  function flatten(array) {
    if (!Array.isArray(array)) {
      return array;
    }
    var flat = [];
    array.forEach(function callback(value) {
      if (Array.isArray(value)) {
        value.forEach(callback);
      } else {
        flat.push(value);
      }
    });
    return flat;
  }
  function getArrayDataType(array, typeOf2) {
    var type;
    var length = 0;
    for (var i = 0; i < array.length; i++) {
      var item = array[i];
      var _isArray = Array.isArray(item);
      if (i === 0 && _isArray) {
        length = item.length;
      }
      if (_isArray && item.length !== length) {
        return void 0;
      }
      var itemType = _isArray ? getArrayDataType(item, typeOf2) : typeOf2(item);
      if (type === void 0) {
        type = itemType;
      } else if (type !== itemType) {
        return "mixed";
      } else {
      }
    }
    return type;
  }
  function concatRecursive(a, b, concatDim, dim) {
    if (dim < concatDim) {
      if (a.length !== b.length) {
        throw new DimensionError(a.length, b.length);
      }
      var c = [];
      for (var i = 0; i < a.length; i++) {
        c[i] = concatRecursive(a[i], b[i], concatDim, dim + 1);
      }
      return c;
    } else {
      return a.concat(b);
    }
  }
  function concat() {
    var arrays = Array.prototype.slice.call(arguments, 0, -1);
    var concatDim = Array.prototype.slice.call(arguments, -1);
    if (arrays.length === 1) {
      return arrays[0];
    }
    if (arrays.length > 1) {
      return arrays.slice(1).reduce(function(A, B) {
        return concatRecursive(A, B, concatDim, 0);
      }, arrays[0]);
    } else {
      throw new Error("Wrong number of arguments in function concat");
    }
  }
  function broadcastSizes() {
    for (var _len = arguments.length, sizes = new Array(_len), _key = 0; _key < _len; _key++) {
      sizes[_key] = arguments[_key];
    }
    var dimensions = sizes.map((s) => s.length);
    var N = Math.max(...dimensions);
    var sizeMax = new Array(N).fill(null);
    for (var i = 0; i < sizes.length; i++) {
      var size2 = sizes[i];
      var dim = dimensions[i];
      for (var j = 0; j < dim; j++) {
        var n = N - dim + j;
        if (size2[j] > sizeMax[n]) {
          sizeMax[n] = size2[j];
        }
      }
    }
    for (var _i = 0; _i < sizes.length; _i++) {
      checkBroadcastingRules(sizes[_i], sizeMax);
    }
    return sizeMax;
  }
  function checkBroadcastingRules(size2, toSize) {
    var N = toSize.length;
    var dim = size2.length;
    for (var j = 0; j < dim; j++) {
      var n = N - dim + j;
      if (size2[j] < toSize[n] && size2[j] > 1 || size2[j] > toSize[n]) {
        throw new Error("shape missmatch: missmatch is found in arg with shape (".concat(size2, ") not possible to broadcast dimension ").concat(dim, " with size ").concat(size2[j], " to size ").concat(toSize[n]));
      }
    }
  }
  function broadcastTo(array, toSize) {
    var Asize = arraySize(array);
    if (deepStrictEqual(Asize, toSize)) {
      return array;
    }
    checkBroadcastingRules(Asize, toSize);
    var broadcastedSize = broadcastSizes(Asize, toSize);
    var N = broadcastedSize.length;
    var paddedSize = [...Array(N - Asize.length).fill(1), ...Asize];
    var A = clone3(array);
    if (Asize.length < N) {
      A = reshape(A, paddedSize);
      Asize = arraySize(A);
    }
    for (var dim = 0; dim < N; dim++) {
      if (Asize[dim] < broadcastedSize[dim]) {
        A = stretch(A, broadcastedSize[dim], dim);
        Asize = arraySize(A);
      }
    }
    return A;
  }
  function stretch(arrayToStretch, sizeToStretch, dimToStretch) {
    return concat(...Array(sizeToStretch).fill(arrayToStretch), dimToStretch);
  }
  function clone3(array) {
    return _extends([], array);
  }

  // node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/esm/utils/function.js
  function maxArgumentCount(fn) {
    return Object.keys(fn.signatures || {}).reduce(function(args, signature) {
      var count = (signature.match(/,/g) || []).length + 1;
      return Math.max(args, count);
    }, -1);
  }

  // node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/esm/type/matrix/DenseMatrix.js
  var name5 = "DenseMatrix";
  var dependencies6 = ["Matrix"];
  var createDenseMatrixClass = /* @__PURE__ */ factory(name5, dependencies6, (_ref) => {
    var {
      Matrix: Matrix2
    } = _ref;
    function DenseMatrix2(data, datatype) {
      if (!(this instanceof DenseMatrix2)) {
        throw new SyntaxError("Constructor must be called with the new operator");
      }
      if (datatype && !isString(datatype)) {
        throw new Error("Invalid datatype: " + datatype);
      }
      if (isMatrix(data)) {
        if (data.type === "DenseMatrix") {
          this._data = clone(data._data);
          this._size = clone(data._size);
          this._datatype = datatype || data._datatype;
        } else {
          this._data = data.toArray();
          this._size = data.size();
          this._datatype = datatype || data._datatype;
        }
      } else if (data && isArray(data.data) && isArray(data.size)) {
        this._data = data.data;
        this._size = data.size;
        validate(this._data, this._size);
        this._datatype = datatype || data.datatype;
      } else if (isArray(data)) {
        this._data = preprocess(data);
        this._size = arraySize(this._data);
        validate(this._data, this._size);
        this._datatype = datatype;
      } else if (data) {
        throw new TypeError("Unsupported type of data (" + typeOf(data) + ")");
      } else {
        this._data = [];
        this._size = [0];
        this._datatype = datatype;
      }
    }
    DenseMatrix2.prototype = new Matrix2();
    DenseMatrix2.prototype.createDenseMatrix = function(data, datatype) {
      return new DenseMatrix2(data, datatype);
    };
    Object.defineProperty(DenseMatrix2, "name", {
      value: "DenseMatrix"
    });
    DenseMatrix2.prototype.constructor = DenseMatrix2;
    DenseMatrix2.prototype.type = "DenseMatrix";
    DenseMatrix2.prototype.isDenseMatrix = true;
    DenseMatrix2.prototype.getDataType = function() {
      return getArrayDataType(this._data, typeOf);
    };
    DenseMatrix2.prototype.storage = function() {
      return "dense";
    };
    DenseMatrix2.prototype.datatype = function() {
      return this._datatype;
    };
    DenseMatrix2.prototype.create = function(data, datatype) {
      return new DenseMatrix2(data, datatype);
    };
    DenseMatrix2.prototype.subset = function(index, replacement, defaultValue) {
      switch (arguments.length) {
        case 1:
          return _get(this, index);
        // intentional fall through
        case 2:
        case 3:
          return _set(this, index, replacement, defaultValue);
        default:
          throw new SyntaxError("Wrong number of arguments");
      }
    };
    DenseMatrix2.prototype.get = function(index) {
      if (!isArray(index)) {
        throw new TypeError("Array expected");
      }
      if (index.length !== this._size.length) {
        throw new DimensionError(index.length, this._size.length);
      }
      for (var x = 0; x < index.length; x++) {
        validateIndex(index[x], this._size[x]);
      }
      var data = this._data;
      for (var i = 0, ii = index.length; i < ii; i++) {
        var indexI = index[i];
        validateIndex(indexI, data.length);
        data = data[indexI];
      }
      return data;
    };
    DenseMatrix2.prototype.set = function(index, value, defaultValue) {
      if (!isArray(index)) {
        throw new TypeError("Array expected");
      }
      if (index.length < this._size.length) {
        throw new DimensionError(index.length, this._size.length, "<");
      }
      var i, ii, indexI;
      var size2 = index.map(function(i2) {
        return i2 + 1;
      });
      _fit(this, size2, defaultValue);
      var data = this._data;
      for (i = 0, ii = index.length - 1; i < ii; i++) {
        indexI = index[i];
        validateIndex(indexI, data.length);
        data = data[indexI];
      }
      indexI = index[index.length - 1];
      validateIndex(indexI, data.length);
      data[indexI] = value;
      return this;
    };
    function _get(matrix2, index) {
      if (!isIndex(index)) {
        throw new TypeError("Invalid index");
      }
      var isScalar = index.isScalar();
      if (isScalar) {
        return matrix2.get(index.min());
      } else {
        var size2 = index.size();
        if (size2.length !== matrix2._size.length) {
          throw new DimensionError(size2.length, matrix2._size.length);
        }
        var min2 = index.min();
        var max2 = index.max();
        for (var i = 0, ii = matrix2._size.length; i < ii; i++) {
          validateIndex(min2[i], matrix2._size[i]);
          validateIndex(max2[i], matrix2._size[i]);
        }
        return new DenseMatrix2(_getSubmatrix(matrix2._data, index, size2.length, 0), matrix2._datatype);
      }
    }
    function _getSubmatrix(data, index, dims, dim) {
      var last = dim === dims - 1;
      var range = index.dimension(dim);
      if (last) {
        return range.map(function(i) {
          validateIndex(i, data.length);
          return data[i];
        }).valueOf();
      } else {
        return range.map(function(i) {
          validateIndex(i, data.length);
          var child = data[i];
          return _getSubmatrix(child, index, dims, dim + 1);
        }).valueOf();
      }
    }
    function _set(matrix2, index, submatrix, defaultValue) {
      if (!index || index.isIndex !== true) {
        throw new TypeError("Invalid index");
      }
      var iSize = index.size();
      var isScalar = index.isScalar();
      var sSize;
      if (isMatrix(submatrix)) {
        sSize = submatrix.size();
        submatrix = submatrix.valueOf();
      } else {
        sSize = arraySize(submatrix);
      }
      if (isScalar) {
        if (sSize.length !== 0) {
          throw new TypeError("Scalar expected");
        }
        matrix2.set(index.min(), submatrix, defaultValue);
      } else {
        if (!deepStrictEqual(sSize, iSize)) {
          try {
            if (sSize.length === 0) {
              submatrix = broadcastTo([submatrix], iSize);
            } else {
              submatrix = broadcastTo(submatrix, iSize);
            }
            sSize = arraySize(submatrix);
          } catch (_unused) {
          }
        }
        if (iSize.length < matrix2._size.length) {
          throw new DimensionError(iSize.length, matrix2._size.length, "<");
        }
        if (sSize.length < iSize.length) {
          var i = 0;
          var outer = 0;
          while (iSize[i] === 1 && sSize[i] === 1) {
            i++;
          }
          while (iSize[i] === 1) {
            outer++;
            i++;
          }
          submatrix = unsqueeze(submatrix, iSize.length, outer, sSize);
        }
        if (!deepStrictEqual(iSize, sSize)) {
          throw new DimensionError(iSize, sSize, ">");
        }
        var size2 = index.max().map(function(i2) {
          return i2 + 1;
        });
        _fit(matrix2, size2, defaultValue);
        var dims = iSize.length;
        var dim = 0;
        _setSubmatrix(matrix2._data, index, submatrix, dims, dim);
      }
      return matrix2;
    }
    function _setSubmatrix(data, index, submatrix, dims, dim) {
      var last = dim === dims - 1;
      var range = index.dimension(dim);
      if (last) {
        range.forEach(function(dataIndex, subIndex) {
          validateIndex(dataIndex);
          data[dataIndex] = submatrix[subIndex[0]];
        });
      } else {
        range.forEach(function(dataIndex, subIndex) {
          validateIndex(dataIndex);
          _setSubmatrix(data[dataIndex], index, submatrix[subIndex[0]], dims, dim + 1);
        });
      }
    }
    DenseMatrix2.prototype.resize = function(size2, defaultValue, copy) {
      if (!isCollection(size2)) {
        throw new TypeError("Array or Matrix expected");
      }
      var sizeArray = size2.valueOf().map((value) => {
        return Array.isArray(value) && value.length === 1 ? value[0] : value;
      });
      var m = copy ? this.clone() : this;
      return _resize2(m, sizeArray, defaultValue);
    };
    function _resize2(matrix2, size2, defaultValue) {
      if (size2.length === 0) {
        var v = matrix2._data;
        while (isArray(v)) {
          v = v[0];
        }
        return v;
      }
      matrix2._size = size2.slice(0);
      matrix2._data = resize(matrix2._data, matrix2._size, defaultValue);
      return matrix2;
    }
    DenseMatrix2.prototype.reshape = function(size2, copy) {
      var m = copy ? this.clone() : this;
      m._data = reshape(m._data, size2);
      var currentLength = m._size.reduce((length, size3) => length * size3);
      m._size = processSizesWildcard(size2, currentLength);
      return m;
    };
    function _fit(matrix2, size2, defaultValue) {
      var newSize = matrix2._size.slice(0);
      var changed = false;
      while (newSize.length < size2.length) {
        newSize.push(0);
        changed = true;
      }
      for (var i = 0, ii = size2.length; i < ii; i++) {
        if (size2[i] > newSize[i]) {
          newSize[i] = size2[i];
          changed = true;
        }
      }
      if (changed) {
        _resize2(matrix2, newSize, defaultValue);
      }
    }
    DenseMatrix2.prototype.clone = function() {
      var m = new DenseMatrix2({
        data: clone(this._data),
        size: clone(this._size),
        datatype: this._datatype
      });
      return m;
    };
    DenseMatrix2.prototype.size = function() {
      return this._size.slice(0);
    };
    DenseMatrix2.prototype.map = function(callback) {
      var me = this;
      var args = maxArgumentCount(callback);
      var recurse = function recurse2(value, index) {
        if (isArray(value)) {
          return value.map(function(child, i) {
            return recurse2(child, index.concat(i));
          });
        } else {
          if (args === 1) {
            return callback(value);
          } else if (args === 2) {
            return callback(value, index);
          } else {
            return callback(value, index, me);
          }
        }
      };
      var data = recurse(this._data, []);
      var datatype = this._datatype !== void 0 ? getArrayDataType(data, typeOf) : void 0;
      return new DenseMatrix2(data, datatype);
    };
    DenseMatrix2.prototype.forEach = function(callback) {
      var me = this;
      var recurse = function recurse2(value, index) {
        if (isArray(value)) {
          value.forEach(function(child, i) {
            recurse2(child, index.concat(i));
          });
        } else {
          callback(value, index, me);
        }
      };
      recurse(this._data, []);
    };
    DenseMatrix2.prototype[Symbol.iterator] = function* () {
      var recurse = function* recurse2(value, index) {
        if (isArray(value)) {
          for (var i = 0; i < value.length; i++) {
            yield* recurse2(value[i], index.concat(i));
          }
        } else {
          yield {
            value,
            index
          };
        }
      };
      yield* recurse(this._data, []);
    };
    DenseMatrix2.prototype.rows = function() {
      var result = [];
      var s = this.size();
      if (s.length !== 2) {
        throw new TypeError("Rows can only be returned for a 2D matrix.");
      }
      var data = this._data;
      for (var row of data) {
        result.push(new DenseMatrix2([row], this._datatype));
      }
      return result;
    };
    DenseMatrix2.prototype.columns = function() {
      var _this = this;
      var result = [];
      var s = this.size();
      if (s.length !== 2) {
        throw new TypeError("Rows can only be returned for a 2D matrix.");
      }
      var data = this._data;
      var _loop = function _loop2(i2) {
        var col = data.map((row) => [row[i2]]);
        result.push(new DenseMatrix2(col, _this._datatype));
      };
      for (var i = 0; i < s[1]; i++) {
        _loop(i);
      }
      return result;
    };
    DenseMatrix2.prototype.toArray = function() {
      return clone(this._data);
    };
    DenseMatrix2.prototype.valueOf = function() {
      return this._data;
    };
    DenseMatrix2.prototype.format = function(options) {
      return format3(this._data, options);
    };
    DenseMatrix2.prototype.toString = function() {
      return format3(this._data);
    };
    DenseMatrix2.prototype.toJSON = function() {
      return {
        mathjs: "DenseMatrix",
        data: this._data,
        size: this._size,
        datatype: this._datatype
      };
    };
    DenseMatrix2.prototype.diagonal = function(k) {
      if (k) {
        if (isBigNumber(k)) {
          k = k.toNumber();
        }
        if (!isNumber(k) || !isInteger(k)) {
          throw new TypeError("The parameter k must be an integer number");
        }
      } else {
        k = 0;
      }
      var kSuper = k > 0 ? k : 0;
      var kSub = k < 0 ? -k : 0;
      var rows = this._size[0];
      var columns = this._size[1];
      var n = Math.min(rows - kSub, columns - kSuper);
      var data = [];
      for (var i = 0; i < n; i++) {
        data[i] = this._data[i + kSub][i + kSuper];
      }
      return new DenseMatrix2({
        data,
        size: [n],
        datatype: this._datatype
      });
    };
    DenseMatrix2.diagonal = function(size2, value, k, defaultValue) {
      if (!isArray(size2)) {
        throw new TypeError("Array expected, size parameter");
      }
      if (size2.length !== 2) {
        throw new Error("Only two dimensions matrix are supported");
      }
      size2 = size2.map(function(s) {
        if (isBigNumber(s)) {
          s = s.toNumber();
        }
        if (!isNumber(s) || !isInteger(s) || s < 1) {
          throw new Error("Size values must be positive integers");
        }
        return s;
      });
      if (k) {
        if (isBigNumber(k)) {
          k = k.toNumber();
        }
        if (!isNumber(k) || !isInteger(k)) {
          throw new TypeError("The parameter k must be an integer number");
        }
      } else {
        k = 0;
      }
      var kSuper = k > 0 ? k : 0;
      var kSub = k < 0 ? -k : 0;
      var rows = size2[0];
      var columns = size2[1];
      var n = Math.min(rows - kSub, columns - kSuper);
      var _value;
      if (isArray(value)) {
        if (value.length !== n) {
          throw new Error("Invalid value array length");
        }
        _value = function _value2(i) {
          return value[i];
        };
      } else if (isMatrix(value)) {
        var ms = value.size();
        if (ms.length !== 1 || ms[0] !== n) {
          throw new Error("Invalid matrix length");
        }
        _value = function _value2(i) {
          return value.get([i]);
        };
      } else {
        _value = function _value2() {
          return value;
        };
      }
      if (!defaultValue) {
        defaultValue = isBigNumber(_value(0)) ? _value(0).mul(0) : 0;
      }
      var data = [];
      if (size2.length > 0) {
        data = resize(data, size2, defaultValue);
        for (var d = 0; d < n; d++) {
          data[d + kSub][d + kSuper] = _value(d);
        }
      }
      return new DenseMatrix2({
        data,
        size: [rows, columns]
      });
    };
    DenseMatrix2.fromJSON = function(json) {
      return new DenseMatrix2(json);
    };
    DenseMatrix2.prototype.swapRows = function(i, j) {
      if (!isNumber(i) || !isInteger(i) || !isNumber(j) || !isInteger(j)) {
        throw new Error("Row index must be positive integers");
      }
      if (this._size.length !== 2) {
        throw new Error("Only two dimensional matrix is supported");
      }
      validateIndex(i, this._size[0]);
      validateIndex(j, this._size[0]);
      DenseMatrix2._swapRows(i, j, this._data);
      return this;
    };
    DenseMatrix2._swapRows = function(i, j, data) {
      var vi = data[i];
      data[i] = data[j];
      data[j] = vi;
    };
    function preprocess(data) {
      if (isMatrix(data)) {
        return preprocess(data.valueOf());
      }
      if (isArray(data)) {
        return data.map(preprocess);
      }
      return data;
    }
    return DenseMatrix2;
  }, {
    isClass: true
  });

  // node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/esm/utils/collection.js
  function deepMap(array, callback, skipZeros) {
    if (array && typeof array.map === "function") {
      return array.map(function(x) {
        return deepMap(x, callback, skipZeros);
      });
    } else {
      return callback(array);
    }
  }

  // node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/esm/plain/number/arithmetic.js
  var n1 = "number";
  var n2 = "number, number";
  function absNumber(a) {
    return Math.abs(a);
  }
  absNumber.signature = n1;
  function addNumber(a, b) {
    return a + b;
  }
  addNumber.signature = n2;
  function subtractNumber(a, b) {
    return a - b;
  }
  subtractNumber.signature = n2;
  function multiplyNumber(a, b) {
    return a * b;
  }
  multiplyNumber.signature = n2;
  function divideNumber(a, b) {
    return a / b;
  }
  divideNumber.signature = n2;
  function unaryMinusNumber(x) {
    return -x;
  }
  unaryMinusNumber.signature = n1;
  function unaryPlusNumber(x) {
    return x;
  }
  unaryPlusNumber.signature = n1;
  function cbrtNumber(x) {
    return cbrt(x);
  }
  cbrtNumber.signature = n1;
  function cubeNumber(x) {
    return x * x * x;
  }
  cubeNumber.signature = n1;
  function expNumber(x) {
    return Math.exp(x);
  }
  expNumber.signature = n1;
  function expm1Number(x) {
    return expm1(x);
  }
  expm1Number.signature = n1;
  function gcdNumber(a, b) {
    if (!isInteger(a) || !isInteger(b)) {
      throw new Error("Parameters in function gcd must be integer numbers");
    }
    var r;
    while (b !== 0) {
      r = a % b;
      a = b;
      b = r;
    }
    return a < 0 ? -a : a;
  }
  gcdNumber.signature = n2;
  function lcmNumber(a, b) {
    if (!isInteger(a) || !isInteger(b)) {
      throw new Error("Parameters in function lcm must be integer numbers");
    }
    if (a === 0 || b === 0) {
      return 0;
    }
    var t;
    var prod = a * b;
    while (b !== 0) {
      t = b;
      b = a % t;
      a = t;
    }
    return Math.abs(prod / a);
  }
  lcmNumber.signature = n2;
  function log10Number(x) {
    return log10(x);
  }
  log10Number.signature = n1;
  function log2Number(x) {
    return log2(x);
  }
  log2Number.signature = n1;
  function log1pNumber(x) {
    return log1p(x);
  }
  log1pNumber.signature = n1;
  function modNumber(x, y) {
    return y === 0 ? x : x - y * Math.floor(x / y);
  }
  modNumber.signature = n2;
  function signNumber(x) {
    return sign(x);
  }
  signNumber.signature = n1;
  function sqrtNumber(x) {
    return Math.sqrt(x);
  }
  sqrtNumber.signature = n1;
  function squareNumber(x) {
    return x * x;
  }
  squareNumber.signature = n1;
  function xgcdNumber(a, b) {
    var t;
    var q;
    var r;
    var x = 0;
    var lastx = 1;
    var y = 1;
    var lasty = 0;
    if (!isInteger(a) || !isInteger(b)) {
      throw new Error("Parameters in function xgcd must be integer numbers");
    }
    while (b) {
      q = Math.floor(a / b);
      r = a - q * b;
      t = x;
      x = lastx - q * x;
      lastx = t;
      t = y;
      y = lasty - q * y;
      lasty = t;
      a = b;
      b = r;
    }
    var res;
    if (a < 0) {
      res = [-a, -lastx, -lasty];
    } else {
      res = [a, a ? lastx : 0, lasty];
    }
    return res;
  }
  xgcdNumber.signature = n2;
  function powNumber(x, y) {
    if (x * x < 1 && y === Infinity || x * x > 1 && y === -Infinity) {
      return 0;
    }
    return Math.pow(x, y);
  }
  powNumber.signature = n2;
  function normNumber(x) {
    return Math.abs(x);
  }
  normNumber.signature = n1;

  // node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/esm/utils/bignumber/nearlyEqual.js
  function nearlyEqual2(x, y, epsilon) {
    if (epsilon === null || epsilon === void 0) {
      return x.eq(y);
    }
    if (x.eq(y)) {
      return true;
    }
    if (x.isNaN() || y.isNaN()) {
      return false;
    }
    if (x.isFinite() && y.isFinite()) {
      var diff = x.minus(y).abs();
      if (diff.isZero()) {
        return true;
      } else {
        var max2 = x.constructor.max(x.abs(), y.abs());
        return diff.lte(max2.times(epsilon));
      }
    }
    return false;
  }

  // node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/esm/utils/complex.js
  function complexEquals(x, y, epsilon) {
    return nearlyEqual(x.re, y.re, epsilon) && nearlyEqual(x.im, y.im, epsilon);
  }

  // node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/esm/function/relational/compareUnits.js
  var createCompareUnits = /* @__PURE__ */ factory("compareUnits", ["typed"], (_ref) => {
    var {
      typed: typed2
    } = _ref;
    return {
      "Unit, Unit": typed2.referToSelf((self2) => (x, y) => {
        if (!x.equalBase(y)) {
          throw new Error("Cannot compare units with different base");
        }
        return typed2.find(self2, [x.valueType(), y.valueType()])(x.value, y.value);
      })
    };
  });

  // node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/esm/function/relational/equalScalar.js
  var name6 = "equalScalar";
  var dependencies7 = ["typed", "config"];
  var createEqualScalar = /* @__PURE__ */ factory(name6, dependencies7, (_ref) => {
    var {
      typed: typed2,
      config: config4
    } = _ref;
    var compareUnits = createCompareUnits({
      typed: typed2
    });
    return typed2(name6, {
      "boolean, boolean": function booleanBoolean(x, y) {
        return x === y;
      },
      "number, number": function numberNumber(x, y) {
        return nearlyEqual(x, y, config4.epsilon);
      },
      "BigNumber, BigNumber": function BigNumberBigNumber(x, y) {
        return x.eq(y) || nearlyEqual2(x, y, config4.epsilon);
      },
      "Fraction, Fraction": function FractionFraction(x, y) {
        return x.equals(y);
      },
      "Complex, Complex": function ComplexComplex(x, y) {
        return complexEquals(x, y, config4.epsilon);
      }
    }, compareUnits);
  });
  var createEqualScalarNumber = factory(name6, ["typed", "config"], (_ref2) => {
    var {
      typed: typed2,
      config: config4
    } = _ref2;
    return typed2(name6, {
      "number, number": function numberNumber(x, y) {
        return nearlyEqual(x, y, config4.epsilon);
      }
    });
  });

  // node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/esm/type/matrix/SparseMatrix.js
  var name7 = "SparseMatrix";
  var dependencies8 = ["typed", "equalScalar", "Matrix"];
  var createSparseMatrixClass = /* @__PURE__ */ factory(name7, dependencies8, (_ref) => {
    var {
      typed: typed2,
      equalScalar: equalScalar2,
      Matrix: Matrix2
    } = _ref;
    function SparseMatrix2(data, datatype) {
      if (!(this instanceof SparseMatrix2)) {
        throw new SyntaxError("Constructor must be called with the new operator");
      }
      if (datatype && !isString(datatype)) {
        throw new Error("Invalid datatype: " + datatype);
      }
      if (isMatrix(data)) {
        _createFromMatrix(this, data, datatype);
      } else if (data && isArray(data.index) && isArray(data.ptr) && isArray(data.size)) {
        this._values = data.values;
        this._index = data.index;
        this._ptr = data.ptr;
        this._size = data.size;
        this._datatype = datatype || data.datatype;
      } else if (isArray(data)) {
        _createFromArray(this, data, datatype);
      } else if (data) {
        throw new TypeError("Unsupported type of data (" + typeOf(data) + ")");
      } else {
        this._values = [];
        this._index = [];
        this._ptr = [0];
        this._size = [0, 0];
        this._datatype = datatype;
      }
    }
    function _createFromMatrix(matrix2, source, datatype) {
      if (source.type === "SparseMatrix") {
        matrix2._values = source._values ? clone(source._values) : void 0;
        matrix2._index = clone(source._index);
        matrix2._ptr = clone(source._ptr);
        matrix2._size = clone(source._size);
        matrix2._datatype = datatype || source._datatype;
      } else {
        _createFromArray(matrix2, source.valueOf(), datatype || source._datatype);
      }
    }
    function _createFromArray(matrix2, data, datatype) {
      matrix2._values = [];
      matrix2._index = [];
      matrix2._ptr = [];
      matrix2._datatype = datatype;
      var rows = data.length;
      var columns = 0;
      var eq = equalScalar2;
      var zero = 0;
      if (isString(datatype)) {
        eq = typed2.find(equalScalar2, [datatype, datatype]) || equalScalar2;
        zero = typed2.convert(0, datatype);
      }
      if (rows > 0) {
        var j = 0;
        do {
          matrix2._ptr.push(matrix2._index.length);
          for (var i = 0; i < rows; i++) {
            var row = data[i];
            if (isArray(row)) {
              if (j === 0 && columns < row.length) {
                columns = row.length;
              }
              if (j < row.length) {
                var v = row[j];
                if (!eq(v, zero)) {
                  matrix2._values.push(v);
                  matrix2._index.push(i);
                }
              }
            } else {
              if (j === 0 && columns < 1) {
                columns = 1;
              }
              if (!eq(row, zero)) {
                matrix2._values.push(row);
                matrix2._index.push(i);
              }
            }
          }
          j++;
        } while (j < columns);
      }
      matrix2._ptr.push(matrix2._index.length);
      matrix2._size = [rows, columns];
    }
    SparseMatrix2.prototype = new Matrix2();
    SparseMatrix2.prototype.createSparseMatrix = function(data, datatype) {
      return new SparseMatrix2(data, datatype);
    };
    Object.defineProperty(SparseMatrix2, "name", {
      value: "SparseMatrix"
    });
    SparseMatrix2.prototype.constructor = SparseMatrix2;
    SparseMatrix2.prototype.type = "SparseMatrix";
    SparseMatrix2.prototype.isSparseMatrix = true;
    SparseMatrix2.prototype.getDataType = function() {
      return getArrayDataType(this._values, typeOf);
    };
    SparseMatrix2.prototype.storage = function() {
      return "sparse";
    };
    SparseMatrix2.prototype.datatype = function() {
      return this._datatype;
    };
    SparseMatrix2.prototype.create = function(data, datatype) {
      return new SparseMatrix2(data, datatype);
    };
    SparseMatrix2.prototype.density = function() {
      var rows = this._size[0];
      var columns = this._size[1];
      return rows !== 0 && columns !== 0 ? this._index.length / (rows * columns) : 0;
    };
    SparseMatrix2.prototype.subset = function(index, replacement, defaultValue) {
      if (!this._values) {
        throw new Error("Cannot invoke subset on a Pattern only matrix");
      }
      switch (arguments.length) {
        case 1:
          return _getsubset(this, index);
        // intentional fall through
        case 2:
        case 3:
          return _setsubset(this, index, replacement, defaultValue);
        default:
          throw new SyntaxError("Wrong number of arguments");
      }
    };
    function _getsubset(matrix2, idx) {
      if (!isIndex(idx)) {
        throw new TypeError("Invalid index");
      }
      var isScalar = idx.isScalar();
      if (isScalar) {
        return matrix2.get(idx.min());
      }
      var size2 = idx.size();
      if (size2.length !== matrix2._size.length) {
        throw new DimensionError(size2.length, matrix2._size.length);
      }
      var i, ii, k, kk;
      var min2 = idx.min();
      var max2 = idx.max();
      for (i = 0, ii = matrix2._size.length; i < ii; i++) {
        validateIndex(min2[i], matrix2._size[i]);
        validateIndex(max2[i], matrix2._size[i]);
      }
      var mvalues = matrix2._values;
      var mindex = matrix2._index;
      var mptr = matrix2._ptr;
      var rows = idx.dimension(0);
      var columns = idx.dimension(1);
      var w = [];
      var pv = [];
      rows.forEach(function(i2, r) {
        pv[i2] = r[0];
        w[i2] = true;
      });
      var values = mvalues ? [] : void 0;
      var index = [];
      var ptr = [];
      columns.forEach(function(j) {
        ptr.push(index.length);
        for (k = mptr[j], kk = mptr[j + 1]; k < kk; k++) {
          i = mindex[k];
          if (w[i] === true) {
            index.push(pv[i]);
            if (values) {
              values.push(mvalues[k]);
            }
          }
        }
      });
      ptr.push(index.length);
      return new SparseMatrix2({
        values,
        index,
        ptr,
        size: size2,
        datatype: matrix2._datatype
      });
    }
    function _setsubset(matrix2, index, submatrix, defaultValue) {
      if (!index || index.isIndex !== true) {
        throw new TypeError("Invalid index");
      }
      var iSize = index.size();
      var isScalar = index.isScalar();
      var sSize;
      if (isMatrix(submatrix)) {
        sSize = submatrix.size();
        submatrix = submatrix.toArray();
      } else {
        sSize = arraySize(submatrix);
      }
      if (isScalar) {
        if (sSize.length !== 0) {
          throw new TypeError("Scalar expected");
        }
        matrix2.set(index.min(), submatrix, defaultValue);
      } else {
        if (iSize.length !== 1 && iSize.length !== 2) {
          throw new DimensionError(iSize.length, matrix2._size.length, "<");
        }
        if (sSize.length < iSize.length) {
          var i = 0;
          var outer = 0;
          while (iSize[i] === 1 && sSize[i] === 1) {
            i++;
          }
          while (iSize[i] === 1) {
            outer++;
            i++;
          }
          submatrix = unsqueeze(submatrix, iSize.length, outer, sSize);
        }
        if (!deepStrictEqual(iSize, sSize)) {
          throw new DimensionError(iSize, sSize, ">");
        }
        if (iSize.length === 1) {
          var range = index.dimension(0);
          range.forEach(function(dataIndex, subIndex) {
            validateIndex(dataIndex);
            matrix2.set([dataIndex, 0], submatrix[subIndex[0]], defaultValue);
          });
        } else {
          var firstDimensionRange = index.dimension(0);
          var secondDimensionRange = index.dimension(1);
          firstDimensionRange.forEach(function(firstDataIndex, firstSubIndex) {
            validateIndex(firstDataIndex);
            secondDimensionRange.forEach(function(secondDataIndex, secondSubIndex) {
              validateIndex(secondDataIndex);
              matrix2.set([firstDataIndex, secondDataIndex], submatrix[firstSubIndex[0]][secondSubIndex[0]], defaultValue);
            });
          });
        }
      }
      return matrix2;
    }
    SparseMatrix2.prototype.get = function(index) {
      if (!isArray(index)) {
        throw new TypeError("Array expected");
      }
      if (index.length !== this._size.length) {
        throw new DimensionError(index.length, this._size.length);
      }
      if (!this._values) {
        throw new Error("Cannot invoke get on a Pattern only matrix");
      }
      var i = index[0];
      var j = index[1];
      validateIndex(i, this._size[0]);
      validateIndex(j, this._size[1]);
      var k = _getValueIndex(i, this._ptr[j], this._ptr[j + 1], this._index);
      if (k < this._ptr[j + 1] && this._index[k] === i) {
        return this._values[k];
      }
      return 0;
    };
    SparseMatrix2.prototype.set = function(index, v, defaultValue) {
      if (!isArray(index)) {
        throw new TypeError("Array expected");
      }
      if (index.length !== this._size.length) {
        throw new DimensionError(index.length, this._size.length);
      }
      if (!this._values) {
        throw new Error("Cannot invoke set on a Pattern only matrix");
      }
      var i = index[0];
      var j = index[1];
      var rows = this._size[0];
      var columns = this._size[1];
      var eq = equalScalar2;
      var zero = 0;
      if (isString(this._datatype)) {
        eq = typed2.find(equalScalar2, [this._datatype, this._datatype]) || equalScalar2;
        zero = typed2.convert(0, this._datatype);
      }
      if (i > rows - 1 || j > columns - 1) {
        _resize2(this, Math.max(i + 1, rows), Math.max(j + 1, columns), defaultValue);
        rows = this._size[0];
        columns = this._size[1];
      }
      validateIndex(i, rows);
      validateIndex(j, columns);
      var k = _getValueIndex(i, this._ptr[j], this._ptr[j + 1], this._index);
      if (k < this._ptr[j + 1] && this._index[k] === i) {
        if (!eq(v, zero)) {
          this._values[k] = v;
        } else {
          _remove(k, j, this._values, this._index, this._ptr);
        }
      } else {
        if (!eq(v, zero)) {
          _insert(k, i, j, v, this._values, this._index, this._ptr);
        }
      }
      return this;
    };
    function _getValueIndex(i, top, bottom, index) {
      if (bottom - top === 0) {
        return bottom;
      }
      for (var r = top; r < bottom; r++) {
        if (index[r] === i) {
          return r;
        }
      }
      return top;
    }
    function _remove(k, j, values, index, ptr) {
      values.splice(k, 1);
      index.splice(k, 1);
      for (var x = j + 1; x < ptr.length; x++) {
        ptr[x]--;
      }
    }
    function _insert(k, i, j, v, values, index, ptr) {
      values.splice(k, 0, v);
      index.splice(k, 0, i);
      for (var x = j + 1; x < ptr.length; x++) {
        ptr[x]++;
      }
    }
    SparseMatrix2.prototype.resize = function(size2, defaultValue, copy) {
      if (!isCollection(size2)) {
        throw new TypeError("Array or Matrix expected");
      }
      var sizeArray = size2.valueOf().map((value) => {
        return Array.isArray(value) && value.length === 1 ? value[0] : value;
      });
      if (sizeArray.length !== 2) {
        throw new Error("Only two dimensions matrix are supported");
      }
      sizeArray.forEach(function(value) {
        if (!isNumber(value) || !isInteger(value) || value < 0) {
          throw new TypeError("Invalid size, must contain positive integers (size: " + format3(sizeArray) + ")");
        }
      });
      var m = copy ? this.clone() : this;
      return _resize2(m, sizeArray[0], sizeArray[1], defaultValue);
    };
    function _resize2(matrix2, rows, columns, defaultValue) {
      var value = defaultValue || 0;
      var eq = equalScalar2;
      var zero = 0;
      if (isString(matrix2._datatype)) {
        eq = typed2.find(equalScalar2, [matrix2._datatype, matrix2._datatype]) || equalScalar2;
        zero = typed2.convert(0, matrix2._datatype);
        value = typed2.convert(value, matrix2._datatype);
      }
      var ins = !eq(value, zero);
      var r = matrix2._size[0];
      var c = matrix2._size[1];
      var i, j, k;
      if (columns > c) {
        for (j = c; j < columns; j++) {
          matrix2._ptr[j] = matrix2._values.length;
          if (ins) {
            for (i = 0; i < r; i++) {
              matrix2._values.push(value);
              matrix2._index.push(i);
            }
          }
        }
        matrix2._ptr[columns] = matrix2._values.length;
      } else if (columns < c) {
        matrix2._ptr.splice(columns + 1, c - columns);
        matrix2._values.splice(matrix2._ptr[columns], matrix2._values.length);
        matrix2._index.splice(matrix2._ptr[columns], matrix2._index.length);
      }
      c = columns;
      if (rows > r) {
        if (ins) {
          var n = 0;
          for (j = 0; j < c; j++) {
            matrix2._ptr[j] = matrix2._ptr[j] + n;
            k = matrix2._ptr[j + 1] + n;
            var p = 0;
            for (i = r; i < rows; i++, p++) {
              matrix2._values.splice(k + p, 0, value);
              matrix2._index.splice(k + p, 0, i);
              n++;
            }
          }
          matrix2._ptr[c] = matrix2._values.length;
        }
      } else if (rows < r) {
        var d = 0;
        for (j = 0; j < c; j++) {
          matrix2._ptr[j] = matrix2._ptr[j] - d;
          var k0 = matrix2._ptr[j];
          var k1 = matrix2._ptr[j + 1] - d;
          for (k = k0; k < k1; k++) {
            i = matrix2._index[k];
            if (i > rows - 1) {
              matrix2._values.splice(k, 1);
              matrix2._index.splice(k, 1);
              d++;
            }
          }
        }
        matrix2._ptr[j] = matrix2._values.length;
      }
      matrix2._size[0] = rows;
      matrix2._size[1] = columns;
      return matrix2;
    }
    SparseMatrix2.prototype.reshape = function(sizes, copy) {
      if (!isArray(sizes)) {
        throw new TypeError("Array expected");
      }
      if (sizes.length !== 2) {
        throw new Error("Sparse matrices can only be reshaped in two dimensions");
      }
      sizes.forEach(function(value) {
        if (!isNumber(value) || !isInteger(value) || value <= -2 || value === 0) {
          throw new TypeError("Invalid size, must contain positive integers or -1 (size: " + format3(sizes) + ")");
        }
      });
      var currentLength = this._size[0] * this._size[1];
      sizes = processSizesWildcard(sizes, currentLength);
      var newLength = sizes[0] * sizes[1];
      if (currentLength !== newLength) {
        throw new Error("Reshaping sparse matrix will result in the wrong number of elements");
      }
      var m = copy ? this.clone() : this;
      if (this._size[0] === sizes[0] && this._size[1] === sizes[1]) {
        return m;
      }
      var colIndex = [];
      for (var i = 0; i < m._ptr.length; i++) {
        for (var j = 0; j < m._ptr[i + 1] - m._ptr[i]; j++) {
          colIndex.push(i);
        }
      }
      var values = m._values.slice();
      var rowIndex = m._index.slice();
      for (var _i = 0; _i < m._index.length; _i++) {
        var r1 = rowIndex[_i];
        var c1 = colIndex[_i];
        var flat = r1 * m._size[1] + c1;
        colIndex[_i] = flat % sizes[1];
        rowIndex[_i] = Math.floor(flat / sizes[1]);
      }
      m._values.length = 0;
      m._index.length = 0;
      m._ptr.length = sizes[1] + 1;
      m._size = sizes.slice();
      for (var _i2 = 0; _i2 < m._ptr.length; _i2++) {
        m._ptr[_i2] = 0;
      }
      for (var h = 0; h < values.length; h++) {
        var _i3 = rowIndex[h];
        var _j = colIndex[h];
        var v = values[h];
        var k = _getValueIndex(_i3, m._ptr[_j], m._ptr[_j + 1], m._index);
        _insert(k, _i3, _j, v, m._values, m._index, m._ptr);
      }
      return m;
    };
    SparseMatrix2.prototype.clone = function() {
      var m = new SparseMatrix2({
        values: this._values ? clone(this._values) : void 0,
        index: clone(this._index),
        ptr: clone(this._ptr),
        size: clone(this._size),
        datatype: this._datatype
      });
      return m;
    };
    SparseMatrix2.prototype.size = function() {
      return this._size.slice(0);
    };
    SparseMatrix2.prototype.map = function(callback, skipZeros) {
      if (!this._values) {
        throw new Error("Cannot invoke map on a Pattern only matrix");
      }
      var me = this;
      var rows = this._size[0];
      var columns = this._size[1];
      var args = maxArgumentCount(callback);
      var invoke = function invoke2(v, i, j) {
        if (args === 1) return callback(v);
        if (args === 2) return callback(v, [i, j]);
        return callback(v, [i, j], me);
      };
      return _map(this, 0, rows - 1, 0, columns - 1, invoke, skipZeros);
    };
    function _map(matrix2, minRow, maxRow, minColumn, maxColumn, callback, skipZeros) {
      var values = [];
      var index = [];
      var ptr = [];
      var eq = equalScalar2;
      var zero = 0;
      if (isString(matrix2._datatype)) {
        eq = typed2.find(equalScalar2, [matrix2._datatype, matrix2._datatype]) || equalScalar2;
        zero = typed2.convert(0, matrix2._datatype);
      }
      var invoke = function invoke2(v, x, y) {
        v = callback(v, x, y);
        if (!eq(v, zero)) {
          values.push(v);
          index.push(x);
        }
      };
      for (var j = minColumn; j <= maxColumn; j++) {
        ptr.push(values.length);
        var k0 = matrix2._ptr[j];
        var k1 = matrix2._ptr[j + 1];
        if (skipZeros) {
          for (var k = k0; k < k1; k++) {
            var i = matrix2._index[k];
            if (i >= minRow && i <= maxRow) {
              invoke(matrix2._values[k], i - minRow, j - minColumn);
            }
          }
        } else {
          var _values = {};
          for (var _k = k0; _k < k1; _k++) {
            var _i4 = matrix2._index[_k];
            _values[_i4] = matrix2._values[_k];
          }
          for (var _i5 = minRow; _i5 <= maxRow; _i5++) {
            var value = _i5 in _values ? _values[_i5] : 0;
            invoke(value, _i5 - minRow, j - minColumn);
          }
        }
      }
      ptr.push(values.length);
      return new SparseMatrix2({
        values,
        index,
        ptr,
        size: [maxRow - minRow + 1, maxColumn - minColumn + 1]
      });
    }
    SparseMatrix2.prototype.forEach = function(callback, skipZeros) {
      if (!this._values) {
        throw new Error("Cannot invoke forEach on a Pattern only matrix");
      }
      var me = this;
      var rows = this._size[0];
      var columns = this._size[1];
      for (var j = 0; j < columns; j++) {
        var k0 = this._ptr[j];
        var k1 = this._ptr[j + 1];
        if (skipZeros) {
          for (var k = k0; k < k1; k++) {
            var i = this._index[k];
            callback(this._values[k], [i, j], me);
          }
        } else {
          var values = {};
          for (var _k2 = k0; _k2 < k1; _k2++) {
            var _i6 = this._index[_k2];
            values[_i6] = this._values[_k2];
          }
          for (var _i7 = 0; _i7 < rows; _i7++) {
            var value = _i7 in values ? values[_i7] : 0;
            callback(value, [_i7, j], me);
          }
        }
      }
    };
    SparseMatrix2.prototype[Symbol.iterator] = function* () {
      if (!this._values) {
        throw new Error("Cannot iterate a Pattern only matrix");
      }
      var columns = this._size[1];
      for (var j = 0; j < columns; j++) {
        var k0 = this._ptr[j];
        var k1 = this._ptr[j + 1];
        for (var k = k0; k < k1; k++) {
          var i = this._index[k];
          yield {
            value: this._values[k],
            index: [i, j]
          };
        }
      }
    };
    SparseMatrix2.prototype.toArray = function() {
      return _toArray(this._values, this._index, this._ptr, this._size, true);
    };
    SparseMatrix2.prototype.valueOf = function() {
      return _toArray(this._values, this._index, this._ptr, this._size, false);
    };
    function _toArray(values, index, ptr, size2, copy) {
      var rows = size2[0];
      var columns = size2[1];
      var a = [];
      var i, j;
      for (i = 0; i < rows; i++) {
        a[i] = [];
        for (j = 0; j < columns; j++) {
          a[i][j] = 0;
        }
      }
      for (j = 0; j < columns; j++) {
        var k0 = ptr[j];
        var k1 = ptr[j + 1];
        for (var k = k0; k < k1; k++) {
          i = index[k];
          a[i][j] = values ? copy ? clone(values[k]) : values[k] : 1;
        }
      }
      return a;
    }
    SparseMatrix2.prototype.format = function(options) {
      var rows = this._size[0];
      var columns = this._size[1];
      var density = this.density();
      var str = "Sparse Matrix [" + format3(rows, options) + " x " + format3(columns, options) + "] density: " + format3(density, options) + "\n";
      for (var j = 0; j < columns; j++) {
        var k0 = this._ptr[j];
        var k1 = this._ptr[j + 1];
        for (var k = k0; k < k1; k++) {
          var i = this._index[k];
          str += "\n    (" + format3(i, options) + ", " + format3(j, options) + ") ==> " + (this._values ? format3(this._values[k], options) : "X");
        }
      }
      return str;
    };
    SparseMatrix2.prototype.toString = function() {
      return format3(this.toArray());
    };
    SparseMatrix2.prototype.toJSON = function() {
      return {
        mathjs: "SparseMatrix",
        values: this._values,
        index: this._index,
        ptr: this._ptr,
        size: this._size,
        datatype: this._datatype
      };
    };
    SparseMatrix2.prototype.diagonal = function(k) {
      if (k) {
        if (isBigNumber(k)) {
          k = k.toNumber();
        }
        if (!isNumber(k) || !isInteger(k)) {
          throw new TypeError("The parameter k must be an integer number");
        }
      } else {
        k = 0;
      }
      var kSuper = k > 0 ? k : 0;
      var kSub = k < 0 ? -k : 0;
      var rows = this._size[0];
      var columns = this._size[1];
      var n = Math.min(rows - kSub, columns - kSuper);
      var values = [];
      var index = [];
      var ptr = [];
      ptr[0] = 0;
      for (var j = kSuper; j < columns && values.length < n; j++) {
        var k0 = this._ptr[j];
        var k1 = this._ptr[j + 1];
        for (var x = k0; x < k1; x++) {
          var i = this._index[x];
          if (i === j - kSuper + kSub) {
            values.push(this._values[x]);
            index[values.length - 1] = i - kSub;
            break;
          }
        }
      }
      ptr.push(values.length);
      return new SparseMatrix2({
        values,
        index,
        ptr,
        size: [n, 1]
      });
    };
    SparseMatrix2.fromJSON = function(json) {
      return new SparseMatrix2(json);
    };
    SparseMatrix2.diagonal = function(size2, value, k, defaultValue, datatype) {
      if (!isArray(size2)) {
        throw new TypeError("Array expected, size parameter");
      }
      if (size2.length !== 2) {
        throw new Error("Only two dimensions matrix are supported");
      }
      size2 = size2.map(function(s) {
        if (isBigNumber(s)) {
          s = s.toNumber();
        }
        if (!isNumber(s) || !isInteger(s) || s < 1) {
          throw new Error("Size values must be positive integers");
        }
        return s;
      });
      if (k) {
        if (isBigNumber(k)) {
          k = k.toNumber();
        }
        if (!isNumber(k) || !isInteger(k)) {
          throw new TypeError("The parameter k must be an integer number");
        }
      } else {
        k = 0;
      }
      var eq = equalScalar2;
      var zero = 0;
      if (isString(datatype)) {
        eq = typed2.find(equalScalar2, [datatype, datatype]) || equalScalar2;
        zero = typed2.convert(0, datatype);
      }
      var kSuper = k > 0 ? k : 0;
      var kSub = k < 0 ? -k : 0;
      var rows = size2[0];
      var columns = size2[1];
      var n = Math.min(rows - kSub, columns - kSuper);
      var _value;
      if (isArray(value)) {
        if (value.length !== n) {
          throw new Error("Invalid value array length");
        }
        _value = function _value2(i2) {
          return value[i2];
        };
      } else if (isMatrix(value)) {
        var ms = value.size();
        if (ms.length !== 1 || ms[0] !== n) {
          throw new Error("Invalid matrix length");
        }
        _value = function _value2(i2) {
          return value.get([i2]);
        };
      } else {
        _value = function _value2() {
          return value;
        };
      }
      var values = [];
      var index = [];
      var ptr = [];
      for (var j = 0; j < columns; j++) {
        ptr.push(values.length);
        var i = j - kSuper;
        if (i >= 0 && i < n) {
          var v = _value(i);
          if (!eq(v, zero)) {
            index.push(i + kSub);
            values.push(v);
          }
        }
      }
      ptr.push(values.length);
      return new SparseMatrix2({
        values,
        index,
        ptr,
        size: [rows, columns]
      });
    };
    SparseMatrix2.prototype.swapRows = function(i, j) {
      if (!isNumber(i) || !isInteger(i) || !isNumber(j) || !isInteger(j)) {
        throw new Error("Row index must be positive integers");
      }
      if (this._size.length !== 2) {
        throw new Error("Only two dimensional matrix is supported");
      }
      validateIndex(i, this._size[0]);
      validateIndex(j, this._size[0]);
      SparseMatrix2._swapRows(i, j, this._size[1], this._values, this._index, this._ptr);
      return this;
    };
    SparseMatrix2._forEachRow = function(j, values, index, ptr, callback) {
      var k0 = ptr[j];
      var k1 = ptr[j + 1];
      for (var k = k0; k < k1; k++) {
        callback(index[k], values[k]);
      }
    };
    SparseMatrix2._swapRows = function(x, y, columns, values, index, ptr) {
      for (var j = 0; j < columns; j++) {
        var k0 = ptr[j];
        var k1 = ptr[j + 1];
        var kx = _getValueIndex(x, k0, k1, index);
        var ky = _getValueIndex(y, k0, k1, index);
        if (kx < k1 && ky < k1 && index[kx] === x && index[ky] === y) {
          if (values) {
            var v = values[kx];
            values[kx] = values[ky];
            values[ky] = v;
          }
          continue;
        }
        if (kx < k1 && index[kx] === x && (ky >= k1 || index[ky] !== y)) {
          var vx = values ? values[kx] : void 0;
          index.splice(ky, 0, y);
          if (values) {
            values.splice(ky, 0, vx);
          }
          index.splice(ky <= kx ? kx + 1 : kx, 1);
          if (values) {
            values.splice(ky <= kx ? kx + 1 : kx, 1);
          }
          continue;
        }
        if (ky < k1 && index[ky] === y && (kx >= k1 || index[kx] !== x)) {
          var vy = values ? values[ky] : void 0;
          index.splice(kx, 0, x);
          if (values) {
            values.splice(kx, 0, vy);
          }
          index.splice(kx <= ky ? ky + 1 : ky, 1);
          if (values) {
            values.splice(kx <= ky ? ky + 1 : ky, 1);
          }
        }
      }
    };
    return SparseMatrix2;
  }, {
    isClass: true
  });

  // node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/esm/type/complex/function/complex.js
  var name8 = "complex";
  var dependencies9 = ["typed", "Complex"];
  var createComplex = /* @__PURE__ */ factory(name8, dependencies9, (_ref) => {
    var {
      typed: typed2,
      Complex: Complex3
    } = _ref;
    return typed2("complex", {
      "": function _() {
        return Complex3.ZERO;
      },
      number: function number(x) {
        return new Complex3(x, 0);
      },
      "number, number": function numberNumber(re, im) {
        return new Complex3(re, im);
      },
      // TODO: this signature should be redundant
      "BigNumber, BigNumber": function BigNumberBigNumber(re, im) {
        return new Complex3(re.toNumber(), im.toNumber());
      },
      Fraction: function Fraction3(x) {
        return new Complex3(x.valueOf(), 0);
      },
      Complex: function Complex4(x) {
        return x.clone();
      },
      string: function string(x) {
        return Complex3(x);
      },
      null: function _null(x) {
        return Complex3(0);
      },
      Object: function Object2(x) {
        if ("re" in x && "im" in x) {
          return new Complex3(x.re, x.im);
        }
        if ("r" in x && "phi" in x || "abs" in x && "arg" in x) {
          return new Complex3(x);
        }
        throw new Error("Expected object with properties (re and im) or (r and phi) or (abs and arg)");
      },
      "Array | Matrix": typed2.referToSelf((self2) => (x) => deepMap(x, self2))
    });
  });

  // node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/esm/type/matrix/function/matrix.js
  var name9 = "matrix";
  var dependencies10 = ["typed", "Matrix", "DenseMatrix", "SparseMatrix"];
  var createMatrix = /* @__PURE__ */ factory(name9, dependencies10, (_ref) => {
    var {
      typed: typed2,
      Matrix: Matrix2,
      DenseMatrix: DenseMatrix2,
      SparseMatrix: SparseMatrix2
    } = _ref;
    return typed2(name9, {
      "": function _() {
        return _create([]);
      },
      string: function string(format4) {
        return _create([], format4);
      },
      "string, string": function stringString(format4, datatype) {
        return _create([], format4, datatype);
      },
      Array: function Array2(data) {
        return _create(data);
      },
      Matrix: function Matrix3(data) {
        return _create(data, data.storage());
      },
      "Array | Matrix, string": _create,
      "Array | Matrix, string, string": _create
    });
    function _create(data, format4, datatype) {
      if (format4 === "dense" || format4 === "default" || format4 === void 0) {
        return new DenseMatrix2(data, datatype);
      }
      if (format4 === "sparse") {
        return new SparseMatrix2(data, datatype);
      }
      throw new TypeError("Unknown matrix type " + JSON.stringify(format4) + ".");
    }
  });

  // node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/esm/function/arithmetic/addScalar.js
  var name10 = "addScalar";
  var dependencies11 = ["typed"];
  var createAddScalar = /* @__PURE__ */ factory(name10, dependencies11, (_ref) => {
    var {
      typed: typed2
    } = _ref;
    return typed2(name10, {
      "number, number": addNumber,
      "Complex, Complex": function ComplexComplex(x, y) {
        return x.add(y);
      },
      "BigNumber, BigNumber": function BigNumberBigNumber(x, y) {
        return x.plus(y);
      },
      "Fraction, Fraction": function FractionFraction(x, y) {
        return x.add(y);
      },
      "Unit, Unit": typed2.referToSelf((self2) => (x, y) => {
        if (x.value === null || x.value === void 0) {
          throw new Error("Parameter x contains a unit with undefined value");
        }
        if (y.value === null || y.value === void 0) {
          throw new Error("Parameter y contains a unit with undefined value");
        }
        if (!x.equalBase(y)) throw new Error("Units do not match");
        var res = x.clone();
        res.value = typed2.find(self2, [res.valueType(), y.valueType()])(res.value, y.value);
        res.fixPrefix = false;
        return res;
      })
    });
  });

  // node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/esm/type/matrix/utils/matAlgo11xS0s.js
  var name11 = "matAlgo11xS0s";
  var dependencies12 = ["typed", "equalScalar"];
  var createMatAlgo11xS0s = /* @__PURE__ */ factory(name11, dependencies12, (_ref) => {
    var {
      typed: typed2,
      equalScalar: equalScalar2
    } = _ref;
    return function matAlgo11xS0s(s, b, callback, inverse) {
      var avalues = s._values;
      var aindex = s._index;
      var aptr = s._ptr;
      var asize = s._size;
      var adt = s._datatype;
      if (!avalues) {
        throw new Error("Cannot perform operation on Pattern Sparse Matrix and Scalar value");
      }
      var rows = asize[0];
      var columns = asize[1];
      var dt;
      var eq = equalScalar2;
      var zero = 0;
      var cf = callback;
      if (typeof adt === "string") {
        dt = adt;
        eq = typed2.find(equalScalar2, [dt, dt]);
        zero = typed2.convert(0, dt);
        b = typed2.convert(b, dt);
        cf = typed2.find(callback, [dt, dt]);
      }
      var cvalues = [];
      var cindex = [];
      var cptr = [];
      for (var j = 0; j < columns; j++) {
        cptr[j] = cindex.length;
        for (var k0 = aptr[j], k1 = aptr[j + 1], k = k0; k < k1; k++) {
          var i = aindex[k];
          var v = inverse ? cf(b, avalues[k]) : cf(avalues[k], b);
          if (!eq(v, zero)) {
            cindex.push(i);
            cvalues.push(v);
          }
        }
      }
      cptr[columns] = cindex.length;
      return s.createSparseMatrix({
        values: cvalues,
        index: cindex,
        ptr: cptr,
        size: [rows, columns],
        datatype: dt
      });
    };
  });

  // node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/esm/type/matrix/utils/matAlgo14xDs.js
  var name12 = "matAlgo14xDs";
  var dependencies13 = ["typed"];
  var createMatAlgo14xDs = /* @__PURE__ */ factory(name12, dependencies13, (_ref) => {
    var {
      typed: typed2
    } = _ref;
    return function matAlgo14xDs(a, b, callback, inverse) {
      var adata = a._data;
      var asize = a._size;
      var adt = a._datatype;
      var dt;
      var cf = callback;
      if (typeof adt === "string") {
        dt = adt;
        b = typed2.convert(b, dt);
        cf = typed2.find(callback, [dt, dt]);
      }
      var cdata = asize.length > 0 ? _iterate(cf, 0, asize, asize[0], adata, b, inverse) : [];
      return a.createDenseMatrix({
        data: cdata,
        size: clone(asize),
        datatype: dt
      });
    };
    function _iterate(f, level, s, n, av, bv, inverse) {
      var cv = [];
      if (level === s.length - 1) {
        for (var i = 0; i < n; i++) {
          cv[i] = inverse ? f(bv, av[i]) : f(av[i], bv);
        }
      } else {
        for (var j = 0; j < n; j++) {
          cv[j] = _iterate(f, level + 1, s, s[level + 1], av[j], bv, inverse);
        }
      }
      return cv;
    }
  });

  // node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/esm/function/arithmetic/multiplyScalar.js
  var name13 = "multiplyScalar";
  var dependencies14 = ["typed"];
  var createMultiplyScalar = /* @__PURE__ */ factory(name13, dependencies14, (_ref) => {
    var {
      typed: typed2
    } = _ref;
    return typed2("multiplyScalar", {
      "number, number": multiplyNumber,
      "Complex, Complex": function ComplexComplex(x, y) {
        return x.mul(y);
      },
      "BigNumber, BigNumber": function BigNumberBigNumber(x, y) {
        return x.times(y);
      },
      "Fraction, Fraction": function FractionFraction(x, y) {
        return x.mul(y);
      },
      "number | Fraction | BigNumber | Complex, Unit": (x, y) => y.multiply(x),
      "Unit, number | Fraction | BigNumber | Complex | Unit": (x, y) => x.multiply(y)
    });
  });

  // node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/esm/function/arithmetic/multiply.js
  var name14 = "multiply";
  var dependencies15 = ["typed", "matrix", "addScalar", "multiplyScalar", "equalScalar", "dot"];
  var createMultiply = /* @__PURE__ */ factory(name14, dependencies15, (_ref) => {
    var {
      typed: typed2,
      matrix: matrix2,
      addScalar: addScalar2,
      multiplyScalar: multiplyScalar2,
      equalScalar: equalScalar2,
      dot: dot2
    } = _ref;
    var matAlgo11xS0s = createMatAlgo11xS0s({
      typed: typed2,
      equalScalar: equalScalar2
    });
    var matAlgo14xDs = createMatAlgo14xDs({
      typed: typed2
    });
    function _validateMatrixDimensions(size1, size2) {
      switch (size1.length) {
        case 1:
          switch (size2.length) {
            case 1:
              if (size1[0] !== size2[0]) {
                throw new RangeError("Dimension mismatch in multiplication. Vectors must have the same length");
              }
              break;
            case 2:
              if (size1[0] !== size2[0]) {
                throw new RangeError("Dimension mismatch in multiplication. Vector length (" + size1[0] + ") must match Matrix rows (" + size2[0] + ")");
              }
              break;
            default:
              throw new Error("Can only multiply a 1 or 2 dimensional matrix (Matrix B has " + size2.length + " dimensions)");
          }
          break;
        case 2:
          switch (size2.length) {
            case 1:
              if (size1[1] !== size2[0]) {
                throw new RangeError("Dimension mismatch in multiplication. Matrix columns (" + size1[1] + ") must match Vector length (" + size2[0] + ")");
              }
              break;
            case 2:
              if (size1[1] !== size2[0]) {
                throw new RangeError("Dimension mismatch in multiplication. Matrix A columns (" + size1[1] + ") must match Matrix B rows (" + size2[0] + ")");
              }
              break;
            default:
              throw new Error("Can only multiply a 1 or 2 dimensional matrix (Matrix B has " + size2.length + " dimensions)");
          }
          break;
        default:
          throw new Error("Can only multiply a 1 or 2 dimensional matrix (Matrix A has " + size1.length + " dimensions)");
      }
    }
    function _multiplyVectorVector(a, b, n) {
      if (n === 0) {
        throw new Error("Cannot multiply two empty vectors");
      }
      return dot2(a, b);
    }
    function _multiplyVectorMatrix(a, b) {
      if (b.storage() !== "dense") {
        throw new Error("Support for SparseMatrix not implemented");
      }
      return _multiplyVectorDenseMatrix(a, b);
    }
    function _multiplyVectorDenseMatrix(a, b) {
      var adata = a._data;
      var asize = a._size;
      var adt = a._datatype || a.getDataType();
      var bdata = b._data;
      var bsize = b._size;
      var bdt = b._datatype || b.getDataType();
      var alength = asize[0];
      var bcolumns = bsize[1];
      var dt;
      var af = addScalar2;
      var mf = multiplyScalar2;
      if (adt && bdt && adt === bdt && typeof adt === "string" && adt !== "mixed") {
        dt = adt;
        af = typed2.find(addScalar2, [dt, dt]);
        mf = typed2.find(multiplyScalar2, [dt, dt]);
      }
      var c = [];
      for (var j = 0; j < bcolumns; j++) {
        var sum2 = mf(adata[0], bdata[0][j]);
        for (var i = 1; i < alength; i++) {
          sum2 = af(sum2, mf(adata[i], bdata[i][j]));
        }
        c[j] = sum2;
      }
      return a.createDenseMatrix({
        data: c,
        size: [bcolumns],
        datatype: adt === a._datatype && bdt === b._datatype ? dt : void 0
      });
    }
    var _multiplyMatrixVector = typed2("_multiplyMatrixVector", {
      "DenseMatrix, any": _multiplyDenseMatrixVector,
      "SparseMatrix, any": _multiplySparseMatrixVector
    });
    var _multiplyMatrixMatrix = typed2("_multiplyMatrixMatrix", {
      "DenseMatrix, DenseMatrix": _multiplyDenseMatrixDenseMatrix,
      "DenseMatrix, SparseMatrix": _multiplyDenseMatrixSparseMatrix,
      "SparseMatrix, DenseMatrix": _multiplySparseMatrixDenseMatrix,
      "SparseMatrix, SparseMatrix": _multiplySparseMatrixSparseMatrix
    });
    function _multiplyDenseMatrixVector(a, b) {
      var adata = a._data;
      var asize = a._size;
      var adt = a._datatype || a.getDataType();
      var bdata = b._data;
      var bdt = b._datatype || b.getDataType();
      var arows = asize[0];
      var acolumns = asize[1];
      var dt;
      var af = addScalar2;
      var mf = multiplyScalar2;
      if (adt && bdt && adt === bdt && typeof adt === "string" && adt !== "mixed") {
        dt = adt;
        af = typed2.find(addScalar2, [dt, dt]);
        mf = typed2.find(multiplyScalar2, [dt, dt]);
      }
      var c = [];
      for (var i = 0; i < arows; i++) {
        var row = adata[i];
        var sum2 = mf(row[0], bdata[0]);
        for (var j = 1; j < acolumns; j++) {
          sum2 = af(sum2, mf(row[j], bdata[j]));
        }
        c[i] = sum2;
      }
      return a.createDenseMatrix({
        data: c,
        size: [arows],
        datatype: adt === a._datatype && bdt === b._datatype ? dt : void 0
      });
    }
    function _multiplyDenseMatrixDenseMatrix(a, b) {
      var adata = a._data;
      var asize = a._size;
      var adt = a._datatype || a.getDataType();
      var bdata = b._data;
      var bsize = b._size;
      var bdt = b._datatype || b.getDataType();
      var arows = asize[0];
      var acolumns = asize[1];
      var bcolumns = bsize[1];
      var dt;
      var af = addScalar2;
      var mf = multiplyScalar2;
      if (adt && bdt && adt === bdt && typeof adt === "string" && adt !== "mixed" && adt !== "mixed") {
        dt = adt;
        af = typed2.find(addScalar2, [dt, dt]);
        mf = typed2.find(multiplyScalar2, [dt, dt]);
      }
      var c = [];
      for (var i = 0; i < arows; i++) {
        var row = adata[i];
        c[i] = [];
        for (var j = 0; j < bcolumns; j++) {
          var sum2 = mf(row[0], bdata[0][j]);
          for (var x = 1; x < acolumns; x++) {
            sum2 = af(sum2, mf(row[x], bdata[x][j]));
          }
          c[i][j] = sum2;
        }
      }
      return a.createDenseMatrix({
        data: c,
        size: [arows, bcolumns],
        datatype: adt === a._datatype && bdt === b._datatype ? dt : void 0
      });
    }
    function _multiplyDenseMatrixSparseMatrix(a, b) {
      var adata = a._data;
      var asize = a._size;
      var adt = a._datatype || a.getDataType();
      var bvalues = b._values;
      var bindex = b._index;
      var bptr = b._ptr;
      var bsize = b._size;
      var bdt = b._datatype || b._data === void 0 ? b._datatype : b.getDataType();
      if (!bvalues) {
        throw new Error("Cannot multiply Dense Matrix times Pattern only Matrix");
      }
      var arows = asize[0];
      var bcolumns = bsize[1];
      var dt;
      var af = addScalar2;
      var mf = multiplyScalar2;
      var eq = equalScalar2;
      var zero = 0;
      if (adt && bdt && adt === bdt && typeof adt === "string" && adt !== "mixed") {
        dt = adt;
        af = typed2.find(addScalar2, [dt, dt]);
        mf = typed2.find(multiplyScalar2, [dt, dt]);
        eq = typed2.find(equalScalar2, [dt, dt]);
        zero = typed2.convert(0, dt);
      }
      var cvalues = [];
      var cindex = [];
      var cptr = [];
      var c = b.createSparseMatrix({
        values: cvalues,
        index: cindex,
        ptr: cptr,
        size: [arows, bcolumns],
        datatype: adt === a._datatype && bdt === b._datatype ? dt : void 0
      });
      for (var jb = 0; jb < bcolumns; jb++) {
        cptr[jb] = cindex.length;
        var kb0 = bptr[jb];
        var kb1 = bptr[jb + 1];
        if (kb1 > kb0) {
          var last = 0;
          for (var i = 0; i < arows; i++) {
            var mark = i + 1;
            var cij = void 0;
            for (var kb = kb0; kb < kb1; kb++) {
              var ib = bindex[kb];
              if (last !== mark) {
                cij = mf(adata[i][ib], bvalues[kb]);
                last = mark;
              } else {
                cij = af(cij, mf(adata[i][ib], bvalues[kb]));
              }
            }
            if (last === mark && !eq(cij, zero)) {
              cindex.push(i);
              cvalues.push(cij);
            }
          }
        }
      }
      cptr[bcolumns] = cindex.length;
      return c;
    }
    function _multiplySparseMatrixVector(a, b) {
      var avalues = a._values;
      var aindex = a._index;
      var aptr = a._ptr;
      var adt = a._datatype || a._data === void 0 ? a._datatype : a.getDataType();
      if (!avalues) {
        throw new Error("Cannot multiply Pattern only Matrix times Dense Matrix");
      }
      var bdata = b._data;
      var bdt = b._datatype || b.getDataType();
      var arows = a._size[0];
      var brows = b._size[0];
      var cvalues = [];
      var cindex = [];
      var cptr = [];
      var dt;
      var af = addScalar2;
      var mf = multiplyScalar2;
      var eq = equalScalar2;
      var zero = 0;
      if (adt && bdt && adt === bdt && typeof adt === "string" && adt !== "mixed") {
        dt = adt;
        af = typed2.find(addScalar2, [dt, dt]);
        mf = typed2.find(multiplyScalar2, [dt, dt]);
        eq = typed2.find(equalScalar2, [dt, dt]);
        zero = typed2.convert(0, dt);
      }
      var x = [];
      var w = [];
      cptr[0] = 0;
      for (var ib = 0; ib < brows; ib++) {
        var vbi = bdata[ib];
        if (!eq(vbi, zero)) {
          for (var ka0 = aptr[ib], ka1 = aptr[ib + 1], ka = ka0; ka < ka1; ka++) {
            var ia = aindex[ka];
            if (!w[ia]) {
              w[ia] = true;
              cindex.push(ia);
              x[ia] = mf(vbi, avalues[ka]);
            } else {
              x[ia] = af(x[ia], mf(vbi, avalues[ka]));
            }
          }
        }
      }
      for (var p1 = cindex.length, p = 0; p < p1; p++) {
        var ic = cindex[p];
        cvalues[p] = x[ic];
      }
      cptr[1] = cindex.length;
      return a.createSparseMatrix({
        values: cvalues,
        index: cindex,
        ptr: cptr,
        size: [arows, 1],
        datatype: adt === a._datatype && bdt === b._datatype ? dt : void 0
      });
    }
    function _multiplySparseMatrixDenseMatrix(a, b) {
      var avalues = a._values;
      var aindex = a._index;
      var aptr = a._ptr;
      var adt = a._datatype || a._data === void 0 ? a._datatype : a.getDataType();
      if (!avalues) {
        throw new Error("Cannot multiply Pattern only Matrix times Dense Matrix");
      }
      var bdata = b._data;
      var bdt = b._datatype || b.getDataType();
      var arows = a._size[0];
      var brows = b._size[0];
      var bcolumns = b._size[1];
      var dt;
      var af = addScalar2;
      var mf = multiplyScalar2;
      var eq = equalScalar2;
      var zero = 0;
      if (adt && bdt && adt === bdt && typeof adt === "string" && adt !== "mixed") {
        dt = adt;
        af = typed2.find(addScalar2, [dt, dt]);
        mf = typed2.find(multiplyScalar2, [dt, dt]);
        eq = typed2.find(equalScalar2, [dt, dt]);
        zero = typed2.convert(0, dt);
      }
      var cvalues = [];
      var cindex = [];
      var cptr = [];
      var c = a.createSparseMatrix({
        values: cvalues,
        index: cindex,
        ptr: cptr,
        size: [arows, bcolumns],
        datatype: adt === a._datatype && bdt === b._datatype ? dt : void 0
      });
      var x = [];
      var w = [];
      for (var jb = 0; jb < bcolumns; jb++) {
        cptr[jb] = cindex.length;
        var mark = jb + 1;
        for (var ib = 0; ib < brows; ib++) {
          var vbij = bdata[ib][jb];
          if (!eq(vbij, zero)) {
            for (var ka0 = aptr[ib], ka1 = aptr[ib + 1], ka = ka0; ka < ka1; ka++) {
              var ia = aindex[ka];
              if (w[ia] !== mark) {
                w[ia] = mark;
                cindex.push(ia);
                x[ia] = mf(vbij, avalues[ka]);
              } else {
                x[ia] = af(x[ia], mf(vbij, avalues[ka]));
              }
            }
          }
        }
        for (var p0 = cptr[jb], p1 = cindex.length, p = p0; p < p1; p++) {
          var ic = cindex[p];
          cvalues[p] = x[ic];
        }
      }
      cptr[bcolumns] = cindex.length;
      return c;
    }
    function _multiplySparseMatrixSparseMatrix(a, b) {
      var avalues = a._values;
      var aindex = a._index;
      var aptr = a._ptr;
      var adt = a._datatype || a._data === void 0 ? a._datatype : a.getDataType();
      var bvalues = b._values;
      var bindex = b._index;
      var bptr = b._ptr;
      var bdt = b._datatype || b._data === void 0 ? b._datatype : b.getDataType();
      var arows = a._size[0];
      var bcolumns = b._size[1];
      var values = avalues && bvalues;
      var dt;
      var af = addScalar2;
      var mf = multiplyScalar2;
      if (adt && bdt && adt === bdt && typeof adt === "string" && adt !== "mixed") {
        dt = adt;
        af = typed2.find(addScalar2, [dt, dt]);
        mf = typed2.find(multiplyScalar2, [dt, dt]);
      }
      var cvalues = values ? [] : void 0;
      var cindex = [];
      var cptr = [];
      var c = a.createSparseMatrix({
        values: cvalues,
        index: cindex,
        ptr: cptr,
        size: [arows, bcolumns],
        datatype: adt === a._datatype && bdt === b._datatype ? dt : void 0
      });
      var x = values ? [] : void 0;
      var w = [];
      var ka, ka0, ka1, kb, kb0, kb1, ia, ib;
      for (var jb = 0; jb < bcolumns; jb++) {
        cptr[jb] = cindex.length;
        var mark = jb + 1;
        for (kb0 = bptr[jb], kb1 = bptr[jb + 1], kb = kb0; kb < kb1; kb++) {
          ib = bindex[kb];
          if (values) {
            for (ka0 = aptr[ib], ka1 = aptr[ib + 1], ka = ka0; ka < ka1; ka++) {
              ia = aindex[ka];
              if (w[ia] !== mark) {
                w[ia] = mark;
                cindex.push(ia);
                x[ia] = mf(bvalues[kb], avalues[ka]);
              } else {
                x[ia] = af(x[ia], mf(bvalues[kb], avalues[ka]));
              }
            }
          } else {
            for (ka0 = aptr[ib], ka1 = aptr[ib + 1], ka = ka0; ka < ka1; ka++) {
              ia = aindex[ka];
              if (w[ia] !== mark) {
                w[ia] = mark;
                cindex.push(ia);
              }
            }
          }
        }
        if (values) {
          for (var p0 = cptr[jb], p1 = cindex.length, p = p0; p < p1; p++) {
            var ic = cindex[p];
            cvalues[p] = x[ic];
          }
        }
      }
      cptr[bcolumns] = cindex.length;
      return c;
    }
    return typed2(name14, multiplyScalar2, {
      // we extend the signatures of multiplyScalar with signatures dealing with matrices
      "Array, Array": typed2.referTo("Matrix, Matrix", (selfMM) => (x, y) => {
        _validateMatrixDimensions(arraySize(x), arraySize(y));
        var m = selfMM(matrix2(x), matrix2(y));
        return isMatrix(m) ? m.valueOf() : m;
      }),
      "Matrix, Matrix": function MatrixMatrix(x, y) {
        var xsize = x.size();
        var ysize = y.size();
        _validateMatrixDimensions(xsize, ysize);
        if (xsize.length === 1) {
          if (ysize.length === 1) {
            return _multiplyVectorVector(x, y, xsize[0]);
          }
          return _multiplyVectorMatrix(x, y);
        }
        if (ysize.length === 1) {
          return _multiplyMatrixVector(x, y);
        }
        return _multiplyMatrixMatrix(x, y);
      },
      "Matrix, Array": typed2.referTo("Matrix,Matrix", (selfMM) => (x, y) => selfMM(x, matrix2(y))),
      "Array, Matrix": typed2.referToSelf((self2) => (x, y) => {
        return self2(matrix2(x, y.storage()), y);
      }),
      "SparseMatrix, any": function SparseMatrixAny(x, y) {
        return matAlgo11xS0s(x, y, multiplyScalar2, false);
      },
      "DenseMatrix, any": function DenseMatrixAny(x, y) {
        return matAlgo14xDs(x, y, multiplyScalar2, false);
      },
      "any, SparseMatrix": function anySparseMatrix(x, y) {
        return matAlgo11xS0s(y, x, multiplyScalar2, true);
      },
      "any, DenseMatrix": function anyDenseMatrix(x, y) {
        return matAlgo14xDs(y, x, multiplyScalar2, true);
      },
      "Array, any": function ArrayAny(x, y) {
        return matAlgo14xDs(matrix2(x), y, multiplyScalar2, false).valueOf();
      },
      "any, Array": function anyArray(x, y) {
        return matAlgo14xDs(matrix2(y), x, multiplyScalar2, true).valueOf();
      },
      "any, any": multiplyScalar2,
      "any, any, ...any": typed2.referToSelf((self2) => (x, y, rest) => {
        var result = self2(x, y);
        for (var i = 0; i < rest.length; i++) {
          result = self2(result, rest[i]);
        }
        return result;
      })
    });
  });

  // node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/esm/function/complex/conj.js
  var name15 = "conj";
  var dependencies16 = ["typed"];
  var createConj = /* @__PURE__ */ factory(name15, dependencies16, (_ref) => {
    var {
      typed: typed2
    } = _ref;
    return typed2(name15, {
      "number | BigNumber | Fraction": (x) => x,
      Complex: (x) => x.conjugate(),
      "Array | Matrix": typed2.referToSelf((self2) => (x) => deepMap(x, self2))
    });
  });

  // node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/esm/utils/noop.js
  function noMatrix() {
    throw new Error('No "matrix" implementation available');
  }

  // node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/esm/function/matrix/size.js
  var name16 = "size";
  var dependencies17 = ["typed", "config", "?matrix"];
  var createSize = /* @__PURE__ */ factory(name16, dependencies17, (_ref) => {
    var {
      typed: typed2,
      config: config4,
      matrix: matrix2
    } = _ref;
    return typed2(name16, {
      Matrix: function Matrix2(x) {
        return x.create(x.size());
      },
      Array: arraySize,
      string: function string(x) {
        return config4.matrix === "Array" ? [x.length] : matrix2([x.length]);
      },
      "number | Complex | BigNumber | Unit | boolean | null": function numberComplexBigNumberUnitBooleanNull(x) {
        return config4.matrix === "Array" ? [] : matrix2 ? matrix2([]) : noMatrix();
      }
    });
  });

  // node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/esm/function/matrix/dot.js
  var name17 = "dot";
  var dependencies18 = ["typed", "addScalar", "multiplyScalar", "conj", "size"];
  var createDot = /* @__PURE__ */ factory(name17, dependencies18, (_ref) => {
    var {
      typed: typed2,
      addScalar: addScalar2,
      multiplyScalar: multiplyScalar2,
      conj: conj2,
      size: size2
    } = _ref;
    return typed2(name17, {
      "Array | DenseMatrix, Array | DenseMatrix": _denseDot,
      "SparseMatrix, SparseMatrix": _sparseDot
    });
    function _validateDim(x, y) {
      var xSize = _size(x);
      var ySize = _size(y);
      var xLen, yLen;
      if (xSize.length === 1) {
        xLen = xSize[0];
      } else if (xSize.length === 2 && xSize[1] === 1) {
        xLen = xSize[0];
      } else {
        throw new RangeError("Expected a column vector, instead got a matrix of size (" + xSize.join(", ") + ")");
      }
      if (ySize.length === 1) {
        yLen = ySize[0];
      } else if (ySize.length === 2 && ySize[1] === 1) {
        yLen = ySize[0];
      } else {
        throw new RangeError("Expected a column vector, instead got a matrix of size (" + ySize.join(", ") + ")");
      }
      if (xLen !== yLen) throw new RangeError("Vectors must have equal length (" + xLen + " != " + yLen + ")");
      if (xLen === 0) throw new RangeError("Cannot calculate the dot product of empty vectors");
      return xLen;
    }
    function _denseDot(a, b) {
      var N = _validateDim(a, b);
      var adata = isMatrix(a) ? a._data : a;
      var adt = isMatrix(a) ? a._datatype || a.getDataType() : void 0;
      var bdata = isMatrix(b) ? b._data : b;
      var bdt = isMatrix(b) ? b._datatype || b.getDataType() : void 0;
      var aIsColumn = _size(a).length === 2;
      var bIsColumn = _size(b).length === 2;
      var add2 = addScalar2;
      var mul2 = multiplyScalar2;
      if (adt && bdt && adt === bdt && typeof adt === "string" && adt !== "mixed") {
        var dt = adt;
        add2 = typed2.find(addScalar2, [dt, dt]);
        mul2 = typed2.find(multiplyScalar2, [dt, dt]);
      }
      if (!aIsColumn && !bIsColumn) {
        var c = mul2(conj2(adata[0]), bdata[0]);
        for (var i = 1; i < N; i++) {
          c = add2(c, mul2(conj2(adata[i]), bdata[i]));
        }
        return c;
      }
      if (!aIsColumn && bIsColumn) {
        var _c = mul2(conj2(adata[0]), bdata[0][0]);
        for (var _i = 1; _i < N; _i++) {
          _c = add2(_c, mul2(conj2(adata[_i]), bdata[_i][0]));
        }
        return _c;
      }
      if (aIsColumn && !bIsColumn) {
        var _c2 = mul2(conj2(adata[0][0]), bdata[0]);
        for (var _i2 = 1; _i2 < N; _i2++) {
          _c2 = add2(_c2, mul2(conj2(adata[_i2][0]), bdata[_i2]));
        }
        return _c2;
      }
      if (aIsColumn && bIsColumn) {
        var _c3 = mul2(conj2(adata[0][0]), bdata[0][0]);
        for (var _i3 = 1; _i3 < N; _i3++) {
          _c3 = add2(_c3, mul2(conj2(adata[_i3][0]), bdata[_i3][0]));
        }
        return _c3;
      }
    }
    function _sparseDot(x, y) {
      _validateDim(x, y);
      var xindex = x._index;
      var xvalues = x._values;
      var yindex = y._index;
      var yvalues = y._values;
      var c = 0;
      var add2 = addScalar2;
      var mul2 = multiplyScalar2;
      var i = 0;
      var j = 0;
      while (i < xindex.length && j < yindex.length) {
        var I = xindex[i];
        var J = yindex[j];
        if (I < J) {
          i++;
          continue;
        }
        if (I > J) {
          j++;
          continue;
        }
        if (I === J) {
          c = add2(c, mul2(xvalues[i], yvalues[j]));
          i++;
          j++;
        }
      }
      return c;
    }
    function _size(x) {
      return isMatrix(x) ? x.size() : size2(x);
    }
  });

  // node_modules/.pnpm/mathjs@12.4.3/node_modules/mathjs/lib/esm/entry/pureFunctionsAny.generated.js
  var BigNumber = /* @__PURE__ */ createBigNumberClass({
    config
  });
  var Complex2 = /* @__PURE__ */ createComplexClass({});
  var Fraction2 = /* @__PURE__ */ createFractionClass({});
  var Matrix = /* @__PURE__ */ createMatrixClass({});
  var DenseMatrix = /* @__PURE__ */ createDenseMatrixClass({
    Matrix
  });
  var typed = /* @__PURE__ */ createTyped({
    BigNumber,
    Complex: Complex2,
    DenseMatrix,
    Fraction: Fraction2
  });
  var addScalar = /* @__PURE__ */ createAddScalar({
    typed
  });
  var complex = /* @__PURE__ */ createComplex({
    Complex: Complex2,
    typed
  });
  var conj = /* @__PURE__ */ createConj({
    typed
  });
  var equalScalar = /* @__PURE__ */ createEqualScalar({
    config,
    typed
  });
  var multiplyScalar = /* @__PURE__ */ createMultiplyScalar({
    typed
  });
  var SparseMatrix = /* @__PURE__ */ createSparseMatrixClass({
    Matrix,
    equalScalar,
    typed
  });
  var matrix = /* @__PURE__ */ createMatrix({
    DenseMatrix,
    Matrix,
    SparseMatrix,
    typed
  });
  var size = /* @__PURE__ */ createSize({
    matrix,
    config,
    typed
  });
  var dot = /* @__PURE__ */ createDot({
    addScalar,
    conj,
    multiplyScalar,
    size,
    typed
  });
  var multiply = /* @__PURE__ */ createMultiply({
    addScalar,
    dot,
    equalScalar,
    matrix,
    multiplyScalar,
    typed
  });

  // web/simulations.ts
  function generateBellState(stateType) {
    const bellState = (0, import_dist.createBellState)(stateType);
    const sqrt2 = Math.sqrt(2);
    const probs = bellState.amplitudes.map((amp, i) => ({
      label: ["|00\u27E9", "|01\u27E9", "|10\u27E9", "|11\u27E9"][i],
      prob: Math.abs(amp.re) * Math.abs(amp.re) + Math.abs(amp.im) * Math.abs(amp.im)
    }));
    const rho = createDensityMatrixFromState(bellState);
    const entropy = calculateEntanglementEntropy(bellState, 2, 2);
    const vectorStr = bellState.amplitudes.map((amp) => formatComplex(amp.re, amp.im)).join(", ");
    return {
      vector: `[${vectorStr}]`,
      entropy,
      probabilities: probs
    };
  }
  function applyGate(initialStateStr, gateName) {
    let initialState;
    switch (initialStateStr) {
      case "|0\u27E9":
        initialState = (0, import_dist.createBasisState)(2, 0);
        break;
      case "|1\u27E9":
        initialState = (0, import_dist.createBasisState)(2, 1);
        break;
      case "|+\u27E9":
        initialState = (0, import_dist.createPlusState)();
        break;
      case "|-\u27E9":
        initialState = new import_dist.StateVector(2, [
          complex(1 / Math.sqrt(2), 0),
          complex(-1 / Math.sqrt(2), 0)
        ]);
        break;
      default:
        initialState = (0, import_dist.createBasisState)(2, 0);
    }
    let resultState;
    switch (gateName) {
      case "X":
        resultState = import_dist.PauliX.apply(initialState);
        break;
      case "Y":
        resultState = import_dist.PauliY.apply(initialState);
        break;
      case "Z":
        resultState = import_dist.PauliZ.apply(initialState);
        break;
      case "H":
        resultState = import_dist.Hadamard.apply(initialState);
        break;
      case "S":
        const SGate = new (require_dist2()).MatrixOperator([
          [complex(1, 0), complex(0, 0)],
          [complex(0, 0), complex(0, 1)]
        ], "unitary");
        resultState = SGate.apply(initialState);
        break;
      case "T":
        const TGate = new (require_dist2()).MatrixOperator([
          [complex(1, 0), complex(0, 0)],
          [complex(0, 0), complex(Math.cos(Math.PI / 4), Math.sin(Math.PI / 4))]
        ], "unitary");
        resultState = TGate.apply(initialState);
        break;
      default:
        resultState = initialState;
    }
    const amplitudes = [
      {
        label: "|0\u27E9",
        magnitude: Math.hypot(resultState.amplitudes[0].re, resultState.amplitudes[0].im),
        phase: Math.atan2(resultState.amplitudes[0].im, resultState.amplitudes[0].re)
      },
      {
        label: "|1\u27E9",
        magnitude: Math.hypot(resultState.amplitudes[1].re, resultState.amplitudes[1].im),
        phase: Math.atan2(resultState.amplitudes[1].im, resultState.amplitudes[1].re)
      }
    ];
    const resultStateStr = `${formatComplex(resultState.amplitudes[0].re, resultState.amplitudes[0].im)}|0\u27E9 + ${formatComplex(resultState.amplitudes[1].re, resultState.amplitudes[1].im)}|1\u27E9`;
    return {
      resultState: resultStateStr,
      amplitudes
    };
  }
  function simulateMeasurement(prob0, numTrials = 1e3) {
    const amp0 = Math.sqrt(prob0);
    const amp1 = Math.sqrt(1 - prob0);
    const state = new import_dist.StateVector(2, [complex(amp0, 0), complex(amp1, 0)]);
    let count0 = 0, count1 = 0;
    for (let i = 0; i < numTrials; i++) {
      if (Math.random() < prob0) {
        count0++;
      } else {
        count1++;
      }
    }
    return {
      measured0: count0,
      measured1: count1,
      theoretical0: prob0,
      theoretical1: 1 - prob0
    };
  }
  function analyzeEntanglement(stateType) {
    let state;
    switch (stateType) {
      case "product":
        state = (0, import_dist.createBasisState)(4, 0);
        break;
      case "bell":
        state = (0, import_dist.createBellState)("Phi+");
        break;
      case "partial":
        state = new import_dist.StateVector(4, [
          complex(Math.sqrt(0.7), 0),
          complex(0, 0),
          complex(0, 0),
          complex(Math.sqrt(0.3), 0)
        ]);
        break;
      case "ghz3-1v2":
        const ghz3 = (0, import_dist.createGHZState)(3);
        state = ghz3;
        break;
      default:
        state = (0, import_dist.createBasisState)(4, 0);
    }
    const entropy = calculateEntanglementEntropy(state, 2, 2);
    const rho = createDensityMatrixFromState(state);
    const conc = (0, import_dist.concurrence)(rho);
    const neg = (0, import_dist.negativity)(rho, 2, 2);
    let typeStr = "Unknown";
    if (entropy < 0.01) typeStr = "Separable (No Entanglement)";
    else if (entropy > Math.log(2) - 0.01) typeStr = "Maximally Entangled";
    else typeStr = "Partially Entangled";
    return {
      entropy,
      concurrence: conc,
      negativity: neg,
      type: typeStr
    };
  }
  function generateMultiQubitState(stateType) {
    let state;
    let components = [];
    switch (stateType) {
      case "ghz2":
        state = (0, import_dist.createBellState)("Phi+");
        components = [
          { label: "|00\u27E9", amplitude: `1/\u221A2 \u2248 0.707` },
          { label: "|11\u27E9", amplitude: `1/\u221A2 \u2248 0.707` }
        ];
        break;
      case "ghz3":
        state = (0, import_dist.createGHZState)(3);
        components = [
          { label: "|000\u27E9", amplitude: `1/\u221A2 \u2248 0.707` },
          { label: "|111\u27E9", amplitude: `1/\u221A2 \u2248 0.707` }
        ];
        break;
      case "w2":
        state = (0, import_dist.createWState)(2);
        components = [
          { label: "|01\u27E9", amplitude: `1/\u221A2 \u2248 0.707` },
          { label: "|10\u27E9", amplitude: `1/\u221A2 \u2248 0.707` }
        ];
        break;
      case "w3":
        state = (0, import_dist.createWState)(3);
        components = [
          { label: "|001\u27E9", amplitude: `1/\u221A3 \u2248 0.577` },
          { label: "|010\u27E9", amplitude: `1/\u221A3 \u2248 0.577` },
          { label: "|100\u27E9", amplitude: `1/\u221A3 \u2248 0.577` }
        ];
        break;
      default:
        state = (0, import_dist.createBasisState)(4, 0);
    }
    const norm = Math.sqrt(
      state.amplitudes.reduce((sum2, amp) => sum2 + amp.re * amp.re + amp.im * amp.im, 0)
    );
    const vectorStr = state.amplitudes.filter((amp) => Math.hypot(amp.re, amp.im) > 1e-3).map((amp) => formatComplex(amp.re, amp.im)).join(", ");
    return {
      vector: `[${vectorStr}]`,
      components,
      dimension: state.dimension,
      norm
    };
  }
  function generateAngularMomentumState(j, m) {
    const state = (0, import_dist.createJmState)(j, m);
    const jzOp = (0, import_dist.createJz)(j);
    const j2Op = (0, import_dist.createJ2)(j);
    const jzEig = (0, import_dist.jmExpectationValue)(jzOp, j, m);
    const j2Eig = (0, import_dist.jmExpectationValue)(j2Op, j, m);
    const jzVal = m;
    const j2Val = j * (j + 1);
    let stateStr = `|${j}, ${m}\u27E9`;
    if (j === 0.5) {
      stateStr = m === 0.5 ? "|\u2191\u27E9 = |1/2, +1/2\u27E9" : "|\u2193\u27E9 = |1/2, -1/2\u27E9";
    }
    return {
      stateStr,
      jzEigenvalue: jzVal,
      j2Eigenvalue: j2Val,
      operatorInfo: `Jz |${j}, ${m}\u27E9 = ${m}\u210F |${j}, ${m}\u27E9; J\xB2 |${j}, ${m}\u27E9 = ${j2Val.toFixed(2)}\u210F\xB2`
    };
  }
  function runQuantumCircuit() {
    const bellPhi = (0, import_dist.createBellState)("Phi+");
    return {
      circuitDesc: "2-Qubit Bell State Circuit: Creates maximally entangled state from |00\u27E9",
      step1: "|00\u27E9 - Initial computational basis state",
      step2: "H\u2081 \u2297 I\u2082 - Apply Hadamard to first qubit: (|0\u27E9 + |1\u27E9)/\u221A2 \u2297 |0\u27E9",
      step3: "CNOT - Apply CNOT gate: Result = \u03A6\u207A = (|00\u27E9 + |11\u27E9)/\u221A2"
    };
  }
  function exploreSuperposition(ampSquared, phaseA) {
    const ampA = Math.sqrt(ampSquared);
    const ampB = Math.sqrt(1 - ampSquared);
    const phaseRad = phaseA * Math.PI / 180;
    const realA = ampA * Math.cos(phaseRad);
    const imagA = ampA * Math.sin(phaseRad);
    const stateStr = `(${realA.toFixed(3)} + ${imagA.toFixed(3)}i)|0\u27E9 + ${ampB.toFixed(3)}|1\u27E9`;
    return {
      stateStr,
      probZero: ampSquared,
      probOne: 1 - ampSquared
    };
  }
  function computeFidelity(stateAStr, stateBStr) {
    const stateMap = {
      "|0\u27E9": (0, import_dist.createBasisState)(2, 0),
      "|1\u27E9": (0, import_dist.createBasisState)(2, 1),
      "|+\u27E9": (0, import_dist.createPlusState)(),
      "|-\u27E9": new import_dist.StateVector(2, [
        complex(1 / Math.sqrt(2), 0),
        complex(-1 / Math.sqrt(2), 0)
      ]),
      "|i\u27E9": new import_dist.StateVector(2, [
        complex(1 / Math.sqrt(2), 0),
        complex(0, 1 / Math.sqrt(2))
      ])
    };
    const stateA = stateMap[stateAStr];
    const stateB = stateMap[stateBStr];
    const overlap = stateA.innerProduct(stateB);
    const fidelity = Math.abs(overlap.re) * Math.abs(overlap.re) + Math.abs(overlap.im) * Math.abs(overlap.im);
    const traceD = Math.sqrt(1 - fidelity);
    const similarity = fidelity * 100;
    const overlapStr = formatComplex(overlap.re, overlap.im);
    return {
      fidelity,
      traceDistance: traceD,
      innerProduct: overlapStr,
      similarity
    };
  }
  var qw1dStateBuffer = null;
  function initializeQuantumWalk1D(latticeSize) {
    const dimension = 2 * latticeSize;
    const hadamardMatrix = [
      [complex(1 / Math.sqrt(2), 0), complex(1 / Math.sqrt(2), 0)],
      [complex(1 / Math.sqrt(2), 0), complex(-1 / Math.sqrt(2), 0)]
    ];
    const coinOp = new import_dist.MatrixOperator(hadamardMatrix, "unitary");
    const shiftMatrix = (0, import_dist.createSparseMatrix)(dimension, dimension);
    for (let pos = 0; pos < latticeSize; pos++) {
      const leftIndex = pos;
      if (pos > 0) {
        const rightIndexPrev = latticeSize + (pos - 1);
        (0, import_dist.setSparseEntry)(shiftMatrix, rightIndexPrev, leftIndex, complex(1, 0));
      } else {
        const rightIndex2 = latticeSize + 0;
        (0, import_dist.setSparseEntry)(shiftMatrix, rightIndex2, leftIndex, complex(1, 0));
      }
      const rightIndex = latticeSize + pos;
      if (pos < latticeSize - 1) {
        const leftIndexNext = pos + 1;
        (0, import_dist.setSparseEntry)(shiftMatrix, leftIndexNext, rightIndex, complex(1, 0));
      } else {
        const leftIndexBound = pos;
        (0, import_dist.setSparseEntry)(shiftMatrix, leftIndexBound, rightIndex, complex(1, 0));
      }
    }
    const shiftOp = new import_dist.SparseOperator(shiftMatrix, "unitary");
    const center = Math.floor(latticeSize / 2);
    const initialAmplitudes = new Array(dimension).fill(null).map(() => complex(0, 0));
    const invSqrt2 = 1 / Math.sqrt(2);
    initialAmplitudes[center] = complex(invSqrt2, 0);
    initialAmplitudes[latticeSize + center] = complex(invSqrt2, 0);
    const initialState = new import_dist.StateVector(dimension, initialAmplitudes);
    qw1dStateBuffer = {
      state: initialState,
      coinOp,
      shiftOp,
      latticeSize,
      currentStep: 0,
      totalSteps: 0,
      history: []
    };
    const initialData = extractQuantumWalk1DData(initialState, latticeSize, 0);
    qw1dStateBuffer.history.push({ step: 0, data: initialData });
    return initialData;
  }
  function stepQuantumWalk1D() {
    if (!qw1dStateBuffer) {
      throw new Error("Quantum walk not initialized. Call initializeQuantumWalk1D first.");
    }
    const { state, coinOp, shiftOp, latticeSize } = qw1dStateBuffer;
    const identityMatrix = [];
    for (let i = 0; i < latticeSize; i++) {
      const row = [];
      for (let j = 0; j < latticeSize; j++) {
        row.push(i === j ? complex(1, 0) : complex(0, 0));
      }
      identityMatrix.push(row);
    }
    const identityOp = new import_dist.MatrixOperator(identityMatrix, "unitary");
    const coinFullOp = coinOp.tensorProduct(identityOp);
    let nextState = coinFullOp.apply(state);
    nextState = shiftOp.apply(nextState);
    nextState = nextState.normalize();
    qw1dStateBuffer.state = nextState;
    qw1dStateBuffer.currentStep++;
    const data = extractQuantumWalk1DData(nextState, latticeSize, qw1dStateBuffer.currentStep);
    qw1dStateBuffer.history.push({ step: qw1dStateBuffer.currentStep, data });
    return data;
  }
  function runQuantumWalk1D(latticeSize, numSteps) {
    initializeQuantumWalk1D(latticeSize);
    if (!qw1dStateBuffer) {
      throw new Error("Failed to initialize quantum walk");
    }
    for (let i = 0; i < numSteps; i++) {
      stepQuantumWalk1D();
    }
    return {
      final: qw1dStateBuffer.history[qw1dStateBuffer.history.length - 1].data,
      history: qw1dStateBuffer.history
    };
  }
  function resetQuantumWalk1D() {
    qw1dStateBuffer = null;
  }
  function getQuantumWalk1DState() {
    if (!qw1dStateBuffer || qw1dStateBuffer.history.length === 0) {
      throw new Error("Quantum walk not initialized");
    }
    return qw1dStateBuffer.history[qw1dStateBuffer.history.length - 1].data;
  }
  function extractQuantumWalk1DData(state, latticeSize, step) {
    const probabilities = [];
    let totalProb = 0;
    let centerOfMass = 0;
    let maxProb = 0;
    const x0 = (latticeSize - 1) / 2;
    for (let pos = 0; pos < latticeSize; pos++) {
      const leftAmp = state.amplitudes[pos];
      const rightAmp = state.amplitudes[latticeSize + pos];
      const leftProb = Math.abs(leftAmp.re) ** 2 + Math.abs(leftAmp.im) ** 2;
      const rightProb = Math.abs(rightAmp.re) ** 2 + Math.abs(rightAmp.im) ** 2;
      const posProb = leftProb + rightProb;
      probabilities.push({ position: pos, probability: posProb });
      totalProb += posProb;
      const x = pos - x0;
      centerOfMass += x * posProb;
      maxProb = Math.max(maxProb, posProb);
    }
    centerOfMass = totalProb > 0 ? centerOfMass / totalProb : 0;
    let variance = 0;
    for (let pos = 0; pos < latticeSize; pos++) {
      const posProb = probabilities[pos].probability;
      const x = pos - x0;
      variance += (x - centerOfMass) ** 2 * posProb;
    }
    return {
      step,
      probabilities,
      centerOfMass,
      variance,
      totalProbability: totalProb,
      maxProbability: maxProb
    };
  }
  var qw1dGroverStateBuffer = null;
  function initializeQuantumWalk1DGrover(latticeSize) {
    const dimension = 2 * latticeSize;
    const groverMatrix = [
      [complex(0, 0), complex(1, 0)],
      [complex(1, 0), complex(0, 0)]
    ];
    const coinOp = new import_dist.MatrixOperator(groverMatrix, "unitary");
    const shiftMatrix = (0, import_dist.createSparseMatrix)(dimension, dimension);
    for (let pos = 0; pos < latticeSize; pos++) {
      const leftIndex = pos;
      if (pos > 0) {
        const rightIndexPrev = latticeSize + (pos - 1);
        (0, import_dist.setSparseEntry)(shiftMatrix, rightIndexPrev, leftIndex, complex(1, 0));
      } else {
        const rightIndex2 = latticeSize + 0;
        (0, import_dist.setSparseEntry)(shiftMatrix, rightIndex2, leftIndex, complex(1, 0));
      }
      const rightIndex = latticeSize + pos;
      if (pos < latticeSize - 1) {
        const leftIndexNext = pos + 1;
        (0, import_dist.setSparseEntry)(shiftMatrix, leftIndexNext, rightIndex, complex(1, 0));
      } else {
        const leftIndexBound = pos;
        (0, import_dist.setSparseEntry)(shiftMatrix, leftIndexBound, rightIndex, complex(1, 0));
      }
    }
    const shiftOp = new import_dist.SparseOperator(shiftMatrix, "unitary");
    const center = Math.floor(latticeSize / 2);
    const initialAmplitudes = new Array(dimension).fill(null).map(() => complex(0, 0));
    const invSqrt2 = 1 / Math.sqrt(2);
    initialAmplitudes[center] = complex(invSqrt2, 0);
    initialAmplitudes[latticeSize + center] = complex(invSqrt2, 0);
    const initialState = new import_dist.StateVector(dimension, initialAmplitudes);
    qw1dGroverStateBuffer = {
      state: initialState,
      coinOp,
      shiftOp,
      latticeSize,
      currentStep: 0,
      history: []
    };
    const initialData = extractQuantumWalk1DData(initialState, latticeSize, 0);
    qw1dGroverStateBuffer.history.push({ step: 0, data: initialData });
    return initialData;
  }
  function stepQuantumWalk1DGrover() {
    if (!qw1dGroverStateBuffer) {
      throw new Error("Grover quantum walk not initialized");
    }
    const { state, coinOp, shiftOp, latticeSize } = qw1dGroverStateBuffer;
    const identityMatrix = [];
    for (let i = 0; i < latticeSize; i++) {
      const row = [];
      for (let j = 0; j < latticeSize; j++) {
        row.push(i === j ? complex(1, 0) : complex(0, 0));
      }
      identityMatrix.push(row);
    }
    const identityOp = new import_dist.MatrixOperator(identityMatrix, "unitary");
    const coinFullOp = coinOp.tensorProduct(identityOp);
    let nextState = coinFullOp.apply(state);
    nextState = shiftOp.apply(nextState);
    nextState = nextState.normalize();
    qw1dGroverStateBuffer.state = nextState;
    qw1dGroverStateBuffer.currentStep++;
    const data = extractQuantumWalk1DData(nextState, latticeSize, qw1dGroverStateBuffer.currentStep);
    qw1dGroverStateBuffer.history.push({ step: qw1dGroverStateBuffer.currentStep, data });
    return data;
  }
  function resetQuantumWalk1DGrover() {
    qw1dGroverStateBuffer = null;
  }
  function getQuantumWalk1DGroverState() {
    if (!qw1dGroverStateBuffer || qw1dGroverStateBuffer.history.length === 0) {
      throw new Error("Grover quantum walk not initialized");
    }
    return qw1dGroverStateBuffer.history[qw1dGroverStateBuffer.history.length - 1].data;
  }
  var qw1dPeriodicStateBuffer = null;
  function initializeQuantumWalk1DPeriodic(latticeSize) {
    const dimension = 2 * latticeSize;
    const hadamardMatrix = [
      [complex(1 / Math.sqrt(2), 0), complex(1 / Math.sqrt(2), 0)],
      [complex(1 / Math.sqrt(2), 0), complex(-1 / Math.sqrt(2), 0)]
    ];
    const coinOp = new import_dist.MatrixOperator(hadamardMatrix, "unitary");
    const shiftMatrix = (0, import_dist.createSparseMatrix)(dimension, dimension);
    for (let pos = 0; pos < latticeSize; pos++) {
      const leftIndex = pos;
      const prevPos = (pos - 1 + latticeSize) % latticeSize;
      const rightIndexPrev = latticeSize + prevPos;
      (0, import_dist.setSparseEntry)(shiftMatrix, rightIndexPrev, leftIndex, complex(1, 0));
      const rightIndex = latticeSize + pos;
      const nextPos = (pos + 1) % latticeSize;
      const leftIndexNext = nextPos;
      (0, import_dist.setSparseEntry)(shiftMatrix, leftIndexNext, rightIndex, complex(1, 0));
    }
    const shiftOp = new import_dist.SparseOperator(shiftMatrix, "unitary");
    const center = Math.floor(latticeSize / 2);
    const initialAmplitudes = new Array(dimension).fill(null).map(() => complex(0, 0));
    const invSqrt2 = 1 / Math.sqrt(2);
    initialAmplitudes[center] = complex(invSqrt2, 0);
    initialAmplitudes[latticeSize + center] = complex(invSqrt2, 0);
    const initialState = new import_dist.StateVector(dimension, initialAmplitudes);
    qw1dPeriodicStateBuffer = {
      state: initialState,
      coinOp,
      shiftOp,
      latticeSize,
      currentStep: 0,
      history: []
    };
    const initialData = extractQuantumWalk1DData(initialState, latticeSize, 0);
    qw1dPeriodicStateBuffer.history.push({ step: 0, data: initialData });
    return initialData;
  }
  function stepQuantumWalk1DPeriodic() {
    if (!qw1dPeriodicStateBuffer) {
      throw new Error("Periodic quantum walk not initialized");
    }
    const { state, coinOp, shiftOp, latticeSize } = qw1dPeriodicStateBuffer;
    const identityMatrix = [];
    for (let i = 0; i < latticeSize; i++) {
      const row = [];
      for (let j = 0; j < latticeSize; j++) {
        row.push(i === j ? complex(1, 0) : complex(0, 0));
      }
      identityMatrix.push(row);
    }
    const identityOp = new import_dist.MatrixOperator(identityMatrix, "unitary");
    const coinFullOp = coinOp.tensorProduct(identityOp);
    let nextState = coinFullOp.apply(state);
    nextState = shiftOp.apply(nextState);
    nextState = nextState.normalize();
    qw1dPeriodicStateBuffer.state = nextState;
    qw1dPeriodicStateBuffer.currentStep++;
    const data = extractQuantumWalk1DData(nextState, latticeSize, qw1dPeriodicStateBuffer.currentStep);
    qw1dPeriodicStateBuffer.history.push({ step: qw1dPeriodicStateBuffer.currentStep, data });
    return data;
  }
  function resetQuantumWalk1DPeriodic() {
    qw1dPeriodicStateBuffer = null;
  }
  function getQuantumWalk1DPeriodicState() {
    if (!qw1dPeriodicStateBuffer || qw1dPeriodicStateBuffer.history.length === 0) {
      throw new Error("Periodic quantum walk not initialized");
    }
    return qw1dPeriodicStateBuffer.history[qw1dPeriodicStateBuffer.history.length - 1].data;
  }
  var classicalWalk1DBuffer = null;
  function initializeClassicalWalk1D(latticeSize) {
    const probs = new Array(latticeSize).fill(0);
    const center = Math.floor(latticeSize / 2);
    probs[center] = 1;
    classicalWalk1DBuffer = {
      probabilities: probs,
      latticeSize,
      currentStep: 0,
      history: []
    };
    const initialData = extractClassicalWalkData(probs, latticeSize, 0);
    classicalWalk1DBuffer.history.push({ step: 0, data: initialData });
    return initialData;
  }
  function stepClassicalWalk1D() {
    if (!classicalWalk1DBuffer) {
      throw new Error("Classical walk not initialized");
    }
    const { probabilities, latticeSize } = classicalWalk1DBuffer;
    const newProbs = new Array(latticeSize).fill(0);
    for (let pos = 0; pos < latticeSize; pos++) {
      if (probabilities[pos] > 0) {
        const prevPos = pos > 0 ? pos - 1 : 0;
        newProbs[prevPos] += probabilities[pos] * 0.5;
        const nextPos = pos < latticeSize - 1 ? pos + 1 : latticeSize - 1;
        newProbs[nextPos] += probabilities[pos] * 0.5;
      }
    }
    classicalWalk1DBuffer.probabilities = newProbs;
    classicalWalk1DBuffer.currentStep++;
    const data = extractClassicalWalkData(newProbs, latticeSize, classicalWalk1DBuffer.currentStep);
    classicalWalk1DBuffer.history.push({ step: classicalWalk1DBuffer.currentStep, data });
    return data;
  }
  function resetClassicalWalk1D() {
    classicalWalk1DBuffer = null;
  }
  function getClassicalWalk1DState() {
    if (!classicalWalk1DBuffer || classicalWalk1DBuffer.history.length === 0) {
      throw new Error("Classical walk not initialized");
    }
    return classicalWalk1DBuffer.history[classicalWalk1DBuffer.history.length - 1].data;
  }
  function extractClassicalWalkData(probs, latticeSize, step) {
    const probabilities = [];
    let totalProb = 0;
    let centerOfMass = 0;
    let maxProb = 0;
    const x0 = (latticeSize - 1) / 2;
    for (let pos = 0; pos < latticeSize; pos++) {
      const posProb = probs[pos];
      probabilities.push({ position: pos, probability: posProb });
      totalProb += posProb;
      const x = pos - x0;
      centerOfMass += x * posProb;
      maxProb = Math.max(maxProb, posProb);
    }
    centerOfMass = totalProb > 0 ? centerOfMass / totalProb : 0;
    let variance = 0;
    for (let pos = 0; pos < latticeSize; pos++) {
      const x = pos - x0;
      variance += (x - centerOfMass) ** 2 * probs[pos];
    }
    return {
      step,
      probabilities,
      centerOfMass,
      variance,
      totalProbability: totalProb,
      maxProbability: maxProb
    };
  }
  function analyzeVarianceGrowth(quantumHistory, classicalHistory) {
    const maxSteps = Math.min(quantumHistory.length, classicalHistory.length);
    const result = [];
    for (let i = 0; i < maxSteps; i++) {
      const qVar = quantumHistory[i].data.variance;
      const cVar = classicalHistory[i].data.variance;
      const advantage = cVar > 0 ? qVar / cVar : 0;
      result.push({
        step: i,
        quantumVariance: qVar,
        classicalVariance: cVar,
        advantage
      });
    }
    return result;
  }
  var qw1dCustomStateBuffer = null;
  function buildCoinOperator(coin, theta) {
    if (coin === "hadamard") {
      const hadamardMatrix = [
        [complex(1 / Math.sqrt(2), 0), complex(1 / Math.sqrt(2), 0)],
        [complex(1 / Math.sqrt(2), 0), complex(-1 / Math.sqrt(2), 0)]
      ];
      return new import_dist.MatrixOperator(hadamardMatrix, "unitary");
    }
    if (coin === "grover") {
      const d = 2;
      const a = 2 / d;
      const groverMatrix = [
        [complex(a - 1, 0), complex(a, 0)],
        [complex(a, 0), complex(a - 1, 0)]
      ];
      return new import_dist.MatrixOperator(groverMatrix, "unitary");
    }
    const c = Math.cos(theta);
    const s = Math.sin(theta);
    const rotMatrix = [
      [complex(c, 0), complex(s, 0)],
      [complex(s, 0), complex(-c, 0)]
    ];
    return new import_dist.MatrixOperator(rotMatrix, "unitary");
  }
  function buildShiftOperator1D(latticeSize, boundary) {
    const dimension = 2 * latticeSize;
    const shiftMatrix = (0, import_dist.createSparseMatrix)(dimension, dimension);
    for (let pos = 0; pos < latticeSize; pos++) {
      const leftIndex = pos;
      if (boundary === "periodic") {
        const prevPos = (pos - 1 + latticeSize) % latticeSize;
        const rightIndexPrev = latticeSize + prevPos;
        (0, import_dist.setSparseEntry)(shiftMatrix, rightIndexPrev, leftIndex, complex(1, 0));
      } else {
        if (pos > 0) {
          const rightIndexPrev = latticeSize + (pos - 1);
          (0, import_dist.setSparseEntry)(shiftMatrix, rightIndexPrev, leftIndex, complex(1, 0));
        } else {
          const rightIndex2 = latticeSize + 0;
          (0, import_dist.setSparseEntry)(shiftMatrix, rightIndex2, leftIndex, complex(1, 0));
        }
      }
      const rightIndex = latticeSize + pos;
      if (boundary === "periodic") {
        const nextPos = (pos + 1) % latticeSize;
        const leftIndexNext = nextPos;
        (0, import_dist.setSparseEntry)(shiftMatrix, leftIndexNext, rightIndex, complex(1, 0));
      } else {
        if (pos < latticeSize - 1) {
          const leftIndexNext = pos + 1;
          (0, import_dist.setSparseEntry)(shiftMatrix, leftIndexNext, rightIndex, complex(1, 0));
        } else {
          const leftIndexBound = pos;
          (0, import_dist.setSparseEntry)(shiftMatrix, leftIndexBound, rightIndex, complex(1, 0));
        }
      }
    }
    return new import_dist.SparseOperator(shiftMatrix, "unitary");
  }
  function initializeQuantumWalk1DCustom(latticeSize, coin = "hadamard", boundary = "reflecting", theta = Math.PI / 4) {
    const dimension = 2 * latticeSize;
    const coinOp = buildCoinOperator(coin, theta);
    const shiftOp = buildShiftOperator1D(latticeSize, boundary);
    const center = Math.floor(latticeSize / 2);
    const initialAmplitudes = new Array(dimension).fill(null).map(() => complex(0, 0));
    const invSqrt2 = 1 / Math.sqrt(2);
    initialAmplitudes[center] = complex(invSqrt2, 0);
    initialAmplitudes[latticeSize + center] = complex(invSqrt2, 0);
    const initialState = new import_dist.StateVector(dimension, initialAmplitudes);
    qw1dCustomStateBuffer = {
      state: initialState,
      coinOp,
      shiftOp,
      latticeSize,
      currentStep: 0,
      history: []
    };
    const initialData = extractQuantumWalk1DData(initialState, latticeSize, 0);
    qw1dCustomStateBuffer.history.push({ step: 0, data: initialData });
    return initialData;
  }
  function stepQuantumWalk1DCustom() {
    if (!qw1dCustomStateBuffer) {
      throw new Error("Custom quantum walk not initialized");
    }
    const { state, coinOp, shiftOp, latticeSize } = qw1dCustomStateBuffer;
    const identityMatrix = [];
    for (let i = 0; i < latticeSize; i++) {
      const row = [];
      for (let j = 0; j < latticeSize; j++) {
        row.push(i === j ? complex(1, 0) : complex(0, 0));
      }
      identityMatrix.push(row);
    }
    const identityOp = new import_dist.MatrixOperator(identityMatrix, "unitary");
    const coinFullOp = coinOp.tensorProduct(identityOp);
    let nextState = coinFullOp.apply(state);
    nextState = shiftOp.apply(nextState);
    nextState = nextState.normalize();
    qw1dCustomStateBuffer.state = nextState;
    qw1dCustomStateBuffer.currentStep++;
    const data = extractQuantumWalk1DData(nextState, latticeSize, qw1dCustomStateBuffer.currentStep);
    qw1dCustomStateBuffer.history.push({ step: qw1dCustomStateBuffer.currentStep, data });
    return data;
  }
  function resetQuantumWalk1DCustom() {
    qw1dCustomStateBuffer = null;
  }
  function getQuantumWalk1DCustomState() {
    if (!qw1dCustomStateBuffer || qw1dCustomStateBuffer.history.length === 0) {
      throw new Error("Custom quantum walk not initialized");
    }
    return qw1dCustomStateBuffer.history[qw1dCustomStateBuffer.history.length - 1].data;
  }
  function measureCoinInComputationalBasis(state, latticeSize) {
    let pLeft = 0;
    let pRight = 0;
    for (let pos = 0; pos < latticeSize; pos++) {
      const leftAmp = state.amplitudes[pos];
      const rightAmp = state.amplitudes[latticeSize + pos];
      pLeft += Math.abs(leftAmp.re) ** 2 + Math.abs(leftAmp.im) ** 2;
      pRight += Math.abs(rightAmp.re) ** 2 + Math.abs(rightAmp.im) ** 2;
    }
    const r = Math.random();
    const outcomeLeft = r < pLeft / (pLeft + pRight);
    const newAmps = state.amplitudes.map((a) => complex(a.re, a.im));
    for (let pos = 0; pos < latticeSize; pos++) {
      if (outcomeLeft) {
        newAmps[latticeSize + pos] = complex(0, 0);
      } else {
        newAmps[pos] = complex(0, 0);
      }
    }
    return new import_dist.StateVector(state.dimension, newAmps).normalize();
  }
  function averageProbabilities(probsAcc, data) {
    for (let i = 0; i < data.probabilities.length; i++) {
      probsAcc[i] += data.probabilities[i].probability;
    }
  }
  function buildDataFromAveragedProbabilities(avgProbs, latticeSize, step) {
    return extractClassicalWalkData(avgProbs, latticeSize, step);
  }
  function runQuantumWalk1DDecoheredEnsemble(latticeSize, numSteps, coin = "hadamard", boundary = "reflecting", theta = Math.PI / 4, pMeasure = 0, ensembleSize = 50) {
    const clampedP = Math.max(0, Math.min(1, pMeasure));
    const M = Math.max(1, Math.floor(ensembleSize));
    const coinOp = buildCoinOperator(coin, theta);
    const shiftOp = buildShiftOperator1D(latticeSize, boundary);
    const dimension = 2 * latticeSize;
    const identityMatrix = [];
    for (let i = 0; i < latticeSize; i++) {
      const row = [];
      for (let j = 0; j < latticeSize; j++) {
        row.push(i === j ? complex(1, 0) : complex(0, 0));
      }
      identityMatrix.push(row);
    }
    const identityOp = new import_dist.MatrixOperator(identityMatrix, "unitary");
    const coinFullOp = coinOp.tensorProduct(identityOp);
    const center = Math.floor(latticeSize / 2);
    const history = [];
    const probsAccByStep = [];
    for (let step = 0; step <= numSteps; step++) {
      probsAccByStep.push(new Array(latticeSize).fill(0));
    }
    for (let m = 0; m < M; m++) {
      const initialAmplitudes = new Array(dimension).fill(null).map(() => complex(0, 0));
      const invSqrt2 = 1 / Math.sqrt(2);
      initialAmplitudes[center] = complex(invSqrt2, 0);
      initialAmplitudes[latticeSize + center] = complex(invSqrt2, 0);
      let state = new import_dist.StateVector(dimension, initialAmplitudes);
      averageProbabilities(probsAccByStep[0], extractQuantumWalk1DData(state, latticeSize, 0));
      for (let step = 1; step <= numSteps; step++) {
        state = coinFullOp.apply(state);
        state = shiftOp.apply(state);
        state = state.normalize();
        if (clampedP > 0 && Math.random() < clampedP) {
          state = measureCoinInComputationalBasis(state, latticeSize);
        }
        averageProbabilities(probsAccByStep[step], extractQuantumWalk1DData(state, latticeSize, step));
      }
    }
    for (let step = 0; step <= numSteps; step++) {
      const avgProbs = probsAccByStep[step].map((v) => v / M);
      const avgData = buildDataFromAveragedProbabilities(avgProbs, latticeSize, step);
      history.push({ step, data: avgData });
    }
    return { final: history[history.length - 1].data, history };
  }
  var persistentClassicalWalk1DBuffer = null;
  function initializePersistentClassicalWalk1D(latticeSize, persistence = 0.9) {
    const q = Math.max(0, Math.min(1, persistence));
    const center = Math.floor(latticeSize / 2);
    const pLeft = new Array(latticeSize).fill(0);
    const pRight = new Array(latticeSize).fill(0);
    pLeft[center] = 0.5;
    pRight[center] = 0.5;
    persistentClassicalWalk1DBuffer = {
      pLeft,
      pRight,
      latticeSize,
      currentStep: 0,
      persistence: q,
      history: []
    };
    const probs = pLeft.map((v, i) => v + pRight[i]);
    const initialData = extractClassicalWalkData(probs, latticeSize, 0);
    persistentClassicalWalk1DBuffer.history.push({ step: 0, data: initialData });
    return initialData;
  }
  function stepPersistentClassicalWalk1D() {
    if (!persistentClassicalWalk1DBuffer) {
      throw new Error("Persistent classical walk not initialized");
    }
    const { pLeft, pRight, latticeSize, persistence } = persistentClassicalWalk1DBuffer;
    const newLeft = new Array(latticeSize).fill(0);
    const newRight = new Array(latticeSize).fill(0);
    for (let pos = 0; pos < latticeSize; pos++) {
      const pl = pLeft[pos];
      const pr = pRight[pos];
      if (pl > 0) {
        const target = pos > 0 ? pos - 1 : 0;
        if (pos > 0) {
          newLeft[target] += pl * persistence;
          newRight[target] += pl * (1 - persistence);
        } else {
          newRight[target] += pl;
        }
      }
      if (pr > 0) {
        const target = pos < latticeSize - 1 ? pos + 1 : latticeSize - 1;
        if (pos < latticeSize - 1) {
          newRight[target] += pr * persistence;
          newLeft[target] += pr * (1 - persistence);
        } else {
          newLeft[target] += pr;
        }
      }
    }
    persistentClassicalWalk1DBuffer.pLeft = newLeft;
    persistentClassicalWalk1DBuffer.pRight = newRight;
    persistentClassicalWalk1DBuffer.currentStep++;
    const probs = newLeft.map((v, i) => v + newRight[i]);
    const data = extractClassicalWalkData(probs, latticeSize, persistentClassicalWalk1DBuffer.currentStep);
    persistentClassicalWalk1DBuffer.history.push({ step: persistentClassicalWalk1DBuffer.currentStep, data });
    return data;
  }
  function resetPersistentClassicalWalk1D() {
    persistentClassicalWalk1DBuffer = null;
  }
  function getPersistentClassicalWalk1DState() {
    if (!persistentClassicalWalk1DBuffer || persistentClassicalWalk1DBuffer.history.length === 0) {
      throw new Error("Persistent classical walk not initialized");
    }
    return persistentClassicalWalk1DBuffer.history[persistentClassicalWalk1DBuffer.history.length - 1].data;
  }
  function getDistributionSnapshot(history, stepIndex) {
    if (stepIndex >= 0 && stepIndex < history.length) {
      return history[stepIndex].data.probabilities;
    }
    return [];
  }
  function compareSpreadingRates(quantumHistory, classicalHistory) {
    if (quantumHistory.length < 2 || classicalHistory.length < 2) {
      return { quantumRate: 0, classicalRate: 0, advantage: 0 };
    }
    const qVar0 = quantumHistory[0].data.variance;
    const qVarFinal = quantumHistory[quantumHistory.length - 1].data.variance;
    const qSteps = quantumHistory.length - 1;
    const cVar0 = classicalHistory[0].data.variance;
    const cVarFinal = classicalHistory[classicalHistory.length - 1].data.variance;
    const cSteps = classicalHistory.length - 1;
    const quantumRate = qSteps > 0 ? (qVarFinal - qVar0) / qSteps : 0;
    const classicalRate = cSteps > 0 ? (cVarFinal - cVar0) / cSteps : 0;
    const advantage = classicalRate > 0 ? quantumRate / classicalRate : 0;
    return {
      quantumRate,
      classicalRate,
      advantage
    };
  }
  function formatComplex(re, im, precision = 4) {
    if (Math.abs(im) < 1e-10) {
      return re.toFixed(precision);
    }
    const sign3 = im >= 0 ? "+" : "";
    return `${re.toFixed(precision)} ${sign3} ${im.toFixed(precision)}i`;
  }
  function createDensityMatrixFromState(state) {
    const dim = state.dimension;
    const matrix2 = [];
    for (let i = 0; i < dim; i++) {
      const row = [];
      for (let j = 0; j < dim; j++) {
        row.push(
          multiply(state.amplitudes[i], conj(state.amplitudes[j]))
        );
      }
      matrix2.push(row);
    }
    return new import_dist.DensityMatrixOperator(matrix2);
  }
  function calculateEntanglementEntropy(state, dimA, dimB) {
    const rho = createDensityMatrixFromState(state);
    let entropy = 0;
    try {
      entropy = (0, import_dist.entanglementEntropy)(state, dimA, dimB);
    } catch {
      entropy = 0;
    }
    return entropy;
  }
  var simulationFunctions = {
    generateBellState,
    applyGate,
    simulateMeasurement,
    analyzeEntanglement,
    generateMultiQubitState,
    generateAngularMomentumState,
    runQuantumCircuit,
    exploreSuperposition,
    computeFidelity,
    initializeQuantumWalk1D,
    stepQuantumWalk1D,
    runQuantumWalk1D,
    resetQuantumWalk1D,
    getQuantumWalk1DState,
    initializeQuantumWalk1DCustom,
    stepQuantumWalk1DCustom,
    resetQuantumWalk1DCustom,
    getQuantumWalk1DCustomState,
    runQuantumWalk1DDecoheredEnsemble,
    initializeQuantumWalk1DGrover,
    stepQuantumWalk1DGrover,
    resetQuantumWalk1DGrover,
    getQuantumWalk1DGroverState,
    initializeQuantumWalk1DPeriodic,
    stepQuantumWalk1DPeriodic,
    resetQuantumWalk1DPeriodic,
    getQuantumWalk1DPeriodicState,
    initializeClassicalWalk1D,
    stepClassicalWalk1D,
    resetClassicalWalk1D,
    getClassicalWalk1DState,
    initializePersistentClassicalWalk1D,
    stepPersistentClassicalWalk1D,
    resetPersistentClassicalWalk1D,
    getPersistentClassicalWalk1DState,
    analyzeVarianceGrowth,
    getDistributionSnapshot,
    compareSpreadingRates
  };
  globalThis.simulations = simulationFunctions;
  if (typeof window !== "undefined") {
    window.simulations = simulationFunctions;
  }
  var simulations_default = simulationFunctions;
})();
/*! Bundled license information:

decimal.js/decimal.js:
decimal.js/decimal.mjs:
  (*!
   *  decimal.js v10.6.0
   *  An arbitrary-precision Decimal type for JavaScript.
   *  https://github.com/MikeMcl/decimal.js
   *  Copyright (c) 2025 Michael Mclaughlin <M8ch88l@gmail.com>
   *  MIT Licence
   *)

fraction.js/fraction.js:
  (**
   * @license Fraction.js v4.3.0 20/08/2023
   * https://www.xarg.org/2014/03/rational-numbers-in-javascript/
   *
   * Copyright (c) 2023, Robert Eisele (robert@raw.org)
   * Dual licensed under the MIT or GPL Version 2 licenses.
   **)

@babel/runtime/helpers/regenerator.js:
  (*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/babel/babel/blob/main/packages/babel-helpers/LICENSE *)
*/
//# sourceMappingURL=bundle.js.map
